<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XQC1368的emo小屋</title>
  
  <subtitle>嬛嬛，朕emo啦！！</subtitle>
  <link href="https://xqc-1368.github.io/atom.xml" rel="self"/>
  
  <link href="https://xqc-1368.github.io/"/>
  <updated>2024-08-18T09:24:54.577Z</updated>
  <id>https://xqc-1368.github.io/</id>
  
  <author>
    <name>XQC1368</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03二叉树的节点距离（LCA）+深度标记：二叉树问题</title>
    <link href="https://xqc-1368.github.io/2024/08/18/03%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%EF%BC%88LCA%EF%BC%89+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>https://xqc-1368.github.io/2024/08/18/03%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%EF%BC%88LCA%EF%BC%89+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-18T09:06:00.750Z</published>
    <updated>2024-08-18T09:24:54.577Z</updated>
    
    <content type="html"><![CDATA[<h1>[JLOI2009] 二叉树问题</h1><h2 id="题目描述">题目描述</h2><p>如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：</p><ul><li>深度：$4$</li><li>宽度：$4$</li><li>结点 8 和 6 之间的距离：$8$</li><li>结点 7 和 6 之间的距离：$3$</li></ul><p>其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。</p><p><img src="/images/2024-08-18-17-03-39-image.png" alt=""></p><p>给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。</p><h2 id="输入格式">输入格式</h2><p>第一行是一个整数，表示树的结点个数 $n$。<br>接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上存在一条连接 $u, v$ 的边。<br>最后一行有两个整数 $x, y$，表示求 $x, y$ 之间的距离。</p><h2 id="输出格式">输出格式</h2><p>输出三行，每行一个整数，依次表示二叉树的深度、宽度和 $x, y$ 之间的距离。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10                                </span><br><span class="line">1 2                            </span><br><span class="line">1 3                            </span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br><span class="line">3 7</span><br><span class="line">5 8</span><br><span class="line">5 9</span><br><span class="line">6 10</span><br><span class="line">8 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>对于全部的测试点，保证 $1 \leq u, v, x, y \leq n \leq 100$，且给出的是一棵树。</p><p>相当于分解成三个问题是吧。</p><p>1.求最大深度（深度优先搜索算法解决）</p><h2 id="MY思路">MY思路</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">depth</span><span class="params">(<span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bi[p].lchild !=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dep++;</span><br><span class="line">        depth(bi[p].lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bi[p].rchild !=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dep++;</span><br><span class="line">        depth(bi[p].rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bi[p].lchild ==<span class="number">-1</span> &amp;&amp; bi[p].rchild ==<span class="number">-1</span> &amp;&amp; dep&gt;ans1)</span><br><span class="line">    &#123;</span><br><span class="line">        ans1=dep;</span><br><span class="line">    &#125;</span><br><span class="line">    dep--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dalao思路">dalao思路</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> father;  <span class="comment">//爸爸</span></span><br><span class="line">    <span class="type">int</span> left;    <span class="comment">//左儿子</span></span><br><span class="line">    <span class="type">int</span> right;   <span class="comment">//右儿子</span></span><br><span class="line">    <span class="type">int</span> deep;    <span class="comment">//深度</span></span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//记录节点走过没</span></span><br><span class="line">&#125;a[<span class="number">10001</span>];</span><br></pre></td></tr></table></figure><p>直接在结构体里面定义了一个深度属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[y].deep=a[x].deep+<span class="number">1</span>;<span class="comment">//遍历树，后一项深度等于前一项加一</span></span><br></pre></td></tr></table></figure><p>2.最大宽度</p><h2 id="my思路-迭代版本-广度优先搜索">my思路(迭代版本   广度优先搜索)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">breath</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    q.push(bi[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> siz=q.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;ans1<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;siz;i++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.front().lchild!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(bi[q.front().lchild]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.front().rchild!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(bi[q.front().rchild]);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(q.size()&gt;ans2)</span><br><span class="line">        &#123;</span><br><span class="line">            ans2=q.size();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     siz=q.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dalao思路-2">dalao思路</h2><p>直接利用第一题的deep，deep相同的在一个桶数组中加在一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)      <span class="comment">//把每一个深度有多少个节点记录</span></span><br><span class="line">        sum[a[i].deep]++;</span><br><span class="line">    sort(sum+<span class="number">1</span>,sum+<span class="number">1</span>+<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxx&lt;&lt;<span class="built_in">endl</span>&lt;&lt;sum[<span class="number">100</span>]&lt;&lt;<span class="built_in">endl</span>&lt;&lt;num+num1; <span class="comment">//sum[100]是最大的宽度节点个数</span></span><br></pre></td></tr></table></figure><p>3.路径长度</p><h2 id="my思路（深度优先搜索）">my思路（深度优先搜索）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> come)</span><span class="comment">//come表示这个节点是怎么被寻找到的（方便回溯） 1：父节点找左子树，2：父节点找右子树3：左子树找父节点4：右子树找父节点 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==node2)</span><br><span class="line">    &#123;</span><br><span class="line">        ans3=pathlen;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(bi[node].lchild !=<span class="number">-1</span> &amp;&amp; come!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        top++;</span><br><span class="line">        path[top]=bi[node].lchild;</span><br><span class="line"></span><br><span class="line">        pathlen++;</span><br><span class="line">        search(bi[node].lchild ,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bi[node].rchild !=<span class="number">-1</span> &amp;&amp; come !=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        top++;</span><br><span class="line">        path[top]=bi[node].rchild;</span><br><span class="line"></span><br><span class="line">        pathlen++;</span><br><span class="line">        search(bi[node].rchild ,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bi[node].father !=<span class="number">-1</span> &amp;&amp; come!=<span class="number">1</span>&amp;&amp;come!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        top++;</span><br><span class="line">        path[top]=bi[node].father;pathlen+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(bi[bi[node].father].lchild!=<span class="number">-1</span> &amp;&amp; bi[bi[node].father].lchild==node)</span><br><span class="line">        &#123;</span><br><span class="line">            search(bi[node].father ,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bi[bi[node].father].rchild!=<span class="number">-1</span> &amp;&amp; bi[bi[node].father].rchild==node)</span><br><span class="line">        &#123;</span><br><span class="line">            search(bi[node].father ,<span class="number">4</span>);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(come==<span class="number">1</span>|| come==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pathlen--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(come==<span class="number">3</span> || come==<span class="number">4</span>)pathlen-=<span class="number">2</span>;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dalao思路（lca算法）">dalao思路（lca算法）</h2><p>普及一下</p><h3 id="最近公共祖先">最近公共祖先</h3><h2 id="简单引入">简单引入</h2><p>对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。</p><p><img src="/images/2024-08-18-17-03-27-image.png" alt=""></p><p>红色的都是是A和B的公共祖先，但只有最近的C才是最近公共祖先。</p><p>LCA问题是树上的一个经典问题，在很多方面有着广泛的应用，比如求LCP（最长公共前缀），接下来我们就来介绍他的几种算法。</p><p>LCA的算法</p><h2 id="暴力枚举法">暴力枚举法</h2><p>如果我们要求a和b的最近公共祖先，就沿着父亲的方向把a的所有祖先都标记一下（类似并查集找父亲，但是没有路径压缩），然后在从b开始往上找祖先，碰到第一个被标记的点，就是a和b的最近公共祖先。</p><p><img src="/images/2024-08-18-17-03-17-image.png" alt=""></p><p>C是最近公共祖先。</p><p>求一个对点的LCA时间复杂度高达O（N）。<br>求m个点对的LCA时间复杂度高达O（mN）。<br>当m和n都高达10万的时候，超时了！！！</p><p>宝宝难以承受！！！！！</p><p>求m个点对的最近公共祖先是可以优化的，一般有两种：<br>1、离线算法（Tarjan离线算法）：所谓的离线算法指的是把所有问题收集起来以后一起去算，最后一起回答。<br>2、在线算法（倍增算法）：所谓的在线算法就是来一个点对，处理一个点对。</p><h2 id="Tarjan离线算法">Tarjan离线算法</h2><p>Robert Tarjan设计了求解的应用领域的许多问题的广泛有效的算法和数据结构。 他已发表了超过228篇理论文章（包括杂志，一些书中的一些章节文章等）。Robert Tarjan以在数据结构和图论上的开创性工作而闻名。 他的一些著名的算法包括 Tarjan最近共同祖先离线算法 ，Tarjan的强连通分量算法等。其中Hopcroft-Tarjan平面嵌入算法是第一个线性时间平面算法。Tarjan也开创了重要的数据结构如：斐波纳契堆和splay树（splay发明者还有Daniel Sleator）。另一项重大贡献是分析了并查集。他是第一个证明了计算反阿克曼函数的乐观时间复杂度的科学家。（此段来自百度百科，有删改）</p><p>简单的介绍一下tarjan算法：<br>tarjan算法是离线算法，它必须先将所有的要查询的点对存起来，然后在搜的时候输出结果。<br>tarjan算法很经典，因为算法的思想很巧妙，利用了并查集思想，在dfs下，将查询一步一步的搜出来。</p><p>基本思路：</p><p><img src="/images/2023-09-24-20-43-45-image.png" alt=""><br>下面给出真代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N],n,m,ans[N],check[N]; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; a[N],b[N],id[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> x==f[x] ? x : f[x]=find(f[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"> f[x]=x; </span><br><span class="line">check[x]=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a[x].size(); i++) &#123;</span><br><span class="line"> <span class="type">int</span> v=a[x][i]; </span><br><span class="line"><span class="keyword">if</span>(!check[v]) &#123;</span><br><span class="line"> tarjan(v);  </span><br><span class="line"> f[v]=x; </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;b[x].size(); i++) &#123;</span><br><span class="line"> <span class="type">int</span> v=b[x][i]; </span><br><span class="line"><span class="keyword">if</span>(!check[v]) <span class="keyword">continue</span>; </span><br><span class="line">ans[id[x][i]]=find(v); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在深度优先遍历的时候，先遍历x节点的左子树，当遍历到u的时候，发现v没有被遍历过，那么就不去管lca(u,v)这个问题，然后我们把已经遍历的x子树的所有节点都合并到他的父亲（即father指向父亲），然后当我们遍历到v的时候，发现u已经遍历过了，那么此时u在并查集里的father就是u和v的最近公共祖先.</p><p>时间复杂度：由于每个点只遍历一次，每个问题只枚举2次，所以时间复杂度是O（N+2Mα(N))。α(N)为并查集查询一次根所需要的时间。</p><h2 id="倍增算法">倍增算法</h2><p>首先一个小问题，给你两个点a和b，你如何快速的回答这两个点在树里面是否具有祖先和后代的关系。<br>暴力算法又是o（N），明显太浪费时间！</p><p>引入时间戳的概念：所谓的时间戳就是在给一棵树进行深度优先遍历的同时，记录下计入每个点的时候和离开每个点的时间。</p><p><img src="/images/2024-08-18-17-03-06-image.png" alt=""></p><p>如图所示，每个节点的左边是进入的时间，右边是离开的时间。</p><p>如果a是b的祖先，只要满足 (in[a]&lt;=in[b]) and (out[b]&lt;=out[a])<br>也就是我们只需要一次深搜，接下来对于任何询问a和b是否有祖先关系的时候，我们只要O(1)的时间就能回答这个问题。</p><p>建立倍增数组：<br>定义f[i][j]为与节点i距离为2^j的祖先的编号。<br>明显的f[i][0]就是每个点直接的父亲。<br>另有递推关系：f[i][j]=f[f[i][j-1],j-1]。<br>于是我们只需要在nlogn的时间内就可以求出f数组的值。</p><p>如果f[i][j]不存在，我们就令f[i][j]=根，方便我们计算<br>接下来如何求a和b的最近公共祖先呢？<br>1、如果a是b的祖先，那么输出a<br>2、如果b是a的祖先，那么输出b<br>3、for i:=20 downto 0 do<br>if f[a][i]不是b的祖先，那么令 a=f[a][i];<br>循环结束的时候，f[a][0]就是最近公共祖先。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ancestor(x,y)) <span class="keyword">return</span> x; </span><br><span class="line">    <span class="keyword">if</span>(ancestor(y,x)) <span class="keyword">return</span> y; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--) </span><br><span class="line">        <span class="keyword">if</span>(!ancestor(f[x][i],y))</span><br><span class="line">    x=f[x][i]; </span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;      <span class="comment">//最最重要！！！求最近公共祖先</span></span><br><span class="line">    a[x].data=<span class="number">1</span>;           <span class="comment">//把x的节点记录已走过</span></span><br><span class="line">    <span class="keyword">while</span>(a[x].father!=<span class="number">0</span>)&#123; <span class="comment">//遍历至根节点</span></span><br><span class="line">        x=a[x].father;     <span class="comment">//更新遍历爸爸</span></span><br><span class="line">        a[x].data=<span class="number">1</span>;       <span class="comment">//记录已走过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a[y].data!=<span class="number">1</span>)&#123;   <span class="comment">//遍历至x节点已走过的节点，找到最近公共祖先</span></span><br><span class="line">        y=a[y].father;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面最后一个代码是实现本题目的代码哦</p><p>完结！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[JLOI2009] 二叉树问题&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度：$4$&lt;/li&gt;
&lt;li&gt;宽度：$4$&lt;/li&gt;
&lt;li&gt;结点 8 和 6 之间的距离</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="DFS" scheme="https://xqc-1368.github.io/tags/DFS/"/>
    
    <category term="BFS" scheme="https://xqc-1368.github.io/tags/BFS/"/>
    
    <category term="倍增" scheme="https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="LCA" scheme="https://xqc-1368.github.io/tags/LCA/"/>
    
    <category term="树上距离" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>03 最近公共祖先（LCA）：倍增解法</title>
    <link href="https://xqc-1368.github.io/2024/08/18/03%20%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89%EF%BC%9A%E5%80%8D%E5%A2%9E%E8%A7%A3%E6%B3%95/"/>
    <id>https://xqc-1368.github.io/2024/08/18/03%20%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89%EF%BC%9A%E5%80%8D%E5%A2%9E%E8%A7%A3%E6%B3%95/</id>
    <published>2024-08-18T09:06:00.743Z</published>
    <updated>2024-08-18T09:26:15.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近公共祖先（LCA）问题——倍增解法">最近公共祖先（LCA）问题——倍增解法</h3><h1>【模板】最近公共祖先（LCA）</h1><h2 id="题目描述">题目描述</h2><p>如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。</p><h2 id="输入格式">输入格式</h2><p>第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。</p><p>接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。</p><p>接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。</p><h2 id="输出格式">输出格式</h2><p>输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 5 4</span><br><span class="line">3 1</span><br><span class="line">2 4</span><br><span class="line">5 1</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 2</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>对于 $30%$ 的数据，$N\leq 10$，$M\leq 10$。</p><p>对于 $70%$ 的数据，$N\leq 10000$，$M\leq 10000$。</p><p>对于 $100%$ 的数据，$1 \leq N,M\leq 500000$，$1 \leq x, y,a ,b \leq N$，<strong>不保证</strong> $a \neq b$。</p><p>样例说明：</p><p>该树结构如下：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2282.png" alt=""></p><p>第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。</p><p>第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。</p><p>第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。</p><p>第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。</p><p>第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。</p><p>故输出依次为 $4, 4, 1, 4, 4$。</p><ul><li>倍增算法求LCA</li></ul><p>第一步：预处理对数表数组</p><p>如果我们预处理一个数组，规定：lg2[i]表示log_2^i+1（别问为什么加一，不然不方便在O(n)的时间内求出，用到的时候-1即可）</p><p>使得：对数可以查表获得，则大大方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//deal array:lg2[i]+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        lg2[i]=lg2[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg2[i<span class="number">-1</span>]==i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>处理方法自己推：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lg2[1]:1 lg2[2]:2 lg2[3]:2 lg2[4]:3 lg2[5]:3 </span><br><span class="line">lg2[6]:3 lg2[7]:3 lg2[8]:4 lg2[9]:4 lg2[10]:4</span><br><span class="line">lg2[11]:4 lg2[12]:4 lg2[13]:4 lg2[14]:4 lg2[15]:4</span><br><span class="line">lg2[16]:5 lg2[17]:5 lg2[18]:5 lg2[19]:5 lg2[20]:5</span><br></pre></td></tr></table></figure><p>解释如下：（ai生成，有删改）</p><p>这段代码定义了一个名为<code>lg2</code>的数组,用于计算以<code>2</code>为底的对数<code>+1</code>。具体来说,<code>lg2[i]</code>表示数字<code>i</code>的以<code>2</code>为底的对数<code>+1</code>的值。</p><p>在循环中,首先将<code>lg2[0]</code>赋值为0。然后,对于每个<code>i</code>(从1到n),将<code>lg2[i]</code>的值设置为<code>lg2[i-1]+(1&lt;&lt;lg2[i-1]==i)</code>。</p><p>这个循环的目的是计算<code>2</code>的整数次幂在<code>lg2</code>数组中的对应位置。具体来说,<code>(1&lt;&lt;lg2[i-1])</code>表示<code>2</code>的<code>i-1</code>次方,<code>==i</code>表示<code>i</code>是<code>2</code>的<code>i-1</code>次方的整数次幂。如果<code>i</code>是<code>2</code>的<code>i-1</code>次方的整数次幂,那么<code>(1&lt;&lt;lg2[i-1])==i</code>,否则<code>(1&lt;&lt;lg2[i-1])!=i</code>。因此,<code>(1&lt;&lt;lg2[i-1]==i)</code>的值为1或0,可以用来判断<code>i</code>是否是<code>2</code>的<code>i-1</code>次方的整数次幂。</p><p>最后,<code>lg2[i]</code>表示数字<code>i</code>的以<code>2</code>为底的对数<code>+1</code>,即<code>log_2(i)+1</code>。</p><p>第二步：通过一次dfs，预处理<code>找2的i次方祖先数组fa</code>和<code>深度数组depth</code>，后面会有用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">predfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> father=<span class="number">0</span>)</span></span><br><span class="line">&#123;<span class="comment">//每递归到一个节点nowpoint,就完成nowpoint节点的depth[nowpoint]和</span></span><br><span class="line"><span class="comment">//nowpoint的最高能跳到的2的i次方级祖先的编纂</span></span><br><span class="line">    depth[nowpoint]=depth[father]+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//nowpoint的深度比其父的深度大1</span></span><br><span class="line">    fa[nowpoint][<span class="number">0</span>]=father;</span><br><span class="line"><span class="comment">//nowpoint的2的0次方级祖先，即nowpoint的1级祖先为父亲节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lg2[depth[nowpoint]];i++)</span><br><span class="line">    &#123;<span class="comment">//这个循环跑遍了nowpoint能大跃进到的每一个祖先节点的可能性</span></span><br><span class="line">        fa[nowpoint][i]=fa[fa[nowpoint][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"> <span class="comment">//意思是now的2^i祖先等于now的2^(i-1)祖先的2^(i-1)祖先</span></span><br><span class="line"><span class="comment">//例如：nowpoint的4级祖先等于nowpoint的2级祖先的2级祖先</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip :ipoint[nowpoint] )</span><br><span class="line">    &#123;<span class="comment">//遍历nowpoint的子节点，继续编纂</span></span><br><span class="line">        <span class="keyword">if</span>(ip!=father)</span><br><span class="line">        &#123;</span><br><span class="line">            predfs(ip,nowpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，理解LCA算法：</p><p>以下开始正式说明：倍增算法  原理视频：<a href="%E3%80%90%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91LCA&amp;RMQ&amp;%E6%A0%91%E5%B7%AE%E5%88%86%E2%80%94%E2%80%94%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91">https://www.bilibili.com/video/BV1nE411L7rz?vd_source=c6cac99ae3e57c727ad51765bee0a508</a></p><p>所谓倍增，就是按2的倍数来增大，也就是跳 1,2,4,8,16,32 …… 不过在这我们不是按从小到大跳，而是从大向小跳，即按……32,16,8,4,2,1来跳，如果大的跳不过去，再把它调小。这是因为从小开始跳，可能会出现“悔棋”的现象。拿 5 为例，从小向大跳，5=1+2+4,所以我们还要回溯一步，然后才能得出5=1+4；而从大向小跳，直接可以得出5=4+1。</p><p><img src="/images/2024-01-12-21-50-47-image.png" alt=""></p><p>如图：节点19的深度depth[19]=13，节点2的深度depth[2]=2</p><p>（如果认为0号节点深度为0的话）</p><p>则18号节点称为19号节点的1级祖先，即为$2^0$级祖先</p><p>同理：17号节点称为19号节点的2级祖先，即为$2^1$级祖先</p><p>同理：15号节点称为19号节点的4级祖先，即为$2^2$级祖先</p><p>同理：11号节点称为19号节点的8级祖先，即为$2^3$级祖先</p><p>所以如果有这样一种可能，一次性跳到  $2^{…32,16,8,4,2,1}$ 级祖先，则加快效率</p><p>一：使得蓝色箭头经过：先跳越$2^3$次（3这个数字通过：$floor(log_2^{depth[19]-depth[2]})$得到，本来理想状况下跳跃depth[19]-depth[2]=13-2=11个节点，由于要用2的……4，3，2，1次方去逼近最终取等<code>depth[19]-depth[2]</code>这个差值）</p><p>二：此时蓝色箭头已经跳跃到了11号点，再跳跃$2^{floor(log_2^{depth[11]-depth[2]})}$ 个点，即$2^1$=2个点，同理，再跳$2^0$=1个点，到3号点。于是此时：箭头与2就处于相同深度（如下图所示）</p><p><img src="/images/2024-01-12-22-16-12-image.png" alt=""></p><p>特判：此时，箭头与2就处于相同深度，如果此时，箭头恰好指向2号节点，即证明19号节点为2号节点的子节点，所以LCA为2号节点，直接返回2号节点作为结果</p><p>如果以上特判不成立：</p><p>三：下面开始做尝试，让两个端点（2，3节点）同时向上跳跃，优先尝试跳跃$2^1$（因为最多也只能向上跳这么多）再尝试跳跃$2^0$ 个，再尝试不跳越。看何时有跳跃后节点不重合情况（因为如下图：0号点和1号点都是2，3点的Common Ancester，所以重合并不能作为判断条件，而是应该寻找非重合的深度最浅的两点（在下图中不用跳即可到达这两点，即这两点恰好为2，3），让2，3处的箭头跳到这两个点，即有：这两个新确定的点的公共父节点为LCA）</p><p><img src="/images/2024-01-12-22-17-21-image.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;depth[y])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x,y);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//以上特判，用数学语言来说就是：不妨设x的深度 &gt;= y的深度</span></span><br><span class="line">    <span class="keyword">while</span>(depth[x]&gt;depth[y])</span><br><span class="line">    &#123;</span><br><span class="line">        x=fa[x][lg2[depth[x]-depth[y]]<span class="number">-1</span>];</span><br><span class="line">    &#125; <span class="comment">//先跳到同一深度</span></span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;<span class="comment">//如果x是y的祖先，那他们的LCA肯定就是x了</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lg2[depth[x]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//不断向上跳（lg就是之前说的常数优化）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">            &#123; <span class="comment">//因为我们要跳到它们LCA的下面一层，所以它们肯定不相等，如果不相等就跳过去。</span></span><br><span class="line">                x=fa[x][i];</span><br><span class="line">                y=fa[y][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];<span class="comment">//返回父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码（100unaccepted）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ipoint[N];</span><br><span class="line"><span class="type">int</span> u,a[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> lg2[N]=&#123;<span class="number">0</span>&#125;,depth[N],father[N][<span class="number">22</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> fa=<span class="number">0</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    depth[nowpoint]=depth[fa]+<span class="number">1</span>;</span><br><span class="line">    father[nowpoint][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lg2[depth[nowpoint]]<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[nowpoint][i]=father[father[nowpoint][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip:ipoint[nowpoint])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=fa)</span><br><span class="line">            dfs(ip,nowpoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;depth[y])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(depth[x]&gt;depth[y])</span><br><span class="line">    &#123;</span><br><span class="line">        x=father[x][lg2[depth[x]-depth[y]]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lg2[depth[x]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(father[x][i]!=father[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x=father[x][i];</span><br><span class="line">            y=father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n,m,s,edge1,edge2;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//deal array:lg2[i]+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        lg2[i]=lg2[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg2[i<span class="number">-1</span>]==i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;edge1, &amp;edge2);</span><br><span class="line">        ipoint[edge1].emplace_back(edge2);</span><br><span class="line">        ipoint[edge2].emplace_back(edge1);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;edge1,&amp;edge2);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;LCA(edge1,edge2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCA解决：树上两点距离公式">LCA解决：树上两点距离公式</h3><p>lca处理树上任意两点间距离，即：<code>dis[a]+dis[b]-2*dis[lca(a,b)]</code></p><h3 id="LCA解决：树上路径相交问题">LCA解决：树上路径相交问题</h3><p>例题如下：</p><h1>仓鼠找 sugar</h1><h2 id="题目描述-2">题目描述</h2><p>小仓鼠的和他的基（mei）友（zi）sugar 住在地下洞穴中，每个节点的编号为 $1\sim n$。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（$a$）到餐厅（$b$），而他的基友同时要从他的卧室（$c$）到图书馆（$d$）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？</p><p>小仓鼠那么弱，还要天天被 zzq 大爷虐，请你快来救救他吧！</p><h2 id="输入格式-2">输入格式</h2><p>第一行两个正整数 $n$ 和 $q$，表示这棵树节点的个数和询问的个数。</p><p>接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$，表示节点 $u$ 到节点 $v$ 之间有一条边。</p><p>接下来 $q$ 行，每行四个正整数 $a$、$b$、$c$ 和 $d$，表示节点编号，也就是一次询问，其意义如上。</p><h2 id="输出格式-2">输出格式</h2><p>对于每个询问，如果有公共点，输出大写字母 <code>Y</code>；否则输出<code>N</code>。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">2 5</span><br><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">5 1 5 1</span><br><span class="line">2 2 1 4</span><br><span class="line">4 1 3 4</span><br><span class="line">3 1 1 5</span><br><span class="line">3 5 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y</span><br><span class="line">N</span><br><span class="line">Y</span><br><span class="line">Y</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><p><strong>本题时限 1s，内存限制 128M，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。</strong></p><p>$20%$ 的数据 $n, q\le200$。</p><p>$40%$ 的数据 $n, q\le 2\times10^3$。</p><p>$70%$ 的数据 $n, q\le 5\times10^4$。</p><p>$100%$ 的数据 $1\le n, q\le10^5$。</p><p>先上结论：</p><p><strong>如果两条路径相交，那么一定有一条路径的LCA在另一条路径上</strong></p><p>而判断一个节点x，是否在路径s-t上需要满足如下几个条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 条件一：deep[x]&gt;=deep[LCA(s,t)]</span><br><span class="line"></span><br><span class="line">- 条件二：LCA(s,x)=x或LCA(t,x)=x;</span><br></pre></td></tr></table></figure><p>判断条件一：（以下一大段内容可以缩写为：不妨设depth[x]&gt;=depth[y]）</p><p>只需讨论两种情况：</p><p>假设要求算a-b和c-d两条路径是否相交，设：</p><p><code>x=LCA(a,b);</code></p><p><code>y=LCA(c,d);</code></p><p>则先比较：depth[x]和depth[y]的大小，如果depth[x]&gt;=depth[y]不做处理，如果depth[x]&lt;depth[y]则对应的交换x与y，a与c，b与d，</p><p>使得现在的x,a,b,这一组数有depth[x]&gt;depth[y]</p><p>然后再判断条件二是否成立即可；</p><p>样例代码（LCA部分和DFS部分不变，主程序如下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,q,v,u;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    lg[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lg[i]=lg[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg[i<span class="number">-1</span>]==i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        ipoint[u].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        ipoint[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> a,b,c,d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">LCA</span>(a,b);</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">LCA</span>(c,d);</span><br><span class="line">        <span class="keyword">if</span>(depth[x]&lt;depth[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="built_in">swap</span>(a,c);</span><br><span class="line">            <span class="built_in">swap</span>(b,d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">LCA</span>(c,x)==x || <span class="built_in">LCA</span>(d,x)==x)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Y\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最近公共祖先（LCA）问题——倍增解法&quot;&gt;最近公共祖先（LCA）问题——倍增解法&lt;/h3&gt;
&lt;h1&gt;【模板】最近公共祖先（LCA）&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。&lt;/p</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="倍增" scheme="https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="LCA" scheme="https://xqc-1368.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>02顺序二叉树+深度标记：二叉树深度</title>
    <link href="https://xqc-1368.github.io/2024/08/18/02%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/"/>
    <id>https://xqc-1368.github.io/2024/08/18/02%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/</id>
    <published>2024-08-18T09:06:00.734Z</published>
    <updated>2024-08-18T09:33:16.394Z</updated>
    
    <content type="html"><![CDATA[<h1>【深基16.例3】二叉树深度</h1><h2 id="题目描述">题目描述</h2><p>有一个 $n(n \le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 <code>0 0</code>。</p><p>建好这棵二叉树之后，请求出它的深度。二叉树的<strong>深度</strong>是指从根节点到叶子结点时，最多经过了几层。</p><h2 id="输入格式">输入格式</h2><p>第一行一个整数 $n$，表示结点数。</p><p>之后 $n$ 行，第 $i$ 行两个整数 $l$、$r$，分别表示结点 $i$ 的左右子结点编号。若 $l=0$ 则表示无左子结点，$r=0$ 同理。</p><h2 id="输出格式">输出格式</h2><p>一个整数，表示最大结点深度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 7</span><br><span class="line">3 6</span><br><span class="line">4 5</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="本蒟蒻的小记">本蒟蒻的小记</h3><p>这道题的步骤划分为两个：</p><p>第一步：根据要求建树，对于这种1-7元素都有的这种树，除了传统的顺序存储，和传统的链式存储，还可以用数组顺序存储链式存储混合存储（即数组中的每个元素都是一个结构体，都有leftchild和rightchild的下标，通过下表实现“指向”的概念）<br><img src="/images/2023-09-23-17-31-56-0ba91885b10918e32a67e326972e7b2.jpg" alt=""></p><p>第二步：广度优先搜索算法：这个比较简单直接看代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_size 1000005</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bit</span>&#123;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> depth=<span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> number;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lchild;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> rchild;</span><br><span class="line">&#125;bitree;</span><br><span class="line">bitree bi[max_size];<span class="comment">//树的数组是全局变量</span></span><br><span class="line"><span class="built_in">queue</span>&lt;bitree&gt; q;<span class="comment">//广搜需要队列</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">bfs</span><span class="params">()</span><span class="comment">//广度优先搜索算法部分</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(bi[<span class="number">1</span>]);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(q.front().lchild!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bi[q.front().lchild].depth =q.front().depth+<span class="number">1</span>;</span><br><span class="line">q.push(bi[q.front().lchild]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q.front().rchild!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">bi[q.front().rchild].depth =q.front().depth+<span class="number">1</span>;</span><br><span class="line">q.push(bi[q.front().rchild]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q.front().lchild==<span class="number">-1</span> &amp;&amp; q.front().rchild==<span class="number">-1</span>  &amp;&amp; q.front().depth&gt;max)</span><br><span class="line">&#123;</span><br><span class="line">max=q.front().depth;</span><br><span class="line">&#125;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,lch,rch,ans;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//这个循环实现了建树功能</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;lch&gt;&gt;rch;</span><br><span class="line">bi[i].number =i;</span><br><span class="line">bi[i].lchild =lch==<span class="number">0</span>?<span class="number">-1</span>:lch;</span><br><span class="line">bi[i].rchild =rch==<span class="number">0</span>?<span class="number">-1</span>:rch;</span><br><span class="line">&#125;</span><br><span class="line">ans=bfs();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="完结撒花">完结撒花</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;【深基16.例3】二叉树深度&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有一个 $n(n &#92;le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 &lt;co</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="DFS" scheme="https://xqc-1368.github.io/tags/DFS/"/>
    
    <category term="二叉树" scheme="https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="树的深度" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    
    <category term="BFS" scheme="https://xqc-1368.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>02 树的直径问题</title>
    <link href="https://xqc-1368.github.io/2024/08/18/02%20%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://xqc-1368.github.io/2024/08/18/02%20%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-18T09:06:00.724Z</published>
    <updated>2024-08-18T09:26:22.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="02-树的直径问题">02 树的直径问题</h3><h5 id="做法-1-两次-DFS">做法 1. 两次 DFS</h5><p>首先从任意节点 y开始进行第一次 DFS，到达距离其最远的节点，记为z，然后再从 z开始做第二次 DFS，到达距离 z最远的节点，记为 z’，则z~z’即为树的直径。</p><p>缺陷：不能处理负权边</p><p>以下代码来自OIWIKI</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c, d[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : E[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[v] &gt; d[c]) c = v;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  d[c] = <span class="number">0</span>, <span class="built_in">dfs</span>(c, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[c]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="做法2：树形dp">做法2：树形dp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ /树形dp结构伪代码描述</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(节点u)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>()&#123;   / /循环访问所有u的子节点</span><br><span class="line">     <span class="built_in">dfs</span>(u的子节点);</span><br><span class="line">     用u的子节点信息更新节点u的信息;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二.用树形dp求树的直径：<br> 既然是树形动态规划，我们就尝试用上面树形dp的框架来解决问题。<br>1.首先，要确定维护的信息是什么？<br>     假设当前父节点是u ,u的所有儿子节点为 $v_{1},…,v_{n}$,那么这个信息必然要满足“只要知道了儿子节点  $v_{1},…,v_{n}$  的该信息，就能确定 u 的该信息”。由于最终要求树上最远两个节点的距离，不妨做这样的定义：设d[x]为节点x到其子孙节点的最大距离、设f[x]为以x为根结点的一条最长路径的距离。即要维护的信息就是d[]，f[]。</p><img src="https://img-blog.csdnimg.cn/2021050509433713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lBTUxTTA==,size_16,color_FFFFFF,t_70#pic_center" title="" alt="图1" width="423"><blockquote><p>2.如何维护上述信息？<br>(1) 假设当前遍历到的节点是u，u的子节点是v_{1},…,v_{n}，对应的边权是w_1,…,w_n.依据树形dp的“后序”思想，继续假设已经求得了u的所有子节点v_{1},…,v_{n}到其子孙节点的最大距离 d[v_{1}],…,d[v_n] 。已知信息画成下图，其中红色箭头所示的边为虚拟的边，也可看成是一条路径。</p><p>(2) 根据已知信息求d[u]:若边权都是正值,则d[u]=max(d[v_1]+w_{1},d[v_2]+w_{2},…,d[ v_n]+w_n)，若存在负的权值，则d[u]=max(0,w_1,d[v_1]+w_{1},w_2,d[v_2]+w_{2},…,w_n,d[v_n]+w_n)，可见d[u]&gt;=0。</p><p>(3)确定f[u]的值：若边权都是正值，则f[u]=(d[ v_x]+w_x)+(d[ v_y]+ w_y ),其中(d[ v_x]+ w_x)和(d[ v_y]+w_y)分别是u能到达子孙节点的最远距离和次远距离。即f[u]=d[u]+(d[ v_y]+w_y)。</p></blockquote><ul><li>以上过程仅为原理解释，不作为下属程序参数和具体做法</li></ul><p>真正的过程：<br>我们记录当 $1$ 为树的根时，每个节点作为子树的根向下，所能延伸的最长路径长度$ d_1$与次长路径（与最长路径无公共边）长度$ d_2$，那么直径就是对于每一个点，该点 $d_1+d_2$ 能取到的值中的最大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> point;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="built_in">edge</span>(<span class="type">int</span> po,<span class="type">int</span> wei):<span class="built_in">point</span>(po),<span class="built_in">weight</span>(wei)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+1</span>;</span><br><span class="line">vector&lt;edge&gt;ipoint[N];</span><br><span class="line"><span class="type">int</span> d1[N],d2[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n,u,v,w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> fa=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[nowpoint]=d2[nowpoint]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(edge ip : ipoint[nowpoint])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip.point!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(ip.point,nowpoint);</span><br><span class="line">            <span class="type">int</span> tempd=d1[ip.point]+ip.weight;</span><br><span class="line">            <span class="keyword">if</span>(tempd&gt;d1[nowpoint])</span><br><span class="line">            &#123;</span><br><span class="line">                d2[nowpoint]=d1[nowpoint];</span><br><span class="line">                d1[nowpoint]=tempd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tempd&gt;d2[nowpoint])</span><br><span class="line">            &#123;</span><br><span class="line">                d2[nowpoint]=tempd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,d1[nowpoint]+d2[nowpoint]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        ipoint[u].<span class="built_in">emplace_back</span>(<span class="built_in">edge</span>(v,w));</span><br><span class="line">        ipoint[v].<span class="built_in">emplace_back</span>(<span class="built_in">edge</span>(u,w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要求出一条直径上所有的节点，则可以在 DP 的过程中，记录下每个节点能向下延伸的最长路径与次长路径（定义同上）所对应的子节点，在求 ans 的同时记下对应的nowpoint 节点 ，使得 $ans=d_1[nowpoint]+d_2[nowpoint]$，即可分别沿着从 nowpoint 开始的最长路径的次长路径对应的子节点一路向某个方向（对于无根树，虽然这里指定了 1为树的根，但仍需记录每点跳转的方向；对于有根树，一路向上跳即可），遍历直径上所有的节点。</p><p>OIWIKI版本代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c, d[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : E[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[v] &gt; d[c]) c = v;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  d[c] = <span class="number">0</span>, <span class="built_in">dfs</span>(c, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[c]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;02-树的直径问题&quot;&gt;02 树的直径问题&lt;/h3&gt;
&lt;h5 id=&quot;做法-1-两次-DFS&quot;&gt;做法 1. 两次 DFS&lt;/h5&gt;
&lt;p&gt;首先从任意节点 y开始进行第一次 DFS，到达距离其最远的节点，记为z，然后再从 z开始做第二次 DFS，到达距离 z最远的节点</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="DFS" scheme="https://xqc-1368.github.io/tags/DFS/"/>
    
    <category term="树形dp" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
    <category term="树的直径" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>01树的重心 and 换根dp</title>
    <link href="https://xqc-1368.github.io/2024/08/18/01%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%20and%20%E6%8D%A2%E6%A0%B9dp/"/>
    <id>https://xqc-1368.github.io/2024/08/18/01%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%20and%20%E6%8D%A2%E6%A0%B9dp/</id>
    <published>2024-08-18T09:06:00.705Z</published>
    <updated>2024-08-18T09:26:26.831Z</updated>
    
    <content type="html"><![CDATA[<h4 id="无根树——树的重心问题">无根树——树的重心问题</h4><p>在后文中，我将用  mss（maximum subtree size）表示<strong>最大子树大小</strong>。用$ size_u(v)$表示以u为根节点时包含v的<strong>子树</strong>的<strong>大小</strong>。 此外，我们设整棵树大小为n。</p><h5 id="1-定义">1. 定义</h5><p>如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。</p><h5 id="2-引理">2. 引理</h5><p>引理1：例如，设 u 和 v  相邻，则 $size_u(v)+size_v(u)=n$。因为树上任意节点 w 要么在以 u 为根 v 所在的子树上，此时有 w=v 或有  w 与 v 进而与 u 连通；要么在以  v 为根 u 所在的子树上，此时此时有 w=u 或有  w 与 u 进而与 v 连通  。</p><p>引理2：设u，v,  w 连通，则$size_u(v) &gt; size_v(w)$ 。</p><h5 id="3-性质">3. 性质</h5><ul><li>性质1: 某个点是树的<strong>重心</strong>等价于它最大子树大小<strong>不大于</strong>整棵树大小的<strong>一半</strong>。</li></ul><p><img src="/images/2024-08-18-16-38-11-image.png" alt=""></p><ul><li>性质2: 树<strong>至多有两个</strong>重心。如果树有两个重心，那么它们<strong>相邻</strong>。此时树一定有<strong>偶数</strong>个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。</li></ul><p><img src="/images/2024-08-18-16-38-20-image.png" alt=""></p><ul><li>性质3：树中所有点到某个点的<strong>距离和</strong>中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。</li></ul><p><img src="/images/2024-08-18-16-38-30-image.png" alt=""></p><ul><li>性质4：往树上增加或减少一个<strong>叶子</strong>，如果原节点数是奇数，那么重心可能<strong>增加</strong>一个，原重心<strong>仍是重心</strong>；如果原节点数是偶数，重心可能<strong>减少</strong>一个，另一个重心<strong>仍是重心</strong>。</li></ul><p><img src="/images/2024-08-18-16-38-38-image.png" alt=""></p><ul><li>性质5：把两棵树通过一条边相连得到一棵新的树，则新的重心在<strong>较大</strong>的一棵树一侧的<strong>连接点</strong>与<strong>原重心</strong>之间的<strong>简单路径</strong>上。如果两棵树大小一样，则重心就是两个连接点。</li></ul><h2 id="找重心">找重心</h2><p>利用性质1，一趟dfs即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, sz[MAXN], mss[MAXN]; <span class="comment">// n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ctr; <span class="comment">// 重心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa = <span class="number">0</span>)</span> <span class="comment">// 找重心</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[p] = <span class="number">1</span>, mss[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [to, w] : edges[p])</span><br><span class="line">        <span class="keyword">if</span> (to != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(to, p);</span><br><span class="line">            mss[p] = <span class="built_in">max</span>(mss[p], sz[to]);</span><br><span class="line">            sz[p] += sz[to];</span><br><span class="line">        &#125;</span><br><span class="line">    mss[p] = <span class="built_in">max</span>(mss[p], n - sz[p]);</span><br><span class="line">    <span class="keyword">if</span> (mss[p] &lt;= n / <span class="number">2</span>) ctr.<span class="built_in">push_back</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变式例题：同时需要统计计算距离的情况——使用换根dp</p><h1>洛谷 P1395 会议</h1><h2 id="题目描述">题目描述</h2><p>有一个村庄居住着 $n$ 个村民，有 $n-1$ 条路径使得这 $n$ 个村民的家联通，每条路径的长度都为 $1$。现在村长希望在某个村民家中召开一场会议，村长希望所有村民到会议地点的距离之和最小，那么村长应该要把会议地点设置在哪个村民的家中，并且这个距离总和最小是多少？若有多个节点都满足条件，则选择节点编号最小的那个点。</p><h2 id="输入格式">输入格式</h2><p>第一行，一个数 $n$，表示有 $n$ 个村民。</p><p>接下来 $n-1$ 行，每行两个数字 $a$ 和 $b$，表示村民 $a$ 的家和村民 $b$ 的家之间存在一条路径。</p><h2 id="输出格式">输出格式</h2><p>一行输出两个数字 $x$ 和 $y$。</p><p>$x$ 表示村长将会在哪个村民家中举办会议。</p><p>$y$ 表示距离之和的最小值。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 </span><br><span class="line">2 3 </span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h4 id="数据范围">数据范围</h4><p>对于 $70%$ 数据 $n \le 10^3$。</p><p>对于 $100%$ 数据 $n \le 5 \times 10^4$。</p><blockquote><p>这一题知道思路后还是非常好理解的</p><p>我们为了使这棵树有一个确定的顺序,可以先定1为根(从1开始遍历,假如从i点走向j点就记i为j的父亲)</p><p>我们定义d[i]为<strong>所有点到i点的距离和</strong>,ct[i]为<strong>i点的子树的所有节点数</strong></p><p>对于这一题,我们可以从点1开始找最佳点,所以我们可以先求d[1]的值,求d[1]时顺便还可以求出所有ct[i]的值,然后我们再考虑怎么求其他的d[i]</p><p>我们先看一张图</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yip9u5z1.png" alt=""></p><p>我们首先知道d[1]=16,我们来看d[2]应该怎么求,我们发现相对于d[1]来说,如果设2为最佳点,2,5,6其距离-1,剩下的1,4,3,7,8,9,10到其距离+1,</p><p>所以d[2]=d[1]+3×(−1)+7×1=20</p><p>我们发现3为2的子树加自己的节点数,即ct[2]+1,7则为其他点的数量,即n−(ct[2]+1),</p><p>再试着举几个例子,不难发现,如果y为x的子树:</p><p>则,d[y]=d[x]+(ct[y]+1)×(−1)+(n−(ct[y]+1))×1</p><p>所以我们直接<strong>从1开始遍历</strong>,然后<strong>一个个算</strong>,最后再求最小值就可以了</p></blockquote><p>由此我们可以看出换根DP的套路：</p><p>1，指定某个节点为根节点。</p><p>2，第一次搜索完成预处理（如子树大小等），同时得到该节点的解。</p><p>3，第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。</p><p>根据以上想法，也即是先利用深搜求出d [1]，继而用递推公式求出d[ n ]：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+5</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;;<span class="type">int</span> n,d[N]=&#123;<span class="number">0</span>&#125;,ct[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> dis,<span class="type">int</span> fa=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip :g[nowpoint])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(ip,dis<span class="number">+1</span>,nowpoint);</span><br><span class="line">            ct[nowpoint]+=ct[ip]<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]+=dis;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip: g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            d[ip]=d[x]-(ct[ip]<span class="number">+1</span>)+(n-(ct[ip]<span class="number">+1</span>));</span><br><span class="line">            <span class="built_in">calculate</span>(ip,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        g[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">calculate</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> minn=d[<span class="number">1</span>],minnp=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;d[1]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(d[i]&lt;minn)</span><br><span class="line">        &#123;</span><br><span class="line">            minn=d[i];</span><br><span class="line">            minnp=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;minnp&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变式例题：同时需要节点加权的情况</p><h1>医院设置</h1><h2 id="题目描述-2">题目描述</h2><p>设有一棵二叉树，如图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/kawht13x.png" alt=""></p><p>其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\times20+2\times40=136$；若医院建在 $3$ 处，则距离和 $=4\times2+13+20+40=81$。</p><h2 id="输入格式-2">输入格式</h2><p>第一行一个整数 $n$，表示树的结点数。</p><p>接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。</p><h2 id="输出格式-2">输出格式</h2><p>一个整数，表示最小距离和。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5                        </span><br><span class="line">13 2 3</span><br><span class="line">4 0 0</span><br><span class="line">12 4 5</span><br><span class="line">20 0 0</span><br><span class="line">40 0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h4 id="数据规模与约定">数据规模与约定</h4><p>对于 $100%$ 的数据，保证 $1 \leq n \leq 100$，$0 \leq u, v \leq n$，$1 \leq w \leq 10^5$。</p><p>即把原来的 ct（节点数）变成人口规模（size）即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pt[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">105</span>],size[<span class="number">105</span>],ds[<span class="number">105</span>];<span class="type">int</span> n,u,v,sumw;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> dis,<span class="type">int</span> fa=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip:pt[nowpoint])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(ip,dis<span class="number">+1</span>,nowpoint);</span><br><span class="line">            size[nowpoint]+=size[ip]+w[ip];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ds[<span class="number">1</span>]+=w[nowpoint]*dis;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamic_programming</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> fa=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip:pt[nowpoint])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            ds[ip]=ds[nowpoint]-size[ip]-w[ip]+(sumw-size[ip]-w[ip]);</span><br><span class="line">            <span class="built_in">dynamic_programming</span>(ip,nowpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        sumw+=w[i];</span><br><span class="line">        <span class="keyword">if</span>(u!=<span class="number">0</span>)&#123;pt[i].<span class="built_in">emplace_back</span>(u);pt[v].<span class="built_in">emplace_back</span>(i);&#125;</span><br><span class="line">        <span class="keyword">if</span>(v!=<span class="number">0</span>)&#123;pt[i].<span class="built_in">emplace_back</span>(v);pt[u].<span class="built_in">emplace_back</span>(i);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dynamic_programming</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先以1为根求出ds[1],和size[1~n]</span></span><br><span class="line">    <span class="type">int</span> mindis=ds[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mindis=<span class="built_in">min</span>(mindis,ds[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;mindis&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;无根树——树的重心问题&quot;&gt;无根树——树的重心问题&lt;/h4&gt;
&lt;p&gt;在后文中，我将用  mss（maximum subtree size）表示&lt;strong&gt;最大子树大小&lt;/strong&gt;。用$ size_u(v)$表示以u为根节点时包含v的&lt;strong&gt;子树&lt;/</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="DFS" scheme="https://xqc-1368.github.io/tags/DFS/"/>
    
    <category term="树的重心" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    
    <category term="换根dp" scheme="https://xqc-1368.github.io/tags/%E6%8D%A2%E6%A0%B9dp/"/>
    
    <category term="树形dp" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>01链式二叉树+遍历问题：求先序遍历</title>
    <link href="https://xqc-1368.github.io/2024/08/18/01%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://xqc-1368.github.io/2024/08/18/01%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2024-08-18T09:06:00.699Z</published>
    <updated>2024-08-18T09:26:30.809Z</updated>
    
    <content type="html"><![CDATA[<h1>[NOIP2001 普及组] 求先序排列</h1><h2 id="题目描述">题目描述</h2><p>给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。</p><h2 id="输入格式">输入格式</h2><p>共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。</p><h2 id="输出格式">输出格式</h2><p>共一行一个字符串，表示一棵二叉树的先序。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BADC</span><br><span class="line">BDCA</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCD</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p><strong>【题目来源】</strong></p><p>NOIP 2001 普及组第三题</p><p>以下为正文：</p><p>这道题本蒟蒻居然去建树，真的是太垃圾了我太菜了，但好在也学习了一下怎么建树，也是比较好的。</p><h2 id="本题思路与大佬代码：">本题思路与大佬代码：</h2><p>模拟了好久，终于找出了套路，用的是DFS，其实就是递归；</p><p>我说一下这题的主要的方法（要点），</p><p>1.后序遍历中，最后一个节点一定是根节点（对于每一颗子树也成立）；</p><p>2.既然这题要求先序遍历，那么我们只需一次输出访问的父节点即可；</p><p>这样的话，我们只要递归将一棵大树分成两颗子树，让后找他们的父节点，不断递归输出；</p><p>3.那么难点就在这了，如何通过一个中序和后序遍历中找出两段子树的后序遍历序列（后序，因为只有后序我们才方便找到父节点）呢？</p><p>自己可以拿几个样例做一做，耐性点就会发现它的套路，我这里简单说一下：</p><p>在中序遍历中找到当前父节点后，我们可以分别求出他的左子树节点数和右子树节点数，因为中序遍历访问的顺序是左子树，父节点，右子树，所以可以直接计算出；</p><p>然后，由于我们对结点的访问一定是先访问一颗子树，在访问另一颗，所以在我们的原后序遍历串右边界中减掉右子树节点个数再减一即为新的左子树右边界，在原后序遍历串左边界加上左子树节点个数即为新的右子树左边界；</p><p>当然右子树右边界和左子树左边界这个非常好确定，就不在多说，自己看代码吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> s2[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==ch) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> l2,<span class="type">int</span> r2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m=find(s2[r2]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s2[r2];</span><br><span class="line">    <span class="keyword">if</span>(m&gt;l1) <span class="comment">/*具有左子树*/</span>dfs(l1,m<span class="number">-1</span>,l2,r2-r1+m<span class="number">-1</span>);<span class="comment">//r1-m为右子树结点数 </span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;r1) <span class="comment">/*具有右子树*/</span>dfs(m+<span class="number">1</span>,r1,l2+m-l1,r2<span class="number">-1</span>);<span class="comment">//m-l1为左子树节点数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s2;</span><br><span class="line">    len=<span class="built_in">strlen</span>(s1);</span><br><span class="line">    dfs(<span class="number">0</span>,len<span class="number">-1</span>,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而本蒟蒻的传统型建树代码效率也很高，也是AC捏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> mid,post;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bit</span>&#123;</span><span class="comment">//二叉树结构体</span></span><br><span class="line">    <span class="type">char</span> content;</span><br><span class="line">    bit* lchild;</span><br><span class="line">    bit *rchild;</span><br><span class="line">&#125;bitree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freebypostertraversal</span><span class="params">(bitree* root)</span><span class="comment">//释放内存空间函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        freebypostertraversal(root-&gt;lchild );</span><br><span class="line">        freebypostertraversal(root-&gt;rchild );</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">preordertraversal</span><span class="params">(bitree* root)</span><span class="comment">//前序遍历函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;content;</span><br><span class="line">        preordertraversal(root-&gt;lchild );</span><br><span class="line">        preordertraversal(root-&gt;rchild );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bitree* <span class="title function_">mptopre</span><span class="params">(<span class="type">char</span> inp,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> startp,<span class="type">int</span> endp)</span></span><br><span class="line">&#123;<span class="comment">//m=中序遍历，p=后续遍历，to=到，pre=前序遍历</span></span><br><span class="line">    <span class="type">int</span> start1,start2,end1,end2,trans,start4,start3,end3,end4;</span><br><span class="line">    bitree *root=(bitree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bitree));<span class="comment">//建立一个节点的内存 </span></span><br><span class="line">    root-&gt;content =inp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start;i&lt;=end ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid[i]==inp)</span><br><span class="line">            &#123;</span><br><span class="line">                trans=i; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//这个循环是在中序遍历中找后序遍历的最后一项的根</span></span><br><span class="line">        start1=start;</span><br><span class="line">        start2=trans+<span class="number">1</span>;</span><br><span class="line">        end1=trans<span class="number">-1</span>;</span><br><span class="line">        end2=end;</span><br><span class="line">        start3=startp;</span><br><span class="line">        end3=start3+end1-start1;</span><br><span class="line">        start4=end3+<span class="number">1</span>;</span><br><span class="line">        end4=endp<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (end3&lt;start3)<span class="comment">// 判断非空 </span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;lchild =<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;lchild=mptopre(post[end3],start1,end1,start3,end3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end4&lt;start4)<span class="comment">// 判断非空 </span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;rchild =<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;rchild =mptopre(post[end4],start2,end2,start4,end4); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//返回指针实现连接 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; mid&gt;&gt;post;</span><br><span class="line">    bitree *root=mptopre(post[post.length() <span class="number">-1</span>],<span class="number">0</span>,mid.length() <span class="number">-1</span>,<span class="number">0</span>,post.length() <span class="number">-1</span>);</span><br><span class="line">    preordertraversal(root);</span><br><span class="line">    freebypostertraversal(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>完结撒花！</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[NOIP2001 普及组] 求先序排列&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ &#92;le 8$）。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;输入</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="DFS" scheme="https://xqc-1368.github.io/tags/DFS/"/>
    
    <category term="二叉树" scheme="https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="链式二叉树" scheme="https://xqc-1368.github.io/tags/%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="遍历问题" scheme="https://xqc-1368.github.io/tags/%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>04 树上差分：最大流问题</title>
    <link href="https://xqc-1368.github.io/2024/08/18/04%20%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    <id>https://xqc-1368.github.io/2024/08/18/04%20%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-18T09:06:00.687Z</published>
    <updated>2024-08-18T09:26:08.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LCA-树上差分-解决最大流问题：Max-Flow-P">LCA+树上差分  解决最大流问题：Max Flow P</h3><p>树上差分<br>树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。这就是树上差分的基本操作。</p><p>树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs 遍历求出差分数组的前缀和，就可以达到降低复杂度的目的。</p><p>树上差分时需要求LCA，对点和边的树上差分原理相同，实现略有不同，这里分开来讲。</p><h5 id="点差分">点差分</h5><p>设将两点u,v之间路径上的所有点权增加x，o=LCA(u,v),o的父亲节点为p，则操作如下：<code>diff[u]+=x,diff[v]+=x,diff[o]-=x,diff[p]-=x;</code><br>怎么样，是不是很简单！原理也很简单，举个例子：</p><p>设原树如下，现要将2,3之间路径上的所有点的权值增加3，设原权值均为0。</p><p><img src="/images/2024-08-18-17-00-39-image.png" alt=""></p><p>则操作后有：</p><p><img src="/images/2024-08-18-17-00-27-image.png" alt=""></p><p>这样，只要dfs一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点的最终权值！</p><h5 id="边差分">边差分</h5><p>思想一样，讲一下操作。</p><p>设将两点u,v之间路径上的所有边权增加x，o=LCA(u,v)，以每条边两端深度较大的节点存储该边的差分数组，则操作如下：</p><p><code>diff[u]+=x,diff[v]+=x,diff[o]-=2*x;</code></p><p>再举个例子，还是上面那个图</p><p><img src="/images/2024-08-18-17-00-16-image.png" alt=""></p><p>则操作后有：</p><p><img src="/images/2024-08-18-17-00-06-image.png" alt=""></p><p>同样地，只要dfs一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点到父亲节点的边的最终权值了！</p><p>例题：</p><h1>[USACO15DEC] Max Flow P</h1><h2 id="题目描述">题目描述</h2><p>Farmer John has installed a new system of $N-1$ pipes to transport milk between the $N$ stalls in his barn ($2 \leq N \leq 50,000$), conveniently numbered $1 \ldots N$.  Each pipe connects a pair of stalls,  and all stalls are connected to each-other via paths of pipes.</p><p>FJ is pumping milk between $K$ pairs of stalls ($1 \leq K \leq 100,000$).  For the $i$th such pair,  you are told two stalls $s_i$ and $t_i$, endpoints of a path along which milk is being pumped at a unit rate.  FJ is concerned that some stalls might end up overwhelmed with all the milk being pumped through them, since a stall can serve as a waypoint along many of the $K$ paths along which milk is being pumped.  Please help him determine the maximum amount of milk being pumped through any stall.  If milk is being pumped along a path from $s_i$ to $t_i$, then it counts as being pumped through the endpoint stalls $s_i$ and</p><p>$t_i$, as well as through every stall along the path between them.</p><p>FJ 给他的牛棚的 $N$ 个隔间之间安装了 $N-1$ 根管道，隔间编号从 $1$ 到 $N$。所有隔间都被管道连通了。</p><p>FJ 有 $K$ 条运输牛奶的路线，第 $i$ 条路线从隔间 $s_i$ 运输到隔间 $t_i$。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。</p><h2 id="输入格式">输入格式</h2><p>The first line of the input contains $N$ and $K$.</p><p>The next $N-1$ lines each contain two integers $x$ and $y$ ($x \ne y$) describing a pipe</p><p>between stalls $x$ and $y$.</p><p>The next $K$ lines each contain two integers $s$ and $t$ describing the endpoint</p><p>stalls of a path through  which milk is being pumped.</p><p>第一行输入两个整数 $N$ 和 $K$。</p><p>接下来 $N-1$ 行每行输入两个整数 $x$ 和 $y$，其中 $x \ne y$。表示一根在牛棚 $x$ 和 $y$ 之间的管道。</p><p>接下来 $K$ 行每行两个整数 $s$ 和 $t$，描述一条从 $s$ 到 $t$ 的运输牛奶的路线。</p><h2 id="输出格式">输出格式</h2><p>An integer specifying the maximum amount of milk pumped through any stall in the barn.</p><p>一个整数，表示压力最大的隔间的压力是多少。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">3 4</span><br><span class="line">1 5</span><br><span class="line">4 2</span><br><span class="line">5 4</span><br><span class="line">5 4</span><br><span class="line">5 4</span><br><span class="line">3 5</span><br><span class="line">4 3</span><br><span class="line">4 3</span><br><span class="line">1 3</span><br><span class="line">3 5</span><br><span class="line">5 4</span><br><span class="line">1 5</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>$2 \le N \le 5 \times 10^4,1 \le K \le 10^5$</p><p>以下程序中power为每个点流量大小的差分</p><p>对于每一次要求的两个端点，先用LCA算法求出其LCA，再对power的差分数组进行++和–操作，以下内容为主函数的一部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    ipoint[x].emplace_back(y);</span><br><span class="line">    ipoint[y].emplace_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    lg2[i]=lg2[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg2[i<span class="number">-1</span>]==i);</span><br><span class="line">&#125;</span><br><span class="line">predfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="type">int</span> lca=LCA(x,y);</span><br><span class="line">    ++power[x];++power[y];</span><br><span class="line">    --power[lca];--power[fa[lca][<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用深度优先搜索实现对每一个节点的子树的差分数组求和操作，同时在算完每一个点时候，使用ans来统计最大流</p><p>在主函数中写：<code>dfs(1);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> father=<span class="number">0</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip: ipoint[nowpoint])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=father)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(ip,nowpoint);</span><br><span class="line">            power[nowpoint]+=power[ip];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=max(ans,power[nowpoint]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出ans即可</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ipoint[N];  </span><br><span class="line"><span class="type">int</span> n,k,depth[N],fa[N][<span class="number">17</span>],lg2[N]=&#123;<span class="number">0</span>&#125;,power[N]=&#123;<span class="number">0</span>&#125;,ans=<span class="number">-1e7</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">predfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> father=<span class="number">0</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    depth[nowpoint]=depth[father]+<span class="number">1</span>;</span><br><span class="line">    fa[nowpoint][<span class="number">0</span>]=father;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lg2[depth[nowpoint]];i++)<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[nowpoint][i]=fa[fa[nowpoint][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip :ipoint[nowpoint] )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=father)</span><br><span class="line">        &#123;</span><br><span class="line">            predfs(ip,nowpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&lt;depth[y])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(depth[x]&gt;depth[y])</span><br><span class="line">    &#123;</span><br><span class="line">        x=fa[x][lg2[depth[x]-depth[y]]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lg2[depth[x]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">            &#123;</span><br><span class="line">                x=fa[x][i];</span><br><span class="line">                y=fa[y][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> father=<span class="number">0</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip: ipoint[nowpoint])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ip!=father)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(ip,nowpoint);</span><br><span class="line">            power[nowpoint]+=power[ip];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=max(ans,power[nowpoint]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        ipoint[x].emplace_back(y);</span><br><span class="line">        ipoint[y].emplace_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lg2[i]=lg2[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg2[i<span class="number">-1</span>]==i);</span><br><span class="line">    &#125;</span><br><span class="line">    predfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="type">int</span> lca=LCA(x,y);</span><br><span class="line">        ++power[x];++power[y];</span><br><span class="line">        --power[lca];--power[fa[lca][<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;LCA-树上差分-解决最大流问题：Max-Flow-P&quot;&gt;LCA+树上差分  解决最大流问题：Max Flow P&lt;/h3&gt;
&lt;p&gt;树上差分&lt;br&gt;
树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树上问题" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    <category term="DFS" scheme="https://xqc-1368.github.io/tags/DFS/"/>
    
    <category term="倍增" scheme="https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="LCA" scheme="https://xqc-1368.github.io/tags/LCA/"/>
    
    <category term="树上差分" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    
    <category term="最大流" scheme="https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>01 并查集，路径压缩优化，按秩合并优化</title>
    <link href="https://xqc-1368.github.io/2024/08/18/01%20%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%EF%BC%8C%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/"/>
    <id>https://xqc-1368.github.io/2024/08/18/01%20%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%EF%BC%8C%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/</id>
    <published>2024-08-18T09:05:45.715Z</published>
    <updated>2024-08-18T09:23:41.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并·查·集">并·查·集</h2><p>需要解决的问题：</p><h4 id="【模板】并查集">【模板】并查集</h4><h5 id="题目描述">题目描述</h5><p>如题，现在有一个并查集，你需要完成合并和查询操作。</p><h6 id="输入格式">输入格式</h6><p>第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。</p><p>接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。</p><p>当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。</p><p>当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出<br><code>Y</code> ；否则输出 <code>N</code> 。</p><h6 id="输出格式">输出格式</h6><p>对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 <code>Y</code> 或者 <code>N</code> 。</p><h6 id="样例-1">样例 #1</h6><h6 id="样例输入-1">样例输入 #1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 7</span><br><span class="line">2 1 2</span><br><span class="line">1 1 2</span><br><span class="line">2 1 2</span><br><span class="line">1 3 4</span><br><span class="line">2 1 4</span><br><span class="line">1 2 3</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><h6 id="样例输出-1">样例输出 #1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N</span><br><span class="line">Y</span><br><span class="line">N</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>对于 $30%$ 的数据，$N \le 10$，$M \le 20$。</p><p>对于 $70%$ 的数据，$N \le 100$，$M \le 10^3$。</p><p>对于 $100%$ 的数据，$1\le N \le 10^4$，$1\le M \le 2\times 10^5$，$1 \le X_i, Y_i \le N$，$Z_i \in { 1, 2 }$。</p><h3 id="1-初始化">1.初始化</h3><p>因为我们在初始化的时候，每个节点的根节点初始化为它自己，<strong>即我爸爸是我自己</strong>，这就是根节点和其他节点的不同之处，当 <code>r==fa[r]</code> 的时候，就说明 <code>r</code> 是根节点.</p><p><img src="https://pic3.zhimg.com/80/v2-dbc232e9f0517145f3d7dc4425a3b5e6_1440w.webp" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        fa[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查（“查”的意思是查找一个结点的根节点-）">2.查（<strong>“查”的意思是查找一个结点的根节点.</strong>）</h3><p>初始化一个fa数组，里面存放<strong>每个节点的的父节点</strong>（ <code>fa[i]=i</code>  的父节点）</p><p>fa数组可以表示一颗树，其目的是为了查根节点，根据这个数组，我们就可以“顺藤摸瓜”，找到每个节点的根节点。</p><p>假如你在一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root.</p><img src="https://pic3.zhimg.com/80/v2-08e43541c8839b529ff042fb7420fdd2_1440w.webp" title="" alt="" width="571"><p>于是我们可以写出find函数（未经过路径压缩版本）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径压缩">路径压缩</h3><p>最简单的并查集效率是比较低的。例如，来看下面这个场景：<br><img src="/images/2024-08-18-16-22-36-image.png" alt=""></p><p>现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样：<br><img src="/images/2024-08-18-16-22-46-image.png" alt=""></p><p>然后我们又找来一个元素4，并需要执行merge(2,4)：<br><img src="/images/2024-08-18-16-22-55-image.png" alt=""></p><p>从2找到1，再找到3，然后fa[3]=4，于是变成了这样：<br><img src="/images/2024-08-18-16-23-05-image.png" alt=""></p><p>大家应该有感觉了，这样可能会形成一条长长的<strong>链</strong>，随着链越来越长，我们想要从底部找到根节点会变得越来越难。</p><p>怎么解决呢？我们可以使用<strong>路径压缩</strong>的方法。既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：<br><img src="/images/2024-08-18-16-23-16-image.png" alt=""></p><p>其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：</p><h3 id="合并（路径压缩）">合并（路径压缩）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码常常简写为一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。</p><p>路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。</p><h3 id="3-并（“并”指把两个在同一连通分量的结点合并）">3.并（<strong>“并”指把两个在同一连通分量的结点合并</strong>）</h3><p>比如有两个节点 x和y, 我们就查一下<strong>x的根节点</strong>和<strong>y的根节点</strong>（并的时候用到了查）是不是同一个节点（<strong>咱们的祖先是不是同一个人</strong>），如果是，那么x和y本来就是一家人，不用做任何操作。</p><p>如果发现x和y的祖先不同，必须有一个人要迁移户口，例如就让y的祖先做x祖先的儿子，这样x 和 y还是成为一家人了（实现了并操纵）。</p><p><img src="/images/2024-08-18-16-23-28-image.png" alt=""></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fax=<span class="built_in">f_a</span>(x);<span class="comment">//找到i的祖先</span></span><br><span class="line">    <span class="type">int</span> fay=<span class="built_in">f_a</span>(y);<span class="comment">//找到j的祖先</span></span><br><span class="line">    <span class="keyword">if</span>(fax!=fay)</span><br><span class="line">        fa[fax]=fay;<span class="comment">//让i的祖先指向j的祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并查集的生动阐释：</p><p><img src="/images/2024-08-18-16-23-37-image.png" alt=""></p><p>以上题目的参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> fa[N];<span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f_a</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        fa[x]=<span class="built_in">f_a</span>(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fax=<span class="built_in">f_a</span>(x);</span><br><span class="line">    <span class="type">int</span> fay=<span class="built_in">f_a</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fax!=fay)</span><br><span class="line">        fa[fax]=fay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">decide</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f_a</span>(x)==<span class="built_in">f_a</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> z,x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)<span class="built_in">merge</span>(x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> result=<span class="built_in">decide</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(result)cout&lt;&lt;<span class="string">&quot;Y&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;N&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：需要记录压缩路径长度，和集合总长度的变式</p><h1>[NOI2002] 银河英雄传说</h1><h2 id="题目背景">题目背景</h2><p>公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。</p><p>宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。</p><h2 id="题目描述-2">题目描述</h2><p>杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 <code>M i j</code>，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。</p><p>然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。</p><p>在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：<code>C i j</code>。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。</p><p>作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。</p><h2 id="输入格式-2">输入格式</h2><p>第一行有一个整数 $T$（$1 \le T \le 5 \times 10^5$），表示总共有 $T$ 条指令。</p><p>以下有 $T$ 行，每行有一条指令。指令有两种格式：</p><ol><li><p><code>M i j</code>：$i$ 和 $j$ 是两个整数（$1 \le i,j \le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。</p></li><li><p><code>C i j</code>：$i$ 和 $j$ 是两个整数（$1 \le i,j \le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。</p></li></ol><h2 id="输出格式-2">输出格式</h2><p>依次对输入的每一条指令进行分析和处理：</p><ul><li>如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。</li><li>如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。</li></ul><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">M 2 3</span><br><span class="line">C 1 2</span><br><span class="line">M 2 4</span><br><span class="line">C 4 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="样例解释">样例解释</h3><p>战舰位置图：表格中阿拉伯数字表示战舰编号。</p><p><img src="/images/2024-01-25-22-30-35-image.png" alt=""></p><p>解析：</p><p><code>fa[]</code>数组维护两个编号之间的连通性，<code>dis[]</code>维护编号为i的战舰到<code>fa[i]</code>之间的距离，<code>num[]</code>维护编号为<code>i</code>的战舰所在的那一列有多少战舰。</p><p>记录距离根节点的距离显得尤为重要，其中距离根节点的距离存储在dis数组内</p><p><img src="/images/2024-01-25-22-34-33-image.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=fa[x];</span><br><span class="line">        fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">        dis[x]+=dis[k];<span class="comment">//这句话很难理解，</span></span><br><span class="line"><span class="comment">//但是经过尝试可以发现，这很好的维护了数组dis，</span></span><br><span class="line"><span class="comment">//以压缩后路径权值的方式维护了每一个节点到根节点的实际距离（配合下面的初始化）</span></span><br><span class="line"><span class="comment">//（即上面的1,2,3）所以记住就好</span></span><br><span class="line">        num[x]=num[fa[x]];<span class="comment">//x节点的队伍长度等于根节点的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是合并函数可以修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r1=<span class="built_in">find</span>(x),r2=<span class="built_in">find</span>(y);<span class="comment">//直接把根节点插上，不多说</span></span><br><span class="line">    <span class="keyword">if</span>(r1!=r2)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[r1]=r2;<span class="comment">//记录父亲</span></span><br><span class="line">        dis[r1]=num[r2];<span class="comment">//原队列长度即是此节点到父亲的距离</span></span><br><span class="line">        num[r2]+=num[r1];<span class="comment">//r2队列后放了num[r1]个战舰</span></span><br><span class="line">        num[r1]=num[r2];<span class="comment">//r1所在的队列和r2所在的已经是同一个队列了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次输出只用输出<code>abs(dis[x]-dis[y])-1;</code>即可</p><p>注意，这里是问中间有几个城市， 不算两边，所以要-1</p><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="按秩合并">按秩合并</h2><p>有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：</p><p><img src="/images/2024-08-18-16-28-40-image.png" alt=""></p><p>假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？</p><p>当然是后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p><p><img src="/images/2024-08-18-16-28-52-image.png" alt=""></p><p>这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</p><p>我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 $O(n)$ ，但是很可能会破坏rank的准确性。</p><h3 id="初始化（按秩合并）">初始化（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并（按秩合并）">合并（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)：</p><p><img src="/images/2024-08-18-16-27-52-image.png" alt=""></p><p>这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样：<br><img src="/images/2024-08-18-16-27-22-image.png" alt=""></p><p>显然树的深度增加了1。另一种合并方式同样会让树的深度+1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并·查·集&quot;&gt;并·查·集&lt;/h2&gt;
&lt;p&gt;需要解决的问题：&lt;/p&gt;
&lt;h4 id=&quot;【模板】并查集&quot;&gt;【模板】并查集&lt;/h4&gt;
&lt;h5 id=&quot;题目描述&quot;&gt;题目描述&lt;/h5&gt;
&lt;p&gt;如题，现在有一个并查集，你需要完成合并和查询操作。&lt;/p&gt;
&lt;h6 id=&quot;输入格</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="并查集" scheme="https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="并查集" scheme="https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="并查集的路径优化压缩" scheme="https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="并查集的按秩合并优化" scheme="https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>02 种类并查集</title>
    <link href="https://xqc-1368.github.io/2024/08/18/02%20%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://xqc-1368.github.io/2024/08/18/02%20%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2024-08-18T09:05:44.155Z</published>
    <updated>2024-08-18T09:29:04.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="种类并查集">种类并查集</h3><p>一般的并查集，维护的是具有连通性、传递性的关系，例如<strong>亲戚的亲戚是亲戚</strong>。但是，有时候，我们要维护另一种关系：<strong>敌人的敌人是朋友</strong>。种类并查集就是为了解决这个问题而诞生的。</p><p>我们先来看一个例题：</p><p>（<strong>洛谷P1525 关押罪犯</strong>）</p><h1>[NOIP2010 提高组] 关押罪犯</h1><h2 id="题目背景">题目背景</h2><p>NOIP2010 提高组 T3</p><h2 id="题目描述">题目描述</h2><p>S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。</p><p>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。</p><p>在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p><p>那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p><h2 id="输入格式">输入格式</h2><p>每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1&lt;a_j\leq b_j\leq N, 0 &lt; c_j\leq 10^9$，且每对罪犯组合只出现一次。</p><h2 id="输出格式">输出格式</h2><p>共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 <code>0</code>。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 4 2534</span><br><span class="line">2 3 3512</span><br><span class="line">1 2 28351</span><br><span class="line">1 3 6618</span><br><span class="line">2 4 1805</span><br><span class="line">3 4 12884</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3512</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p><strong>输入输出样例说明</strong></p><p>罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。</p><p><img src="/images/2024-01-26-23-00-48-image.png" alt=""></p><p><strong>数据范围</strong></p><p>对于 $30%$ 的数据有 $N\leq 15$。</p><p>对于 $70%$ 的数据有 $N\leq 2000,M\leq 50000$。</p><p>对于 $100%$ 的数据有 $N\leq 20000,M\leq 100000$。</p><p>我们开一个<strong>两倍大小</strong>的并查集。例如，假如我们要维护4个元素的并查集，我们改为开8个单位的空间：</p><p><img src="/images/2024-08-18-16-32-28-image.png" alt=""></p><p>我们用1~4维护<strong>朋友</strong>关系（就这道题而言，是指关在同一个监狱的狱友），用5~8维护<strong>敌人</strong>关系（这道题里是指关在不同监狱的仇人）。现在假如我们得到信息：1和2是敌人，应该怎么办？</p><p>我们<code>merge(1, 2+n), merge(1+n, 2);</code>。这里n就等于4，但我写成n这样更清晰。对于1个编号为i的元素，i+n是它的敌人。所以这里的意思就是：1是2的敌人，2是1的敌人。</p><p><img src="/images/2024-08-18-16-32-36-image.png" alt=""></p><p>现在假如我们又知道2和4是敌人，我们<code>merge(2, 4+n), merge(2+n, 4);</code>：</p><p><img src="/images/2024-08-18-16-32-46-image.png" alt=""></p><p>发现了吗，<strong>敌人的敌人就是朋友</strong>，2和4是敌人，2和1也是敌人，所以这里，1和4通过2+n这个元素<strong>间接</strong>地连接起来了。这就是种类并查集工作的原理。</p><p><img src="/images/2024-04-10-11-49-34-680a938828136b119e2cc1b192590ff.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//快速读入，可忽略</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = (ans &lt;&lt; <span class="number">3</span>) + (ans &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>  <span class="comment">//以结构体方式保存便于排序</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125; C[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(data &amp;a, data &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">40005</span>], rank[<span class="number">40005</span>];  <span class="comment">//以下为并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fa[a] == a) ? a : (fa[a] = <span class="built_in">find</span>(fa[a]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(a), y = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (rank[x] &gt;= rank[y])</span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>(n * <span class="number">2</span>); <span class="comment">//对于罪犯i，i+n为他的敌人</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i].a = <span class="built_in">read</span>();</span><br><span class="line">        C[i].b = <span class="built_in">read</span>();</span><br><span class="line">        C[i].w = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(C, C + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">query</span>(C[i].a, C[i].b))  <span class="comment">//试图把两个已经被标记为“朋友”的人标记为“敌人”</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C[i].w); <span class="comment">//此时的怒气值就是最大怒气值的最小值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">merge</span>(C[i].a, C[i].b + n);</span><br><span class="line">        <span class="built_in">merge</span>(C[i].b, C[i].a + n);</span><br><span class="line">        <span class="keyword">if</span> (i == m - <span class="number">1</span>)  <span class="comment">//如果循环结束仍无冲突，输出0</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才我说，种类并查集可以维护<strong>敌人的敌人是朋友</strong>这样的关系，这种说法不够准确，较为本质地说，种类并查集（包括普通并查集）维护的是一种<strong>循环对称</strong>的关系。</p><p><img src="/images/2024-08-18-16-33-03-image.png" alt=""></p><p>所以如果是三个及以上的集合，只要每个集合都是等价的，且集合间的每个关系都是等价的，就能够用种类并查集进行维护。例如下面这道题：</p><h1>[NOI2001] 食物链</h1><h2 id="题目描述-2">题目描述</h2><p>动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。</p><p>现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：</p><ul><li>第一种说法是 <code>1 X Y</code>，表示 $X$ 和 $Y$ 是同类。</li><li>第二种说法是<code>2 X Y</code>，表示 $X$ 吃 $Y$。</li></ul><p>此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ul><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；</li><li>当前的话表示 $X$ 吃 $X$，就是假话。</li></ul><p>你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。</p><h2 id="输入格式-2">输入格式</h2><p>第一行两个整数，$N,K$，表示有 $N$ 个动物，$K$ 句话。</p><p>第二行开始每行一句话（按照题目要求，见样例）</p><h2 id="输出格式-2">输出格式</h2><p>一行，一个整数，表示假话的总数。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1</span><br><span class="line">2 1 2</span><br><span class="line">2 2 3</span><br><span class="line">2 3 3</span><br><span class="line">1 1 3</span><br><span class="line">2 3 1</span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><p>对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。</p><p>于是我们可以用一个三倍大小的并查集进行维护，用i+n表示i的捕食对象，而i+2n表示i的天敌。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r1 = <span class="built_in">find</span>(x), r2 = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (r1 != r2)</span><br><span class="line">        fa[r1] = r2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">question</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> * n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> oper, x, y, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;oper, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">question</span>(x + n, y) || <span class="built_in">question</span>(x + <span class="number">2</span> * n, y))</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x, y);</span><br><span class="line">                <span class="built_in">merge</span>(x + n, y + n);</span><br><span class="line">                <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y + <span class="number">2</span> * n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">question</span>(x, y) || <span class="built_in">question</span>(x, y + n))</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">merge</span>(x + n, y);</span><br><span class="line">                <span class="built_in">merge</span>(x + <span class="number">2</span> * n, y + n);</span><br><span class="line">                <span class="built_in">merge</span>(x, y + <span class="number">2</span> * n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;种类并查集&quot;&gt;种类并查集&lt;/h3&gt;
&lt;p&gt;一般的并查集，维护的是具有连通性、传递性的关系，例如&lt;strong&gt;亲戚的亲戚是亲戚&lt;/strong&gt;。但是，有时候，我们要维护另一种关系：&lt;strong&gt;敌人的敌人是朋友&lt;/strong&gt;。种类并查集就是为了解决这个问题</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="并查集" scheme="https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="并查集" scheme="https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="种类并查集" scheme="https://xqc-1368.github.io/tags/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>10 数位DP：数字计数</title>
    <link href="https://xqc-1368.github.io/2024/08/17/10%20%E6%95%B0%E4%BD%8DDP%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/"/>
    <id>https://xqc-1368.github.io/2024/08/17/10%20%E6%95%B0%E4%BD%8DDP%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</id>
    <published>2024-08-17T06:53:17.229Z</published>
    <updated>2024-08-17T14:32:09.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10数位DP：数字计数">10数位DP：数字计数</h2><h1>[ZJOI2010] 数字计数</h1><h2 id="题目描述">题目描述</h2><p>给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。</p><h2 id="输入格式">输入格式</h2><p>仅包含一行两个整数 $a,b$，含义如上所述。</p><h2 id="输出格式">输出格式</h2><p>包含一行十个整数，分别表示 $0\sim 9$ 在 $[a,b]$ 中出现了多少次。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 99</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 20 20 20 20 20 20 20 20 20</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h4 id="数据规模与约定">数据规模与约定</h4><ul><li>对于 $30%$ 的数据，保证 $a\le b\le10^6$；</li><li>对于 $100%$ 的数据，保证 $1\le a\le b\le 10^{12}$。</li></ul><p>数位DP主要通过记忆化搜索实现，记忆化搜索的本质就是把条件对应的结论记下来，相同条件一定最后对应相同的结论，条件的个数也就决定了DP的维数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long<span class="comment">//注意都要开long long</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ay[<span class="number">20</span>];</span><br><span class="line"><span class="comment">//ay来存这个数每个位子上的数码，倒序存放</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">20</span>][<span class="number">2</span>][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//zero=1表示前面是否全部都是前导零</span></span><br><span class="line"><span class="comment">//limit=1 表示前面对本位有没有限制</span></span><br><span class="line"><span class="comment">//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">记忆化搜索。</span></span><br><span class="line"><span class="comment">pos是当前为从高到低位置。limit表示当前位之前的所有位置是否和ay[pos]相等，</span></span><br><span class="line"><span class="comment">                                                    1是相等，0是不相等。</span></span><br><span class="line"><span class="comment">sum表示当前数字出现的次数。zero表示之前是否都是前导0。target是当前在算的数码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> limit,<span class="type">int</span> sum,<span class="type">int</span> zero,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)<span class="keyword">return</span> sum;<span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(dp[pos][limit][sum][zero]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][limit][sum][zero];</span><br><span class="line">    <span class="comment">//记搜检索：检索是否已经被记录</span></span><br><span class="line">    <span class="type">int</span> maxnum=limit?ay[pos]:<span class="number">9</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   由于我们是从高位到低位枚举的，所以如果之前一位的数码和最大数的数码相同，</span></span><br><span class="line"><span class="comment">   这一位就只能枚举到ay[pos]；</span></span><br><span class="line"><span class="comment">   否则如果之前一位比最大数的数码小，那这一位就可以从0~9枚举了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=maxnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,limit &amp;&amp;(i==maxnum),sum+((i==target) &amp;&amp; (i||!zero)),zero &amp;&amp; (i==<span class="number">0</span>),target);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        继续搜索，数位减一（到下一个位置，倒序存储，从高位到低位），</span></span><br><span class="line"><span class="comment">        limit的更新要看之前有没有相等，且这一位有没有相等；</span></span><br><span class="line"><span class="comment">        sum的更新要看之前是否为前导0或者这一位不是0；</span></span><br><span class="line"><span class="comment">        zero的更新就看之前是否为前导0且这一位继续为0；</span></span><br><span class="line"><span class="comment">        target继续传进去。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][limit][sum][zero]=ret;<span class="comment">//记忆化，把搜到的都记下来</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">part</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">        ay[++len]=a%<span class="number">10</span>;</span><br><span class="line">        a/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">dfs</span>(len,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,d);</span><br><span class="line"> <span class="comment">//开始在第len位上，最高位只能枚举到ay[pos]所以limit是0，sum=0，有前导0。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">part</span>(b,i)-<span class="built_in">part</span>(a<span class="number">-1</span>,i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一道题：</p><h1>[SCOI2009] windy 数</h1><h2 id="题目背景">题目背景</h2><p>windy 定义了一种 windy 数。</p><h2 id="题目描述-2">题目描述</h2><p>不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？</p><h2 id="输入格式-2">输入格式</h2><p>输入只有一行两个整数，分别表示 $a$ 和 $b$。</p><h2 id="输出格式-2">输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 50</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h4 id="数据规模与约定-2">数据规模与约定</h4><p>对于全部的测试点，保证 $1 \leq a \leq b \leq 2 \times 10^9$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ay[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//dp[i][j]表示搜到第i位，前一位是j，的！limit方案totnum；</span></span><br><span class="line"><span class="comment">//zero=1表示前面是否全部都是前导零</span></span><br><span class="line"><span class="comment">//limit=1 表示前面对本位有没有限制</span></span><br><span class="line"><span class="comment">//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> prenum,<span class="type">int</span> st,<span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//pos当前位置,pre前一位数,st判断前面是否全是0,limit最高位限制</span></span><br><span class="line">    <span class="keyword">if</span>(pos&gt;len)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//搜完了 </span></span><br><span class="line">    <span class="keyword">if</span>(limit==<span class="number">0</span> &amp;&amp; dp[pos][prenum]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][prenum];</span><br><span class="line">    <span class="comment">//没有最高位限制且已经搜过了</span></span><br><span class="line">    <span class="type">int</span> maxnum=limit?ay[len<span class="number">+1</span>-pos]:<span class="number">9</span>;<span class="comment">//当前位最大数字 </span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=maxnum;i++)<span class="comment">//从0枚举到最大数字 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(i-prenum)&lt;<span class="number">2</span>)<span class="keyword">continue</span>;<span class="comment">//不符合题意，继续</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; st==<span class="number">1</span>)ret+=<span class="built_in">dfs</span>(pos<span class="number">+1</span>,<span class="number">-2</span>,st,limit &amp;&amp; (i==maxnum));</span><br><span class="line">        <span class="comment">//如果有前导0，下一位随意 </span></span><br><span class="line">        <span class="keyword">else</span> ret+=<span class="built_in">dfs</span>(pos<span class="number">+1</span>,i,<span class="number">0</span>,limit &amp;&amp; (i==maxnum));</span><br><span class="line">        <span class="comment">//如果没有前导0，继续按部就班地搜 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(limit==<span class="number">0</span> &amp;&amp; st==<span class="number">0</span>)dp[pos][prenum]=ret;</span><br><span class="line"><span class="comment">//没有最高位限制且没有前导0时记录结果 ，至于为什么要这样，我也不知道，其实可以都记下来的</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">part</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">        ay[++len]=a%<span class="number">10</span>;</span><br><span class="line">        a/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span> (dp));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">part</span>(b)-<span class="built_in">part</span>(a<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱就主打一个看注释吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;10数位DP：数字计数&quot;&gt;10数位DP：数字计数&lt;/h2&gt;
&lt;h1&gt;[ZJOI2010] 数字计数&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数位DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数位DP" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>09 区间DP的博弈论模型： Letter Picking</title>
    <link href="https://xqc-1368.github.io/2024/08/17/09%20%E5%8C%BA%E9%97%B4DP%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%A8%A1%E5%9E%8B%EF%BC%9A%20Letter%20Picking/"/>
    <id>https://xqc-1368.github.io/2024/08/17/09%20%E5%8C%BA%E9%97%B4DP%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%A8%A1%E5%9E%8B%EF%BC%9A%20Letter%20Picking/</id>
    <published>2024-08-17T06:53:17.224Z</published>
    <updated>2024-08-17T14:31:59.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区间DP的博弈论模型：-Letter-Picking">区间DP的博弈论模型： Letter Picking</h2><h1>Letter Picking</h1><h2 id="题面翻译">题面翻译</h2><h3 id="题目描述">题目描述</h3><p>Alice 和 Bob 在玩游戏。</p><p>给出一个长度为偶数的，非空的且仅含小写字母的字符串 $s$。每个玩家还拥有一个初始为空的字符串。</p><p>Alice 先手，两名玩家交替行动。在一次行动中，玩家可以取 $s$ 首或尾字符，将其从 $s$ 中移除后加入到自己的字符串的 <strong>最前面</strong>。</p><p>当 $s$ 为空时游戏结束，拥有字典序更小的字符串的玩家获胜。若两名玩家的字符串相等则平局。</p><p>若 Alice 和 Bob 都足够聪明，判断谁会取胜，或者游戏为平局。</p><p>数据组数 $t\leq 10^3$，$\sum|s|\leq 2\times 10^3$。保证所有输入的 $|s|$ 长度都为偶数。</p><h2 id="题目描述-2">题目描述</h2><p>Alice and Bob are playing a game. Initially, they are given a non-empty string $s$ , consisting of lowercase Latin letters. The length of the string is even. Each player also has a string of their own, initially empty.</p><p>Alice starts, then they alternate moves. In one move, a player takes either the first or the last letter of the string $s$ , removes it from $s$ and prepends (adds to the beginning) it to their own string.</p><p>The game ends when the string $s$ becomes empty. The winner is the player with a lexicographically smaller string. If the players’ strings are equal, then it’s a draw.</p><p>A string $a$ is lexicographically smaller than a string $b$ if there exists such position $i$ that $a_j = b_j$ for all $j &lt; i$ and $a_i &lt; b_i$ .</p><p>What is the result of the game if both players play optimally (e. g. both players try to win; if they can’t, then try to draw)?</p><h2 id="输入格式">输入格式</h2><p>The first line contains a single integer $t$ ( $1 \le t \le 1000$ ) — the number of testcases.</p><p>Each testcase consists of a single line — a non-empty string $s$ , consisting of lowercase Latin letters. The length of the string $s$ is even.</p><p>The total length of the strings over all testcases doesn’t exceed $2000$ .</p><h2 id="输出格式">输出格式</h2><p>For each testcase, print the result of the game if both players play optimally. If Alice wins, print “Alice”. If Bob wins, print “Bob”. If it’s a draw, print “Draw”.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">forces</span><br><span class="line">abba</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alice</span><br><span class="line">Draw</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>One of the possible games Alice and Bob can play in the first testcase:</p><ol><li>Alice picks the first letter in $s$ : $s=$ “orces”, $a=$ “f”, $b=$ “”;</li><li>Bob picks the last letter in $s$ : $s=$ “orce”, $a=$ “f”, $b=$ “s”;</li><li>Alice picks the last letter in $s$ : $s=$ “orc”, $a=$ “ef”, $b=$ “s”;</li><li>Bob picks the first letter in $s$ : $s=$ “rc”, $a=$ “ef”, $b=$ “os”;</li><li>Alice picks the last letter in $s$ : $s=$ “r”, $a=$ “cef”, $b=$ “os”;</li><li>Bob picks the remaining letter in $s$ : $s=$ “”, $a=$ “cef”, $b=$ “ros”.</li></ol><p>Alice wins because “cef” &lt; “ros”. Neither of the players follows any strategy in this particular example game, so it doesn’t show that Alice wins if both play optimally.</p><p>定义状态：</p><p>对于区间i~j，博弈后的结果，记1为先手胜，0为先手平，-1为先手负</p><p>考虑先手：<br><img src="/images/2023-11-15-13-12-58-%E8%80%83%E8%99%91%E5%85%88%E6%89%8B.png" alt=""></p><p>以上为先手必获胜的结果，当先手出招时候，后手想使用反制手段，但是发现后手的每一种选择都是使结果导向先手方胜利，那么后手方没办法只能输；</p><p>接下来讨论先手出招，但后手通过反制手段，但因为选择当中没有使后手方获胜的情况，但存在若干个平手的情况，于是后手方退而求其次，使最终结果导向平局的情况；</p><p>当然这里讨论的是先手不输的情况，先手不输的情况包括先手赢和先手平两种，如果用if+先手赢+else if+先手不输 来把先手赢的情况再第二种情况之前拒之门外，那么第二种情况就是先手不输的情况</p><p>即为</p><p><img src="/images/2023-11-15-13-26-10-%E8%80%83%E8%99%91%E5%85%88%E6%89%8B%20(2).png" alt=""></p><p>附上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>; j &lt;= n; i++, j++) <span class="comment">// 1 start</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; <span class="number">2</span> * k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">2</span> * k; j &lt;= n; i++, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s[i] &lt; s[i + <span class="number">1</span>] &amp;&amp; dp[i + <span class="number">2</span>][j] == <span class="number">0</span> || dp[i + <span class="number">2</span>][j] == <span class="number">1</span>) </span><br><span class="line">            &amp;&amp; (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; s[i] &lt; s[j] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>)  </span><br><span class="line">            || (s[j] &lt; s[j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">2</span>] == <span class="number">0</span> || dp[i][j - <span class="number">2</span>] == <span class="number">1</span>)</span><br><span class="line">            &amp;&amp; (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; s[j] &lt; s[i] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">            (((s[i] &lt;= s[i + <span class="number">1</span>] &amp;&amp; dp[i + <span class="number">2</span>][j] == <span class="number">0</span> || dp[i + <span class="number">2</span>][j] == <span class="number">1</span>) </span><br><span class="line">            &amp;&amp; (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; s[i] &lt;= s[j] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>))</span><br><span class="line">            || (s[j] &lt;= s[j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">2</span>] == <span class="number">0</span> || dp[i][j - <span class="number">2</span>] == <span class="number">1</span>) </span><br><span class="line">            &amp;&amp; (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; s[j] &lt;= s[i] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=1;j&lt;=n;j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> temp, s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        s += temp;</span><br><span class="line">        <span class="type">int</span> ans = solve(s);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Draw&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Alice&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;区间DP的博弈论模型：-Letter-Picking&quot;&gt;区间DP的博弈论模型： Letter Picking&lt;/h2&gt;
&lt;h1&gt;Letter Picking&lt;/h1&gt;
&lt;h2 id=&quot;题面翻译&quot;&gt;题面翻译&lt;/h2&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="区间DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
    
    <category term="博弈论" scheme="https://xqc-1368.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="区间DP" scheme="https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
    <category term="博弈论" scheme="https://xqc-1368.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>08 四边形不等式优化的环形DP：石子合并</title>
    <link href="https://xqc-1368.github.io/2024/08/17/08%20%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96%E7%9A%84%E7%8E%AF%E5%BD%A2DP%EF%BC%9A%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
    <id>https://xqc-1368.github.io/2024/08/17/08%20%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96%E7%9A%84%E7%8E%AF%E5%BD%A2DP%EF%BC%9A%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</id>
    <published>2024-08-17T06:53:17.221Z</published>
    <updated>2024-08-17T14:32:04.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环形DP-四边形不等式优化的区间DP：石子合并">环形DP+四边形不等式优化的区间DP：石子合并</h2><h1>[NOI1995] 石子合并</h1><h2 id="题目描述">题目描述</h2><p>在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。</p><h2 id="输入格式">输入格式</h2><p>数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。</p><p>第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。</p><h2 id="输出格式">输出格式</h2><p>输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 5 9 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">43</span><br><span class="line">54</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>$1\leq N\leq 100$，$0\leq a_i\leq 20$。</p><p>考虑的难点主要有两个：</p><p>1.区间dp处理环形dp的思路是什么？</p><p>2.区间dp的优化方法：四边形不等式；</p><p>先解决问题1：</p><p>环形dp的处理方法就是将原来的数组扩充两倍，将n+1项写成第1项，将n+2项写成第2项······以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,stone[<span class="number">500</span>],pre[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;stone[i];</span><br><span class="line">        stone[i+n]=stone[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+stone[i];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;pre[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;endl;</span></span><br></pre></td></tr></table></figure><p>以n=4为例，最后要输出的是</p><p>dp[1][4]，dp[2][5]，dp[3][6]，dp[4][7]，dp[5][8]的最小值/最大值，即所有长度为n的区间的最值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minn=INT_MAX,maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n;j&lt;=<span class="number">2</span>*n;i++,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        minn=min(minn,dpmin[i][j]);</span><br><span class="line">        maxn=max(maxn,dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;minn&lt;&lt;<span class="built_in">endl</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>再解决问题2：<br>先介绍方法：</p><p><img src="/images/2023-11-06-18-51-26-image.png" alt=""></p><p><img src="/images/2023-11-06-18-51-50-image.png" alt=""></p><p><img src="/images/2023-11-06-18-51-10-image.png" alt=""></p><p><img src="/images/2023-11-06-18-52-49-image.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    m[i][i] = i; <span class="comment">// 初始化边界决策点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; d &lt;= n; ++d)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = d; r &lt;= n; ++l，++ r)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[l][r] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = m[l][r - <span class="number">1</span>]; k &lt;= m[l + <span class="number">1</span>][r];++k) </span><br><span class="line">        <span class="comment">// 利用结论，缩小了枚举范围</span></span><br><span class="line">            <span class="keyword">if</span> (dp[l][k] + dp[k + <span class="number">1</span>][r] + w(l, r) &lt; dp[l][r])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[l][r] = dp[l][k] + dp[k + <span class="number">1</span>][r] + w(l, r); </span><br><span class="line">                <span class="comment">// 更新dp数组</span></span><br><span class="line">                m[l][r] = k; </span><br><span class="line">                <span class="comment">// 更新决策点</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运用最优决策点的关系，可以实现优化。</p><p>然而，我们由上面的文章可以看到，四边形不等式的使用条件其一是w（l，r）满足区间单调性，这个只能数学证明，而且很容易看出来。</p><p><img src="/images/2023-11-06-18-58-09-image.png" alt=""></p><p>其二是，m这个用于标记最佳决策点的数组，在每一行，每一列上都实现单调不下降。本题中，求最大值的时候，m数组不符合这个条件（怎么发现的呢，假设符合条件，然后敲一遍代码，敲完后把m数组打印出来结果如下）<br><img src="/images/2023-11-06-19-00-44-image.png" alt=""></p><p>于是就不符合，只能使用简单的区间dp完成。</p><p>而求最小值的时候，m数组符合这个条件（运行截图如下），于是就可以使用四边形不等式<br><img src="/images/2023-11-06-19-02-47-image.png" alt=""></p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">500</span>][<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dpmin[<span class="number">500</span>][<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> m[<span class="number">500</span>][<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> m1[<span class="number">500</span>][<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,stone[<span class="number">500</span>],pre[<span class="number">500</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;stone[i];</span><br><span class="line">        stone[i+n]=stone[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+stone[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//m数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i][i]=i;</span><br><span class="line">        m1[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e=<span class="number">2</span>;e&lt;=<span class="number">2</span>*n;e++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=e;j&lt;=<span class="number">2</span>*n;i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dpmin[i][j]=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][k]+dp[k+<span class="number">1</span>][j]+pre[j]-pre[i<span class="number">-1</span>]&gt;dp[i][j] &amp;&amp; k+<span class="number">1</span>&lt;=j &amp;&amp; i&lt;=k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i][k]+dp[k+<span class="number">1</span>][j]+pre[j]-pre[i<span class="number">-1</span>];</span><br><span class="line">                    m[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = m1[i][j - <span class="number">1</span>]; k &lt;= m1[i + <span class="number">1</span>][j]; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dpmin[i][k] + dpmin[k + <span class="number">1</span>][j] + pre[j] - pre[i - <span class="number">1</span>] &lt; dpmin[i][j] &amp;&amp; k + <span class="number">1</span> &lt;= j &amp;&amp; i &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dpmin[i][j] = dpmin[i][k] + dpmin[k + <span class="number">1</span>][j] + pre[j] - pre[i - <span class="number">1</span>];</span><br><span class="line">                    m1[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> minn=INT_MAX,maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n;j&lt;=<span class="number">2</span>*n;i++,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        minn=min(minn,dpmin[i][j]);</span><br><span class="line">        maxn=max(maxn,dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;minn&lt;&lt;<span class="built_in">endl</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环形DP-四边形不等式优化的区间DP：石子合并&quot;&gt;环形DP+四边形不等式优化的区间DP：石子合并&lt;/h2&gt;
&lt;h1&gt;[NOI1995] 石子合并&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="环形DP的四边形不等式优化" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="环形DP的四边形不等式优化" scheme="https://xqc-1368.github.io/tags/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>07 二进制优化多重背包问题：樱花</title>
    <link href="https://xqc-1368.github.io/2024/08/17/07%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E6%A8%B1%E8%8A%B1/"/>
    <id>https://xqc-1368.github.io/2024/08/17/07%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E6%A8%B1%E8%8A%B1/</id>
    <published>2024-08-17T06:53:17.218Z</published>
    <updated>2024-08-17T14:31:50.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制优化多重背包问题：樱花">二进制优化多重背包问题：樱花</h2><h1>樱花</h1><h2 id="题目背景">题目背景</h2><p>《爱与愁的故事第四弹·plant》第一章。</p><h2 id="题目描述">题目描述</h2><p>爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \le C_i \le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $P_i(0 \le P_i \le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \le T_i \le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。</p><h2 id="输入格式">输入格式</h2><p>共 $n+1$行：</p><p>第 $1$ 行：现在时间 $T_s$（几时：几分），去上学的时间 $T_e$（几时：几分），爱与愁大神院子里有几棵樱花树 $n$。这里的 $T_s$，$T_e$ 格式为：<code>hh:mm</code>，其中 $0 \leq hh \leq 23$，$0 \leq mm \leq 59$，且 $hh,mm,n$ 均为正整数。</p><p>第 $2$ 行到第 $n+1$ 行，每行三个正整数：看完第 $i$ 棵树的耗费时间 $T_i$，第 $i$ 棵树的美学值 $C_i$，看第 $i$ 棵树的次数 $P_i$（$P_i=0$ 表示无数次，$P_i$ 是其他数字表示最多可看的次数 $P_i$）。</p><h2 id="输出格式">输出格式</h2><p>只有一个整数，表示最大美学值。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6:50 7:00 3</span><br><span class="line">2 1 0</span><br><span class="line">3 3 1</span><br><span class="line">4 5 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>$100%$ 数据：$T_e-T_s \leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。</p><p>样例解释：赏第一棵樱花树一次，赏第三棵樱花树 $2$ 次。</p><h2 id="这是一个普通背包，多重背包，完全背包的混合">这是一个普通背包，多重背包，完全背包的混合</h2><p>其他的背包正常做就行，但由于平时都是把多重背包一个物品最多取n件拆成n个这种的一件物品。时间会消耗得很厉害。于是就出现了二进制优化：</p><p>一个正整数n，可以被分解成1,2,4,…,2^(k-1),n-2^k+1的形式。其中，k是满足n-2^k+1&gt;0的最大整数。</p><p>例如，假设给定价值为2，数量为10的物品，依据二进制优化思想可将10分解为1+2+4+3，则原来价值为2，数量为10的物品可等效转化为价值分别为1x2，2x2，4x2，3x2，即价值分别为2，4，8，6，数量均为1的物品。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4cfb65670d62868228c256e5e03cfef1.png" alt=""></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t,c,p;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exchage</span><span class="params">(<span class="built_in">string</span> st,<span class="built_in">string</span> ed)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(st[<span class="number">1</span>]==<span class="string">&#x27;:&#x27;</span>)st=<span class="string">&quot;0&quot;</span>+st;</span><br><span class="line">    <span class="keyword">if</span>(ed[<span class="number">1</span>]==<span class="string">&#x27;:&#x27;</span>)ed=<span class="string">&quot;0&quot;</span>+ed;</span><br><span class="line">    <span class="type">int</span> hs=stoi(st.substr(<span class="number">0</span>,<span class="number">2</span>)),hed=stoi(ed.substr(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="type">int</span> ms=stoi(st.substr(<span class="number">3</span>,<span class="number">5</span>)),med=stoi(ed.substr(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hed&lt;hs)hed+=<span class="number">24</span>;</span><br><span class="line">    <span class="type">int</span> ret=(hed-hs)*<span class="number">60</span>+med-ms;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> st,ed;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed&gt;&gt;n;</span><br><span class="line">    T=exchage(st,ed);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;T&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tempt,tempc,tempp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tempt&gt;&gt;tempc&gt;&gt;tempp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tempp==<span class="number">1</span> || tempp==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t.push_back(tempt);</span><br><span class="line">            c.push_back(tempc);</span><br><span class="line">            p.push_back(tempp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tempp&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tempp &gt; <span class="built_in">pow</span>(<span class="number">2</span>, x))</span><br><span class="line">            &#123;</span><br><span class="line">                t.push_back(tempt * <span class="built_in">pow</span>(<span class="number">2</span>, x));</span><br><span class="line">                c.push_back(tempc * <span class="built_in">pow</span>(<span class="number">2</span>, x));</span><br><span class="line">                p.push_back(<span class="number">1</span>);</span><br><span class="line">                tempp -= <span class="built_in">pow</span>(<span class="number">2</span>, x);</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">                t.push_back(tempt * tempp);</span><br><span class="line">                c.push_back(tempc * tempp);</span><br><span class="line"><span class="comment">//注意，数量（2个，4个...）绑定后相应的价值和重量也会发生改变</span></span><br><span class="line">                p.push_back(<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="number">0</span>)<span class="comment">//complete package</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=t[i];j&lt;=T;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=max(dp[j],dp[j-t[i]]+c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=T;j&gt;=t[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=max(dp[j],dp[j-t[i]]+c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[T]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二进制优化多重背包问题：樱花&quot;&gt;二进制优化多重背包问题：樱花&lt;/h2&gt;
&lt;h1&gt;樱花&lt;/h1&gt;
&lt;h2 id=&quot;题目背景&quot;&gt;题目背景&lt;/h2&gt;
&lt;p&gt;《爱与愁的故事第四弹·plant》第一章。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;爱与愁大</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="多重背包DP的二进制优化" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="多重背包DP的二进制优化" scheme="https://xqc-1368.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>06 树形DP：金明的预算方案</title>
    <link href="https://xqc-1368.github.io/2024/08/17/06%20%E6%A0%91%E5%BD%A2DP%EF%BC%9A%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/"/>
    <id>https://xqc-1368.github.io/2024/08/17/06%20%E6%A0%91%E5%BD%A2DP%EF%BC%9A%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/</id>
    <published>2024-08-17T06:53:17.215Z</published>
    <updated>2024-08-17T14:31:45.547Z</updated>
    
    <content type="html"><![CDATA[<h1>树形DP：金明的预算方案</h1><p>其实这道题不用树形dp，也可以使用普通的背包dp，但是鉴于树形dp的简单题一题难求，于是我们用树形dp做。</p><h3 id="P1064-NOIP2006-提高组-金明的预算方案">P1064 [NOIP2006 提高组] 金明的预算方案</h3><h2 id="题目描述">题目描述</h2><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><table><thead><tr><th style="text-align:center">主件</th><th style="text-align:center">附件</th></tr></thead><tbody><tr><td style="text-align:center">电脑</td><td style="text-align:center">打印机，扫描仪</td></tr><tr><td style="text-align:center">书柜</td><td style="text-align:center">图书</td></tr><tr><td style="text-align:center">书桌</td><td style="text-align:center">台灯，文具</td></tr><tr><td style="text-align:center">工作椅</td><td style="text-align:center">无</td></tr></tbody></table><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：</p><p>$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$。</p><p>请你帮助金明设计一个满足要求的购物单。</p><h2 id="输入格式">输入格式</h2><p>第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。</p><p>第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。</p><h2 id="输出格式">输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h4 id="数据规模与约定">数据规模与约定</h4><p>对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。</p><p>定义状态：dp【i】【j】=以后序遍历的方式遍历到节点  i  时，还剩的空间为 j 时的最佳answer。</p><p>首先，我们需要构建一个树：（对于测试样例）注意一开始为了统摄所有根节点，我们建立一个0号节点来统摄。</p><p><img src="/images/2023-10-31-20-03-36-image.png" alt=""><br>这是这个dp数组在测试案例的情况下的最后输出结果，（后面可能会用到）</p><p><img src="/images/2023-10-31-19-57-49-image.png" alt=""></p><p>状态转移方程：xbcl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; point_to[<span class="number">61</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;, p[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;, q[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">3200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nowpoint,<span class="type">int</span> nowweight)</span></span><br><span class="line">&#123;<span class="comment">//第一个参数表示当前节点，第二个参数表示当前还剩的重量</span></span><br><span class="line">    <span class="keyword">if</span>(nowweight&lt;=<span class="number">0</span>)<span class="keyword">return</span> ;<span class="comment">//如果当前还剩的重量已经小于0，那么直接返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;point_to[nowpoint].size();i++)</span><br><span class="line">    &#123;<span class="comment">//遍历每一个当前节点的子节点</span></span><br><span class="line">        <span class="type">int</span> child = point_to[nowpoint][i];<span class="comment">//child为子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = nowweight-v[child]; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[child][j] = dp[nowpoint][j] + p[child]*v[child];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把当前0~nowweight-v[child]的所有项给直接搬过来。</span></span><br><span class="line"><span class="comment">再加上p[child]*v[child]即题目规定的权值</span></span><br><span class="line"><span class="comment">其中0~nowweight-v[child]记录着遍历过他的哥哥节点（前面的兄弟节点）后，</span></span><br><span class="line"><span class="comment">所得出的最佳答案</span></span><br><span class="line"><span class="comment">为什么把0~nowweight-v[child]直接搬过来加？首先我们要知道</span></span><br><span class="line"><span class="comment">dp[父节点]【0~nowweight-v[child]】表示的是在父亲只有该子节点的所有哥哥节点的时候</span></span><br><span class="line"><span class="comment">，而完全不取该子节点的有关权值的时候的最优解。</span></span><br><span class="line"><span class="comment">因为我们现在在讨论该子节点取的情况下的最优解，</span></span><br><span class="line"><span class="comment">而取该子节点势必会消耗v[child]的限额，于是我们给该子节点预留v[child]，</span></span><br><span class="line"><span class="comment">那么取完该节点后剩下0~nowweight-v[child]，</span></span><br><span class="line"><span class="comment">在递归到叶子节点（即下一行程序的dfs）</span></span><br><span class="line"><span class="comment">返回后0~nowweight-v[child]一一顺序对应v[child]~nowweight</span></span><br><span class="line"><span class="comment">于是对应原来父节点集合的v[child]~nowweight元素比大小（下面一个循环干的事），</span></span><br><span class="line"><span class="comment">最终得到父节点nowpoint的最优值集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        dfs(child, nowweight - v[child]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = nowweight; k &gt;= v[child]; k--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[nowpoint][k] = max(dp[nowpoint][k], dp[child][k - v[child]]);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这时候你会问了，对于兄弟节点之间，取两个，三个等等在哪里体现。</span></span><br><span class="line"><span class="comment">其实，这在搬过来加权值的时候已经体现了；</span></span><br><span class="line"><span class="comment">如处理样例中5号这个节点的时候，</span></span><br><span class="line"><span class="comment">我们把00000000···00000 1200 1200 1200···1200（十一（因为包括首尾）个）搬过来</span></span><br><span class="line"><span class="comment">在5号节点这个节点的权值1000加上去，dp第五行自然也就变成了1000 1000···1000 2200</span></span><br><span class="line"><span class="comment"> 2200··2200了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    n/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;p[i]&gt;&gt;q[i];</span><br><span class="line">        v[i]/=<span class="number">10</span>;</span><br><span class="line">        point_to[q[i]].push_back(i);</span><br><span class="line"><span class="comment">//建树的过程，point_to是二维数组，用point_to[i]记录i号节点指向的所有节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][n]*<span class="number">10</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>树状dp主要解决树形最优解问题。</p><p>步骤：</p><p>0.递归终止条件：</p><p>剩下限重小于0，返回即可；</p><p>1.遍历每一个子节点：</p><p>（1）搬来加权值：把父节点剪掉子节点的重量的部分照搬，加上子节点的权值，成为子节点的那一行的数组；</p><p>（2）递归：往下递归一层，就更新传参，更新当前节点的参数，更新当前限重。</p><p>（3）高位搬回去比较。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;树形DP：金明的预算方案&lt;/h1&gt;
&lt;p&gt;其实这道题不用树形dp，也可以使用普通的背包dp，但是鉴于树形dp的简单题一题难求，于是我们用树形dp做。&lt;/p&gt;
&lt;h3 id=&quot;P1064-NOIP2006-提高组-金明的预算方案&quot;&gt;P1064 [NOIP2006 提高组] </summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树形DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树形DP" scheme="https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>05 单调队列优化DP：华科A题</title>
    <link href="https://xqc-1368.github.io/2024/08/17/05%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%EF%BC%9A%E5%8D%8E%E7%A7%91A%E9%A2%98/"/>
    <id>https://xqc-1368.github.io/2024/08/17/05%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%EF%BC%9A%E5%8D%8E%E7%A7%91A%E9%A2%98/</id>
    <published>2024-08-17T06:53:17.210Z</published>
    <updated>2024-08-17T14:31:40.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单调队列">单调队列</h2><p>“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理</p><h4 id="单调队列是一种主要用于解决”滑动区间“的最值问题的数据结构"><strong>单调队列</strong>是一种主要用于解决”滑动区间“的最值问题的数据结构</h4><p>即，在长度为  的序列中，求每个长度为  的区间的区间最值。它的时间复杂度是  ，在这个问题中比  的ST表和线段树要优。</p><p><img src="https://pic4.zhimg.com/80/v2-ef66afc38e068600939980673114127f_1440w.webp" alt=""></p><p>单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素<strong>可能</strong>成为某个区间最值时才保留它。</p><p>形象地打个比方，上面的序列可以看成学校里各个年级XCPC选手，数字越大代表能力越强。每个选手只能在大学四年间参赛，毕业了就没有机会了。那么，每一年的王牌选手都在哪个年级呢？</p><p>一开始的时候，大三大四的学长都比较菜，大二的最强，而大一的等大二的毕业后还有机会上位，所以队列里有两个数。</p><p><img src="https://pic3.zhimg.com/80/v2-eeda8e22e5931732675ab99754f93bce_1440w.webp" alt=""></p><p>一年过去了，原本大一的成为大二，却发现新进校的新生非常强，自己再也没有机会成为最大值了，所以弹出队列。</p><p><img src="https://pic4.zhimg.com/80/v2-6749c5666b76cdc2f497df072f8626b3_1440w.webp" alt=""></p><p>又过了一年，新入校的新生尽管能力只有1，但理论上只要后面的人比他还菜，还是可能成为区间最大值的，所以入队。</p><p><img src="https://pic4.zhimg.com/80/v2-e8be2abc277505561313d865b856d327_1440w.webp" alt=""></p><p>终于，原本的王牌毕业了，后面的人以为熬出头了，谁知道这时一个巨佬级别的新生进入了集训队，这下其他所有人都没机会了。</p><p><img src="https://pic3.zhimg.com/80/v2-71dc212718a2565ce57d9e334c93da2e_1440w.webp" alt=""></p><p><em>（这只是比方，现实中各位选手的实力是会增长的，不符合这个模型ovo）</em></p><p>总之，观察就会发现，我们维护的这个队列总是单调递减的。如果维护区间最小值，那么维护的队列就是单调递增的。这就是为什么叫<strong>单调</strong>队列。</p><p><strong>例题：单调队列优化动态规划的应用</strong></p><h4 id="选择数字">选择数字</h4><h6 id="题目描述">题目描述</h6><p>给定一行 $n$ 个非负整数 $a_1 \cdots a_n$。现在你可以选择其中若干个数，但不能有超过 $k$ 个连续的数字被选择。你的任务是使得选出的数字的和最大。</p><h6 id="输入格式">输入格式</h6><p>第一行两个整数 $n$，$k$。</p><p>以下 $n$ 行，每行一个整数表示 $a_i$。</p><h6 id="输出格式">输出格式</h6><p>输出一个值表示答案。</p><h6 id="样例-1">样例 #1</h6><h6 id="样例输入-1">样例输入 #1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h6 id="样例输出-1">样例输出 #1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h4 id="提示">提示</h4><p>对于 $20%$ 的数据，$n \le 10$。</p><p>对于另外 $20%$ 的数据，$k=1$。</p><p>对于 $60%$ 的数据，$n \le 1000$。</p><p>对于 $100%$ 的数据，$1 \le n \le 100000$，$1 \le k \le n$，$0 \le$ 数字大小 $\le 1,000,000,000$。</p><p>时间限制 $500$ ms。</p><p>这种题是很典型的<strong>单调队列优化DP</strong>。</p><p>我们把问题转化为删除若干个数，且删除的数间隔不超过<code>k</code>，求删除数的最小值。设<code>dp[i]</code>表示在删除第<code>i</code>个数的情况下， 前<code>i</code>个数中删除数的最小和。那么很容易想到转移方程：<br><img src="/images/2023-10-24-19-02-53-image.png" alt=""></p><p>这是因为，如果要删除某个数，除非它是前 k+1个数之一，否则在它之前的k+1个数中，至少要删除一个。最后的答案在最后 k+1个数里找最小值，然后用总和去减即可，因为最后 k+1个数中至少有一个是要删除的。</p><p>这个朴素方法是O（mn）的，为了优化它，我们可以使用单调队列。注意到，我们不断地在求<code>dp</code>的区间最小值，而且区间长度是固定的m+1  ，这正好符合滑动窗口的模型。只不过，我们需要动态地进行整个过程，即，在维护单调队列的过程中求出<code>dp</code>。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxsize = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> dp[maxsize] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,k,a[maxsize],sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看作删除若干个数，但是不能有间隔超过k；</span></span><br><span class="line">    <span class="comment">//dp[i]表示，删除a[i]的情况下，完成删除的最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=k+<span class="number">1</span>)</span><br><span class="line">            dp[i]=a[i];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            dp[i]=dp[q.front()]+a[i];        </span><br><span class="line">        <span class="keyword">if</span>(!q.empty() &amp;&amp; q.front()&lt;i-k) q.pop_front();</span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; dp[q.back()] &gt; dp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> emin=LONG_LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-k;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        emin=min(dp[i],emin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum-emin&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在这个过程中的易错点是：</p><p>进入队列的是元素下标不是元素内容！！，且每一次循环不一定一定有元素从头部出队。</p><p>另一个例题：华中科技大学2023新生赛A题</p><h1>[HUSTFC 2023] 简单的加法乘法计算题</h1><h2 id="题目描述-2">题目描述</h2><p>JokerShaco 有一个数字 $x$，最开始 $x=0$，他想要把 $x$ 变成 $y$。为了达到这个目标，他可以利用两个集合 $A$ 和 $B$。其中集合 $A$ 包含 $n$ 个元素，分别是从 $1$ 到 $n$ 的所有正整数；集合 $B$ 包含 $m$ 个元素。每次它可以对 $x$ 进行如下任意次操作：</p><ul><li>选择 $A$ 中的一个元素 $a$，令 $x$ 加上 $a$。</li><li>选择 $B$ 中的一个元素 $b$，令 $x$ 乘以 $b$。</li></ul><p>已知 $y$，$n$，$m$ 和 $B$ 中 $m$ 个元素的具体值，JokerShaco 想知道让 $x$ 变成 $y$ 的最少操作次数。</p><h2 id="输入格式-2">输入格式</h2><p>第一行包含三个整数 $y\ (1\le y\le 5\cdot 10^6)$，$n\ (1\le n\le 5\cdot 10^6)$ 和 $m\ (1\le m\le 10)$，其含义如题目所述。</p><p>第二行包含 $m$ 个正整数，其中第 $i$ 个表示 $B$ 中的第 $i$ 个元素 $b_i\ (1\le b_i\le 5\cdot 10^6)$。</p><h2 id="输出格式-2">输出格式</h2><p>输出一个整数，表示让 $x$ 变成 $y$ 的最少操作次数。在题目条件下可知一定能将 $x$ 变成 $y$。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 3 1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 6 3</span><br><span class="line">2 3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>初步想法是利用线性动态规划进行，dp[i]表示y=i的时候需要走的最少步骤数，状态转移方程为：</p><p>dp[i]=min(    minE(k from i-1 to i-n)  {dp[k]+1}    ,</p><p>minE(r from 1 to m)   if(dp[i]%b[r]=0）dp[i]/b[r] )</p><p>可行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxsize=<span class="number">5000005</span>;</span><br><span class="line"><span class="type">int</span> dp[maxsize]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> b[<span class="number">11</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> y,n,m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;y&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;maxsize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=min(dp[i],dp[dq.front()]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> r = <span class="number">1</span>; r &lt;= m; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">if</span> (i % b[r] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   dp[i] = min(dp[i], dp[i / b[r]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!dq.empty() &amp;&amp; dq.front()&lt;=i-n)</span><br><span class="line">        &#123;</span><br><span class="line">            dq.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty() &amp;&amp; dp[dq.back()]&gt;dp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.push_back(i);<span class="comment">//注意队列中始终是位置，而不是元素内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[y]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>特定类型的题型：多重背包的单调队列优化</h1><h1>宝物筛选</h1><h2 id="题目描述-3">题目描述</h2><p>终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。</p><p>这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。</p><p>小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 $W$ 的采集车，洞穴里总共有 $n$ 种宝物，每种宝物的价值为 $v_i$，重量为 $w_i$，每种宝物有 $m_i$ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。</p><h2 id="输入格式-3">输入格式</h2><p>第一行为一个整数 $n$ 和 $W$，分别表示宝物种数和采集车的最大载重。</p><p>接下来 $n$ 行每行三个整数 $v_i,w_i,m_i$。</p><h2 id="输出格式-3">输出格式</h2><p>输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 20</span><br><span class="line">3 9 3</span><br><span class="line">5 9 1</span><br><span class="line">9 4 2</span><br><span class="line">8 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><p>对于 $30%$ 的数据，$n\leq \sum m_i\leq 10^4$，$0\le W\leq 10^3$。</p><p>对于 $100%$ 的数据，$n\leq \sum m_i \leq 10^5$，$0\le W\leq 4\times 10^4$，$1\leq n\le 100$。</p><h2 id="多重背包的原始状态转移方程：">多重背包的原始状态转移方程：</h2><p>f(i,j)=max(f(i−1,j),f(i−1,j−v)+w,⋯,f(i−1,j−sv)+sw)</p><p>f(i,j−v)=max(f(i−1,j−v),f(i−1,j−2v)+w,⋯,f(i−1,j−(s+1)v)+(s)w)</p><p>f(i,j−2v)=max(f(i−1,j−2v),f(i−1,j−3v)+w,⋯,f(i−1,j−(s+2)v)+sw)</p><p>…</p><p>此处我们取 r = j % v</p><p>f(i,r+sv)=max(f(i−1,r+sv),f(i−1,r+(s−1)v)+w,⋯,f(i−1,r)+sw)</p><p>⋯</p><p>f(i,r+2v)=max(f(i−1,r+2v),f(i−1,r+v)+w,f(i−1,r)+2w)</p><p>f(i,r+v)=max(f(i−1,r+v),f(i−1,r)+w)</p><p>f(i,r)=f(i−1,r)</p><p><img src="https://img-blog.csdnimg.cn/603c76ef4bae466ca24948b2abc6facc.png" alt="">朴素二维数组代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxsize=<span class="number">4e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dp[maxsize][maxsize]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> v[<span class="number">105</span>],w[<span class="number">105</span>],m[<span class="number">105</span>],n,W;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//当前考虑到第i件物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;w[i];r++)<span class="comment">//考虑余数r，余数可能为0~w[i]-1中的任意一个数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=r;j&lt;=W;j+=w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i])</span><br><span class="line">                    q.pop_front();</span><br><span class="line">                <span class="keyword">while</span> (!q.empty() &amp;&amp; dp[i - <span class="number">1</span>][q.back()] + (j - q.back()) / w[i] * v[i] &lt;= dp[i - <span class="number">1</span>][j])</span><br><span class="line">                    q.pop_back();</span><br><span class="line">                q.push_back(j);</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][q.front()] + (j - q.front()) / w[i] * v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一维数组空间优化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxsize=<span class="number">4e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dp[maxsize]=&#123;<span class="number">0</span>&#125;,g[maxsize]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> v[<span class="number">10005</span>],w[<span class="number">10005</span>],m[<span class="number">10005</span>],n,W;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//当前考虑到第i件物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;w[i];r++)<span class="comment">//考虑余数r，余数可能为0~w[i]-1中的任意一个数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">            <span class="built_in">memcpy</span>(g,dp,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=r;j&lt;=W;j+=w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i])</span><br><span class="line">                    q.pop_front();</span><br><span class="line">                <span class="keyword">while</span> (!q.empty() &amp;&amp; g[q.back()] + (j - q.back()) / w[i] * v[i] &lt;= g[j])</span><br><span class="line">                    q.pop_back();</span><br><span class="line">                q.push_back(j);</span><br><span class="line">                dp[j] = g[q.front()] + (j - q.front()) / w[i] * v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单调队列&quot;&gt;单调队列&lt;/h2&gt;
&lt;p&gt;“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理&lt;/p&gt;
&lt;h4 id=&quot;单调队列是一种主要用于解决”滑动区间“的最值问题的数据结构&quot;&gt;&lt;strong&gt;单调队列&lt;/strong&gt;是一种主要用于解决”滑动区间“</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="DP的单调队列优化" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="DP的单调队列优化" scheme="https://xqc-1368.github.io/tags/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>04 状态压缩DP：吃奶酪+Vitamin</title>
    <link href="https://xqc-1368.github.io/2024/08/17/04%20%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP%EF%BC%9A%E5%90%83%E5%A5%B6%E9%85%AA+Vitamin/"/>
    <id>https://xqc-1368.github.io/2024/08/17/04%20%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP%EF%BC%9A%E5%90%83%E5%A5%B6%E9%85%AA+Vitamin/</id>
    <published>2024-08-17T06:53:17.207Z</published>
    <updated>2024-08-17T14:31:30.692Z</updated>
    
    <content type="html"><![CDATA[<h1>吃奶酪</h1><h2 id="题目描述">题目描述</h2><p>房间里放着 $n$ 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$ 点处。</p><h2 id="输入格式">输入格式</h2><p>第一行有一个整数，表示奶酪的数量 $n$。</p><p>第 $2$ 到第 $(n + 1)$ 行，每行两个实数，第 $(i + 1)$ 行的实数分别表示第 $i$ 块奶酪的横纵坐标 $x_i, y_i$。</p><h2 id="输出格式">输出格式</h2><p>输出一行一个实数，表示要跑的最少距离，保留 $2$ 位小数。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 -1</span><br><span class="line">-1 1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.41</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h4 id="数据规模与约定">数据规模与约定</h4><p>对于全部的测试点，保证 $1\leq n\leq 15$，$|x_i|, |y_i| \leq 200$，小数点后最多有 $3$ 位数字。</p><h4 id="提示-2">提示</h4><p>对于两个点 $(x_1,y_1)$，$(x_2, y_2)$，两点之间的距离公式为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。</p><hr><p>$2022.7.13$：新增加一组 $\text{Hack}$ 数据。</p><p>本题使用状态压缩动态规划：状态压缩DP用于解决N小于21的图论问题（本身需要搜索解决的）</p><h6 id="理解状压DP：">理解状压DP：</h6><p>DP[ j ][ S ]表示已走过S的二进制表示的路径，目前终点为 j ；</p><p>比如S是00110101表示已走过第一个点，第三个点，第五个点，第六个点。<br>而假如所给输入一共有n个点，单独表示第一个点记为1&lt;&lt;0,单独表示第二个点记为1&lt;&lt;1由此类推单独表示第n个点为1&lt;&lt;(n-1)，表示已经走过n个点中所有的点，为(1&lt;&lt;n)-1因此，最外层循环枚举 00000000~11111111这所有的情况</p><p>核心部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">1</span>;S&lt;(<span class="number">1</span>&lt;&lt;n);S++)<span class="comment">//S</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//i</span></span><br><span class="line">       <span class="keyword">if</span>(S &amp; (<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))<span class="comment">//2</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">              <span class="keyword">if</span> (!(S &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) &amp;&amp; G[i][j]!=<span class="number">-1</span>)<span class="comment">//3</span></span><br><span class="line">                 dp[j][S | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] = min(dp[j][S | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] , dp[i][S] + G[i][j]);</span><br></pre></td></tr></table></figure><p>状态转移方程为：</p><p>if(S的j-1项为0)  ：</p><p>dp[j][S的j-1项置1]=minE(i from 1 to n and S的第i项为1)  {dp[i][S]+G[i][j]}其中G为邻接表</p><p>总体思路：</p><p>以j为终点</p><p>枚举每个可能的i 到 j，所需要的权值，求最小；</p><p>//S的一层循环提供了每个可能的已走过的路径：</p><p>//i一层循环枚举了目前处于第i个点，但是第i个点不一定在当前的S状态下被走过，所以我们需要判断语句//2，来知晓是否被走过，如果没被走过，则不用再往下考虑。</p><p>S&amp;(1&lt;&lt;(i-1))  表示S从右往左数第（i-1）位为1；</p><p>为什么要i-1，因为我们想最大化利用空间，S最右边是第零位，即S=00000001 = =1&lt;&lt;(1-1)以此类推；</p><p>//j这层循环中枚举了每个在当前的S的状态下，还未到达过的点，即S为0的位置，//3处判断表示当前已走过路径的S的（j-1）位未走过（即为0），并且G[i][j]!=-1表示当前枚举的i可以到达j，G是一个整体的邻接表。</p><p>接下来填充dp[ j ][ S  | (1 &lt;&lt; ( j - 1 ) ) ]位置的数字，即dp当中，以j位置结尾，已走过路径为当前的S在第（j-1）位加上1，即路径上的第j位表示走过  的数字等于每一个以i结尾，已走过路径为S的dp表格值加上i到j的权值的和的最小值，于是，我们求出整个dp表格</p><p>最后关于如何寻找最值位置的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans &gt; dp[i][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] ? dp[i][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] : ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ans为输出的最短路径规划，遍历每一个终点，寻找走过（1&lt;&lt;n）-1即走过11111111的路径的所有终点状态，即找以1号位置结尾的11111111，以2号位置结尾的11111111········</p><p>于是，我们求出了答案；</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 17</span></span><br><span class="line"><span class="type">double</span> dp[<span class="number">16</span>][<span class="number">66000</span>];<span class="comment">//n最大值为15，因此取2的15次方大小，为了保险我取了16次方</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> x[maxsize]=&#123;<span class="number">0</span>&#125;,y[maxsize]=&#123;<span class="number">0</span>&#125;,G[maxsize][maxsize]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxsize;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;maxsize;j++)</span><br><span class="line">    G[i][j]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">            G[i][j] =G[j][i]= <span class="built_in">sqrt</span>((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">66000</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=DBL_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">1</span> &lt;&lt; (i<span class="number">-1</span>)] = <span class="built_in">sqrt</span>((x[i]) * (x[i]) + (y[i]) * (y[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">1</span>;S&lt;(<span class="number">1</span>&lt;&lt;n);S++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S &amp; (<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (!(S &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) &amp;&amp; G[i][j]!=<span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[j][S | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] = dp[j][S | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] &gt; dp[i][S] + G[i][j] ? dp[i][S] + G[i][j] : dp[j][S | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans &gt; dp[i][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] ? dp[i][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的题目是对图论的dp方法，下面的例题显然可以看出的状压dp</p><h1>Vitamins</h1><h2 id="题面翻译">题面翻译</h2><p>数据有$n$组数,每组数有一个价值$c_i$和一个字符串S,字符串S中包含3个字母A,B,C，问集齐ABC三个字母的最小价值（一个字母可以有多个）</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5 C</span><br><span class="line">6 B</span><br><span class="line">16 BAC</span><br><span class="line">4 A</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">10 AB</span><br><span class="line">15 BA</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10 A</span><br><span class="line">9 BC</span><br><span class="line">11 CA</span><br><span class="line">4 A</span><br><span class="line">5 B</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">100 A</span><br><span class="line">355 BCA</span><br><span class="line">150 BC</span><br><span class="line">160 AC</span><br><span class="line">180 B</span><br><span class="line">190 CA</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">250</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 BA</span><br><span class="line">11 CB</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> c[maxsize] = &#123;<span class="number">0</span>&#125;, a[maxsize] = &#123;<span class="number">0</span>&#125;, dp[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> x, <span class="built_in">string</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[x] = a[x] | (<span class="number">1</span> &lt;&lt; ((<span class="type">long</span> <span class="type">long</span>)s[i] - <span class="number">65</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i] &gt;&gt; s;</span><br><span class="line">        mark(i, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = LONG_LONG_MAX / <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> st = (<span class="number">1</span> &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>; st &gt;= <span class="number">0</span>; st--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[st | a[i]] = min(dp[st | a[i]], dp[st] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[(<span class="number">1</span> &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>] == (<span class="type">long</span> <span class="type">long</span>)(LONG_LONG_MAX / <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">10</span>)))</span><br><span class="line">        dp[(<span class="number">1</span> &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次实现了状压dp可视化！！！！<br><img src="/images/20231027174441.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;吃奶酪&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;房间里放着 $n$ 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$ 点处。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;输入格式&lt;/h2&gt;
&lt;p&gt;第一行有一个整数，表示奶酪</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="状压DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="状压DP" scheme="https://xqc-1368.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>03 区域DP：三素数数</title>
    <link href="https://xqc-1368.github.io/2024/08/17/03%20%E5%8C%BA%E5%9F%9FDP%EF%BC%9A%E4%B8%89%E7%B4%A0%E6%95%B0%E6%95%B0/"/>
    <id>https://xqc-1368.github.io/2024/08/17/03%20%E5%8C%BA%E5%9F%9FDP%EF%BC%9A%E4%B8%89%E7%B4%A0%E6%95%B0%E6%95%B0/</id>
    <published>2024-08-17T06:53:17.204Z</published>
    <updated>2024-08-17T13:31:16.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区域DP：三素数数">区域DP：三素数数</h2><h1>三素数数</h1><h2 id="题目背景">题目背景</h2><p>蛟川书院的一道练习题QAQ</p><h2 id="题目描述">题目描述</h2><p>如果一个数的所有连续三位数字都是大于100的素数，则该数称为三素数数。比如113797是一个6位的三素数数。</p><h2 id="输入格式">输入格式</h2><p>一个整数n（3 ≤ n ≤ 10000），表示三素数数的位数。</p><h2 id="输出格式">输出格式</h2><p>一个整数，表示n位三素数的个数m，要求输出m除以10^9 + 9的余数。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">204</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>区域动归QAQ</p><p>设<code>dp[k][i][j]</code>表示到了第k位，这个数字是i，上一个数字是j的方案数</p><ul><li>初始化 <code>dp[2][0→9][0→9]=1</code></li><li>枚举第几位<code>i</code>，现在的数字<code>now</code>，之前的数字<code>pre</code>，上上个数字<code>last</code></li><li>如果<code>last∗100+pre+10+now</code>是素数，那么<code>dp[i][now][pre]+=dp[i−1][pre][last]</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10001</span>][<span class="number">11</span>][<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; <span class="title function_">is_prime</span><span class="params">(<span class="number">1001</span>)</span>; <span class="comment">// 0表示质数，1表示不是质数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_prime</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//欧拉筛板子</span></span><br><span class="line">&#123;</span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i] == <span class="number">0</span>)</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : prime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * j &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            is_prime[i * j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)is_prime[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//仅需要统计101~999的质数，剩下的不属于这个范围</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">combine</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">100</span>+b*<span class="number">10</span>+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n; get_prime(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">            dp[<span class="number">2</span>][i][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">3</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=<span class="number">9</span>;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(is_prime[combine(l,j,i)]==<span class="number">0</span>)</span><br><span class="line">                    dp[k][i][j]=(dp[k][i][j]+dp[k<span class="number">-1</span>][j][l])%MOD;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)ans=(ans+dp[n][i][j])%MOD;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另一道题目：Colo">另一道题目：Colo.</h2><h2 id="题目描述-2">题目描述</h2><p>小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 n，宽度为 1 的网格图上画画，从左往右第 i 个方格被涂成了一种颜色 a_i。</p><p>你觉得他的随意涂鸦太难看了，想要保留恰好 k 种颜色（<strong>你不能保留没在网格图上出现的颜色</strong>），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。</p><p>此外，小 Y 使用的第 i 种颜色有一个价值 b_i，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。</p><p>你需要求出你能够获得的最大的价值是多少。</p><h2 id="输入格式-2">输入格式</h2><p>第一行两个整数 n,k，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。<br>第二行 n 个整数 a_i，表示小 Y 画出来的网格图从左往右第 i 个格子的颜色。<br>第三行 n 个整数 b_i，表示第 i 种颜色的价值。</p><h2 id="输出格式-2">输出格式</h2><p>一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 -1。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 2 1 3 2</span><br><span class="line">5 3 1 100 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 3</span><br><span class="line">1 3 4 2 9 3 4 2 5 1</span><br><span class="line">1 5 2 3 9 8 1 2 3 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h4 id="【样例解释-1】">【样例解释 #1】</h4><p>对于第一组样例，我们可以选择 1 号和 3 号颜色保留，剩下的网格图即为 [1,1,3]，满足单调不下降这一个限制，获得的价值即为 b_1+b_3=5+1=6，可以证明这是最优的办法。</p><h4 id="【数据范围】">【数据范围】</h4><p>对于所有测试数据，满足 1 \le n \le 500，1 \le k \le 500，1 \le a_i \le n，1 \le b_i \le 10^9。</p><p>各测试点的附加限制如下表所示。</p><p><strong>本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 \text{Subtask}。</strong></p><table><thead><tr><th>测试点</th><th>n,k \le</th><th>特殊性质</th></tr></thead><tbody><tr><td>1 \sim 3</td><td>10</td><td>无</td></tr><tr><td>4 \sim 5</td><td>100</td><td>无</td></tr><tr><td>6 \sim 10</td><td>500</td><td>不同的颜色不超过 10 种</td></tr><tr><td>11 \sim 15</td><td>500</td><td>每种颜色出现的次数不超过 2 次</td></tr><tr><td>16 \sim 20</td><td>500</td><td>无</td></tr></tbody></table><p>首先是输入部分代码</p><p>在输入时候用bucket的方式记录每一种颜色的对应第一个和最后一个位置（后面有用）</p><p>记录方式用桶的方式便于查询</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(bucket[a[i]].begin ==inf)&#123;</span><br><span class="line">            bucket[a[i]].begin =i;</span><br><span class="line">            bucket[a[i]].last =i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[a[i]].last =i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br></pre></td></tr></table></figure><p>接下来记录遍历每个颜色（对于每个颜色i） ，看看有哪些颜色（即j）在原数组中的位置是完全在他前面的，即 j 颜色的last小于 i 颜色的begin，(并且j&lt;i由循环条件可知默认成立)。如果有的话加入到数组g的第 i 项指向的（可以这么理解）数组中去。表示在取 i 颜色时候，可以取 j 颜色作为他的前驱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> g[<span class="number">505</span>][<span class="number">505</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].begin ==inf)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bucket[j].begin ==inf)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].begin &gt;bucket[j].last )&#123;</span><br><span class="line">                g[i][count]=j;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最重要的部分：填表</p><p>表格含义如下</p><p><img src="/images/2023-10-03-21-09-42-image.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].begin !=inf)</span><br><span class="line">            dp[<span class="number">1</span>][i]=b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)<span class="comment">//i循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)<span class="comment">//j循环</span></span><br><span class="line">            <span class="keyword">if</span>(bucket[j].begin !=inf &amp;&amp; g[j][<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;g[j][p]!=<span class="number">0</span>;p++)<span class="comment">//p循环</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][g[j][p]] !=<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=max(dp[i][j],dp[i<span class="number">-1</span>][g[j][p]]+b[j]);<span class="comment">//#</span></span><br></pre></td></tr></table></figure><p>以样例二为例</p><p>关键数组信息</p><p><img src="/images/2023-10-03-21-10-42-image.png" alt=""></p><p>第一行循环设置递推初始调件；</p><p>第二个 i 循环，遍历从第二行到第k行，因为问的是选k个，再往下遍历没有意义</p><p>第三个 j 循环，遍历第 i 列到最后的值，ij用来定位每个位置</p><p>以上好像都是废话。。</p><p>第四个p循环，遍历当前所在位置的上一行中所有可能成为该位置前驱的位置，#处表示取这些通过状态转移方程到该位置的所有值的最大值</p><p>最后，遍历第k行找出所有可能情况的最大值，没有，则输出-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> maxf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].begin !=inf)</span><br><span class="line">            maxf=max(maxf,dp[k][i]);</span><br><span class="line">    <span class="keyword">if</span>(maxf==<span class="number">0</span>)maxf=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxf&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>完整代码附上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf -1</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> g[<span class="number">505</span>][<span class="number">505</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span>  begin;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span>  last;</span><br><span class="line">&#125;edge;</span><br><span class="line">edge bucket[<span class="number">505</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,k,a[<span class="number">505</span>],b[<span class="number">505</span>],dp[<span class="number">505</span>][<span class="number">505</span>]=&#123;<span class="number">0</span>&#125;,count;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        bucket[i].begin =inf;</span><br><span class="line">        bucket[i].last =inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(bucket[a[i]].begin ==inf)&#123;</span><br><span class="line">            bucket[a[i]].begin =i;</span><br><span class="line">            bucket[a[i]].last =i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[a[i]].last =i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].begin ==inf)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bucket[j].begin ==inf)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].begin &gt;bucket[j].last )&#123;</span><br><span class="line">                g[i][count]=j;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].begin !=inf)</span><br><span class="line">            dp[<span class="number">1</span>][i]=b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(bucket[j].begin !=inf &amp;&amp; g[j][<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;g[j][p]!=<span class="number">0</span>;p++)</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][g[j][p]] !=<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=max(dp[i][j],dp[i<span class="number">-1</span>][g[j][p]]+b[j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].begin !=inf)</span><br><span class="line">            maxf=max(maxf,dp[k][i]);</span><br><span class="line">    <span class="keyword">if</span>(maxf==<span class="number">0</span>)maxf=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;区域DP：三素数数&quot;&gt;区域DP：三素数数&lt;/h2&gt;
&lt;h1&gt;三素数数&lt;/h1&gt;
&lt;h2 id=&quot;题目背景&quot;&gt;题目背景&lt;/h2&gt;
&lt;p&gt;蛟川书院的一道练习题QAQ&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;如果一个数的所有连续三位数字都是大于10</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="区域DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9FDP/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="区域DP" scheme="https://xqc-1368.github.io/tags/%E5%8C%BA%E5%9F%9FDP/"/>
    
  </entry>
  
  <entry>
    <title>02 区间DP：涂色</title>
    <link href="https://xqc-1368.github.io/2024/08/17/02%20%E5%8C%BA%E9%97%B4DP%EF%BC%9A%E6%B6%82%E8%89%B2/"/>
    <id>https://xqc-1368.github.io/2024/08/17/02%20%E5%8C%BA%E9%97%B4DP%EF%BC%9A%E6%B6%82%E8%89%B2/</id>
    <published>2024-08-17T06:53:17.201Z</published>
    <updated>2024-08-17T06:36:14.454Z</updated>
    
    <content type="html"><![CDATA[<h1>[CQOI2007] 涂色</h1><h2 id="题目描述">题目描述</h2><p>假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\texttt{RGBGR}$。</p><p>每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\texttt{RRRRR}$，第二次涂成 $\texttt{RGGGR}$，第三次涂成 $\texttt{RGBGR}$，达到目标。</p><p>用尽量少的涂色次数达到目标。</p><h2 id="输入格式">输入格式</h2><p>输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。</p><h2 id="输出格式">输出格式</h2><p>仅一行，包含一个数，即最少的涂色次数。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAA</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGBGR</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>$40%$ 的数据满足 $1\le n\le 10$。</p><p>$100%$ 的数据满足 $1\le n\le 50$。</p><p>区间dp的plus版：我愿称之为完全区间dp</p><p>把从i到j的所有情况列在对应表格中；我们发现：</p><p>GBBR可以分解为（此处为常规区间dp）</p><p>G+BBR</p><p>GB+BR</p><p>GBB+R</p><p>这3种情况（隔板法分割把区间一分为二）</p><p>当然也会出现不用讨论分隔直接完成的：比如RGBBR相对于RGBB就可以相等；</p><p>首先赋初值，对角线为初值，赋1；</p><p><img src="/images/2023-10-12-00-01-28-image.png" alt=""></p><p>然后我们可以手动填上第二个斜线上的数字，我们可以看见，因为s[2]==s[3]，所以只要在刷一个的时候范围刷大刷到另一个所在位置即可，故dp[ i ][ j ] = =dp[ i-1 ][ j ]==dp[i+1][ j ]</p><p>所以当区间 i~j 首末数字相等时，可以直接 ”刷过来“ ，即等于下面的或者左边的；</p><p><img src="/images/2023-10-12-00-01-58-image.png" alt=""></p><p>当区间 i~j 首末数字不相等时候，则用区间dp对当前空格位置代表的字符串切分，比出一个最小值</p><p>例如GBBR可以分解为（此处为常规区间dp）</p><p>G+BBR   dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ]</p><p>GB+BR   dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ]</p><p>GBB+R   dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ]</p><p>这3种情况（隔板法分割把区间一分为二）</p><p>因此：dp[ 1 ][ 4 ]=max{ dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ] , dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ] , dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ] };</p><p>由此我们得到对于任意一个dp[ i ][ j ]的状态转移方程</p><p>dp[ i ][ j ]=  case1:   dp[ i-1 ][ j ]  or  dp[i+1][ j ]  ( if s[ i ]==s[ j ] )</p><p>case 2: maxE(k from i to j-1){dp[ i ][ k ]+dp[ k+1 ][ j ]}  ( if s[ i ]!=s[ j ] )</p><p><img src="/images/2023-10-12-00-03-22-image.png" alt=""></p><p>由此我们就可以很愉快的敲代码了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 55</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> dp[maxsize][maxsize]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;s.size()<span class="number">-1</span>;p++)<span class="comment">//注意见下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=p+<span class="number">1</span>;j&lt;s.size();i++,j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])dp[i][j]=dp[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i][i]+dp[i+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)</span><br><span class="line">                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][s.size()<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的p是指对第2~n个主对角线方向的斜线的遍历（第一个斜线即主对角线已经遍历过了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[CQOI2007] 涂色&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$&#92;textt</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="区间DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="区间DP" scheme="https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚</title>
    <link href="https://xqc-1368.github.io/2024/08/17/01%20%E8%83%8C%E5%8C%85DP%EF%BC%9AMake_Full_Use_Of%E6%A8%A1%E5%9E%8B%EF%BC%9Akkksc03%E8%80%83%E5%89%8D%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/"/>
    <id>https://xqc-1368.github.io/2024/08/17/01%20%E8%83%8C%E5%8C%85DP%EF%BC%9AMake_Full_Use_Of%E6%A8%A1%E5%9E%8B%EF%BC%9Akkksc03%E8%80%83%E5%89%8D%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/</id>
    <published>2024-08-17T06:53:17.196Z</published>
    <updated>2024-08-17T14:31:12.026Z</updated>
    
    <content type="html"><![CDATA[<h1>kkksc03考前临时抱佛脚</h1><h2 id="题目背景">题目背景</h2><p>kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。</p><h2 id="题目描述">题目描述</h2><p>这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。</p><p>kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。</p><p>由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。</p><h2 id="输入格式">输入格式</h2><p>本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。</p><p>第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。</p><p>第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。</p><p>第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。</p><p>第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。</p><h2 id="输出格式">输出格式</h2><p>输出一行,为复习完毕最短时间。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 1 3        </span><br><span class="line">5</span><br><span class="line">4 3</span><br><span class="line">6</span><br><span class="line">2 4 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>$1\leq s_1,s_2,s_3,s_4\leq 20$。</p><p>$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。</p><p>本题为背包dp的 “ 简单 ” 变式：虽然简单变一变本蒟蒻已经不会了。</p><p>一开始的思路是贪心算法：对每一组而言先排序，然后从后向前把元素往两个空脑子里丢，哪个脑子目前内容比较少就丢哪个。</p><p>代码如下，喜提零分（听取蛙声一片）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxsize = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, inp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min_time</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> lsum=<span class="number">0</span>,rsum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lsum&gt;rsum)rsum+=a[i];</span><br><span class="line">        <span class="keyword">else</span> lsum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(lsum,rsum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum_time=<span class="number">0</span>,na,nb,nc,nd;</span><br><span class="line">    <span class="type">int</span> a[maxsize],b[maxsize],c[maxsize],d[maxsize];</span><br><span class="line">        cin&gt;&gt;na&gt;&gt;nb&gt;&gt;nc&gt;&gt;nd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;na;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nb;i++)</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nc; i++)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nd; i++)</span><br><span class="line">        cin &gt;&gt; d[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">min_time</span>(a, na) + <span class="built_in">min_time</span>(b, nb) + <span class="built_in">min_time</span>(c, nc) + <span class="built_in">min_time</span>(d, nd) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：以上代码为错误代码！！！！！！！！！</p><p>因为可以找到一组hack数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在某一行：</span><br><span class="line">10 10 6 6 5 3 </span><br></pre></td></tr></table></figure><p>按照贪心算法</p><p>10 6 5</p><p>10 6 3</p><p>max为21</p><p>但是实际上：</p><p>10 10</p><p>6 6 5 3</p><p>max为20</p><p>于是验证了贪心的不可行性，而这种退一步达到全局最优解的情况，就应该使用dp</p><p>这道题使用的是最基本的背包dp。我们由以上思路可以知晓，当两个脑子处理的内容大小最接近 的时候将会达到本组最优解。于是我给第一个脑子一个容量预算为sum/2（即背包容量），在运算过程中不能超过这个预算。通过将每个选择装进背包的物品的v等价于其重量w这种方法，由此得出最大化利用sum/2的背包空间所能装得下的处理总量，即dp[ sum/2 ];</p><p>而max（sum-dp[ sum/2 ]，dp[ sum/2 ]）即为某一组耗时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dynamic_programming</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> homework[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> homework[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">2501</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum/<span class="number">2</span>;j&gt;=homework[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-homework[i]]+homework[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(sum - dp[sum / <span class="number">2</span>], dp[sum / <span class="number">2</span>]); </span><br><span class="line">    <span class="comment">// return sum - dp[sum / 2];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外由于int是除以2（在正数范围内）向下取整的特性，可以数学证明sum-dp[ sum/2 ]总是大于dp[ sum/2 ]，所以注释行也还可以那样输出。</p><p>最后，完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dynamic_programming</span><span class="params">(<span class="type">int</span> sum,<span class="type">int</span> homework[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> homework[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">2501</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum/<span class="number">2</span>;j&gt;=homework[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-homework[i]]+homework[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(sum - dp[sum / <span class="number">2</span>], dp[sum / <span class="number">2</span>]); <span class="comment">// return sum - dp[sum / 2];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>   b[<span class="number">21</span>] = &#123;<span class="number">0</span>&#125;,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=a[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;b[j];</span><br><span class="line">            sum+=b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=<span class="built_in">dynamic_programming</span>(sum,b,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;kkksc03考前临时抱佛脚&lt;/h1&gt;
&lt;h2 id=&quot;题目背景&quot;&gt;题目背景&lt;/h2&gt;
&lt;p&gt;kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;这次期末</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="背包DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="背包DP" scheme="https://xqc-1368.github.io/tags/%E8%83%8C%E5%8C%85DP/"/>
    
  </entry>
  
  <entry>
    <title>11 期望DP：收集邮票</title>
    <link href="https://xqc-1368.github.io/2024/08/17/11%20%E6%9C%9F%E6%9C%9BDP%EF%BC%9A%E6%94%B6%E9%9B%86%E9%82%AE%E7%A5%A8/"/>
    <id>https://xqc-1368.github.io/2024/08/17/11%20%E6%9C%9F%E6%9C%9BDP%EF%BC%9A%E6%94%B6%E9%9B%86%E9%82%AE%E7%A5%A8/</id>
    <published>2024-08-17T06:53:17.192Z</published>
    <updated>2024-08-17T14:32:13.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11期望DP">11期望DP</h2><h1>收集邮票</h1><h2 id="题目描述">题目描述</h2><p>有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $1/n$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 次邮票需要支付 $k$ 元钱。</p><p>现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。</p><h2 id="输入格式">输入格式</h2><p>一行，一个数字 $N$（$N \le 10000$）。</p><h2 id="输出格式">输出格式</h2><p>输出要付出多少钱，保留二位小数。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21.25</span><br></pre></td></tr></table></figure><ul><li>定义状态</li></ul><p>众所周知，期望DP的定义状态一般都为<strong>已经……还需要……的期望</strong></p><p>由于本题需要求的就是</p><p><em>自己得到所有种类的邮票需要花费的钱数目的期望。</em></p><p>那么我们就可以定义一个 <code>ex</code> ，它的意义是：</p><p>$ex(i)$：已经收集到了 i 种邮票，还需要花费的钱数的期望。</p><p>但是题目中有一个条件</p><p><em>皮皮购买第k张邮票需要支付k元钱</em></p><p>这意味着购买价格是与购买次数有关的。</p><p>所以我们还需要定义一个状态 <code>num</code> ，它的意义是：$num(i)$：</p><p>已经收集到了 <code>i </code>种邮票，还需要购买的次数的期望。</p><ul><li>初始化：$num(n)=0$，$ex(n)=0$</li></ul><p>这个应该不需要我讲吧qwq</p><ul><li>状态转移</li></ul><p>首先吧这个写在前面</p><p>期望公式：$E(X)= \sum pi​⋅xi$​ ，其中 pi​ 是事件 i 发生的概率，xi​ 是权值。</p><p>发现 num 的转移是比较简单的，先考虑 num。有以下两种情况：</p><ul><li><p>买到之前买到过的邮票种类，此时 $x=num(i)+1$（种类总数不变），$p=\frac{i}{n}$​</p></li><li><p>买到之前没有买到过的，此时 $x=num(i+1)+1$（总种类数量+1），$p=\frac{n-i}{n}$​</p></li></ul><p>注：以上的 x 指的是<strong>次数</strong>。</p><p>根据公式，我们就可以得到关于 num 的公式：</p><p>$num(i)=(num(i)+1)×\frac{i}{n}+(num(i+1)+1)×\frac{n-i}{n}$</p><p>化简之后得到状态转移方程：</p><p>$$<br>num(i)= \frac{num(i+1)×\frac{n-i}{n}+1}{1−\frac{n-i}{n}}​<br>$$</p><p>得到 num 后，我们再思考 ans 的转移，同样是以上的两种情况</p><ul><li><p>买到之前买到过的邮票种类：此时 $x=ex(i)+num(i)+1$（种类+1，总花费=之前花费+本次花费），$p=\frac{i}{n}$</p></li><li><p>买到之前没有买到过的，此时$x=ex(i+1)+num(i+1)+1$（同上），$p=\frac{n-i}{n}$</p></li></ul><p>然后我们又轻松地得到了关于 <code>ex</code> 的公式：</p><p>$ex(i)=(ex(i)+num(i)+1)×\frac{i}{n}​+(ex(i+1)+num(i+1)+1)×​\frac{n-i}{n}$</p><p><s>请自行化简</s></p><p>既然我们有了转移方程，那就开写呗</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> num[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;,ex[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    num[n]=<span class="number">0</span>;ex[n]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> p=(<span class="type">double</span>)n/(n-i);</span><br><span class="line">        num[i]=p+num[i+<span class="number">1</span>];</span><br><span class="line">        ex[i]=p*num[i]+ex[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;=n;i++)cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;=n;i++)cout&lt;&lt;ex[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ex[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;ex[0]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;11期望DP&quot;&gt;11期望DP&lt;/h2&gt;
&lt;h1&gt;收集邮票&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="期望DP" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="期望DP" scheme="https://xqc-1368.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"/>
    
  </entry>
  
</feed>
