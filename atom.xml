<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XQC1368的emo小屋</title>
  
  <subtitle>嬛嬛，朕emo啦！！</subtitle>
  <link href="https://xqc-1368.github.io/atom.xml" rel="self"/>
  
  <link href="https://xqc-1368.github.io/"/>
  <updated>2024-08-19T03:31:56.292Z</updated>
  <id>https://xqc-1368.github.io/</id>
  
  <author>
    <name>XQC1368</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07函数</title>
    <link href="https://xqc-1368.github.io/2024/08/19/07%E5%87%BD%E6%95%B0/"/>
    <id>https://xqc-1368.github.io/2024/08/19/07%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-19T04:23:45.921Z</published>
    <updated>2024-08-19T03:31:56.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础笔记07函数"><a class="markdownIt-Anchor" href="#基础笔记07函数"></a> 基础笔记：07函数</h2><h5 id="1函数定义-函数调用-函数原型"><a class="markdownIt-Anchor" href="#1函数定义-函数调用-函数原型"></a> 1.函数定义、函数调用、函数原型</h5><p>（1）定义：函数（Function）是C中模块化编程的最小单位；</p><ul><li>一个C程序由一个或多个源程序文件组成</li></ul><ul><li>一个源程序文件由一个或多个函数组成<br /><img src="/images/2023-11-17-14-28-57-image.png" alt="" /></li></ul><p>（2）函数的地位关系</p><ul><li><p>函数是平等的</p></li><li><p>main()稍微特殊一点，C程序的执行从main函数开始。调用其他函数后流程回到main函数，在main函数中结束整个程序的运行<br /><img src="/images/2023-11-17-14-39-23-image.png" alt="" /></p></li></ul><p>（3）函数的分类</p><p>标准库函数</p><ul><li><p>ANSI/ISOC定义的标准库函数</p><ul><li><p>符合标准的C语言编译器必须提供这些函数</p></li><li><p>函数的行为也要符合ANSI/ISOC定义</p></li></ul></li><li><p>第三方库函数</p><ul><li><p>其他厂商自行开发的C语言函数库</p></li><li><p>不在标准范围内，能扩充C语言的功能（图形、数据库等）</p></li></ul></li></ul><p>自定义函数</p><ul><li><p>用户自己定义的函数</p><ul><li>包装后，也可成为函数库，供别人使用</li></ul></li></ul><p>（4）程序设计中函数的功能</p><ul><li>不局限于计算，还有判断推理</li></ul><p>（5）函数定义方法<br /><img src="/images/2023-11-17-14-43-24-image.png" alt="" /><br /><img src="/images/2023-11-17-14-44-14-image.png" alt="" /></p><blockquote><p><strong>C/C++main函数返回值以及return 0的作用</strong></p><p><strong>main函数的返回值</strong></p><p>main函数的返回值用于说明程序的退出状态。如果返回0，则代表程序正常退出。返回其它数字的含义则由系统决定。通常，返回非零代表程序异常退出。</p></blockquote><p>素养阅读<br /><img src="/images/2023-11-17-14-48-44-image.png" alt="" /></p><p><img src="/images/2023-11-17-14-48-57-image.png" alt="" /></p><h5 id="2函数的参数传递与返回值"><a class="markdownIt-Anchor" href="#2函数的参数传递与返回值"></a> 2.函数的参数传递与返回值</h5><p>（1）函数的参数传递和返回值</p><ul><li><p>调用者通过函数名调用函数</p></li><li><p><img src="/images/2023-11-17-14-50-21-image.png" alt="" /></p></li><li><p>有返回值时，可放到一个赋值表达式语句中</p></li><li><p><img src="/images/2023-11-17-14-50-37-image.png" alt="" /></p></li><li><p>还可放到一个函数调用语句中，作为另一个函数的参数</p></li><li><p><img src="/images/2023-11-17-14-50-52-image.png" alt="" /></p></li></ul><p>（2）函数调用</p><ul><li><p>函数定义时的参数，形式参数（Parameter），简称形参</p></li><li><p>函数调用时的参数，实际参数（Argument），简称实参</p></li></ul><p>过程：每次执行函数调用时</p><ul><li><p>现场保护并为函数的内部变量（包括形参）分配内存</p></li><li><p>把实参值复制给形参，单向传值（实参–&gt;形参）</p></li><li><p>实参与形参数目一致，类型匹配（否则类型自动转换）</p></li><li><p>现场保护</p></li></ul><p>执行函数内语句</p><ul><li>当执行到return语句或}时，从函数退出</li></ul><p>从函数退出时</p><ul><li><p>根据函数调用栈中保存的返回地址，返回到当次函数调用的地方</p></li><li><p>程序控制权交给调用者，返回值作为函数调用表达式的值</p></li><li><p>收回分配给函数内所有变量（包括形参）的内存</p></li></ul><p>（3）函数原型</p><ul><li><p>调用函数前先声明返回值类型、函数名和形参类型</p></li><li><p>有助于编译器对函数参数类型的匹配检查<br /><img src="/images/2023-11-17-14-56-25-image.png" alt="" /></p></li></ul><p>区别：<br /><img src="/images/2023-11-17-14-57-11-image.png" alt="" /></p><p>（4）函数封装（Encapsulation）</p><ul><li><p>外界对函数的影响仅限于入口参数</p></li><li><p>函数对外界的影响仅限于一个返回值和数组、指针形参</p></li></ul><p>如何增强程序的健壮性，使函数具有遇到不正确使用或非法数据输入时避免出错的能力？答：在函数的入口处，检查输入参数的合法性，同时，主程序增加对函数返回值的检验</p><p>（5）函数复用：就是用好几次</p><p>（6）断言（assert）<br /><img src="/images/2023-11-17-15-09-13-image.png" alt="" /></p><p>考虑使用断言的几种情况</p><ul><li><p>检查程序中的各种假设的正确性</p></li><li><p>证实或测试某种不可能发生的状况确实不会发生</p></li></ul><p>仅用于调试程序，不能作为程序的功能</p><ul><li><p>Debug版有效</p></li><li><p>Release版失效</p><blockquote><p><strong>Debug和Release的区别</strong><br />Debug：调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。<strong>Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息</strong><br />Release：发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。<strong>Release模式下生成一个文件.exe或.dll文件</strong></p><p><strong>Debug 版本：</strong><br />/MDd /MLd 或 /MTd 使用 Debug runtime library(调试版本的运行时刻函数库)<br />/Od 关闭优化开关<br />/D “_DEBUG” 相当于 #define _DEBUG,打开编译调试代码开关(主要针对assert函数)<br />/ZI 创建 Edit and continue(编辑继续)数据库，这样在调试过程中如果修改了源代码不需重新编译<br />/GZ 可以帮助捕获内存错误<br />/Gm 打开最小化重链接开关，减少链接时间</p><p><strong>Release 版本：</strong><br />/MD /ML 或 /MT 使用发布版本的运行时刻函数库<br />/O1 或 /O2 优化开关，使程序最小或最快<br />/D “NDEBUG” 关闭条件编译调试代码开关(即不编译assert函数)<br />/GF 合并重复的字符串，并将字符串常量放到只读内存，防止被修改</p></blockquote></li></ul><h5 id="3递归函数"><a class="markdownIt-Anchor" href="#3递归函数"></a> 3.递归函数</h5><p>（1）函数的嵌套调用</p><ul><li><p>C语言规定函数不能嵌套定义</p><ul><li>函数是相互平行的，该限制可以使编译器简单化</li></ul></li><li><p>但可以嵌套调用</p><ul><li>在调用一个函数的过程中又调用另一个函数<br /><img src="/images/2023-11-17-15-17-27-image.png" alt="" /></li></ul></li><li><p>函数直接或间接调用自己，称为递归调用（RecursiveCall），这样的函数，称为递归函数（Recursive Function）</p></li></ul><p>（2）递归函数</p><ul><li><p>字典是递归定义的典型实例<br /><img src="/images/2023-11-17-15-24-53-image.png" alt="" /><br /><img src="/images/2023-11-17-15-25-15-image.png" alt="" /></p></li><li><p>递归过程<br /><img src="/images/2023-11-17-15-24-22-image.png" alt="" /></p></li><li><p>函数调用栈<br /><img src="/images/2023-11-17-15-19-33-image.png" alt="" /><br /><img src="/images/2023-11-17-15-20-15-image.png" alt="" /><br /><img src="/images/2023-11-17-15-20-30-image.png" alt="" /><br /><img src="/images/2023-11-17-15-20-55-image.png" alt="" /><br /><img src="/images/2023-11-17-15-21-28-image.png" alt="" /></p></li></ul><p><img src="/images/2023-11-17-15-22-48-image.png" alt="" /><br /><img src="/images/2023-11-17-15-23-15-image.png" alt="" /><br /><img src="/images/2023-11-17-15-23-22-image.png" alt="" /><br /><img src="/images/2023-11-17-15-23-29-image.png" alt="" /></p><p>(5)递归方法编写程序的优点</p><ul><li><p>符合人的思维习惯，逼近数学公式的表示</p></li><li><p>从编程角度来看，简洁、直观、精炼，易编、易懂、逻辑清楚，结构清晰、可读性好</p></li></ul><p>（6）递归方法编写程序的缺点</p><ul><li><p>增加了函数调用开销，每次调用都需参数传递、现场保护等，为函数使用的参数、局部变量等额外分配存储空间</p></li><li><p>耗费更多的时间和栈空间，时空效率低</p></li><li><p>重复计算多</p></li></ul><h5 id="4变量的作用域与存储类型"><a class="markdownIt-Anchor" href="#4变量的作用域与存储类型"></a> 4.变量的作用域与存储类型</h5><ul><li><p>变量的作用域 （Scope）:指在源程序中定义变量的位置及其能被读写访问的</p><p>范围，分为：</p><ul><li><p>局部变量（Local Variable）:在语句块内（函数、复合语句）定义的变量</p></li><li><p>有效范围仅为该语句块（函数，复合语句）</p><p>仅能由语句块内的语句访问，退出语句块时释放内存，不再有效</p></li><li><p>全局变量（Global Variable )：在所有函数之外定义的变量</p><p>有效范围是从定义变量的位置开始，到本程序结束</p></li></ul></li><li><p>假如变量同名…</p><ul><li><p>并列语句块内各自定义（不同作用域）的变量同名互不干扰</p></li><li><p>形参和实参的作用域不同，互不干扰（改变形参对实参不影响）</p></li><li><p>局部变量与全局变量同名：局部变量屏蔽全局变量</p><p>只要作用域不同，新的声明屏蔽旧的声明<br /><img src="/images/2023-11-17-15-36-40-image.png" alt="" /></p></li></ul></li><li><p>编译器如何区分不同作用域的同名变量？</p><ul><li><p>一个变量名能代表两个不同的值，仅当它能代表两个不同的内存地址</p></li><li><p>编译器通过将同名变量映射到不同的内存地址来实现作用域的划分局部变量和全局变量被分配的内存区域不同，因而内存地址也不同</p></li><li><p>形参和实参的作用域、内存地址不同，所以形参值的改变不会影响实参</p></li></ul></li></ul><blockquote><p>可划分为四大内存分区：堆、栈、静态存储区和代码区。</p><p><strong>堆区：</strong><br />由程序猿手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请，堆的总大小为机器的虚拟内存的大小。<br />说明：new操作符本质上是使用了malloc进行内存的申请，new和malloc的区别如下：<br />（1）malloc是C语言中的函数，而new是C++中的操作符。<br />（2）malloc申请之后返回的类型是void*，而new返回的指针带有类型。<br />（3）malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数。</p><p><strong>栈区：</strong><br />由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。整个程序的栈区的大小可以在编译器中由用户自行设定，VS中默认的栈区大小为1M，可通过VS手动更改栈的大小。64bits的Linux默认栈大小为10MB，可通过ulimit -s临时修改。</p><p><strong>静态存储区：</strong><br />静态存储区内的变量在程序编译阶段已经分配好内存空间并初始化。这块内存在程序的整个运行期间都存在，它主要存放静态变量、全局变量和常量。<br /><strong>注意：</strong><br />（1）<em>这里不区分初始化和未初始化的数据区</em>，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。<br />（2）静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。<br />（3）字符串常量存储在静态存储区的常量区，字符串常量的名称即为它本身，属于常变量。<br />（4）数据区的具体划分，有利于我们对于变量类型的理解。不同类型的变量存放的区域不同。后面将以实例代码说明这四种数据区中具体对应的变量。</p><p><strong>代码区：</strong><br />存放程序体的二进制代码。比如我们写的函数，都是在代码区的。</p><p><strong>示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//静态全局变量区</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//编译器默认初始化为NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//栈</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//栈</span></span><br><span class="line">    <span class="type">char</span> *p2 = <span class="string">&quot;123456&quot;</span>;<span class="comment">//123456在字符串常量区，p2在栈上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c =<span class="number">0</span>; <span class="comment">//c在静态变量区，0为文字常量，在代码区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d=<span class="number">0</span>; <span class="comment">//栈</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> d;<span class="comment">//静态常量区</span></span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);<span class="comment">//分配得来得10字节在堆区。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="comment">//123456放在字符变量想串常量区，编译器可能会将它与p2所指向的&quot;123456&quot;优化成一个地方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上所有代码，编译成二进制后存放于代码区，文字常量存放于代码区，是不可寻址的。</p></blockquote><ul><li><p>变量的存储类型</p><p>存储类型  数据类型  变量名;</p><ul><li>C存储类型关键字：auto（自动变量）、static（静态变量）(包括：静态局部变量，静态外部变量)、extern（外部变量）（编译器并不对其分配内存，只是表明“我知道了”）、register（寄存器变量）</li></ul></li><li><p>全局变量（跟下面几类不是并列关系）</p></li></ul><p>先看看定义：定义在函数外面的变量，就叫全局变量。</p><p>包括：<strong>普通全局变量</strong>   <strong>静态全局变量</strong>    <strong>跨文件引用全局变量(extern)</strong></p><ul><li><strong>关于自动变量的解释</strong></li></ul><blockquote><p>又叫动态局部变量（缺省类型），存在栈内。进入语句块时自动申请内存，退出时自动释放内存，离开函数，值就消失</p></blockquote><ul><li><strong>关于外部变量的解释</strong></li></ul><blockquote><p>全局变量在整个程序中起作用，如果程序包含多个程序文件模块，可以通过外部声明，使得全局变量的作用范围扩展到其他模块，也可以通过定义静态全局变量，使其作用范围仅限制在这个模块</p><p>全局变量只能被定义一次，如果其他模块要使用该全局变量，需要通过外部变量的声明。</p><p>外部变量声明格式： extern 变量名表；</p><p>只起说明作用，不分配存储单元，对应存储单元在全局变量定义时分配。</p><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">write_extern</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> count = <span class="number">5</span>;</span><br><span class="line"> write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>support.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_extern</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;count is %d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>关于静态局部变量的解释</strong></li></ul><blockquote><ol><li>静态局部变量在静态存储区内分配存储单元，在程序整个运行期间都不释放。而普通局部变量属于动态存储类别，存储在动态存储区空间，函数调用结束后即释放；</li><li>静态局部变量只初始化一次，以后每次调用函数时保留上次函数调用结束时的值。而自动变量每调用一次函数重新执行一次赋值语句；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(对数值型变量)或空字符(对字符型变量)。而对自动变量来说，如果不赋初值，则它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的值是不确定的。</li><li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域仍为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它的。</li></ol></blockquote><ul><li><strong>关于静态全局变量的解释</strong></li></ul><blockquote><p>当程序只有一个文件模块，其与一般全局变量作用相同； 当程序有多个模块时，C语言静态全局变量的作用范围局限于该模块。</p><p>1）全局变量是不显式用static修饰的全局变量，但全局变量默认是动态的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。</p><p>2）全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。</p><p>静态全局变量有以下特点：</p><p>1.该变量在全局数据区分配内存；</p><p>2.未经初始化的静态全局变量会被程序自动初始化为0</p><p>3.静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</p><p>4.静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。</p><ul><li><p>局部变量初始化时机问题：</p><p>首先，静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。</p><p>在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p><p>而在C<ins>中，初始化时在执行相关代码时才会进行初始化，~~*主要是由于C</ins>引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C<ins>标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。*~~ **所以在C</ins>中是可以使用变量对静态局部变量进行初始化的。**</p></li><li><p>后面再来谈谈另一个问题，假如我们在一个循环中，定义了一个静态局部变量并进行初始化，循环过程中，编译器怎么知道当前的静态局部变量已经初始化过了呢？</p><ul><li><p>这个问题C和C++的处理方式也是不一样的。</p></li><li><p>C中编译器会直接跳过这一个语句，因为在编译的时候已经对静态局部变量进行过分配空间并初始化，所以代码执行过程中根本不需要再次执行。</p></li><li><p>而在C++中，编译器会在编译器分配内存后，在全局区域（当前静态局部变量的地址）<strong>附近</strong>同样分配一块空间，进行记录变量是否已经进行过初始化。之所以说附近是根据编译器不同，处理方式不同导致的。</p></li></ul></li></ul></blockquote><ul><li><strong>关于寄存器变量的解释</strong></li></ul><blockquote><p>在程序运行时，根据需要到内存中相应的存储单元中调用，如果一个变量在程序中频繁使用，例如循环变量，那么，系统就必须多次访问内存中的该单元，影响程序的执行效率。</p><p>因此，C语言\C++语言还定义了一种变量，不是保存在内存上，而是直接存储在CPU中的寄存器中，这种变量称为寄存器变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> i=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><ol><li>C编译程序会自动地将寄存器变量变为自动变量</li></ol><ul><li><p>对于VC编译器会自动优化，即使没有声明寄存器变量，VC也会自动优化。</p></li><li><p>对于GCC编译器就不会自动优化。</p></li></ul><ol start="2"><li><p>由于受硬件寄存器长度的限制，所以寄存器变量只能是char、int或指针型。</p></li><li><p>寄存器说明符只能用于说明函数中的变量和函数中的形参，因此不允许将外部变量或静态变量说明为&quot;register&quot;</p></li><li><p>register变量使用的是硬件CPU中的寄存器，寄存器变量无地址，所以不能使用取地址运算符&quot;&amp;&quot;求寄存器变量的地址。</p></li></ol></blockquote><h5 id="5模块化程序设计方法自顶向下"><a class="markdownIt-Anchor" href="#5模块化程序设计方法自顶向下"></a> 5.模块化程序设计方法：自顶向下</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础笔记07函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础笔记07函数&quot;&gt;&lt;/a&gt; 基础笔记：07函数&lt;/h2&gt;
&lt;h5 id=&quot;1函数定义-函数调用-函数原型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    <category term="C语言程序设计" scheme="https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="C语言" scheme="https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="函数" scheme="https://xqc-1368.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>07 多态</title>
    <link href="https://xqc-1368.github.io/2024/08/19/07%20%E5%A4%9A%E6%80%81/"/>
    <id>https://xqc-1368.github.io/2024/08/19/07%20%E5%A4%9A%E6%80%81/</id>
    <published>2024-08-19T04:23:45.918Z</published>
    <updated>2024-08-19T04:25:39.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="06-多态"><a class="markdownIt-Anchor" href="#06-多态"></a> 06 多态</h3><ul><li><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</li></ul><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><h5 id="1虚函数和多态"><a class="markdownIt-Anchor" href="#1虚函数和多态"></a> 1.虚函数和多态</h5><p>在类的定义中，前面有 virtual 关键字的成员函数就是虚函数。</p><p>virtual 关键字只用在类定义里的函数声明中，写函数体时不用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">base::get</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="2-多态的两种表现形式"><a class="markdownIt-Anchor" href="#2-多态的两种表现形式"></a> 2. 多态的两种表现形式</h5><p>表现形式一：派生类的指针可以赋给基类指针。</p><ul><li><p>通过基类指针调用基类和派生类中的同名虚函数时:</p><ul><li><p>（1）若该指针指向一个基类的对象，那么被调用是基类的虚函数；</p></li><li><p>（2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</p></li></ul></li></ul><p>这种机制就叫做“多态”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SomeVirtualFunction</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDerived</span> : <span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SomeVirtualFunction</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;derived&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDerived ODerived;</span><br><span class="line">CBase *p = &amp;ODerived;</span><br><span class="line">p-&gt;<span class="built_in">SomeVirtualFunction</span>(); <span class="comment">// 调用哪个虚函数取决于p指向哪种类型的对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的基类指针p指向派生类对象，所以调用的是派生类的成员函数</p><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derived</span><br></pre></td></tr></table></figure><p>表现形式二：派生类的对象可以赋给基类引用</p><ul><li><p>通过基类引用调用基类和派生类中的同名虚函数时:</p><ul><li><p>（1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；</p></li><li><p>（2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚数。</p></li></ul></li></ul><p>这种机制也叫做“多态”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SomeVirtualFunction</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDerived</span> : <span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SomeVirtualFunction</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;derived&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDerived ODerived;</span><br><span class="line">CBase &amp;r = ODerived;</span><br><span class="line">r.<span class="built_in">SomeVirtualFunction</span>(); <span class="comment">// 调用哪个虚函数取决于r引用哪种类型的对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derived</span><br></pre></td></tr></table></figure><h5 id="3-构造函数和析构函数中调用虚函数"><a class="markdownIt-Anchor" href="#3-构造函数和析构函数中调用虚函数"></a> 3. 构造函数和析构函数中调用虚函数</h5><ul><li><p>在构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数</p></li><li><p>派生类中和基类中虚函数<u>同名同参数表的函数</u>，不加virtual也自动成为虚函数</p></li></ul><h5 id="4-多态实现的关键-虚函数表"><a class="markdownIt-Anchor" href="#4-多态实现的关键-虚函数表"></a> 4. 多态实现的关键 — 虚函数表</h5><ul><li><p>每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的</p></li><li><p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。</p></li></ul><h5 id="5虚析构函数"><a class="markdownIt-Anchor" href="#5虚析构函数"></a> 5.虚析构函数</h5><p>背景：通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数，但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。</p><ul><li><p>解决办法：把基类的析构函数声明为virtual，派生类的析构函数可以virtual不进行声明。通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数</p></li><li><p>结论：一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。</p></li><li><p>注意：不允许以虚函数作为构造函数</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">son</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from son&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">public</span> son</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">grandson</span>() &#123; cout &lt;&lt; <span class="string">&quot;bye from grandson&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">son *pson;</span><br><span class="line">pson = <span class="keyword">new</span> <span class="built_in">grandson</span>();</span><br><span class="line"><span class="keyword">delete</span> pson;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bye from grandson</span><br><span class="line">bye from son</span><br></pre></td></tr></table></figure><p>执行<code>grandson::~grandson()</code>，引起执行<code>son::~son()</code>！！！</p><h5 id="6-纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#6-纯虚函数和抽象类"></a> 6. 纯虚函数和抽象类</h5><p>纯虚函数： 没有函数体的虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">( )</span> </span>= <span class="number">0</span> ; <span class="comment">//纯虚函数</span></span><br></pre></td></tr></table></figure><p>抽象类：包含纯虚函数的类叫抽象类</p><ul><li><p>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</p></li><li><p>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;<span class="comment">// 错，A 是抽象类，不能创建对象</span></span><br><span class="line">A *pa;<span class="comment">// ok,可以定义抽象类的指针和引用</span></span><br><span class="line">pa = <span class="keyword">new</span> A; <span class="comment">// 错误, A 是抽象类，不能创建对象</span></span><br></pre></td></tr></table></figure><ul><li><p>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数</p></li><li><p>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。（翻译成人话就是：类里面但凡有一个纯虚函数，就只能算抽象类）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;06-多态&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#06-多态&quot;&gt;&lt;/a&gt; 06 多态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多态&lt;/strong&gt;按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，</summary>
      
    
    
    
    <category term="OOP面向对象" scheme="https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="OOP" scheme="https://xqc-1368.github.io/tags/OOP/"/>
    
    <category term="多态" scheme="https://xqc-1368.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="虚函数" scheme="https://xqc-1368.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>06 继承与派生</title>
    <link href="https://xqc-1368.github.io/2024/08/19/06%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/"/>
    <id>https://xqc-1368.github.io/2024/08/19/06%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/</id>
    <published>2024-08-19T04:23:45.912Z</published>
    <updated>2024-08-19T03:21:23.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承与派生"><a class="markdownIt-Anchor" href="#继承与派生"></a> 继承与派生</h3><h5 id="1定义"><a class="markdownIt-Anchor" href="#1定义"></a> 1.定义</h5><p><strong>继承</strong>：</p><ul><li>在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个基类，而把B作为基类的一个派生类(也称子类)。</li></ul><p><strong>派生</strong>：</p><ul><li><p>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。</p></li><li><p>派生类一经定义后，可以独立使用，不依赖于基类。</p></li><li><p>派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public</p></li><li><p>在派生类的各个成员函数中，<u>不能访问</u>  基类中的private成员。</p></li></ul><p>派生类写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名：<span class="keyword">public</span> 基类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;width = w;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;height = h;&#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;</span><br><span class="line">      <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintCost</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;<span class="keyword">return</span> area * <span class="number">70</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (width * height); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="type">int</span> area;</span><br><span class="line"></span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-派生类对象的内存空间"><a class="markdownIt-Anchor" href="#2-派生类对象的内存空间"></a> 2. 派生类对象的内存空间</h5><p>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，而且<u>基类对象的存储位置位于派生类对象新增的成员变量之前</u>。<br /><img src="/images/2024-01-09-12-11-34-image.png" alt="" /></p><h5 id="3类的两种关系继承关系与复合关系"><a class="markdownIt-Anchor" href="#3类的两种关系继承关系与复合关系"></a> 3.类的两种关系——继承关系与复合关系</h5><p><strong>继承：“是”关系。</strong></p><ul><li><p>基类 A，B是基类A的派生类。</p></li><li><p>逻辑上要求：“一个B对象也是一个A对象”。</p></li></ul><p><strong>复合：“有”关系。</strong>（可能算下表中的组合关系？吧）</p><ul><li><p>类C中“有”成员变量k，k是类D的对象，则C和D是复合关系</p></li><li><p>一般逻辑上要求：“D对象是C对象的固有属性或组成部分”</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CCircle</span>;</span><br><span class="line">    <span class="comment">//便于Ccirle类操作其圆心</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCircle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    CPoint center;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复合关系的另一种写法：（可能算下表中的关联关系吧？）</p><p>例题：为“狗”类设一个“业主”类的对象指针；为“业主”类设一个“狗”类的对象指针数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMaster</span>; <span class="comment">//CMaster必须提前声明，不能先</span></span><br><span class="line">            <span class="comment">//写CMaster类后写Cdog类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDog</span></span><br><span class="line">&#123;</span><br><span class="line">    CMaster *pm;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMaster</span></span><br><span class="line">&#123;</span><br><span class="line">    CDog *dogs[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/2024-01-09-14-04-50-image.png" alt="" /></p><h5 id="3-派生类覆盖基类成员"><a class="markdownIt-Anchor" href="#3-派生类覆盖基类成员"></a> 3. 派生类覆盖基类成员</h5><p>派生类可以定义一个和基类成员同名的成员，这叫覆盖。在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号<code>::</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> j;<span class="type">int</span> i;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;fuck&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;fucku&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">derived::access</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    j = <span class="number">5</span>;        <span class="comment">//引用的是基类的j（只有一个j）</span></span><br><span class="line">    i = <span class="number">5</span>;        <span class="comment">//引用的是派生类的 i</span></span><br><span class="line">    base::i = <span class="number">5</span>;  <span class="comment">//引用的是基类的 i</span></span><br><span class="line">    <span class="built_in">func</span>();       <span class="comment">//派生类的</span></span><br><span class="line">    base::<span class="built_in">func</span>(); <span class="comment">//基类的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derived obj;</span><br><span class="line">    obj.i = <span class="number">1</span>;</span><br><span class="line">    obj.base::i = <span class="number">1</span>;</span><br><span class="line">    obj.<span class="built_in">access</span>();</span><br><span class="line">    cout&lt;&lt;obj.j&lt;&lt;endl;<span class="comment">//obj.j改成obj.base::j输出一样的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fucku</span><br><span class="line">fuck</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><img src="/images/2024-01-09-14-24-08-image.png" alt="" /></p><p>注：若在基类中加入<code>int k;</code>并且在access方法中加入<code>k=3;</code>则报错，因为派生类的成员函数无权访问基类的私有变量。</p><h5 id="4-类的保护成员"><a class="markdownIt-Anchor" href="#4-类的保护成员"></a> 4. 类的保护成员</h5><ul><li><p>基类的private成员：可以被下列函数访问</p><ul><li><p>基类的成员函数</p></li><li><p>基类的友元函数</p></li></ul></li><li><p>基类的public成员：可以被下列函数访问</p><ul><li><p>基类的成员函数</p></li><li><p>基类的友元函数</p></li><li><p>派生类的成员函数</p></li><li><p>派生类的友元函数</p></li><li><p>其他的函数</p></li></ul></li><li><p>基类的protected成员：可以被下列函数访问</p><ul><li><p>基类的成员函数</p></li><li><p>基类的友元函数</p></li><li><p>派生类的成员函数可以访问当前对象和其它对象的基类的保护成员</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> nPrivate; <span class="comment">//私有成员</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> nPublic; <span class="comment">//公有成员</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">int</span> nProtected; <span class="comment">// 保护成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AccessFather</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nPublic = <span class="number">1</span>;    <span class="comment">// ok;</span></span><br><span class="line">        nPrivate = <span class="number">1</span>;   <span class="comment">// wrong</span></span><br><span class="line">        nProtected = <span class="number">1</span>; <span class="comment">// OK，访问从基类继承的protected成员</span></span><br><span class="line">        Son f;</span><br><span class="line">        f.nProtected = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Father f;</span><br><span class="line">    Son s;</span><br><span class="line">    f.nPublic = <span class="number">1</span>;    <span class="comment">// Ok</span></span><br><span class="line">    s.nPublic = <span class="number">1</span>;    <span class="comment">// Ok</span></span><br><span class="line">    f.nProtected = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">    f.nPrivate = <span class="number">1</span>;   <span class="comment">// error</span></span><br><span class="line">    s.nProtected = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">    s.nPrivate = <span class="number">1</span>;   <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-派生类的构造函数"><a class="markdownIt-Anchor" href="#5-派生类的构造函数"></a> 5. 派生类的构造函数</h5><p>例如，我们写了以下 “昆虫”类 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> nLegs;</span><br><span class="line">        <span class="type">int</span> nColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> nType;</span><br><span class="line">        <span class="built_in">Bug</span>(<span class="type">int</span> legs, <span class="type">int</span> color);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PrintBug</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyBug</span> : <span class="keyword">public</span> Bug <span class="comment">// FlyBug是Bug的派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nWings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">FlyBug</span>(<span class="type">int</span> legs, <span class="type">int</span> color, <span class="type">int</span> wings);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>继承关系派生类的构造函数的写法：</li></ul><p>对于类FlyBug而言，<u>只能使用</u> 初始化列表构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bug的构造函数没有关系，跟之前一样的</span></span><br><span class="line">Bug::<span class="built_in">Bug</span>(<span class="type">int</span> legs, <span class="type">int</span> color)</span><br><span class="line">&#123;</span><br><span class="line">    nLegs = legs;</span><br><span class="line">    nColor = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误的FlyBug构造函数</span></span><br><span class="line">FlyBug::<span class="built_in">FlyBug</span>(<span class="type">int</span> legs, <span class="type">int</span> color, <span class="type">int</span> wings)</span><br><span class="line">&#123;</span><br><span class="line">    nLegs = legs;   <span class="comment">// 不能访问</span></span><br><span class="line">    nColor = color; <span class="comment">// 不能访问</span></span><br><span class="line">    nType = <span class="number">1</span>;      <span class="comment">// ok</span></span><br><span class="line">    nWings = wings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的FlyBug构造函数：</span></span><br><span class="line">FlyBug::<span class="built_in">FlyBug</span>(<span class="type">int</span> legs, <span class="type">int</span> color, <span class="type">int</span> wings) : <span class="built_in">Bug</span>(legs, color)</span><br><span class="line">&#123;</span><br><span class="line">    nWings = wings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时，即初始化对象时写法：<code>FlyBug fb ( 2,3,4);</code></p><p>注意：</p><ul><li><p>在创建派生类的对象时，<u>需要调用基类的构造函数</u>：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是<u>先执行基类的构造函数</u>。</p></li><li><p>调用基类构造函数的两种方式</p><ul><li>显式方式：在派生类的构造函数中，为基类的构造函数提供参数.</li></ul><p><code>derived::derived(arg_derived-list):base(arg_base-list)</code></p><ul><li>隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则<u>自动调用基类的无参构造函数</u></li></ul></li><li><p>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。</p></li></ul><p>考虑以下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">Base</span>(<span class="type">int</span> i) : <span class="built_in">n</span>(i)</span><br><span class="line">        &#123;cout &lt;&lt; <span class="string">&quot;Base &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; constructed&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">        ~<span class="built_in">Base</span>()</span><br><span class="line">        &#123;cout &lt;&lt; <span class="string">&quot;Base &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; destructed&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>(<span class="type">int</span> i) : <span class="built_in">Base</span>(i)</span><br><span class="line">        &#123;cout &lt;&lt; <span class="string">&quot;Derived constructed&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">        ~<span class="built_in">Derived</span>()</span><br><span class="line">        &#123;cout &lt;&lt; <span class="string">&quot;Derived destructed&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">Obj</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base 3 constructed</span><br><span class="line">Derived constructed</span><br><span class="line">Derived destructed</span><br><span class="line">Base 3 destructed</span><br></pre></td></tr></table></figure><h5 id="6-包含成员对象的派生类的构造函数写法"><a class="markdownIt-Anchor" href="#6-包含成员对象的派生类的构造函数写法"></a> 6. 包含成员对象的派生类的构造函数写法</h5><p>即：第一类复合关系的派生函数的构造函数的写法（关键在最后一行啊前面是铺垫）</p><p>也是使用初始化列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> nLegs;</span><br><span class="line">        <span class="type">int</span> nColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> nType;</span><br><span class="line">        <span class="built_in">Bug</span>(<span class="type">int</span> legs, <span class="type">int</span> color);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PrintBug</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Skill</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyBug</span> : <span class="keyword">public</span> Bug</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nWings;</span><br><span class="line">    Skill sk1, sk2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">FlyBug</span>(<span class="type">int</span> legs, <span class="type">int</span> color, <span class="type">int</span> wings);</span><br><span class="line">&#125;;</span><br><span class="line">FlyBug::<span class="built_in">FlyBug</span>(<span class="type">int</span> legs, <span class="type">int</span> color, <span class="type">int</span> wings) : <span class="built_in">Bug</span>(legs, color), <span class="built_in">sk1</span>(<span class="number">5</span>), <span class="built_in">sk2</span>(color), <span class="built_in">nWings</span>(wings)&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="7封闭派生类对象的构造函数和析构函数的执行顺序"><a class="markdownIt-Anchor" href="#7封闭派生类对象的构造函数和析构函数的执行顺序"></a> 7.封闭派生类对象的构造函数和析构函数的执行顺序</h5><p>在创建派生类的对象时:</p><ol><li><p>先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员；</p></li><li><p>再执行成员对象类的构造函数，用以初始化派生类对象中成员对象。</p></li><li><p>最后执行派生类自己的构造函数</p></li></ol><p>在派生类对象消亡时：</p><ol><li><p>先执行派生类自己的析构函数</p></li><li><p>再依次执行各成员对象类的析构函数</p></li><li><p>最后执行基类的析构函数</p></li></ol><p>析构函数的调用顺序与构造函数的调用顺序相反。</p><h5 id="8public继承的赋值兼容规则"><a class="markdownIt-Anchor" href="#8public继承的赋值兼容规则"></a> 8.public继承的赋值兼容规则</h5><p>以public方式继承时，考虑以下程序段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;&#125;;</span><br><span class="line">base b;</span><br><span class="line">derived d;</span><br></pre></td></tr></table></figure><blockquote><p>1） 派生类的对象可以赋值给基类对象</p><p>b = d;</p><p>2） 派生类对象可以初始化基类引用</p><p>base &amp; br = d;</p><p>3） 派生类对象的地址可以赋值给基类指针</p><p>base * pb = &amp; d;</p></blockquote><p>如果派生方式是 private或protected，则上述三条不可行。</p><p>protected继承和private继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">protected</span> base</span><br><span class="line">&#123;&#125;;</span><br><span class="line">base b;</span><br><span class="line">derived d;</span><br></pre></td></tr></table></figure><ul><li><p>protected继承时，基类的public成员和protected成员成为派生类的protected成员。</p></li><li><p>private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。</p></li><li><p>protected和private继承不是“是”的关系。</p></li></ul><h5 id="9-基类与派生类的指针强制转换"><a class="markdownIt-Anchor" href="#9-基类与派生类的指针强制转换"></a> 9. 基类与派生类的指针强制转换</h5><p>公有派生的情况下,派生类对象的指针可以直接赋值给基类指针：</p><p><code>Base * ptrBase = &amp;objDerived;</code></p><p><em>因为基类指针指向基类对象的首地址，也就是指向派生类对象，而派生类的所有变量地址中前几个是基类变量所拥有的地址，但是因为指针是指向基类的指针，所有只能访问的内存是基类的那几个变量。</em></p><ul><li><p>ptrBase指向的是一个Derived类的对象；</p></li><li><p>*ptrBase可以看作一个Base类的对象，访问它的public成员直接通过ptrBase即可，但不能通过ptrBase访问objDerived对象中属于Derived类而不属于Base类的成员</p></li><li><p>即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有，而派生类中有的成员。</p></li></ul><p>但是，通过强制指针类型转换，可以把ptrBase转换成Derived类的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base * ptrBase = &amp;objDerived;</span><br><span class="line">Derived *ptrDerived = (Derived * ) ptrBase;</span><br></pre></td></tr></table></figure><p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会出错。</p><h5 id="10直接基类和间接基类"><a class="markdownIt-Anchor" href="#10直接基类和间接基类"></a> 10.直接基类和间接基类</h5><p>在声明派生类时，只需要列出它的直接基类</p><p>派生类的成员包括：</p><ul><li><p>派生类自己定义的成员</p></li><li><p>直接基类中的所有成员</p></li><li><p>所有间接基类的全部成员</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">Base</span>(<span class="type">int</span> i) : <span class="built_in">n</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; constructed&quot;</span></span><br><span class="line">                &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Base</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Base &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; destructed&quot;</span></span><br><span class="line">                &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>(<span class="type">int</span> i) : <span class="built_in">Base</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Derived constructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Derived</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Derived destructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoreDerived</span> : <span class="keyword">public</span> Derived</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MoreDerived</span>() : <span class="built_in">Derived</span>(<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;More Derived constructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">MoreDerived</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;More Derived destructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MoreDerived Obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base 4 constructed</span><br><span class="line">Derived constructed</span><br><span class="line">More Derived constructed</span><br><span class="line">More Derived destructed</span><br><span class="line">Derived destructed</span><br><span class="line">Base 4 destructed</span><br></pre></td></tr></table></figure><h5 id="11-多继承"><a class="markdownIt-Anchor" href="#11-多继承"></a> 11. 多继承</h5><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;</span><br><span class="line">      <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintCost</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost<span class="comment">//多继承</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="type">int</span> area;</span><br><span class="line"></span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total area: 35</span><br><span class="line">Total paint cost: $2450</span><br></pre></td></tr></table></figure><p>附录：Python面向对象程序设计菜鸟教程链接<a href="https://www.runoob.com/python/python-object.html">Python 面向对象 | 菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;继承与派生&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承与派生&quot;&gt;&lt;/a&gt; 继承与派生&lt;/h3&gt;
&lt;h5 id=&quot;1定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1定义&quot;&gt;&lt;/a&gt; 1.定义&lt;/h</summary>
      
    
    
    
    <category term="OOP面向对象" scheme="https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="OOP" scheme="https://xqc-1368.github.io/tags/OOP/"/>
    
    <category term="继承与复合关系" scheme="https://xqc-1368.github.io/tags/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/"/>
    
    <category term="派生类" scheme="https://xqc-1368.github.io/tags/%E6%B4%BE%E7%94%9F%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>05 流运算符和一元运算符的重载</title>
    <link href="https://xqc-1368.github.io/2024/08/19/05%20%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>https://xqc-1368.github.io/2024/08/19/05%20%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2024-08-19T04:23:45.905Z</published>
    <updated>2024-08-19T02:55:44.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-流插入运算符和流提取运算符的重载"><a class="markdownIt-Anchor" href="#1-流插入运算符和流提取运算符的重载"></a> 1. 流插入运算符和流提取运算符的重载</h3><ul><li><p>cout 是在 iostream 中定义的，ostream 类的对象。</p></li><li><p>“&lt;&lt;” 能用在cout 上是因为，在iostream 里对 “&lt;&lt;” 进行了重载。</p></li></ul><p>例题：假定c是Complex复数类的对象，现在希望写“<code>cout &lt;&lt; c;</code>”，就能以“<code>a+b</code>i”的形式输出c的值，写“<code>cin&gt;&gt;c;</code>”，就能从键盘接受“<code>a+bi</code>”形式的输入，并且使得<code>c.real = a,c.imag = b。</code></p><p>解答：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="type">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;cin, Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, <span class="type">const</span> Complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; c.real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>; <span class="comment">//以&quot;a+bi&quot;的形式输出</span></span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;cin, Complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s; <span class="comment">//将&quot;a+bi&quot;作为字符串读入, “a+bi” 中间不能有空格</span></span><br><span class="line">    <span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;+&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;%s\n&quot;,s.c_str());</span></span><br><span class="line">    string sTmp = s.<span class="built_in">substr</span>(<span class="number">0</span>, pos); <span class="comment">//分离出代表实部的字符串</span></span><br><span class="line">    c.real = <span class="built_in">stof</span>(sTmp);    <span class="comment">// atof库函数能将const char*指针指向的内容转换成 float</span></span><br><span class="line">        sTmp = s.<span class="built_in">substr</span>(pos + <span class="number">1</span>, s.<span class="built_in">length</span>() - <span class="number">2</span>); <span class="comment">//分离出代表虚部的字符串</span></span><br><span class="line">    c.imag = <span class="built_in">stof</span>(sTmp);</span><br><span class="line">    <span class="keyword">return</span> cin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex c,n;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2+3i</span><br><span class="line">4+5i</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2+3i,4+5i</span><br></pre></td></tr></table></figure><h3 id="2-自增-自减运算符的重载和类型转换运算符"><a class="markdownIt-Anchor" href="#2-自增-自减运算符的重载和类型转换运算符"></a> 2. 自增、自减运算符的重载和类型转换运算符</h3><ul><li><p>自增运算符++、自减运算符–有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，C++规定：</p><ul><li><p>前置运算符作为一元运算符重载</p><p>重载为成员函数：</p><p><code>T &amp; operator++();</code></p><p><code>T &amp; operator--();</code></p><p>重载为全局函数：</p><p><code>T1 &amp; operator++(T2);</code></p><p><code>T1 &amp; operator—(T2);</code></p></li><li><p>后置运算符作为二元运算符重载，多写一个没用的参数：</p><p>重载为成员函数：</p><p><code>T operator++(int);</code></p><p><code>T operator--(int);</code></p><p>重载为全局函数：</p><p><code>T1 operator++(T2,int );</code></p><p><code>T1 operator—( T2,int);</code></p></li></ul></li></ul><p>但是在没有后置运算符重载而有前置重载的情况下，在vs中，obj++ 也调用前置重载，而dev则令 obj ++ 编译出错</p><ul><li>类型转换运算符：</li></ul><p><code>operator int ( ) &#123; return n; &#125;</code></p><p>这里，int 作为一个类型强制转换运算符被重载, 此后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Demo s;</span><br><span class="line">(<span class="type">int</span>) s ;<span class="comment">//等效于 s.int();</span></span><br></pre></td></tr></table></figure><p>注意：类型强制转换运算符被重载时不能写返回值类型，实际上其返回值类型就是该类型强制转换运算符代表的类型</p><p>实际案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CDemo</span>(<span class="type">int</span> i = <span class="number">0</span>) : <span class="built_in">n</span>(i) &#123;&#125;</span><br><span class="line">    CDemo &amp;<span class="keyword">operator</span>++();   <span class="comment">//用于前置形式</span></span><br><span class="line">    CDemo <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">//用于后置形式</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="keyword">friend</span> CDemo &amp;<span class="keyword">operator</span>--(CDemo &amp;);</span><br><span class="line">    <span class="keyword">friend</span> CDemo <span class="keyword">operator</span>--(CDemo &amp;, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CDemo &amp;CDemo::<span class="keyword">operator</span>++()</span><br><span class="line">&#123; <span class="comment">//前置 ++</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; <span class="comment">// ++s即为: s.operator++();</span></span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span>++(<span class="type">int</span> k)</span><br><span class="line">&#123;                     <span class="comment">//后置 ++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp; <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125; <span class="comment">// s++即为: s.operator++(0);</span></span><br><span class="line">CDemo &amp;<span class="keyword">operator</span>--(CDemo &amp;d)</span><br><span class="line">&#123; <span class="comment">//前置--</span></span><br><span class="line">    d.n--;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125; <span class="comment">//--s即为: operator--(s);</span></span><br><span class="line">CDemo <span class="keyword">operator</span>--(CDemo &amp;d, <span class="type">int</span>)</span><br><span class="line">&#123; <span class="comment">//后置--</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(d)</span></span>;</span><br><span class="line">    d.n--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125; <span class="comment">// s--即为: operator--(s, 0); </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CDemo <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">//因为写了类型转换运算符，所以以下所有输出检测到输出对象的时候能瞬间把对象转换成int，</span></span><br><span class="line"><span class="comment">//于是就按照int类型输出</span></span><br><span class="line">    cout &lt;&lt; (d++) &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//等价于 d.operator++(0);</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    cout &lt;&lt; (++d) &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//等价于 d.operator++();</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (d--) &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//等价于 operator--(d,0);</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    cout &lt;&lt; (--d) &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//等价于 operator--(d);</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运算符重载的注意事项</li></ul><ol><li><p>C++不允许定义新的运算符 ；</p></li><li><p>重载后运算符的含义应该符合日常习惯；</p></li><li><p>运算符重载<u>不改变运算符的优先级</u>；</p></li><li><p>以下运算符不能被重载：“.”、“.*”、“::”、“?:”、sizeof；</p></li><li><p>重载运算符()、[]、-&gt;或者赋值运算符=时，<u>运算符重载函数必须声明为类的成员函数。</u></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-流插入运算符和流提取运算符的重载&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-流插入运算符和流提取运算符的重载&quot;&gt;&lt;/a&gt; 1. 流插入运算符和流提取运算符的重载&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cout 是在 iostr</summary>
      
    
    
    
    <category term="OOP面向对象" scheme="https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="OOP" scheme="https://xqc-1368.github.io/tags/OOP/"/>
    
    <category term="运算符重载" scheme="https://xqc-1368.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
    <category term="流运算符" scheme="https://xqc-1368.github.io/tags/%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>04双向广度优先搜索：八数码难题</title>
    <link href="https://xqc-1368.github.io/2024/08/19/04%E5%8F%8C%E5%90%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%9A%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/"/>
    <id>https://xqc-1368.github.io/2024/08/19/04%E5%8F%8C%E5%90%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%9A%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/</id>
    <published>2024-08-19T04:23:45.901Z</published>
    <updated>2024-08-19T03:20:26.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双向广度优先搜索八数码难题"><a class="markdownIt-Anchor" href="#双向广度优先搜索八数码难题"></a> 双向广度优先搜索：八数码难题</h2><h1 id="八数码难题"><a class="markdownIt-Anchor" href="#八数码难题"></a> 八数码难题</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的棋盘上，摆有八个棋子，每个棋子上标有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 的某一数字。棋盘中留有一个空格，空格用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>123804765</mn></mrow><annotation encoding="application/x-tex">123804765</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">8</span><span class="mord">0</span><span class="mord">4</span><span class="mord">7</span><span class="mord">6</span><span class="mord">5</span></span></span></span>），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>输入初始状态，一行九个数字，空格用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 表示。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数。保证测试数据中无特殊无法到达目标状态数据。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">283104765</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h2><h3 id="样例解释"><a class="markdownIt-Anchor" href="#样例解释"></a> 样例解释</h3><p><img src="/images/2024-08-19-11-19-34-image.png" alt="" /></p><p>图中标有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的是空格。绿色格子是空格所在位置，橙色格子是下一步可以移动到空格的位置。如图所示，用四步可以达到目标状态。</p><p>并且可以证明，不存在更优的策略。</p><h2 id="双向广度优先搜索"><a class="markdownIt-Anchor" href="#双向广度优先搜索"></a> 双向广度优先搜索：</h2><p>我们常常会面临这样一类搜索问题：起点是给出的，终点也是已知的，需要确定能否从起点到达终点，如果可以，需要多少步。</p><p>如果我们用常规的搜索方法，从起点开始往下搜，那得到的解答树可能非常庞大，这样漫无目的的搜索就像<strong>大海捞针</strong>。</p><p><img src="/images/2024-08-19-11-19-43-image.png" alt="" /></p><p>要从庞大的解答树中找到一根“针”，即终点，用蓝色表示</p><p>让我们切换一下思路，既然终点是已知的，我们何必让它闲着呢？我们完全可以<strong>分别</strong>从起点和终点出发，看它们能否<strong>相遇</strong>：</p><p><img src="/images/2024-08-19-11-19-52-image.png" alt="" /></p><p>从起点和终点分别展开搜索，解答树瞬间缩小了很多</p><p>如果原本的解答树规模是  ，使用双向搜索后，规模立刻缩小到了约  ，当  较大时优化非常可观。</p><p>双向搜索主要有两种，双向BFS和双向迭代加深。</p><h2 id="双向bfs"><a class="markdownIt-Anchor" href="#双向bfs"></a> 双向BFS</h2><p>与普通的BFS不同，双向BFS维护<u>两个</u>而不是<u>一个</u>队列，然后<strong>轮流</strong>拓展两个队列。同时，用<strong>数组</strong>（如果状态可以被表示为较小的整数）或<strong>哈希表</strong>记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束。</p><p>主要代码部分思想</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; Q[<span class="number">3</span>]; <span class="comment">// T要替换为用来表示状态的类型，可能为int，string还有bitset等</span></span><br><span class="line"><span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">Q[<span class="number">1</span>].push(st); <span class="comment">// st为起始状态</span></span><br><span class="line">Q[<span class="number">2</span>].push(ed); <span class="comment">// ed为终止状态</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; D + <span class="number">2</span>; ++d) <span class="comment">// 这个我也不知道为什么这么写，</span></span><br><span class="line"><span class="comment">//应该是设计一个最大深度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dir = (d &amp; <span class="number">1</span>) + <span class="number">1</span>, sz = Q[dir].size(); <span class="comment">// 记录一下当前的搜索方向，1为正向，2为反向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = Q[dir].front();</span><br><span class="line">        Q[dir].pop();</span><br><span class="line">        <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>) <span class="comment">// H是数组或哈希表，若H[x]+dir==3说明两个方向都搜到过这个点</span></span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        H[x] = dir;</span><br><span class="line">        <span class="comment">// 这里需要把当前状态能够转移到的新状态压入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="type">int</span>&gt; H;<span class="comment">//建立一个哈希表H用于记录当前状态是否被搜索过</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q[<span class="number">3</span>];<span class="comment">//建立一个q[1],q[2]分别用于表示从前广搜和从后广搜的经历过的状态</span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">justswap</span><span class="params">(<span class="built_in">string</span> temp,<span class="type">int</span> pos,<span class="type">int</span> topos)</span></span><br><span class="line">&#123;<span class="comment">//本函数用于交换字符串temp中pos位置和topos位置的值，返回一个字符串</span></span><br><span class="line">    <span class="keyword">if</span>(topos&lt;pos)<span class="comment">//如果顺序不对，换一下，保证pos&lt;topos</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp=topos;</span><br><span class="line">        topos=pos;</span><br><span class="line">        pos=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//切片，返回即可</span></span><br><span class="line">    <span class="built_in">string</span> ret1=temp.substr(<span class="number">0</span>,pos);</span><br><span class="line">    <span class="built_in">string</span> ret2=temp.substr(pos+<span class="number">1</span>,topos-pos<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">string</span> ret3=temp.substr(topos+<span class="number">1</span>,temp.size()-topos);</span><br><span class="line">    <span class="keyword">return</span> ret1+temp[topos]+ret2+temp[pos]+ret3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> st;</span><br><span class="line">    <span class="built_in">string</span> ed = <span class="string">&quot;123804765&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;st;</span><br><span class="line">    q[<span class="number">1</span>].push(st);<span class="comment">//1表示正向搜索</span></span><br><span class="line">    q[<span class="number">2</span>].push(ed);<span class="comment">//2表示反向搜索</span></span><br><span class="line">    <span class="type">int</span> co=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q[<span class="number">1</span>].empty() || !q[<span class="number">2</span>].empty())<span class="comment">//这个终止条件没什么用在这里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> direct=co%<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//co用于计数</span></span><br><span class="line">        <span class="type">int</span> qs=q[direct].size();<span class="comment">//要提前取出队列大小，不然一边向队列里</span></span><br><span class="line">                    <span class="comment">//添加元素，一边删元素，会出现混乱</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;qs;i++)</span><br><span class="line">        &#123;<span class="comment">//对direct方向的队列元素进行拓展</span></span><br><span class="line">            <span class="built_in">string</span> temp=q[direct].front();</span><br><span class="line">            q[direct].pop();</span><br><span class="line">            <span class="keyword">if</span>(H.count(temp))<span class="comment">//如果temp状态已经被走过了</span></span><br><span class="line">            &#123;<span class="comment">//如果没有被走过进不了下面这个if，则不处理，直接考察q[direct]的下一个元素</span></span><br><span class="line">                <span class="keyword">if</span>(H[temp]+direct==<span class="number">3</span>)<span class="comment">//如果temp已经被另一个方向走过了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;co<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出步数，注意是co-1；</span></span><br><span class="line"><span class="comment">//因为交汇的状态算了两次</span></span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//如果没有走过</span></span><br><span class="line">            &#123;</span><br><span class="line">                H.insert(&#123;temp,direct&#125;);<span class="comment">//插入键值对</span></span><br><span class="line">                <span class="type">int</span> pos=temp.find(<span class="string">&#x27;0&#x27;</span>);<span class="comment">//找到0的位置</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)<span class="comment">//在temp基础上往四个方向拓展</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((pos%<span class="number">3</span>)+dx[i]&lt;<span class="number">0</span> || (pos%<span class="number">3</span>)+dx[i]&gt;<span class="number">2</span> || pos+dy[i]*<span class="number">3</span>&lt;<span class="number">0</span> || pos+dy[i]*<span class="number">3</span>&gt;=<span class="number">9</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//处理越界情况</span></span><br><span class="line">                    <span class="built_in">string</span> t=justswap(temp,pos,pos+dx[i]+dy[i]*<span class="number">3</span>);</span><br><span class="line">                    <span class="comment">//往四个方向拓展</span></span><br><span class="line">                    q[direct].push(t);</span><br><span class="line">                    <span class="comment">//压入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        co++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般形式（节选自oiwiki）(用一个队列写的方式，但是不适用于本题)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">将开始结点和目标结点加入队列 q</span><br><span class="line">标记开始结点为 <span class="number">1</span></span><br><span class="line">标记目标结点为 <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> (队列 q 不为空)</span><br><span class="line">&#123;</span><br><span class="line"> 从 q.front() 扩展出新的 s 个结点</span><br><span class="line"> 如果 新扩展出的结点已经被其他数字标记过</span><br><span class="line"> 那么 表示搜索的两端碰撞</span><br><span class="line"> 那么 循环结束</span><br><span class="line"> 如果 新的 s 个结点是从开始结点扩展来的</span><br><span class="line"> 那么 将这个 s 个结点标记为 <span class="number">1</span> 并且入队 q </span><br><span class="line">如果 新的 s 个结点是从目标结点扩展来的</span><br><span class="line"> 那么 将这个 s 个结点标记为 <span class="number">2</span> 并且入队 q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;双向广度优先搜索八数码难题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#双向广度优先搜索八数码难题&quot;&gt;&lt;/a&gt; 双向广度优先搜索：八数码难题&lt;/h2&gt;
&lt;h1 id=&quot;八数码难题&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"/>
    
    
    <category term="BFS" scheme="https://xqc-1368.github.io/tags/BFS/"/>
    
    <category term="双向BFS" scheme="https://xqc-1368.github.io/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
  </entry>
  
  <entry>
    <title>04 一般运算符与赋值符的重载</title>
    <link href="https://xqc-1368.github.io/2024/08/19/04%20%E4%B8%80%E8%88%AC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%B5%8B%E5%80%BC%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>https://xqc-1368.github.io/2024/08/19/04%20%E4%B8%80%E8%88%AC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%B5%8B%E5%80%BC%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2024-08-19T04:23:45.898Z</published>
    <updated>2024-08-19T03:18:38.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="04运算符重载运算符与赋值符"><a class="markdownIt-Anchor" href="#04运算符重载运算符与赋值符"></a> 04运算符重载——运算符与赋值符</h2><h3 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1. 基本概念</h3><ul><li><p>运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之<br />能作用于对象。</p></li><li><p>运算符重载的实质是函数重载</p></li></ul><p>因此，既可以重载为普通函数，又可以重载为成员函数</p><p>解读时：把含运算符的表达式转换成对运算符函数的调用，把运算符的操作数转换成运算符函数的参数。运算符被多次重载时，根据实参的类型决定调用哪个运算符函数。</p><h3 id="2-运算符重载的形式"><a class="markdownIt-Anchor" href="#2-运算符重载的形式"></a> 2. 运算符重载的形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 operator 运算符 ( 形参表 )</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>重载为成员函数时，参数个数为运算符目数减一（减掉的那个是作用的对象中前面一个）。</p></li><li><p>重载为普通函数时，参数个数为运算符目数。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;a, <span class="type">const</span> Complex &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(a.real + b.real, a.imag + b.imag); <span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(real - c.real, imag - c.imag); <span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span>, c</span>;</span><br><span class="line">    c = a + b; <span class="comment">//等价于c=operator+(a,b);</span></span><br><span class="line">    cout &lt;&lt; c.real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; c.imag &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (a - b).real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; (a - b).imag &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// a-b等价于a.operator-(b)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5,5</span><br><span class="line">3,3</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>c = a + b;</code> 等价于<code>c=operator+(a,b);</code></p><p><code>a-b</code> 等价于<code>a.operator-(b)</code></p><h3 id="3-赋值运算符的重载"><a class="markdownIt-Anchor" href="#3-赋值运算符的重载"></a> 3. 赋值运算符的重载</h3><ul><li><p>有时候希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个 char * 类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“=”。</p></li><li><p>赋值运算符“=”<u>只能重载为成员函数</u></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">String</span>() : <span class="built_in">str</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>]) &#123; str[<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> str; &#125;;</span><br><span class="line">        String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *s);</span><br><span class="line">        ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] str; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">String &amp;String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123; <span class="comment">//重载“=”以使得 obj = “hello”能够成立</span></span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    s = <span class="string">&quot;Good Luck,&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Good Luck,&quot;);</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// String s2 = &quot;hello!&quot;; //这条语句要是不注释掉就会出错,因为这句话需要用到复制构造函数</span></span><br><span class="line">    s = <span class="string">&quot;Shenzhou 8!&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Shenzhou 8!&quot;);</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Good Luck,</span><br><span class="line">Shenzhou 8!</span><br></pre></td></tr></table></figure><p>tips：</p><blockquote><h6 id="c中有参构造函数拷贝构造函数和赋值运算符重载的区别和实现"><a class="markdownIt-Anchor" href="#c中有参构造函数拷贝构造函数和赋值运算符重载的区别和实现"></a> C++中有参构造函数，拷贝构造函数和赋值运算符重载的区别和实现</h6><p>1.拷贝构造函数（复制构造函数）</p><p><strong>强调：这里b对象是不存在的，是用a 对象来构造和初始化b的！！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="comment">//或：A b=a;  都是拷贝构造函数来创建对象b</span></span><br></pre></td></tr></table></figure><p>2.有参构造函数</p><p><strong>当创建一个类的对象时，它被调用来对类的数据成员进行初始化和分配内存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a(2);</span><br></pre></td></tr></table></figure><p>3.赋值运算符重载</p><p>当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。</p><p>当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">A b;</span><br><span class="line">b=a; </span><br></pre></td></tr></table></figure><ul><li><p><strong>强调：这里a,b对象是已经存在的，是用a 对象来赋值给b的！！</strong></p><p>赋值运算的重载声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   A&amp; operator = (const A&amp; other)</span><br></pre></td></tr></table></figure></li></ul><p>通常大家会对拷贝构造函数和赋值函数混淆，这儿仔细比较两者的区别：</p><p>1）<strong>拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。</strong></p><p><em>2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象</em></p><p><em>3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。（这些要点会在下面的String实现代码中体现）</em></p></blockquote><h3 id="4浅拷贝-深拷贝"><a class="markdownIt-Anchor" href="#4浅拷贝-深拷贝"></a> 4.浅拷贝、深拷贝</h3><p>如不定义自己的赋值运算符，那么S1=S2实际上导致 S1.str和 S2.str指向同一地方。<br /><img src="/images/2023-12-31-16-48-33-image.png" alt="" /></p><p>问题：</p><ol><li><p>如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还要释放一次，不妥。</p></li><li><p>另外，如果执行 S1 = “other”；会导致S2.str指向的地方被delete</p></li></ol><p>另外，考虑下面语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br><span class="line">s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s = s;</span><br></pre></td></tr></table></figure><p>如果不判定字符串是否完全相同，则导致等号左右两侧同时被析构，导致赋值出错</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;s)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，operator = 返回值类型为String&amp;类型，那么这里能不能使用void或String呢？</p><p>考虑以下情况：<code>a = b = c;</code>   连等语句的撰写</p><p>当函数返回值为引用的时候才能放在等号左边，为了保留原风格的特性，于是使用引用。</p><p>则此时：</p><p><code>a = b = c;</code>等价于<code>a.operator=(b.operator=(c));</code></p><p><code>(a=b)=c;</code>等价于<code>(a.operator=(b)).operator=(c);</code></p><ul><li>引申：为了避免浅拷贝，于是我们写复制构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(String &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5运算符重载为友元函数"><a class="markdownIt-Anchor" href="#5运算符重载为友元函数"></a> 5.运算符重载为友元函数</h3><ul><li><p>需要知道的是：一般情况下，将运算符重载为类的成员函数，是较好的选择。</p></li><li><p>但有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。</p></li></ul><p>考虑下面程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i)&#123;&#125;;</span><br><span class="line">        Complex <span class="keyword">operator</span>+(<span class="type">double</span> r);</span><br><span class="line">&#125;;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="type">double</span> r)</span><br><span class="line">&#123; <span class="comment">//能解释 c+5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(real + r, imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述重载后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex c ;</span><br><span class="line">c = c + <span class="number">5</span>; <span class="comment">//有定义，相当于 c = c.operator +(5);</span></span><br></pre></td></tr></table></figure><p>但是：</p><p><code>c = 5 + c; //编译出错</code></p><p>所以，为了使得上述的表达式能成立，需要将 + 重载为普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">double</span> r, <span class="type">const</span> Complex &amp;c)</span><br><span class="line">&#123; <span class="comment">//能解释 5+c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.real + r, c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>但是普通函数又不能访问私有成员，所以，需要将运算符 + 重载为友元。</u></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i)&#123;&#125;;</span><br><span class="line">        Complex <span class="keyword">operator</span>+(<span class="type">double</span> r);</span><br><span class="line">        <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">double</span> r, <span class="type">const</span> Complex &amp;c);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>项目练习：动态数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//写一个动态内存数组</span></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="comment">//复制构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CArray</span>&#123;    </span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> *p;    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CArray</span>(<span class="type">int</span> s=<span class="number">0</span>);<span class="comment">//有参构造函数</span></span><br><span class="line">        ~<span class="built_in">CArray</span>();<span class="comment">//析构函数</span></span><br><span class="line">        <span class="built_in">CArray</span>(CArray &amp;a);<span class="comment">//复制构造函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> ele)</span></span>;<span class="comment">//push_back函数</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>;           <span class="comment">// length函数</span></span><br><span class="line">        CArray &amp;<span class="keyword">operator</span>=(<span class="type">const</span> CArray &amp;a);<span class="comment">//=重载</span></span><br><span class="line">        <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> i);<span class="comment">//[]重载</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;p[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CArray::<span class="built_in">CArray</span>(CArray &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a.p)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="literal">NULL</span>;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len=a.len;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line">    <span class="built_in">memcpy</span>(p,a.p,<span class="built_in">sizeof</span>(<span class="type">int</span>)*len);</span><br><span class="line">&#125;</span><br><span class="line">CArray :: <span class="built_in">CArray</span>(<span class="type">int</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    len=s;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> p=<span class="keyword">new</span> <span class="type">int</span> [len];</span><br><span class="line">&#125;</span><br><span class="line">CArray ::~<span class="built_in">CArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)<span class="keyword">delete</span>[]p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CArray::push_back</span><span class="params">(<span class="type">int</span> ele)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *tp = <span class="keyword">new</span> <span class="type">int</span>[len+ <span class="number">1</span>];         <span class="comment">//重新分配空间</span></span><br><span class="line">        <span class="built_in">memcpy</span>(tp, p, <span class="built_in">sizeof</span>(<span class="type">int</span>) * len); <span class="comment">//拷贝原数组内容</span></span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">        p = tp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p[len]=ele;</span><br><span class="line">    ++len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CArray::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> &amp;CArray::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p[i];</span><br><span class="line">&#125;</span><br><span class="line">CArray &amp;CArray::<span class="keyword">operator</span>=(<span class="type">const</span> CArray &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==a.p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">delete</span> []p;</span><br><span class="line">        p=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.len&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p) <span class="keyword">delete</span>[] p;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[a.len];</span><br><span class="line">    &#125;</span><br><span class="line">    len=a.len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p,a.p,<span class="built_in">sizeof</span>(<span class="type">int</span>)*a.len);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;             <span class="comment">//要编写可变长整型数组类，使之能如下使用：</span></span><br><span class="line">    CArray a; <span class="comment">//开始里的数组是空的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);<span class="comment">//push_back函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">    CArray a2, a3;</span><br><span class="line">    a2 = a;<span class="comment">//赋值符号重载</span></span><br><span class="line">    a<span class="number">2.</span><span class="built_in">display</span>();</span><br><span class="line">    a2 = a3;   <span class="comment">// a2是空的</span></span><br><span class="line">    a<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">100</span>;<span class="comment">//[]重载</span></span><br><span class="line">    <span class="function">CArray <span class="title">a4</span><span class="params">(a)</span></span>;</span><br><span class="line">    a<span class="number">4.</span><span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 </span><br><span class="line">0 1 2 3 4</span><br><span class="line"></span><br><span class="line">0 1 2 100 4</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;04运算符重载运算符与赋值符&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#04运算符重载运算符与赋值符&quot;&gt;&lt;/a&gt; 04运算符重载——运算符与赋值符&lt;/h2&gt;
&lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a class=&quot;markdownIt-</summary>
      
    
    
    
    <category term="OOP面向对象" scheme="https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="OOP" scheme="https://xqc-1368.github.io/tags/OOP/"/>
    
    <category term="运算符重载" scheme="https://xqc-1368.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>02Bucket思想：A-B 数对</title>
    <link href="https://xqc-1368.github.io/2024/08/19/02Bucket%E6%80%9D%E6%83%B3%EF%BC%9AA-B%20%E6%95%B0%E5%AF%B9/"/>
    <id>https://xqc-1368.github.io/2024/08/19/02Bucket%E6%80%9D%E6%83%B3%EF%BC%9AA-B%20%E6%95%B0%E5%AF%B9/</id>
    <published>2024-08-19T04:23:45.894Z</published>
    <updated>2024-08-19T02:47:32.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="好题记录20239-1"><a class="markdownIt-Anchor" href="#好题记录20239-1"></a> 好题记录2023.9-1</h2><p>题目：</p><h1 id="a-b-数对"><a class="markdownIt-Anchor" href="#a-b-数对"></a> A-B 数对</h1><h2 id="题目背景"><a class="markdownIt-Anchor" href="#题目背景"></a> 题目背景</h2><p>出题是一件痛苦的事情！</p><p>相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给出一串正整数数列以及一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，要求计算出所有满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>−</mo><mi>B</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A - B = C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的数对的个数（不同位置的数字一样的数对算不同的数对）。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>输入共两行。</p><p>第一行，两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">N,C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>。</p><p>第二行，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个正整数，作为要求处理的那串数。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>一行，表示该串正整数中包含的满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>−</mo><mi>B</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A - B = C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的数对的个数。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 1 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h2><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>75</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">75\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1 \leq N \leq 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq N \leq 2 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq a_i &lt;2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>C</mi><mo>&lt;</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq C &lt; 2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>2017/4/29 新添数据两组</p><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1><h2 id="on2思路"><a class="markdownIt-Anchor" href="#on2思路"></a> O(n2)思路</h2><p>楼下的题解讲的很清楚，就是将A−B=C变成A=B+C，朴素的算法是一个二重循环，当然我们知道这肯定会超时的。</p><h2 id="onlogn思路笔者采用这个思路"><a class="markdownIt-Anchor" href="#onlogn思路笔者采用这个思路"></a> O(nlogn)思路（笔者采用这个思路）</h2><p>利用二分，一遍循环枚举找B，中间二分找C，时间复杂度O(nlogn)，可以通过本题</p><p>也可以利用stl中自带的红黑树map达到AC的效果</p><h2 id="on思路"><a class="markdownIt-Anchor" href="#on思路"></a> O(n)思路</h2><p>优化一点的算法呢则是用桶去保存每个数，这样我们就只需要枚举B，然后判断一下C存不存在就行了，这样的时间复杂度是O(n)，当然此算法空间复杂度很高会MLE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search_low</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a[],<span class="type">long</span> <span class="type">long</span> key,<span class="type">long</span> <span class="type">long</span> low,<span class="type">long</span> <span class="type">long</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> i=low,mid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> j=high,flag=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(i+j)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=key)</span><br><span class="line">        &#123;</span><br><span class="line">            j=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==key)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search_high</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a[],<span class="type">long</span> <span class="type">long</span> key,<span class="type">long</span> <span class="type">long</span> low,<span class="type">long</span> <span class="type">long</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> i=low,mid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> j=high,flag=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(i+j)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            j=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[j]==key)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> i,j,n,c,mid,flag1,ans=<span class="number">0</span>,flag2;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a[n],key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a,a+n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag1=binary_search_high(a,a[i]+c,i+<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">        flag2=binary_search_low(a,a[i]+c,i+<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag1!=<span class="number">-1</span> &amp;&amp; flag2!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=(flag1-flag2+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然sort部分可以编写快速排序，但是不给过，有两个测试点超时</p><p>以下内容看不懂</p><h1 id="正题"><a class="markdownIt-Anchor" href="#正题"></a> 正题</h1><p>好吧，前面讲了这么多都是为了告诉你各算法的优缺点，自然在目前来看，HASH解法是最优秀的（除了打表），那么具体怎样实现呢？</p><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><p>前面讲O(n)算法的时候，讲过用桶去做，这样的代价是用空间换时间，需要的空间代价是极高的，而HASH就是避免了这一点。</p><p>其实我们可以发现，桶数组中是有很多桶是没有用到的，也就是浪费了空间，比如有4个数</p><p>2 4 7 10001</p><p>用桶你就必须得开一个10001的数组，而用HASH只需要开一个长度为4的数组，它们的位置分别为</p><p>2%4=2 4%4=0 7%4=3 10001%4=1</p><p>在HASH表中表示为</p><p>0 1         2 3</p><p>4 10001 2 7</p><p>明白了吗？其实就是%一个数而已，若%的过程中，这个位置已经有数了，那么就放在它的后面就行了，以此类推。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;好题记录20239-1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#好题记录20239-1&quot;&gt;&lt;/a&gt; 好题记录2023.9-1&lt;/h2&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;h1 id=&quot;a-b-数对&quot;&gt;&lt;a class=&quot;markdownIt</summary>
      
    
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02 类和对象：构造函数和析构函数</title>
    <link href="https://xqc-1368.github.io/2024/08/19/02%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>https://xqc-1368.github.io/2024/08/19/02%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-19T04:23:45.887Z</published>
    <updated>2024-08-19T03:18:09.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类-对象"><a class="markdownIt-Anchor" href="#类-对象"></a> 类 &amp; 对象</h1><ul><li><p>面向对象的程序设计：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>面向对象的程序</mtext><mo>=</mo><mtext>类</mtext><mo>+</mo><mtext>类</mtext><mo>+</mo><mo>…</mo><mo>+</mo><mtext>类</mtext></mrow><annotation encoding="application/x-tex">面向对象的程序 = 类 + 类 + …+ 类</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">序</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">类</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">类</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">类</span></span></span></span>    设计程序的过程，就是设计类的过程。</li></ul></li><li><p>对象的内存分配：对象所占用的内存空间的大小，等于所有成员变量的大小之和。</p><ul><li>求法：<code>sizeof(类名)</code></li></ul></li><li><p>对象之间的运算：</p><ul><li>对象之间可以用 “=”进行赋值，但是不能用 “==”，“!=”，“&gt;”,“&lt;”“&gt;=”“&lt;=”进行比较，除非这些运算符经过了“重载”。</li></ul></li></ul><h5 id="1类的定义"><a class="markdownIt-Anchor" href="#1类的定义"></a> 1.类的定义</h5><p>类中的数据称为成员变量，函数称为成员函数。</p><p>类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。</p><p>定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p><p><img src="/images/2024-08-19-11-16-58-image.png" alt="" /></p><p>以下实例我们使用关键字 <strong>class</strong> 定义 Box 数据类型，包含了三个成员变量 length、breadth 和 height：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>，这个我们稍后会进行讲解。</p><h5 id="2定义对象"><a class="markdownIt-Anchor" href="#2定义对象"></a> 2.定义对象</h5><p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box Box1;          <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">Box Box2;          <span class="comment">// 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure><p>对象 Box1 和 Box2 都有它们各自的数据成员。</p><p>下面程序定义了一个roommate类，记录了几个人的睡觉时间和起床时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">roommate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> name,getup,sleep;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">average_sleeptime</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> _name,<span class="type">int</span> _getup,<span class="type">int</span> _sleep)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            name=_name;getup=_getup;sleep=_sleep;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> roommate ::<span class="built_in">average_sleeptime</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sleep&lt;<span class="number">24</span> &amp;&amp; sleep&gt;<span class="number">12</span>)<span class="keyword">return</span> getup<span class="number">+24</span>-sleep;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> getup-sleep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3访问数据成员"><a class="markdownIt-Anchor" href="#3访问数据成员"></a> 3.访问数据成员</h5><p>用法1：对象名.成员名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRectangle r1,r2;</span><br><span class="line">r<span class="number">1.</span>w = <span class="number">5</span>;</span><br><span class="line">r<span class="number">2.</span><span class="built_in">Init</span>(<span class="number">5</span>,<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>用法2：指针-&gt;成员名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CRectangle r1,r2;</span><br><span class="line">CRectangle * p1 = &amp; r1;</span><br><span class="line">CRectangle * p2 = &amp; r2;</span><br><span class="line">p1-&gt;w = <span class="number">5</span>;</span><br><span class="line">p2-&gt;<span class="built_in">Init</span>(<span class="number">5</span>,<span class="number">4</span>); <span class="comment">//Init作用在p2指向的对象上</span></span><br></pre></td></tr></table></figure><p>用法3：引用名.成员名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CRectangle r2;</span><br><span class="line">CRectangle &amp; rr = r2;</span><br><span class="line">rr.w = <span class="number">5</span>;</span><br><span class="line">rr.<span class="built_in">Init</span>(<span class="number">5</span>,<span class="number">4</span>); <span class="comment">//rr的值变了，r2的值也变</span></span><br></pre></td></tr></table></figure><p>类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。</p><p><img src="/images/2024-08-19-11-17-10-image.png" alt="" /></p><h5 id="4类成员的可访问范围"><a class="markdownIt-Anchor" href="#4类成员的可访问范围"></a> 4.类成员的可访问范围</h5><p>在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围：</p><ul><li><p>private: 私有成员，只能在成员函数内访问</p></li><li><p>public : 公有成员，可以在任何地方访问</p></li><li><p>protected: 保护成员</p></li></ul><p><em>注：三种关键字出现的次数和先后次序都没有限制</em></p><p>如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nAge; <span class="comment">//私有成员</span></span><br><span class="line">    <span class="type">char</span> szName[<span class="number">20</span>]; <span class="comment">// 私有成员</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">char</span> * szName)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>( Man::szName,szName);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类的成员函数内部，能够访问：</p><ul><li><p>当前对象的全部属性、函数；</p></li><li><p>同类其它对象的全部属性、函数。</p></li></ul><p><em>注：用struct定义类和用&quot;class&quot;的唯一区别，就是未说明是公有还是私有的成员，就是公有</em></p><h5 id="5成员函数的重载和参数缺省"><a class="markdownIt-Anchor" href="#5成员函数的重载和参数缺省"></a> 5.成员函数的重载和参数缺省</h5><p>成员函数也可以重载       成员函数可以带缺省参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Location</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">( <span class="type">int</span> x=<span class="number">0</span> , <span class="type">int</span> y = <span class="number">0</span> )</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">valueX</span><span class="params">( <span class="type">int</span> val )</span> </span>&#123; x = val ;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">valueX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Location::init</span><span class="params">( <span class="type">int</span> X, <span class="type">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = X ;             </span><br><span class="line">    y = Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Location A,B;</span><br><span class="line">    A.<span class="built_in">init</span>(<span class="number">5</span>);</span><br><span class="line">    A.<span class="built_in">valueX</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; A.<span class="built_in">valueX</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6构造函数"><a class="markdownIt-Anchor" href="#6构造函数"></a> 6.构造函数</h5><p>定义：成员函数的一种：</p><ul><li><p><u>名字与类名相同</u>，可以有参数，不能有返回值(void也不行)</p></li><li><p>作用是对对象进行初始化，如给成员变量赋初值。</p></li><li><p>如果定义类时没写构造函数，则<u>编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作</u></p></li><li><p>如果定义了构造函数，则编译器不生成默认的无参数的构造函数。对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</p></li><li><p>一个类可以有多个构造函数</p></li></ul><p>系统自动生成的无参构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">( <span class="type">double</span> r, <span class="type">double</span> i)</span></span>;</span><br><span class="line"><span class="comment">//相当于系统自动在这里写了一个：（无参构造函数）</span></span><br><span class="line"><span class="comment">//      Complex();</span></span><br><span class="line">&#125;; <span class="comment">//编译器自动生成默认构造函数</span></span><br><span class="line"></span><br><span class="line">Complex c1; <span class="comment">//默认构造函数被调用</span></span><br><span class="line">Complex * pc = <span class="keyword">new</span> Complex; <span class="comment">//默认构造函数被调用</span></span><br></pre></td></tr></table></figure><p>手写的带参构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>( <span class="type">double</span> r, <span class="type">double</span> i = <span class="number">0</span>);<span class="comment">//提前定义，并写好缺省值</span></span><br><span class="line">&#125;; </span><br><span class="line">Complex::<span class="built_in">Complex</span>( <span class="type">double</span> r, <span class="type">double</span> i) </span><br><span class="line">&#123;</span><br><span class="line">    real = r; imag = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex c1; <span class="comment">// error, 缺少构造函数的参数</span></span><br><span class="line">Complex * pc = <span class="keyword">new</span> Complex; <span class="comment">// error, 没有参数</span></span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// OK</span></span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Complex * pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>带参构造函数的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> real, imag;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">double</span> r, <span class="type">double</span> i)</span></span>;</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i);</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r);</span><br><span class="line">        <span class="built_in">Complex</span>(Complex c1, Complex c2);</span><br><span class="line">&#125;;</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    real = r;</span><br><span class="line">    imag = i;</span><br><span class="line">&#125;</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    real = r;</span><br><span class="line">    imag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex::<span class="built_in">Complex</span>(Complex c1, Complex c2)</span><br><span class="line">&#123;</span><br><span class="line">    real = c<span class="number">1.</span>real + c<span class="number">2.</span>real;</span><br><span class="line">    imag = c<span class="number">1.</span>imag + c<span class="number">2.</span>imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c1 = &#123;3, 0&#125;, c2 = &#123;1, 0&#125;, c3 = &#123;4, 0&#125;;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">c3</span><span class="params">(c1, c2)</span></span>;</span><br><span class="line">    cout&lt;&lt;c<span class="number">1.</span>real&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：构造函数最好是public的，private构造函数不能直接用来初始化对象</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSample</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">CSample</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CSample Obj; <span class="comment">//err. 唯一构造函数是private</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7构造函数在数组中的使用"><a class="markdownIt-Anchor" href="#7构造函数在数组中的使用"></a> 7.构造函数在数组中的使用</h5><p>构造一个对象，就调用一次构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CSample</span>()<span class="comment">//（1）无参构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Constructor 1 Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CSample</span>(<span class="type">int</span> n)<span class="comment">//（2）带参构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = n;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Constructor 2 Called&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSample array1[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//构造两个无参对象，都使用（1）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CSample array2[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//构造两个有参对象，都使用（2）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CSample array3[<span class="number">2</span>] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//构造1个有参对象和1个无参对象，先使用（1），再使用（2）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step3&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CSample *array4 =<span class="keyword">new</span> CSample[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//构造两个无参对象，都使用（1）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] array4;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constructor 1 Called</span><br><span class="line">Constructor 1 Called</span><br><span class="line">step1</span><br><span class="line">Constructor 2 Called</span><br><span class="line">Constructor 2 Called</span><br><span class="line">step2</span><br><span class="line">Constructor 2 Called</span><br><span class="line">Constructor 1 Called</span><br><span class="line">step3</span><br><span class="line">Constructor 1 Called</span><br><span class="line">Constructor 1 Called</span><br></pre></td></tr></table></figure><p>单对象多参数的构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> n) &#123;&#125;        <span class="comment">//(1)</span></span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> n, <span class="type">int</span> m) &#123;&#125; <span class="comment">//(2)</span></span><br><span class="line">        <span class="built_in">Test</span>() &#123;&#125;             <span class="comment">//(3)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 三个元素分别用(1),(2),(3)初始化</span></span><br><span class="line">Test array1[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>) &#125;;</span><br><span class="line"><span class="comment">//等价于：Test array1[3] = &#123;Test(1), Test(1, 2),Test()&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有申请内存的不能算数</span></span><br><span class="line">Test * pArray[<span class="number">3</span>] = &#123; <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>) &#125;;</span><br><span class="line"><span class="comment">//两个元素（注意：是两个元素，不是三个）分别用(1),(2) 初始化</span></span><br></pre></td></tr></table></figure><h6 id="拓展使用初始化列表来初始化字段"><a class="markdownIt-Anchor" href="#拓展使用初始化列表来初始化字段"></a> 拓展：使用初始化列表来初始化字段</h6><p>使用初始化列表来初始化字段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len): <span class="built_in">length</span>(len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的语法等同于如下语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8复制构造函数copy-constructor"><a class="markdownIt-Anchor" href="#8复制构造函数copy-constructor"></a> 8.复制构造函数（copy constructor）</h5><ul><li><p>只有一个参数,即对同类对象的引用。</p></li><li><p>形如 X::X( X&amp; )或X::X(const X &amp;), 二者选一      后者能以常量对象作为参数</p></li><li><p>如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能</p><p>注意：</p><p><mark>不允许有形如 X::X( X ) or X ( X ) 的构造函数</mark>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSample</span> &#123;</span><br><span class="line">    <span class="built_in">CSample</span>( CSample c ) &#123;&#125; <span class="comment">//错，不允许这样的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="9复制构造函数起作用的三种情况"><a class="markdownIt-Anchor" href="#9复制构造函数起作用的三种情况"></a> 9.复制构造函数起作用的三种情况</h5><p>1)当用一个对象去初始化同类的另一个对象时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1; <span class="comment">//初始化语句，非赋值语句</span></span><br></pre></td></tr></table></figure><p>2)如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类A的复制构造函数将被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; &#125;;</span><br><span class="line">        <span class="built_in">A</span>( A &amp; a) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(A a1)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    A a2;</span><br><span class="line">    <span class="built_in">Func</span>(a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序输出结果为: </span><br><span class="line">Copy constructor called</span><br></pre></td></tr></table></figure><p>3)如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123; v = n; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Func</span>().v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序理论上应该输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor called</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>但实际上只输出了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>这是因为：</p><blockquote><p>C++ 函数返回值为对象时调用复制构造函数的问题<br />知识点：<br />C++中调用复制构造函数的三种情况：</p><p>1.通过一个对象构造另一个对象<br />2.调用参数为对象的函数<br />3.调用返回值为对象的函数<br />– 上述知识点在各种书籍、博客都无不同，属于C++的标准<br />– 但是实际测试的时候，当调用返回值为对象的函数时，并未按预想地调用复制构造函数。<br />– 在查阅了很多博客资料后，原因如下：</p><p>当调用返回值为对象的函数时，系统消耗调用复制构造函数、调用构造函数，调用析构函数的代价，为了减少消耗，编译器使用了一项名为返回值优化的技术，使得调用函数时不需要调用复制构造函数<br />具体过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用复制构造函数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个Person对象</span></span><br><span class="line"><span class="function">Person <span class="title">create</span><span class="params">(string name,<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Person</span>(name,age);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p = <span class="built_in">create</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化前：调用create函数时，先根据传入的参数生成一个临时对象 t1（栈中），然后拷贝生成临时对象 t2（栈外），函数执行完毕，返回 t2的地址，t1被回收；p根据返回的 t2 地址构造对象</p><p>优化后：调用create函数时，编译器偷偷地增加了一个参数，传入了p的地址，直接在函数内部构造了p对象</p></blockquote><h5 id="10转换构造函数intconstructor"><a class="markdownIt-Anchor" href="#10转换构造函数intconstructor"></a> 10.转换构造函数（Intconstructor）</h5><ul><li><p>定义转换构造函数的目的是实现类型的自动转换。 只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数。</p></li><li><p>当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象(或临时变量)。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Complex</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//显式类型转换构造函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IntConstructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">        real = i;</span><br><span class="line">        imag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        real = r;</span><br><span class="line">        imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    Complex c2 = <span class="built_in">Complex</span>(<span class="number">12</span>);</span><br><span class="line">    c1 = <span class="number">9</span>;         <span class="comment">// error, 9不能被自动转换成一个临时Complex对象</span></span><br><span class="line">    c1 = <span class="built_in">Complex</span>(<span class="number">9</span>); <span class="comment">// ok</span></span><br><span class="line">    cout&lt;&lt; c<span class="number">1.</span>real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; c<span class="number">1.</span>imag &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式类型转换构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> i)<span class="comment">//区别1</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;IntConstructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">        real = i;</span><br><span class="line">        imag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        real = r;</span><br><span class="line">        imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    Complex c2 = <span class="number">12</span>;<span class="comment">//区别2</span></span><br><span class="line">    c1 = <span class="number">9</span>; <span class="comment">// 9被自动转换成一个临时Complex对象</span></span><br><span class="line">    cout &lt;&lt; c<span class="number">1.</span>real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; c<span class="number">1.</span>imag &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11析构函数destructors"><a class="markdownIt-Anchor" href="#11析构函数destructors"></a> 11.析构函数（destructors）</h5><ul><li><p>名字与类名相同，在前面加  <code>~</code>  ， 没有参数和返回值，一个类最多只能有一个析构函数。</p></li><li><p>析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。</p></li><li><p>如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做。</p></li><li><p>如果定义了析构函数，则编译器不生成缺省析构函数。</p></li></ul><p>析构函数实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">String</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">String</span>();</span><br><span class="line">&#125;;</span><br><span class="line">String ::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数被调用的几种情况：</p><p>1.对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ctest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">Ctest</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Ctest array[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End Main&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.delete 运算导致析构函数调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Ctest *pTest;</span><br><span class="line">    pTest = <span class="keyword">new</span> Ctest;<span class="comment">//构造函数调用</span></span><br><span class="line">    <span class="keyword">delete</span> pTest;<span class="comment">//析构函数调用</span></span><br><span class="line">    pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>]; <span class="comment">//构造函数调用3次</span></span><br><span class="line">    <span class="keyword">delete</span>[] pTest;  <span class="comment">//析构函数调用3次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对象(调用一次析构函数)</li></ul><p>3.析构函数在对象作为函数返回值返回后被调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CMyclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CMyclass obj;</span><br><span class="line"><span class="function">CMyclass <span class="title">fun</span><span class="params">(CMyclass sobj)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//参数对象消亡也会导致析构函数被调用</span></span><br><span class="line">    <span class="keyword">return</span> sobj; <span class="comment">//函数调用返回时生成临时对象返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj = <span class="built_in">fun</span>(obj); <span class="comment">//函数调用的返回值（临时对象）被</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//用过后，该临时对象析构函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类-对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类-对象&quot;&gt;&lt;/a&gt; 类 &amp;amp; 对象&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向对象的程序设计：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span </summary>
      
    
    
    
    <category term="OOP面向对象" scheme="https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="OOP" scheme="https://xqc-1368.github.io/tags/OOP/"/>
    
    <category term="类和对象" scheme="https://xqc-1368.github.io/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="构造函数和析构函数" scheme="https://xqc-1368.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>01删除标记思想：队列安排</title>
    <link href="https://xqc-1368.github.io/2024/08/19/01%E5%88%A0%E9%99%A4%E6%A0%87%E8%AE%B0%E6%80%9D%E6%83%B3%EF%BC%9A%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92/"/>
    <id>https://xqc-1368.github.io/2024/08/19/01%E5%88%A0%E9%99%A4%E6%A0%87%E8%AE%B0%E6%80%9D%E6%83%B3%EF%BC%9A%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92/</id>
    <published>2024-08-19T04:23:45.883Z</published>
    <updated>2024-08-19T02:45:45.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列安排"><a class="markdownIt-Anchor" href="#队列安排"></a> 队列安排</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>一个学校里老师要将班上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个同学排成一列，同学被编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1\sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，他采取如下的方法：</p><ol><li><p>先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号同学安排进队列，这时队列中只有他一个人；</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">2\sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 号同学依次入列，编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的同学入列方式为：老师指定编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的同学站在编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1\sim(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 中某位同学（即之前已经入列的同学）的左边或右边；</p></li><li><p>从队列中去掉 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个同学，其他同学位置顺序不变。</p></li></ol><p>在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>第一行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，表示了有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个同学。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">2\sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo separator="true">,</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">k,p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 为小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的正整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则表示将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 号同学插入到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 号同学的左边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 则表示插入到右边。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 行为一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示去掉的同学数目。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，表示将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 号同学从队列中移去，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 号同学已经不在队列中则忽略这一条指令。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>一行，包含最多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个空格隔开的整数，表示了队列从左到右所有同学的编号。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 0</span><br><span class="line">2 1</span><br><span class="line">1 0</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 1</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h2><p><strong>【样例解释】</strong></p><p>将同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 插入至同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 左边，此时队列为：</p><p><code>2 1</code></p><p>将同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 插入至同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 右边，此时队列为：</p><p><code>2 3 1</code></p><p>将同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 插入至同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 左边，此时队列为：</p><p><code>2 3 4 1</code></p><p>将同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 从队列中移出，此时队列为：</p><p><code>2 4 1</code></p><p>同学 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 已经不在队列中，忽略最后一条指令</p><p>最终队列：</p><p><code>2 4 1</code></p><p><strong>【数据范围】</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1\leq N\leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">40\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1\leq N\leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>M</mi><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1&lt;M\leq N\leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><h2 id="vector做法在删除on不够方便部分运用桶的思想删除时标记删除"><a class="markdownIt-Anchor" href="#vector做法在删除on不够方便部分运用桶的思想删除时标记删除"></a> Vector做法：在删除（O（n）不够方便）部分运用桶的思想，删除时“标记删除”</h2><p>注：以下的queue仅仅为动态数组的名字，并不是队列，和队列没半毛钱关系</p><p>添加部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,k,p,end,x,m,k0=<span class="number">0</span>,k1=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">queue</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>;</span><br><span class="line"><span class="type">int</span> del[<span class="number">100005</span>]    =&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(iter=<span class="built_in">queue</span>.begin();iter!=<span class="built_in">queue</span>.end();iter++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*iter==k)<span class="keyword">break</span>;<span class="comment">//iter为迭代器，用于遍历queue，寻找k号同学</span></span><br><span class="line">        k0++;<span class="comment">//这个循环相当于find函数</span></span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>.insert(<span class="built_in">queue</span>.begin()+k0,i);</span><br><span class="line">        k0=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>.insert(<span class="built_in">queue</span>.begin()+k0+<span class="number">1</span>,i);</span><br><span class="line">        k0=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><u><strong>重头戏：删除部分代码，看网友大佬如何用桶思想实现标记删除（在桶中标记所有现有的元素，然后用桶标记要删除的元素，实则在queue中并没有将该元素删除，而是在输出时候检测桶中这个元素是否已经被删除了，考虑是否输出，时间复杂度骤降，但只适用于每个元素只出现一次的情况，好处是与此同时可以实现删除时候的去重）</strong></u></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    del[i]=<span class="number">1</span>;<span class="comment">//由上一段代码可知，del是一个全为0的桶，此处赋值所有已存在在queue中的内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    del[x]=<span class="number">0</span>;<span class="comment">//用标记法“删除”元素x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (iter=<span class="built_in">queue</span>.begin();iter!=<span class="built_in">queue</span>.end();iter++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(del[*iter]==<span class="number">1</span>)<span class="comment">//标记删除的元素不输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>需要的头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> </span></span><br></pre></td></tr></table></figure><p>注意：本做法在www.luogu.com中仅开启吸氧O2才能通过，因此没有这么完美</p><h2 id="list做法在查找方面用索引的做法记录每号同学的位置"><a class="markdownIt-Anchor" href="#list做法在查找方面用索引的做法记录每号同学的位置"></a> List做法：在查找方面用索引的做法，记录每号同学的位置</h2><p>索引查找仅限于用于链表，因为只有链表插入时是不改变其他同学的地址信息的，也就是说pos[?]的位置不用再一一修订。</p><p>以下片段为插入部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">Iter pos[maxN];</span><br><span class="line">list&lt;<span class="type">int</span>&gt; queList;</span><br><span class="line"><span class="type">bool</span> erased[maxN];</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">queList.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">pos[<span class="number">1</span>] = queList.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> k, p;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;p);</span><br><span class="line">      <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          pos[i] = queList.<span class="built_in">insert</span>(pos[k], i); <span class="comment">//left</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">auto</span> nextIter = <span class="built_in">next</span>(pos[k]);</span><br><span class="line">          pos[i] = queList.<span class="built_in">insert</span>(nextIter, i); <span class="comment">//right</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>pos[n]为索引数组，其内容为n的位置</p><p>在删除方面，直接使用内置函数即可，因为erase在list之中的复杂度较低，直接用没什么问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;M);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x, i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="keyword">if</span> (!erased[x])</span><br><span class="line">      &#123;</span><br><span class="line">          queList.erase(pos[x]);</span><br><span class="line">      &#125;</span><br><span class="line">      erased[x] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;队列安排&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#队列安排&quot;&gt;&lt;/a&gt; 队列安排&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h2</summary>
      
    
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01 面向对象程序设计基础</title>
    <link href="https://xqc-1368.github.io/2024/08/19/01%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://xqc-1368.github.io/2024/08/19/01%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2024-08-19T04:23:45.879Z</published>
    <updated>2024-08-19T02:52:24.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-从c到c"><a class="markdownIt-Anchor" href="#第一章-从c到c"></a> 第一章  从C到C++</h2><h3 id="11引用"><a class="markdownIt-Anchor" href="#11引用"></a> 1.1引用</h3><h6 id="1概念"><a class="markdownIt-Anchor" href="#1概念"></a> 1概念：</h6><p>某个变量的引用，等价于这个变量，相当于这个变量的一个别名</p><p>写法：<code>类型名&amp;引用名= 某变量名</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//b引用了a，b的类型是  int&amp;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上述程序输出为2</p><ul><li>注：改变引用变量的值，原变量也会改变，因为引用变量仅仅是一个别名</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line">b=<span class="number">8</span>;<span class="comment">//修改引用变量的值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//原变量的值也被修改</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>上述程序输出为8</p><h6 id="2-引用的要求"><a class="markdownIt-Anchor" href="#2-引用的要求"></a> 2 引用的要求：</h6><ul><li><p>定义引用时，一定要将其初始化成引用某个<u>变量</u></p></li><li><p>初始化后，他就一直引用该变量，不会再引用其他变量</p></li><li><p>引用只能引用变量，不能引用常量和表达式。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>,c=<span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line">b=c;<span class="comment">//仅仅表示把c的值赋给b，即把c的值赋给a，b并没有引用</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h6 id="3-引用作为函数参数"><a class="markdownIt-Anchor" href="#3-引用作为函数参数"></a> 3 引用作为函数参数</h6><p>可以在函数内部修改参数的值</p><p>相当于指针，但是不用像指针一样麻烦地每次都写*</p><p>用于交换a，c的程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span><br><span class="line">&#123;</span><br><span class="line">    a^=b;</span><br><span class="line">    b^=a;</span><br><span class="line">    a^=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">2</span>,c=<span class="number">9</span>;</span><br><span class="line">    swap(a,c);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序输出为9 2</p><h6 id="4-引用作为函数的返回值"><a class="markdownIt-Anchor" href="#4-引用作为函数的返回值"></a> 4 引用作为函数的返回值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="title function_">setvalue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvalue()=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序输出为40</p><h6 id="5-常引用"><a class="markdownIt-Anchor" href="#5-常引用"></a> 5 常引用</h6><p>概念：</p><p><code>const int&amp; r=n</code>r的类型为const int &amp;</p><p>不能通过常引用去修改其引用的内容（但内容本身可以修改）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r=n;</span><br><span class="line">n=<span class="number">0</span>;<span class="comment">//OK</span></span><br><span class="line">r=<span class="number">9</span>;<span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注：<code>const int&amp;</code>与<code>int &amp;</code>是 不同类型</p><h3 id="12-内联函数和重载函数"><a class="markdownIt-Anchor" href="#12-内联函数和重载函数"></a> 1.2 内联函数和重载函数</h3><h6 id="1-内联函数"><a class="markdownIt-Anchor" href="#1-内联函数"></a> 1 内联函数</h6><p>作用：减少函数调用的开销</p><ul><li>编译器处理对内联函数的调用语句时，是将整个函数的代码  <u>插入</u>  到调用语句处，而不会产生调用函数的语句。</li></ul><p>在函数定义前面加<code>inline</code>关键字，即可定义内联函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">MAX</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">9</span>,b=<span class="number">8</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;MAX(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-函数重载"><a class="markdownIt-Anchor" href="#2-函数重载"></a> 2 函数重载</h6><p>一个或多个函数，<strong>名字相同，然而参数个数或参数类型不相同</strong>，这叫做函数的重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MAX</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">MAX</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span><span class="comment">//(2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MAX</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><span class="comment">//(3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d=a&gt;b?a:b;</span><br><span class="line">    <span class="keyword">return</span> d&gt;c?d:c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">9</span>,b=<span class="number">8</span>,c=<span class="number">12</span>;</span><br><span class="line"><span class="comment">//2 int</span></span><br><span class="line"><span class="comment">//3 int</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">MAX</span>(a,b)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">MAX</span>(a,b,c)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//2 double  调用（2）</span></span><br><span class="line">    <span class="type">double</span> r=<span class="number">3.4</span>,g=<span class="number">2.5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">MAX</span>(r,g)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//generate two-meaning error 二义性错误</span></span><br><span class="line">    <span class="type">double</span> t=<span class="number">9.9</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">MAX</span>(t,b)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//generate two-meaning error 二义性错误</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">MAX</span>(<span class="number">3</span>,<span class="number">2.4</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数重载使得函数命名变得简单。编译器根据调用语句的中的实参的个数和类型判断应<br />该调用哪个函数。</p><h6 id="3-函数的缺省值"><a class="markdownIt-Anchor" href="#3-函数的缺省值"></a> 3 函数的缺省值</h6><p>定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">2</span>,<span class="type">int</span> c=<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">9</span>,b=<span class="number">8</span>,c=<span class="number">12</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(a)&lt;&lt;endl;<span class="comment">//等价于func(9,2,3)输出14</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(a,b)&lt;&lt;endl;<span class="comment">//等价于func(9,8,3)输出20</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(a,b,c)&lt;&lt;endl;<span class="comment">//等价于func(9,8,12)输出29</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(a, , c) &lt;&lt; endl; <span class="comment">//不行,只能最右边的连续若干个参数缺省</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-const关键字"><a class="markdownIt-Anchor" href="#13-const关键字"></a> 1.3 const关键字</h3><ul><li>不可通过常量指针修改其指向的内容</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">8</span>,b; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line">    a=<span class="number">5</span>;<span class="comment">//correct</span></span><br><span class="line">    *p=<span class="number">0</span>;<span class="comment">//error：表达式必须是可修改的左值</span></span><br><span class="line">    p = &amp;b; <span class="comment">// correct 常量指针的指向可以变化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不能把常量指针赋值给非常量指针，反过来可以：因为const int *类型的初始化的时候默认指向的值不可修改</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">8</span>,b=<span class="number">9</span>,*p2=&amp;b; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line">    p=p2;</span><br><span class="line">    p2 = p; <span class="comment">// 不能将 const int*类型的值分配到 int 类型的实体</span></span><br><span class="line">    p2=(<span class="type">int</span>*)p;<span class="comment">//correct</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrintf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * p )</span></span></span><br><span class="line"><span class="function"></span>&#123;            </span><br><span class="line">   <span class="built_in">strcpy</span>( p,<span class="string">&quot;this&quot;</span>); <span class="comment">//编译出错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p); <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-动态内存分配"><a class="markdownIt-Anchor" href="#14-动态内存分配"></a> 1.4 动态内存分配</h3><h6 id="1-分配一个变量"><a class="markdownIt-Anchor" href="#1-分配一个变量"></a> 1 分配一个变量</h6><p><code>P = new T; </code><br />T是任意类型名，P是类型为T * 的指针。</p><p>动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="2-分配一个数组"><a class="markdownIt-Anchor" href="#2-分配一个数组"></a> 2 分配一个数组</h6><p><code>P = new T[N];</code></p><p>T :任意类型名<br />P :类型为T * 的指针<br />N :要分配的数组元素的个数，可以是整型表达式<br />动态分配出一片大小为 sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给P。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line">    p[<span class="number">5</span>]=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;p[<span class="number">5</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-delete运算符释放动态分配的内存"><a class="markdownIt-Anchor" href="#3-delete运算符释放动态分配的内存"></a> 3 delete运算符释放动态分配的内存</h6><p>用“new”动态分配的内存空间，一定要用“delete”运算符进行释放</p><p>句法：<code>delete 指针；</code>//该指针必须指向new出来的空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">* p = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//导致异常，一片空间不能被delete多次</span></span><br></pre></td></tr></table></figure><p>用“delete”释放动态分配的数组，要加“[]”<br />句法：<code>delete [ ] 指针；</code>//该指针必须指向new出来的数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章-从c到c&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一章-从c到c&quot;&gt;&lt;/a&gt; 第一章  从C到C++&lt;/h2&gt;
&lt;h3 id=&quot;11引用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11引用</summary>
      
    
    
    
    <category term="OOP面向对象" scheme="https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="OOP" scheme="https://xqc-1368.github.io/tags/OOP/"/>
    
    <category term="引用" scheme="https://xqc-1368.github.io/tags/%E5%BC%95%E7%94%A8/"/>
    
    <category term="内联函数" scheme="https://xqc-1368.github.io/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    
    <category term="重载函数" scheme="https://xqc-1368.github.io/tags/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"/>
    
    <category term="动态内存分配" scheme="https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>字符串操作函数汇总</title>
    <link href="https://xqc-1368.github.io/2024/08/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/"/>
    <id>https://xqc-1368.github.io/2024/08/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/</id>
    <published>2024-08-19T04:23:45.874Z</published>
    <updated>2024-08-19T03:39:04.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-字符串"><a class="markdownIt-Anchor" href="#c-字符串"></a> C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p><ul><li>C 风格字符串</li><li>C++ 引入的 string 类类型</li></ul><h2 id="c-风格字符串"><a class="markdownIt-Anchor" href="#c-风格字符串"></a> C 风格字符串</h2><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 \0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>下面的声明和初始化创建了一个 <strong>RUNOOB</strong> 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 <strong>RUNOOB</strong> 的字符数多一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p>以下是 C/C++ 中定义的字符串的内存表示：</p><p><img src="/images/2024-08-19-11-38-48-image.png" alt="" /></p><p>其实，您不需要把 <strong>null</strong> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 \0 放在字符串的末尾。让我们尝试输出上面的字符串：</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line"> &#123; </span><br><span class="line">    <span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;菜鸟教程: &quot;</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; site &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p>菜鸟教程: RUNOOB</p><p>C++ 中有大量的函数用来操作以 null 结尾的字符串:</p><table><thead><tr><th>序号</th><th>函数 &amp; 目的</th></tr></thead><tbody><tr><td>1</td><td><strong>strcpy(s1, s2);</strong><br>复制字符串 s2 到字符串 s1。</td></tr><tr><td>2</td><td><strong>strcat(s1, s2);</strong><br>连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如:<br><br><br>string str1 = “runoob”;<br>string str2 = “google”;<br>string str = str1 + str2;</td></tr><tr><td>3</td><td><strong>strlen(s1);</strong><br>返回字符串 s1 的长度。</td></tr><tr><td>4</td><td><strong>strcmp(s1, s2);</strong><br>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td></tr><tr><td>5</td><td><strong>strchr(s1, ch);</strong><br>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td>6</td><td><strong>strstr(s1, s2);</strong><br>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><p>下面的实例使用了上述的一些函数：</p><h2 id="实例-2"><a class="markdownIt-Anchor" href="#实例-2"></a> 实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">13</span>] = <span class="string">&quot;runoob&quot;</span>; </span><br><span class="line">    <span class="type">char</span> str2[<span class="number">13</span>] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">13</span>]; </span><br><span class="line">    <span class="type">int</span> len ; </span><br><span class="line">    <span class="comment">//复制 str1 到 str3 </span></span><br><span class="line">    <span class="built_in">strcpy</span>( str3, str1);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;strcpy( str3, str1) : &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">// 连接 str1 和 str2 </span></span><br><span class="line">    <span class="built_in">strcat</span>( str1, str2); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;strcat( str1, str2): &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 连接后，str1 的总长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str1); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;strlen(str1) : &quot;</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>( str3, str1) : runoob</span><br><span class="line"><span class="title function_">strcat</span><span class="params">( str1, str2)</span>: runoobgoogle</span><br><span class="line"><span class="title function_">strlen</span><span class="params">(str1)</span> : 12</span><br></pre></td></tr></table></figure><h2 id="c-中的-string-类"><a class="markdownIt-Anchor" href="#c-中的-string-类"></a> C++ 中的 String 类</h2><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p><p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p><h2 id="实例-3"><a class="markdownIt-Anchor" href="#实例-3"></a> 实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">&quot;google&quot;</span>; </span><br><span class="line">    <span class="built_in">string</span> str3; <span class="type">int</span> len ; </span><br><span class="line">    <span class="comment">// 复制 str1 到 str3 </span></span><br><span class="line">    str3 = str1; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">// 连接 str1 和 str2 </span></span><br><span class="line">    str3 = str1 + str2; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 连接后，str3 的总长度 </span></span><br><span class="line">    len = str3.size(); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3.size() : &quot;</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str3 : runoob</span><br><span class="line">str1 + str2 : runoobgoogle</span><br><span class="line">str3.size() : <span class="number">12</span></span><br></pre></td></tr></table></figure><p>其他一些实用函数</p><h4 id="in-c"><a class="markdownIt-Anchor" href="#in-c"></a> in c</h4><h4 id="in-c-2"><a class="markdownIt-Anchor" href="#in-c-2"></a> in c++</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-字符串&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-字符串&quot;&gt;&lt;/a&gt; C++ 字符串&lt;/h1&gt;
&lt;p&gt;C++ 提供了以下两种类型的字符串表示形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C 风格字符串&lt;/li&gt;
&lt;li&gt;C++ 引入的 </summary>
      
    
    
    
    <category term="C语言程序设计" scheme="https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="C++ STL" scheme="https://xqc-1368.github.io/categories/C-STL/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="C语言" scheme="https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="字符串" scheme="https://xqc-1368.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="STL" scheme="https://xqc-1368.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>指针与二维数组</title>
    <link href="https://xqc-1368.github.io/2024/08/19/%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <id>https://xqc-1368.github.io/2024/08/19/%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</id>
    <published>2024-08-19T04:23:45.869Z</published>
    <updated>2024-08-19T03:08:18.529Z</updated>
    
    <content type="html"><![CDATA[<p>指针与二维数组</p><p>数组法及其变式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组法1</span></span><br><span class="line">a==a+<span class="number">0</span>==&amp;a[<span class="number">0</span>]; *a==*(a+<span class="number">0</span>)==a[<span class="number">0</span>];</span><br><span class="line">a+<span class="number">1</span>==&amp;a[<span class="number">1</span>]; *(a+<span class="number">1</span>)==a[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//数组法2</span></span><br><span class="line">a[<span class="number">0</span>]+<span class="number">1</span>==&amp;a[<span class="number">0</span>][<span class="number">1</span>]; *(a[<span class="number">0</span>]+<span class="number">1</span>)==a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="comment">//数组法3</span></span><br><span class="line">*(a+<span class="number">1</span>)+<span class="number">2</span>==&amp;a[<span class="number">1</span>][<span class="number">2</span>]; *(*(a+<span class="number">1</span>)+<span class="number">2</span>)==a[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//数组法4</span></span><br><span class="line">(*(a+<span class="number">1</span>))[<span class="number">2</span>]==a[<span class="number">1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>列指针法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列指针的定义方法</span></span><br><span class="line"><span class="type">int</span> *p; </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方法</span></span><br><span class="line"><span class="comment">//初始化：指向第一个元素：（以下三个方法等价）</span></span><br><span class="line">p=a[<span class="number">0</span>] ; p=*a ; p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//初始化：指向任意一个元素：</span></span><br><span class="line">p=a[i][j];p=a[<span class="number">2</span>][<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//列指针的使用方法：（a为m行n列的一个二维数组）</span></span><br><span class="line">*(p+i*n+j)==a[i][j];    p+i*n+j==&amp;a[i][j];</span><br><span class="line">p[i*n+j]==a[i][j];     </span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>语法</th><th>样例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>指向任意元素</td><td>指针变量=&amp;数组名[下标1][下标2]</td><td>p=&amp;a[1][2]</td><td style="text-align:center">p指向的元素为7</td></tr><tr><td>指向首个元素</td><td>指针变量=&amp;数组名[0][0]<br/>指针变量=*二维数组名</td><td>p=&amp;a[0][0]或p=*a</td><td style="text-align:center">p指向首个元素，即数值1所在位置</td></tr></tbody></table><table><thead><tr><th>p</th><th>p+1</th><th>p+2</th><th>p+3</th></tr></thead><tbody><tr><td>p+4</td><td>p+5</td><td>p+6</td><td>p+7</td></tr><tr><td>p+8</td><td>p+9</td><td>p+10</td><td>p+11</td></tr></tbody></table><table><thead><tr><th>表示方法</th><th>说明</th><th>指针类型</th></tr></thead><tbody><tr><td>a[0]</td><td>是一维数组名称，首地址<br>第0个元素地址(a[0]+0)</td><td>列指针</td></tr><tr><td>a[0]+1</td><td>第0行，第1个元素</td><td>列指针</td></tr><tr><td>a[0]+2</td><td>第0行，第2个元素</td><td>列指针</td></tr><tr><td>a[0]+3</td><td>第0行，第3个元素</td><td>列指针</td></tr></tbody></table><p>行指针法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//行指针的定义</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//行指针的初始化(a为某数组)(二者任选其一即可)</span></span><br><span class="line">p=a;  p=&amp;a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//行指针应用公式</span></span><br><span class="line">p[i][j]==a[i][j];</span><br><span class="line">*(*(p+i)+j)==a[i][j];   *(p+i)+j==&amp;a[i][j];</span><br><span class="line">*(p[i]+j)==a[i][j];     p[i]+j==&amp;a[i][j];</span><br><span class="line">(*(p+i))[j]==a[i][j];</span><br></pre></td></tr></table></figure><p>二维数组的名字默认是行指针</p><table><thead><tr><th>表示方法</th><th>说明</th><th>指针类型</th></tr></thead><tbody><tr><td>a或a+0</td><td>指向第0行</td><td>行指针</td></tr><tr><td>a+1</td><td>指向第1行</td><td>行指针</td></tr><tr><td>a+2</td><td>指向第2行</td><td>行指针</td></tr></tbody></table><h4 id="行指针和列指针的联系"><a class="markdownIt-Anchor" href="#行指针和列指针的联系"></a> 行指针和列指针的联系</h4><p>行指针：指的是一整行，不指向具体元素。</p><p>列指针：指的是二维数组中某一行的某个具体元素。</p><p><strong>可以将列指针认为是行指针的具体元素，行指针是列指针的地址。</strong></p><p>两者间的具体转化：</p><p>*行指针—&gt;列指针</p><p>&amp;列指针—&gt;行指针</p><table><thead><tr><th>行指针</th><th>转换成：列指针</th></tr></thead><tbody><tr><td>a或a+0</td><td>*a或a[0]</td></tr><tr><td>a+1</td><td>*(a+1)或a[1]</td></tr></tbody></table><table><thead><tr><th>列指针解引用</th><th>内容等价表示</th><th>含义</th></tr></thead><tbody><tr><td>*a[0]</td><td>*(*a)</td><td>a[0][0]</td></tr><tr><td>*a[1]</td><td>*( *(a+1))</td><td>a[1][0]</td></tr></tbody></table><table><thead><tr><th>某一行的列指针</th><th>转换成：某一行的行指针</th></tr></thead><tbody><tr><td>a[0]</td><td>&amp;a[0]或&amp;a或&amp;(a+0)</td></tr><tr><td>a[1]</td><td>&amp;a[1]或&amp;(a+1)</td></tr></tbody></table><p>行指针和列指针转换试验结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列指针的定义方法</span></span><br><span class="line"><span class="type">int</span> *p; </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方法</span></span><br><span class="line"><span class="comment">//初始化：指向第一个元素：（以下三个方法等价）</span></span><br><span class="line">p=a[<span class="number">0</span>] ; p=*a ; p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//初始化：指向任意一个元素：</span></span><br><span class="line">p=a[i][j];p=a[<span class="number">2</span>][<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//目前p是列指针是吧  根据：&amp;列指针==行指针  发现只有用[]的方法表示的时候才可以实现</span></span><br><span class="line">(&amp;p)[i][j]==a[i][j];<span class="comment">//试验可行</span></span><br><span class="line">*(*(&amp;p+i)+j)==a[i][j];   *(&amp;p+i)+j==&amp;a[i][j];<span class="comment">//试验不可行</span></span><br><span class="line">*(&amp;p[i]+j)==a[i][j];     &amp;p[i]+j==&amp;a[i][j];<span class="comment">//试验可行</span></span><br><span class="line">(*(&amp;p+i))[j]==a[i][j];<span class="comment">//试验不可行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//行指针的定义</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//行指针的初始化(a为某数组)(二者任选其一即可)</span></span><br><span class="line">p=a;  p=&amp;a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前p是行指针吧  根据：*行指针==列指针  发现均可以实现</span></span><br><span class="line">*(*p+i*n+j)==a[i][j];    *p+i*n+j==&amp;a[i][j];<span class="comment">//试验可行</span></span><br><span class="line">(*p)[i*n+j]==a[i][j]; <span class="comment">//试验可行</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;指针与二维数组&lt;/p&gt;
&lt;p&gt;数组法及其变式&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="C语言程序设计" scheme="https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="C语言" scheme="https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="数组" scheme="https://xqc-1368.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="指针" scheme="https://xqc-1368.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>指向函数的指针的理解问题</title>
    <link href="https://xqc-1368.github.io/2024/08/19/%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E9%97%AE%E9%A2%98/"/>
    <id>https://xqc-1368.github.io/2024/08/19/%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-19T04:23:45.866Z</published>
    <updated>2024-08-19T03:37:28.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指向函数的指针的理解问题"><a class="markdownIt-Anchor" href="#指向函数的指针的理解问题"></a> 指向函数的指针的理解问题</h2><p>原题如下：<br /><img src="/images/2023-10-09-21-17-24-image.png" alt="" /></p><p>calculate形参中函数指针部分：应该理解为第三个参数为一个指向a function which return double and need one double 该指针叫hanshu</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">for_y1</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">for_y2</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x/(<span class="number">1</span>+x*x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">calculate</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> (*hanshu)(<span class="type">double</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> n=<span class="number">10000</span>;<span class="comment">//n为等分数</span></span><br><span class="line">    <span class="type">double</span> h=(b-a)/n;</span><br><span class="line">    <span class="type">double</span> sum=((*hanshu)(a)+(*hanshu)(b))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=(*hanshu)(a+i*h);<span class="comment">//(*hanshu)表示取hanshu指针指向的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf %lf&quot;</span>, calculate(a, b, for_y1), calculate(a, b, for_y2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;指向函数的指针的理解问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#指向函数的指针的理解问题&quot;&gt;&lt;/a&gt; 指向函数的指针的理解问题&lt;/h2&gt;
&lt;p&gt;原题如下：&lt;br /&gt;
&lt;img src=&quot;/images/2023-10-09-2</summary>
      
    
    
    
    <category term="C语言程序设计" scheme="https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="C语言" scheme="https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="指针" scheme="https://xqc-1368.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>问答形式标记法</title>
    <link href="https://xqc-1368.github.io/2024/08/19/%E9%97%AE%E7%AD%94%E5%BD%A2%E5%BC%8F%E6%A0%87%E8%AE%B0%E6%B3%95/"/>
    <id>https://xqc-1368.github.io/2024/08/19/%E9%97%AE%E7%AD%94%E5%BD%A2%E5%BC%8F%E6%A0%87%E8%AE%B0%E6%B3%95/</id>
    <published>2024-08-19T04:23:45.856Z</published>
    <updated>2024-08-19T03:07:23.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问答形式标记法"><a class="markdownIt-Anchor" href="#问答形式标记法"></a> 问答形式标记法</h2><p>如</p><h1 id="01迷宫"><a class="markdownIt-Anchor" href="#01迷宫"></a> 01迷宫</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>有一个仅由数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 组成的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 格迷宫。若你位于一格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 上，那么你可以移动到相邻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 格中的某一格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 上，同样若你位于一格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 上，那么你可以移动到相邻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 格中的某一格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 上。</p><p>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>第一行为两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>下面 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个字符，字符只可能是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，字符之间没有空格。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行两个用空格分隔的正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，对应了迷宫中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 列的一个格子，询问从这一格开始能移动到多少格。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，对于每个询问输出相应答案。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h2><p>对于样例，所有格子互相可达。</p><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">n \leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">40\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">n \leq 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">50\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">m \leq 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n,m \leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1\le n \leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1\le m \leq 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</li></ul><p>思路是因为可以把迷宫想象成若干区块构成，相同区块之间可以互通，不同区块之间不能互通。</p><p>那么找到某一个区块，用bfs的手段就可以在二维数组map中找到所有可以与他相连可以互通的区块，于是就将这些区块的数量总和标在另一个数组visited中。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> visited[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;pos;</span><br><span class="line">queue&lt;pos&gt;q;</span><br><span class="line">queue&lt;pos&gt; save;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cont</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">     sum=<span class="number">1</span>;</span><br><span class="line">    pos temp;</span><br><span class="line">    temp.x=x;</span><br><span class="line">    temp.y=y;</span><br><span class="line">     visited[x][y]=<span class="number">-1</span>;</span><br><span class="line">     q.<span class="built_in">push</span>(temp);</span><br><span class="line">     <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">int</span> tx=q.<span class="built_in">front</span>().x;</span><br><span class="line">         <span class="type">int</span> ty=q.<span class="built_in">front</span>().y;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(tx+dx[i]&gt;=<span class="number">0</span> &amp;&amp; tx+dx[i]&lt;n &amp;&amp; ty+dy[i]&gt;=<span class="number">0</span> &amp;&amp; ty+dy[i]&lt;n &amp;&amp; visited[tx+dx[i]][ty+dy[i]]==<span class="number">0</span> &amp;&amp;map[tx+dx[i]][ty+dy[i]]==<span class="number">1</span>-map[tx][ty])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[tx+dx[i]][ty+dy[i]]=<span class="number">-1</span>;</span><br><span class="line">            sum++;</span><br><span class="line">            pos temp;</span><br><span class="line">            temp.x=tx+dx[i];</span><br><span class="line">            temp.y=ty+dy[i];</span><br><span class="line">            q.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        save.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        <span class="comment">//cout&lt;&lt;tx&lt;&lt;&quot; &quot;&lt;&lt;ty&lt;&lt;endl;</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> tt=save.<span class="built_in">size</span>();<span class="comment">//把本次fs遍历过的点存到save中</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[save.<span class="built_in">front</span>().x][save.<span class="built_in">front</span>().y]=sum;</span><br><span class="line">        save.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;t;</span><br><span class="line">            map[i][j]=(<span class="type">long</span> <span class="type">long</span>)t<span class="number">-48</span>;</span><br><span class="line">         &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sx,sy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cont</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;n;i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    for(int j=0;j&lt;n;j++)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        cout&lt;&lt;visited[i][j]&lt;&lt;&quot; &quot;; </span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;sx&gt;&gt;sy;</span><br><span class="line">         cout&lt;&lt;visited[sx<span class="number">-1</span>][sy<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问答形式标记法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问答形式标记法&quot;&gt;&lt;/a&gt; 问答形式标记法&lt;/h2&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;h1 id=&quot;01迷宫&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0</summary>
      
    
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前缀和背景下的二分答案 ：平均数</title>
    <link href="https://xqc-1368.github.io/2024/08/19/%E5%89%8D%E7%BC%80%E5%92%8C%E8%83%8C%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%20%EF%BC%9A%E5%B9%B3%E5%9D%87%E6%95%B0/"/>
    <id>https://xqc-1368.github.io/2024/08/19/%E5%89%8D%E7%BC%80%E5%92%8C%E8%83%8C%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%20%EF%BC%9A%E5%B9%B3%E5%9D%87%E6%95%B0/</id>
    <published>2024-08-19T04:23:45.851Z</published>
    <updated>2024-08-19T03:07:03.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平均数"><a class="markdownIt-Anchor" href="#平均数"></a> 平均数</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的数列，我们需要找出该数列的一个子串，使得子串平均数最大化，并且子串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\ge m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>第一行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示序列第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>一个整数，表示最大平均数的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 倍，如果末尾有小数，直接舍去，不要用四舍五入求整。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 6</span><br><span class="line">6</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6500</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h2><h4 id="数据规模与约定"><a class="markdownIt-Anchor" href="#数据规模与约定"></a> 数据规模与约定</h4><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">m\le n\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq m\le n\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">0\le a_i\le2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</li></ul><p>思路：1.先找一个基准数字x；这个基准数的找寻可以使用二分。</p><p>2.求出数组中每个数字相对于这个基准数字的偏移量数组。</p><p>例如：4 -1 -2 8 -1 的数组，假设我某一轮二分答案的mid为4；</p><p>则我找到的偏移量数组为：0 -5 -6 4 -5；</p><p>3.接下来，求这个偏移量数组的前缀和数组，便于后续的求和处理；</p><p>例如：上述数组的前缀和数组为：0 -5 -11 -7 -12</p><ol start="4"><li>i 从第m位开始遍历到n（数组最后），开始求以 i 为结尾的子串的最大字串和。最大子段和可以转化为前缀和相减的形式。 设sum[i]为序列A的前i项的和 。设s[i]是序列A以A[i]结尾且长度不小于F的最大连续子段和, 那么显然有: <strong><strong>s[i] = sum[i] - min{sum[j]}(0&lt;=j&lt;=i-L)</strong></strong></li></ol><p>使用minn这个变量记录1~m位置的最小值（因为我们总希望前缀和a[ i ]减去一个尽量小的数字）。但这个过程可以不用再添加一个循环，因为我只需要在一开始，i-m还是0的时候就记录从0号位置，后续随着i 往后移动，每增加一个位置就也相当于放开了i-m号位置，这时判断i-m号位置的元素是不是比前面0<sub>i-m-1这个号码范围内的元素的最小值更小即可求出0</sub>i-m范围内的最小值。</p><p>附上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="type">double</span> a[MAXN], sum[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> presum_of_dis[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i  &lt;= n; i++)<span class="comment">//构造前缀和数组</span></span><br><span class="line">    &#123;<span class="comment">//presum_of_dis为距离基准值x的距离数组的前缀和</span></span><br><span class="line">        presum_of_dis[i] = presum_of_dis[i - <span class="number">1</span>]+(a[i]-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> minn=INF,maxn=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=m;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(minn&gt;presum_of_dis[i-m])minn=presum_of_dis[i-m];</span><br><span class="line">        <span class="keyword">if</span>(presum_of_dis[i]-minn&gt;maxn)maxn=presum_of_dis[i]-minn;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(maxn&gt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">double</span> i= <span class="number">0</span>, j = <span class="number">2000</span>,ans;</span><br><span class="line">    <span class="keyword">while</span> (i-j &lt;=<span class="number">0.0000000000001</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (i + j) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            i = mid +<span class="number">0.0000001</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = mid <span class="number">-0.0000001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="type">int</span>)(i*<span class="number">1000</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;平均数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#平均数&quot;&gt;&lt;/a&gt; 平均数&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目描述&quot;&gt;&lt;/a&gt; 题目描述&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分" scheme="https://xqc-1368.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="前缀和" scheme="https://xqc-1368.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>GIT操作的注释</title>
    <link href="https://xqc-1368.github.io/2024/08/19/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E9%87%8A/"/>
    <id>https://xqc-1368.github.io/2024/08/19/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E9%87%8A/</id>
    <published>2024-08-19T04:23:45.842Z</published>
    <updated>2024-08-19T03:06:05.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于git的操作的注释"><a class="markdownIt-Anchor" href="#关于git的操作的注释"></a> 关于git的操作的注释</h3><p>1 git问题error: remote origin already exists.</p><p><a href="https://blog.csdn.net/weixin_43916997/article/details/123645376">git问题error: remote origin already exists._git error: remote origin already exists.-CSDN博客</a></p><p>2 上传本地代码到github网站</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">添加远程库 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>但是其中的ssh协议的传输已经不能使用, 应该使用http协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于git的操作的注释&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于git的操作的注释&quot;&gt;&lt;/a&gt; 关于git的操作的注释&lt;/h3&gt;
&lt;p&gt;1 git问题error: remote origin already exists.&lt;/</summary>
      
    
    
    
    <category term="git" scheme="https://xqc-1368.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://xqc-1368.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>二分答案基础：书的复制</title>
    <link href="https://xqc-1368.github.io/2024/08/19/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%B9%A6%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>https://xqc-1368.github.io/2024/08/19/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%B9%A6%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2024-08-19T04:23:45.834Z</published>
    <updated>2024-08-19T03:37:31.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="书的复制"><a class="markdownIt-Anchor" href="#书的复制"></a> 书的复制</h1><h2 id="题目背景"><a class="markdownIt-Anchor" href="#题目背景"></a> 题目背景</h2><p>大多数人的错误原因：尽可能让前面的人少抄写，如果前几个人可以不写则不写，对应的人输出 <code>0 0</code> 。</p><p>不过，已经修改数据，保证每个人都有活可干。</p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>现在要把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 本有顺序的书分给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。</p><p>现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>第一行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</p><p>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个整数表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 本书的页数。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 行，每行两个整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 行表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个人抄写的书的起始编号和终止编号。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 行的起始编号应该从小到大排列，如果有多解，则尽可能让前面的人少抄写。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 3</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">6 7</span><br><span class="line">8 9</span><br></pre></td></tr></table></figure><h2 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">1\le k \le m \le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</p><p>无论使用二分答案还是动态规划，最后都要使用贪心，<strong>“则尽可能让前面的人少抄写。”</strong></p><p>二分答案做法（较简便）（识别使用二分答案的依据是：最大值的最小值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 505</span></span><br><span class="line"><span class="type">int</span> a[maxsize]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> m, k, sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> need=<span class="number">1</span>,temp=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=a[i])temp-=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp=x-a[i];</span><br><span class="line">            need++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(need&gt;k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=sum/k,j=sum,mid,ans;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(i+j)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            j=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> i=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp=ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    t.push_back(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= a[i])</span><br><span class="line">            temp -= a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = ans - a[i];</span><br><span class="line">            t.push_back(i+<span class="number">2</span>);</span><br><span class="line">            t.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;t[i<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp的话这是区间dp</p><p>注意：leap是累计数组，通过数组之间元素相减在可以直接得出区间元素和。</p><p>动态数组的行列定义：</p><p>i~人数k：当前拥有的人手</p><p>j<sub>m当前讨论的范围为0</sub>j</p><p>前两层循环遍历每一个格子；</p><p><img src="/images/2023-10-11-15-07-37-image.png" alt="" /></p><p>状态转移方程</p><p>f [ i ] [ j ] = minE(t from 1 to j-1)(  max{dp[i-1][t],leap[j]-leap[t] } )</p><p>上面的minE表示枚举取最小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 505</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,k,a[maxsize]=&#123;<span class="number">0</span>&#125;,leap[maxsize]=&#123;<span class="number">0</span>&#125;,dp[maxsize][maxsize]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">            leap[i] =a[i];</span><br><span class="line">        <span class="keyword">else</span> leap[i] = leap[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">1</span>][i]=leap[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], leap[j] - leap[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;j;t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(max(dp[i<span class="number">-1</span>][t],leap[j]-leap[t])&lt;dp[i][j])</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][t], leap[j] - leap[t]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> indeedmin=dp[k][m],i=m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.push_back(m);</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indeedmin-a[i]&gt;=<span class="number">0</span>)</span><br><span class="line">            indeedmin-=a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            indeedmin=dp[k][m]-a[i];</span><br><span class="line">            v.push_back(i+<span class="number">1</span>);</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=v.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v[i<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;书的复制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#书的复制&quot;&gt;&lt;/a&gt; 书的复制&lt;/h1&gt;
&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目背景&quot;&gt;&lt;/a&gt; 题目背景&lt;/h2</summary>
      
    
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分" scheme="https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"/>
    
    
    <category term="算法" scheme="https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分" scheme="https://xqc-1368.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>The conclusion of  process of debug</title>
    <link href="https://xqc-1368.github.io/2024/08/19/The%20conclusion%20of%20%20process%20of%20debug/"/>
    <id>https://xqc-1368.github.io/2024/08/19/The%20conclusion%20of%20%20process%20of%20debug/</id>
    <published>2024-08-19T04:23:45.823Z</published>
    <updated>2024-08-19T03:42:01.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="the-conclusion-of-process-of-debug"><a class="markdownIt-Anchor" href="#the-conclusion-of-process-of-debug"></a> The conclusion of  process of debug</h2><p>1.迷宫问题中如果迷宫长这样</p><p><img src="/images/2023-10-25-12-33-47-image.png" alt="" /></p><p>请把a[i][j]使用字符输入</p><p>不然一次会读入一整行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;the-conclusion-of-process-of-debug&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#the-conclusion-of-process-of-debug&quot;&gt;&lt;/a&gt; The conclusion of  </summary>
      
    
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="思想方法" scheme="https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://xqc-1368.github.io/2024/08/19/STL/"/>
    <id>https://xqc-1368.github.io/2024/08/19/STL/</id>
    <published>2024-08-19T04:23:45.808Z</published>
    <updated>2024-08-19T04:23:26.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-基本概念"><a class="markdownIt-Anchor" href="#一-基本概念"></a> 一、基本概念</h2><p>STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C<ins>中，但在被引入C</ins>之前该技术就已经存在了很长的一段时间。</p><p>STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文 件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;</span><br></pre></td></tr></table></figure><p>使用STL的好处</p><p>1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p><p>2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。</p><p>例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；</p><p>STL的sort()函数可以用来操作vector,list等容器。</p><p>3）程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p><p>4）STL具有高可重用性，高性能，高移植性，跨平台的优点。</p><ul><li>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</li><li>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</li><li>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</li><li>跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</li></ul><h2 id="二-容器"><a class="markdownIt-Anchor" href="#二-容器"></a> 二、容器</h2><h3 id="1-容器的分类"><a class="markdownIt-Anchor" href="#1-容器的分类"></a> 1 容器的分类</h3><p><strong>（1）序列式容器（Sequence containers）</strong></p><ul><li>每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。</li><li>vector、deque、list、stack、queue</li></ul><p><strong>（2）关联式容器（Associated containers）</strong></p><ul><li>元素位置取决于特定的排序准则，和插入顺序无关</li><li>set、multiset、map、multimap</li></ul><p><img src="/images/2024-08-19-12-11-30-image.png" alt="" /></p><h3 id="2-vector-容器"><a class="markdownIt-Anchor" href="#2-vector-容器"></a> 2 vector 容器</h3><p>（1） vector容器简介</p><ul><li>vector是将元素置于一个动态数组中加以管理的容器。</li><li>vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。</li><li>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时</li></ul><p>（2）vector对象的默认构造</p><p><strong>vector采用模板类实现</strong>，vector对象的默认构造形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; vecT; </span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;            <span class="comment">//一个存放int的vector容器。</span></span><br><span class="line">vector&lt;<span class="type">float</span>&gt; vecFloat;         <span class="comment">//一个存放float的vector容器。</span></span><br><span class="line">vector&lt;string&gt; vecString;       <span class="comment">//一个存放string的vector容器。</span></span><br><span class="line">...                    <span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CA</span>&#123;&#125;;</span><br><span class="line">vector&lt;CA*&gt; vecpCA;          <span class="comment">//用于存放CA对象的指针的vector容器。</span></span><br><span class="line">vector&lt;CA&gt; vecCA;         <span class="comment">//用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，</span></span><br><span class="line">                        <span class="comment">//所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。</span></span><br></pre></td></tr></table></figure><p>（3）vector对象的带参数构造</p><p>理论知识</p><ul><li>vector(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</li><li>vector(n,elem);   //构造函数将n个elem拷贝给本身。</li><li>vector(const vector &amp;vec);  //拷贝构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  iArray[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntA</span><span class="params">(iArray, iArray<span class="number">+5</span>)</span></span>;</span><br><span class="line"><span class="comment">// //用构造函数初始化容器vecIntB </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntB</span><span class="params">(vecIntA.begin() , vecIntA.end())</span></span>;  </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntB</span><span class="params">(vecIntA.begin() , vecIntA.begin()<span class="number">+3</span>)</span></span>;  </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntC</span><span class="params">(<span class="number">3</span>,<span class="number">9</span>)</span></span>; <span class="comment">//此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntD</span><span class="params">(vecIntA)</span></span>;</span><br></pre></td></tr></table></figure><p>（4）vector的赋值</p><p>理论知识</p><ul><li>vector.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</li><li>vector.assign(n,elem);  //将n个elem拷贝赋值给本身。</li><li>vector&amp; operator=(const vector  &amp;vec);    //重载等号操作符</li><li>vector.swap(vec);  // 将vec与本身的元素互换。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA, vecIntB, vecIntC, vecIntD;</span><br><span class="line"><span class="type">int</span>  iArray[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">vecIntA.<span class="built_in">assign</span>(iArray,iArray<span class="number">+5</span>);</span><br><span class="line"><span class="comment">//用其它容器的迭代器作参数。</span></span><br><span class="line">vecIntB.<span class="built_in">assign</span>(vecIntA.<span class="built_in">begin</span>(),  vecIntA.<span class="built_in">end</span>());  </span><br><span class="line">vecIntC.<span class="built_in">assign</span>(<span class="number">3</span>,<span class="number">9</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntD;</span><br><span class="line">vecIntD = vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">swap</span>(vecIntD);</span><br></pre></td></tr></table></figure><p>（5）vector的大小</p><p>理论知识</p><ul><li>vector.size();       //返回容器中元素的个数</li><li>vector.empty();       //判断容器是否为空</li><li>vector.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li>vector.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li>例如   vecInt是vector  声明的容器，现已包含1,2,3元素。<br />int iSize = vecInt.size();        //iSize == 3;<br />bool bEmpty = vecInt.empty();    // bEmpty == false;<br />执行vecInt.resize(5);  //此时里面包含1,2,3,0,0元素。<br />再执行vecInt.resize(8,3);  //此时里面包含1,2,3,0,0,3,3,3元素。<br />再执行vecInt.resize(2);  //此时里面包含1,2元素。</li></ul><p>（6）vector末尾的添加移除操作</p><ul><li>vector vecInt;</li><li>vecInt.push_back(1);  //在容器尾部加入一个元素</li><li>vecInt.push_back(3);</li><li>vecInt.push_back(5);</li><li>vecInt.push_back(7);</li><li>vecInt.push_back(9);</li><li>vecInt.pop_back();</li><li>vecInt.pop_back();</li></ul><p>（7）vector的数据存取</p><p>理论知识：</p><ul><li><a href="http://vec.at">vec.at</a>(idx);  //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</li><li>vec[idx];      //返回索引idx所指的数据，越界时，运行直接报错</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;    <span class="comment">//假设包含1 ,3 ,5 ,7 ,9</span></span><br><span class="line">vecInt.<span class="built_in">at</span>(<span class="number">2</span>) == vecInt[<span class="number">2</span>]    ;        <span class="comment">//5</span></span><br><span class="line">vecInt.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">8</span>;  或  vecInt[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">vecInt 就包含 <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>值</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iF = vector.<span class="built_in">front</span>();    <span class="comment">//iF==1</span></span><br><span class="line"><span class="type">int</span> iB = vector.<span class="built_in">back</span>();    <span class="comment">//iB==9</span></span><br><span class="line">vector.<span class="built_in">front</span>() = <span class="number">11</span>;    <span class="comment">//vecInt包含&#123;11,3,8,7,9&#125;</span></span><br><span class="line">vector.<span class="built_in">back</span>() = <span class="number">19</span>;    <span class="comment">//vecInt包含&#123;11,3,8,7,19&#125;</span></span><br></pre></td></tr></table></figure><p>（8）vector的插入</p><p>理论知识</p><ul><li>vector.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li>vector.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</li><li>vector.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值</li></ul><p>简单案例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecA;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecB;</span><br><span class="line"></span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">vecA.<span class="built_in">insert</span>(vecA.<span class="built_in">begin</span>(), <span class="number">11</span>); <span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;  pos必须是地址值 </span></span><br><span class="line">vecA.<span class="built_in">insert</span>(vecA.<span class="built_in">begin</span>()<span class="number">+1</span>,<span class="number">2</span>,<span class="number">33</span>); <span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">vecA.<span class="built_in">insert</span>(vecA.<span class="built_in">begin</span>() , vecB.<span class="built_in">begin</span>() , vecB.<span class="built_in">end</span>()); <span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure><p>9、vector的删除</p><p>理论知识</p><ul><li>vector.clear(); //移除容器的所有数据</li><li>vec.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>vec.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</li></ul><p>简单案例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除区间内的元素</span><br><span class="line">vecInt是用vector&lt;<span class="type">int</span>&gt;声明的容器，现已包含按顺序的<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>元素。</span><br><span class="line">vecInt.<span class="built_in">erase</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">begin</span>()<span class="number">+3</span>);</span><br><span class="line"><span class="comment">//删除vecInt的所有元素</span></span><br><span class="line">vecInt.<span class="built_in">clear</span>(); <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure><p>10、迭代器</p><p>1）迭代器的基本概念</p><ul><li><p>什么是迭代器：</p><ul><li>迭代器是一种检查容器内元素并且遍历容器内元素的数据类型。</li></ul></li><li><p>迭代器的作用：</p><ul><li>迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。</li></ul></li><li><p>为什么需要迭代器：</p><ul><li><p>STL提供了多种容器，每种容器的实现原理各不相同，如果没有迭代器我们需要记住每一种容器中对象的访问方法，很显然这样会变得非常麻烦。</p></li><li><p>STL提供的许多容器中都实现了一个迭代器用于对容器中对象的访问，虽然每个容器中的迭代器的实现方式不一样，但是对于用户来说操作方法是一致的，也就说通过迭代器统一了对所有容器的访问方式。例如：访问当前元素的下一个元素我们可以通过迭代器自增进行访问。</p><p><img src="/images/2024-08-19-12-11-58-image.png" alt="" /></p></li><li><p>迭代器是为了提高编程效率而开发的。</p></li></ul></li><li><p>迭代器的本质：</p><ul><li><p>迭代器是容器类中专门实现的一个访问容器中数据的内嵌类（类中类）<img src="/images/2024-08-19-12-12-08-image.png" alt="" /></p></li><li><p>为了统一每个容器中对于迭代器的操作，在容器类中会使用typedef将迭代器类进行别名定义，别名为：<strong>iterator</strong><img src="/images/2024-08-19-12-12-17-image.png" alt="" /></p></li><li><p>迭代器类对容器中元素的访问方式：指针<img src="/images/2024-08-19-12-12-28-image.png" alt="" /></p></li><li><p>迭代器类的具体实现：为了隐藏每个容器中迭代器的具体实现，也为了统一用户对于每个容器中迭代器的访问方式，用户可以把迭代器当成一个指针对容器中的元素进行访问。但是因为迭代器不是指针，因此在迭代器类中我们需要对 * 、-&gt;、前置++/–、后置++/–等操作符进行重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;&#125;</span><br><span class="line">node&lt;T&gt;*<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;&#125;</span><br><span class="line">list_iterator &amp;<span class="keyword">operator</span>++() &#123;&#125;</span><br><span class="line">list_iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> list_iterator &amp;t) <span class="type">const</span> &#123;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> list_iterator &amp;t) <span class="type">const</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>2）vector容器的迭代器</p><p>每种容器类型都定义了自己的迭代器类型，如vector：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter; <span class="comment">//变量名为iter。</span></span><br></pre></td></tr></table></figure><p>3）vector容器迭代器类中的成员函数</p><p>vector容器的迭代器属于“<strong>随机访问迭代器</strong>”：<strong>迭代器一次可以移动多个位置</strong></p><p><img src="/images/2024-08-19-12-12-39-image.png" alt="" /></p><p>4）begin和end操作</p><p>每种容器都定义了一队命名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的元素指向第一个元素。</p><p><img src="/images/2024-08-19-12-12-51-image.png" alt="" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter=v.<span class="built_in">begin</span>(); <span class="comment">//若v不为空，iter指向v[0]。</span></span><br></pre></td></tr></table></figure><p>由end返回的迭代器指向最后一个元素的下一个, 若v为空，begin和end返回的相同。</p><ul><li><strong>++iter;//使迭代器自增指向下一个元素</strong></li><li>==和!=操作符来比较两个迭代器，若两个迭代器指向同一个元素，则它们相等，否则不想等。</li></ul><p>迭代器使用举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator iter=v.<span class="built_in">begin</span>();iter!=v.<span class="built_in">end</span>();iter++)</span><br><span class="line">    *iter=<span class="number">0</span>; <span class="comment">//将vector中的元素全部赋值为0；</span></span><br></pre></td></tr></table></figure><p>5）迭代器的算术操作</p><ul><li>iter+n; //迭代器iter加上n，指在当前迭代器所在的位置i（如在vector第一个元素位置）之前加上n个元素后的位置。</li><li>iter-n;  //迭代器iter减去n，指在当前迭代器的所在位置之后减n个元素的位置</li></ul><p>5）迭代器失效</p><ul><li>插入元素导致迭代器失效</li></ul><p>我们先看这么一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);<span class="comment">//v有三个元素 1，2，3,4</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it1 = v.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line">    v.<span class="built_in">insert</span>(it1, <span class="number">8</span>);<span class="comment">//插入一个8</span></span><br><span class="line">    cout &lt;&lt; *it1 &lt;&lt; endl;<span class="comment">//输出it位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面这段代码，我们会发现输出的结果并不是8，甚至有可能会导致程序崩溃。这是为什么呢？</p><p><strong>因为在insert时，vector可能需要进行扩容，而扩容的本质是new一块新的空间，再将数据迁移过去。而我们知道，迭代器的内部是通过指针访问容器中的元素的，而插入后，若vector扩容，则原有的数据被释放，指向原有数据的迭代器就成了野指针，所以迭代器失效了。</strong></p><p>而解决的办法很简单，insert函数提供了返回值，这个返回值是指向插入之后的val的迭代器。我们只需要保存返回的迭代器，并使用这个新的迭代器即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);<span class="comment">//v有三个元素 1，2，3,4</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it1 = v.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    it1 = v.<span class="built_in">insert</span>(it1, <span class="number">8</span>);<span class="comment">//插入一个8</span></span><br><span class="line">    cout &lt;&lt; *it1 &lt;&lt; endl;<span class="comment">//输出it位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除元素导致迭代器失效</li></ul><p>我们先看这们一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; cont =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();iter++)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span> (*iter == <span class="number">3</span>)</span><br><span class="line">           cont.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于序列式容器(如vector,deque)，序列式容器就是数组式容器，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。所以不能使用erase(iter++)的方式，还好erase方法可以返回下一个有效的iterator。</p><p>解决办法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; cont =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span> (*iter == <span class="number">3</span>)</span><br><span class="line">           iter = cont.<span class="built_in">erase</span>(iter);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           iter++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1023-deque容器"><a class="markdownIt-Anchor" href="#1023-deque容器"></a> 10.2.3 deque容器</h3><p>deque简介：</p><ul><li>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。</li><li>deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</li><li>deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，</li><li>deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。</li></ul><p>deque与vector在操作上几乎一样，deque多两个函数：</p><ul><li>deque.push_front(elem); //在容器头部插入一个数据</li><li>deque.pop_front(); //删除容器第一个数据</li></ul><h3 id="1024-list容器"><a class="markdownIt-Anchor" href="#1024-list容器"></a> 10.2.4 list容器</h3><p>1、list简介</p><ul><li>list是一个<strong>双向链表容器</strong>，可高效地进行插入删除元素。</li><li>list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok)    it+5(err)</li></ul><p>2、list对象的默认构造</p><p>list采用模板类实现,对象的默认构造形式：list <type> lst 如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;            <span class="comment">//定义一个存放int的list容器。</span></span><br><span class="line">list&lt;<span class="type">float</span>&gt; lstFloat;     <span class="comment">//定义一个存放float的list容器。</span></span><br><span class="line">list&lt;string&gt; lstString;     <span class="comment">//定义一个存放string的list容器。</span></span><br></pre></td></tr></table></figure><p>3、list头尾的添加移除操作</p><ul><li>list.push_back(elem);    //在容器尾部加入一个元素</li><li>list.pop_back();              //删除容器中最后一个元素</li><li>list.push_front(elem);     //在容器开头插入一个元素</li><li>list.pop_front();              //从容器开头移除第一个元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><p>4、list的数据存取</p><ul><li>list.front();   //返回第一个元素。</li><li>list.back();  //返回最后一个元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> iFront = lstInt.<span class="built_in">front</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> iBack = lstInt.<span class="built_in">back</span>(); <span class="comment">//9</span></span><br><span class="line">lstInt.<span class="built_in">front</span>() = <span class="number">11</span>; <span class="comment">//11</span></span><br><span class="line">lstInt.<span class="built_in">back</span>() = <span class="number">19</span>; <span class="comment">//19</span></span><br></pre></td></tr></table></figure><p>5、list与迭代器</p><p>list 容器的迭代器是“双向迭代器”：双向迭代器从两个方向读写容器。除了提供前向迭代器的全部操作之外，双向迭代器还提供前置和后置的自减运算</p><ul><li>list.begin();                     //返回容器中第一个元素的迭代器。</li><li>list.end();                       //返回容器中最后一个元素之后的迭代器。</li><li>list.rbegin();         //返回容器中倒数第一个元素的迭代器。</li><li>list.rend();         //返回容器中倒数最后一个元素的后面的迭代器。</li></ul><p><img src="/images/2024-08-19-12-13-07-image.png" alt="" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::iterator it=lstInt.<span class="built_in">begin</span>(); it!=lstInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::reverse_iterator rit=lstInt.<span class="built_in">rbegin</span>(); rit!=lstInt.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *rit;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、list对象的带参数构造</p><ul><li></li><li>list(n,elem);   //构造函数将n个elem拷贝给本身。</li><li>list(beg,end);   //构造函数将[beg,end]区间中的元素拷贝给本身</li><li>list(const list &amp;lst);  //拷贝构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lstIntB</span><span class="params">(lstIntA.begin(),lstIntA.end())</span></span>; <span class="comment">//1 3 5 7 9</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lstIntC</span><span class="params">(<span class="number">5</span>,<span class="number">8</span>)</span></span>; <span class="comment">//8 8 8 8 8</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lstIntD</span><span class="params">(lstIntA)</span></span>; <span class="comment">//1 3 5 7 9</span></span><br></pre></td></tr></table></figure><p>7、list的赋值</p><ul><li>list.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</li><li>list.assign(n,elem);  //将n个elem拷贝赋值给本身。</li><li>list&amp; operator=(const list &amp;lst); //重载等号操作符</li><li>list.swap(lst);  // 将lst与本身的元素互换。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstIntA,lstIntB,lstIntC,lstIntD;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">lstIntB.<span class="built_in">assign</span>(lstIntA.<span class="built_in">begin</span>(),lstIntA.<span class="built_in">end</span>()); <span class="comment">//1 3 5 7 9</span></span><br><span class="line">lstIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>); <span class="comment">//8 8 8 8 8</span></span><br><span class="line">lstIntD = lstIntA; <span class="comment">//1 3 5 7 9</span></span><br><span class="line">lstIntC.<span class="built_in">swap</span>(lstIntD); <span class="comment">//互换</span></span><br></pre></td></tr></table></figure><p>8、list的大小</p><ul><li>list.size();    //返回容器中元素的个数</li><li>list.empty();    //判断容器是否为空</li><li>list.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li>list.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!lstIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = lstIntA.<span class="built_in">size</span>(); <span class="comment">//3</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">5</span>); <span class="comment">//1 3 5 0 0</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="comment">//1 3 5 0 0 1 1</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">2</span>); <span class="comment">//1 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、list的插入</p><ul><li><p>list.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p>list.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。</p></li><li><p>list.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstA;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lstB;</span><br><span class="line"> </span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>(), <span class="number">11</span>); <span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(++lstA.<span class="built_in">begin</span>(),<span class="number">2</span>,<span class="number">33</span>); <span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>() , lstB.<span class="built_in">begin</span>() , lstB.<span class="built_in">end</span>() ); <span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>10、list的删除</p><ul><li>list.clear(); //移除容器的所有数据</li><li>list.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>list.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。</li><li>lst.remove(elem);   //删除容器中所有与elem值匹配的元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;::iterator itBegin=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++itBegin;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator itEnd=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++itEnd;</span><br><span class="line">++itEnd;</span><br><span class="line">++itEnd;</span><br><span class="line">lstInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器lstInt包含按顺序的1,6,9三个元素。</span></span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">remove</span>(<span class="number">3</span>); <span class="comment">//将list中所有的3删除</span></span><br><span class="line">lstA.<span class="built_in">clear</span>();<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure><p>11、list的反序排列</p><ul><li>lst.reverse();     //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstA;</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">lstA.<span class="built_in">reverse</span>(); <span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure><p>12、list迭代器失效</p><ul><li>删除结点导致迭代器失效</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::iterator it=lstInt.<span class="built_in">being</span>(); it!=lstInt.<span class="built_in">end</span>(); )    <span class="comment">//小括号里不需写  ++it</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*it == <span class="number">3</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       lstInt.<span class="built_in">erase</span>(it);  <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="附加部分c-stl-prev和next函数"><a class="markdownIt-Anchor" href="#附加部分c-stl-prev和next函数"></a> 附加部分：C++ STL prev()和next()函数</h1><p>1 advance() 函数移动的是源迭代器</p><p>2 prev()函数</p><p>3 next()函数</p><h3 id="1-advance-函数移动的是源迭代器"><a class="markdownIt-Anchor" href="#1-advance-函数移动的是源迭代器"></a> 1 advance() 函数移动的是源迭代器</h3><pre><code>    但值得一提的是，advance() 函数移动的是源迭代器，举个例子：</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// std::advance</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 vector 容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">//it为随机访问迭代器，其指向 myvector 容器中第一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::iterator it = myvector.begin();</span><br><span class="line"><span class="comment">//输出 it 迭代器指向的数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;移动前的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//借助 advance() 函数将 it 迭代器前进 2 个位置</span></span><br><span class="line">advance(it, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;移动后的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/2024-08-19-12-13-19-image.png" alt="" /></p><p>通过程序的运行结果不难看出，advance() 函数没有任何返回值，其移动的是 it 迭代器本身。</p><p>这就产生一个问题，若我们不想移动 it 迭代器本身，而仅仅是想在 it 迭代器的基础上，得到一个移动指定位置的新迭代器，显然 advance() 函数是不合适的，这时就可以使用</p><h3 id="2-prev函数"><a class="markdownIt-Anchor" href="#2-prev函数"></a> 2 prev()函数</h3><p>prev 原意为“上一个”，但 prev() 的功能远比它的本意大得多，该函数可用来获取一个距离指定迭代器 n 个元素的迭代器。</p><p>prev() 函数的语法格式如下：</p><p>template <class BidirectionalIterator><br />BidirectionalIterator prev (BidirectionalIterator it, typename iterator_traits<BidirectionalIterator>::difference_type n = 1);</p><p>其中，it 为源迭代器，其类型只能为双向迭代器或者随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 1。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。</p><p>注意，当 n 为正数时，其返回的迭代器将位于 it 左侧；反之，当 n 为负数时，其返回的迭代器位于 it 右侧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// next</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> <span class="comment">// list</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并初始化一个 list 容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="type">int</span>&gt;::iterator it = mylist.end();</span><br><span class="line"><span class="comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 左侧</span></span><br><span class="line"><span class="keyword">auto</span> newit = prev(it, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;prev(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n为负数，newit 位于 it 右侧</span></span><br><span class="line">it = mylist.begin();</span><br><span class="line">newit = prev(it, <span class="number">-2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;prev(it, -2) = &quot;</span> &lt;&lt; *newit;</span><br></pre></td></tr></table></figure><p><img src="/images/2024-08-19-12-13-28-image.png" alt="" /></p><p>可以看到，当 it 指向 mylist 容器最后一个元素之后的位置时，通过 prev(it, 2) 可以获得一个新迭代器 newit，其指向的是距离 it 左侧 2 个元素的位置（其存储的是元素 4）；当 it 指向 mylist 容器中首个元素时，通过 prev(it, -2) 可以获得一个指向距离 it 右侧 2 个位置处的新迭代器。</p><h3 id="3-next函数"><a class="markdownIt-Anchor" href="#3-next函数"></a> 3 next()函数</h3><p>和 prev 相反，next 原意为“下一个”，但其功能和 prev() 函数类似，即用来获取一个距离指定迭代器 n 个元素的迭代器。</p><p>next() 函数的语法格式如下：</p><p>template <class ForwardIterator><br />ForwardIterator next (ForwardIterator it, typename iterator_traits<ForwardIterator>::difference_type n = 1);</p><p>其中 it 为源迭代器，其类似可以为前向迭代器、双向迭代器以及随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 1。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。</p><p>需要注意的是，当 it 为前向迭代器时，n 只能为正数，该函数最终得到的新迭代器位于 it 右侧；当 it 为双向迭代器或者随机访问迭代器时，若 n 为正数，则得到的新迭代器位于 it 右侧，反之位于 it 左侧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span> <span class="comment">// std::next</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> <span class="comment">// std::list</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并初始化一个 list 容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="type">int</span>&gt;::iterator it = mylist.begin();</span><br><span class="line"><span class="comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 右侧</span></span><br><span class="line"><span class="keyword">auto</span> newit = next(it, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;next(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n为负数，newit 位于 it 左侧</span></span><br><span class="line">it = mylist.end();</span><br><span class="line">newit = next(it, <span class="number">-2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;next(it, -2) = &quot;</span> &lt;&lt; *newit;</span><br></pre></td></tr></table></figure><p>可以看到，和 prev() 函数恰好相反，当 n 值为 2 时，next(it, 2) 函数获得的新迭代器位于 it 迭代器的右侧，距离 2 个元素；反之，当 n 值为 -2 时，新迭代器位于 it 迭代器的左侧，距离 2 个元素。</p><p>注意，和 prev() 函数一样，next() 函数自身也不会检查新迭代器指向的有效性，需要我们自己来保证。</p><h3 id="1025-stack容器"><a class="markdownIt-Anchor" href="#1025-stack容器"></a> 10.2.5 stack容器</h3><p>1、Stack简介</p><ul><li>stack是堆栈容器，是一种“先进后出”的容器。</li><li>stack是简单地装饰deque容器而成为另外的一种容器。</li></ul><p>2、stack对象的默认构造</p><p>stack采用模板类实现， stack对象的默认构造形式：stack <type> s;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack &lt;<span class="type">int</span>&gt; stkInt;            <span class="comment">//一个存放int的stack容器。</span></span><br><span class="line">stack &lt;<span class="type">float</span>&gt; stkFloat;     <span class="comment">//一个存放float的stack容器。</span></span><br><span class="line">stack &lt;string&gt; stkString;     <span class="comment">//一个存放string的stack容器。</span></span><br><span class="line">...   </span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure><p>3、stack的push()与pop()方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack.<span class="built_in">push</span>(elem);   <span class="comment">//往栈头添加元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>();   <span class="comment">//从栈头移除第一个元素</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkInt;  </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">1</span>);stkInt.<span class="built_in">push</span>(<span class="number">3</span>);stkInt.<span class="built_in">pop</span>();   </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">5</span>);stkInt.<span class="built_in">push</span>(<span class="number">7</span>);  </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">9</span>);stkInt.<span class="built_in">pop</span>();   </span><br><span class="line">stkInt.<span class="built_in">pop</span>();  </span><br><span class="line"><span class="comment">//此时stkInt存放的元素是1,5  </span></span><br></pre></td></tr></table></figure><p>4、 stack对象的拷贝构造与赋值</p><ul><li>stack(const stack &amp;stk);      //拷贝构造函数</li><li>stack&amp; operator=(const stack &amp;stk); //重载等号操作符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stkIntB</span><span class="params">(stkIntA)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntC;</span><br><span class="line">stkIntC = stkIntA; <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p>5、 stack的数据存取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack.<span class="built_in">top</span>();   <span class="comment">//返回最后一个压入栈元素</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iTop = stkIntA.<span class="built_in">top</span>(); <span class="comment">//9</span></span><br><span class="line">stkIntA.<span class="built_in">top</span>() = <span class="number">19</span>; <span class="comment">//19</span></span><br></pre></td></tr></table></figure><p>6、stack的大小</p><ul><li>stack.empty();   //判断堆栈是否为空</li><li>stack.size();      //返回堆栈的大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!stkIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = stkIntA.<span class="built_in">size</span>(); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1026-queue-容器"><a class="markdownIt-Anchor" href="#1026-queue-容器"></a> 10.2.6 queue 容器</h3><p>1、Queue简介</p><ul><li>queue是队列容器，是一种“先进先出”的容器。</li></ul><p>2、queue对象的默认构造</p><p>queue采用模板类实现，queue对象的默认构造形式：queue <type>q;  如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queInt;            <span class="comment">//一个存放int的queue容器。</span></span><br><span class="line">queue&lt;<span class="type">float</span>&gt; queFloat;     <span class="comment">//一个存放float的queue容器。</span></span><br><span class="line">queue&lt;string&gt; queString;     <span class="comment">//一个存放string的queue容器。</span></span><br><span class="line">...     </span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure><p>3、queue的push()与pop()方法</p><ul><li>queue.push(elem);   //往队尾添加元素</li><li>queue.pop();   //从队头移除第一个元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queInt;</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">1</span>);queInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">5</span>);queInt.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">9</span>);queInt.<span class="built_in">pop</span>();</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br><span class="line">此时queInt存放的元素是<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span></span><br></pre></td></tr></table></figure><p>4、queue对象的拷贝构造与赋值</p><ul><li>queue(const queue &amp;que);      //拷贝构造函数</li><li>queue&amp; operator=(const queue &amp;que); //重载等号操作符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">queIntB</span><span class="params">(queIntA)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; queIntC;</span><br><span class="line">queIntC = queIntA; <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><p>5、queue的数据存取</p><ul><li>queue.back();   //返回最后一个元素</li><li>queue.front();   //返回第一个元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> iFront = queIntA.<span class="built_in">front</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> iBack = queIntA.<span class="built_in">back</span>(); <span class="comment">//9</span></span><br><span class="line"> </span><br><span class="line">queIntA.<span class="built_in">front</span>() = <span class="number">11</span>; <span class="comment">//11</span></span><br><span class="line">queIntA.<span class="built_in">back</span>() = <span class="number">19</span>; <span class="comment">//19</span></span><br></pre></td></tr></table></figure><p>6、queue的大小</p><ul><li>queue.empty();   //判断队列是否为空</li><li>queue.size();      //返回队列的大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queIntA; </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);   </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);  </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!queIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = queIntA.<span class="built_in">size</span>(); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1027-set和multiset容器"><a class="markdownIt-Anchor" href="#1027-set和multiset容器"></a> 10.2.7 Set和multiset容器</h3><p>1、set/multiset的简介</p><ul><li>set是一个集合容器，其中所包含的<strong>元素是唯一的</strong>，集合中的<strong>元素按一定的顺序排列</strong>。元素插入过程是按排序规则插入，所以不能指定插入位置。</li><li><strong>set采用红黑树变体的数据结构实现</strong>，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</li><li>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</li><li>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。</li><li>不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</li><li><pre class="highlight"><code class="">#include &lt;set&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2、set/multiset对象的默认构造</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">set&lt;int&gt; setInt;            //一个存放int的set容器。</span><br><span class="line">set&lt;float&gt; setFloat;     //一个存放float的set容器。</span><br><span class="line">set&lt;string&gt; setString;     //一个存放string的set容器。</span><br><span class="line">multiset&lt;int&gt; mulsetInt;            //一个存放int的multi set容器。</span><br><span class="line">multi set&lt;float&gt; multisetFloat;     //一个存放float的multi set容器。</span><br><span class="line">multi set&lt;string&gt; multisetString;     //一个存放string的multi set容器。</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>3、set对象的拷贝构造与赋值</p><ul><li>set(const set &amp;st);      //拷贝构造函数</li><li>set&amp; operator=(const set &amp;st); //重载等号操作符</li><li>set.swap(st); //交换两个集合容器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">setIntB</span><span class="params">(setIntA)</span></span>;  <span class="comment">//1 3 5 7 9</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; setIntC;</span><br><span class="line">setIntC = setIntA; <span class="comment">//1 3 5 7 9</span></span><br><span class="line"> </span><br><span class="line">setIntC.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">setIntC.<span class="built_in">swap</span>(setIntA);   <span class="comment">//交换</span></span><br></pre></td></tr></table></figure><p>4、set的大小</p><ul><li>set.size(); //返回容器中元素的数目</li><li>set.empty();//判断容器是否为空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!setIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = setIntA.<span class="built_in">size</span>(); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、set的插入与迭代器</p><ul><li>set.insert(elem);     //在容器中插入元素。</li><li>set.begin();  //返回容器中第一个数据的迭代器。</li><li>set.end();  //返回容器中最后一个数据之后的迭代器。</li><li>set.rbegin();  //返回容器中倒数第一个元素的迭代器。</li><li>set.rend();   //返回容器中倒数最后一个元素的后面的迭代器。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>); </span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it=setInt.<span class="built_in">begin</span>(); it!=setInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> iItem = *it;</span><br><span class="line">      cout &lt;&lt; iItem;    <span class="comment">//或直接使用cout &lt;&lt; *it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便顺序输出  1 2 3 5。 </span></span><br></pre></td></tr></table></figure><p>5、set的删除</p><ul><li>set.clear(); //清除所有元素</li><li>set.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>set.erase(beg,end);     //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>set.erase(elem);     //删除容器中值为elem的元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">删除区间内的元素</span><br><span class="line">setInt是用set&lt;<span class="type">int</span>&gt;声明的容器，现已包含按顺序的<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>元素。</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itBegin=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++itBegin;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itEnd=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++itEnd;</span><br><span class="line">++itEnd;</span><br><span class="line">++itEnd;</span><br><span class="line">setInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器setInt包含按顺序的1,6,9,11四个元素。</span></span><br><span class="line"> </span><br><span class="line">删除容器中第一个元素</span><br><span class="line">setInt.<span class="built_in">erase</span>(setInt.<span class="built_in">begin</span>()); <span class="comment">//6,9,11</span></span><br><span class="line"> </span><br><span class="line">删除容器中值为<span class="number">9</span>的元素</span><br><span class="line">set.<span class="built_in">erase</span>(<span class="number">9</span>);    </span><br><span class="line"> </span><br><span class="line">删除setInt的所有元素</span><br><span class="line">setInt.<span class="built_in">clear</span>(); <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure><p>6、set集合的元素排序</p><p><img src="/images/2024-08-19-12-13-43-image.png" alt="" /></p><ul><li>要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。</li><li>下面将讲解什么是functor，functor的用法。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt; setIntB;   </span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">此时容器setIntB就包含了按顺序的<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>元素</span><br></pre></td></tr></table></figure><p>函数对象functor的用法</p><ul><li>尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</li><li>functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</li><li>greater&lt;&gt;与less&lt;&gt;就是函数对象。</li></ul><p>下面举出greater的简易实现原理:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class greater</span><br><span class="line">&#123;</span><br><span class="line">    bool operator() (const int&amp; iLeft, const int&amp; iRight)</span><br><span class="line">    &#123;</span><br><span class="line">           return (iLeft&gt;iRight);    //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容器就是调用函数对象的operator()方法去比较两个值的大小。</strong></p><p>思考：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CStudent</span>(<span class="type">int</span> iID, string strName)</span><br><span class="line">    &#123;</span><br><span class="line">          m_iID = iID;</span><br><span class="line">          m_strName = strName;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> m_iID; <span class="comment">//学号</span></span><br><span class="line">     string m_strName; <span class="comment">//姓名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本类不写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StuFunctor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span>  <span class="params">(<span class="type">const</span> CStudent &amp;stu1, <span class="type">const</span> CStudent &amp;stu2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (stu<span class="number">1.</span>m_iID&lt;stu<span class="number">2.</span>m_iID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   set&lt;CStudent, StuFunctor&gt; setStu;</span><br><span class="line">   setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">   setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>));</span><br><span class="line">   setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line">   setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">2</span>,<span class="string">&quot;小刘&quot;</span>));</span><br><span class="line">   <span class="comment">//此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、set的查找</p><ul><li>set.find(elem);   //查找elem元素，返回指向elem元素的迭代器。</li><li>set.count(elem);   //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</li><li>set.lower_bound(elem);  //返回第一个 &gt;=elem元素的迭代器。</li><li>set.upper_bound(elem);    //  返回第一个&gt;elem元素的迭代器。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itA = setInt.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> iA = *itA; <span class="comment">//iA == 5</span></span><br><span class="line"><span class="type">int</span> iCount = setInt.<span class="built_in">count</span>(<span class="number">5</span>); <span class="comment">//iCount == 1</span></span><br><span class="line"> </span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itB = setInt.<span class="built_in">lower_bound</span>(<span class="number">5</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itC = setInt.<span class="built_in">upper_bound</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> iB = *itB; <span class="comment">//iB == 5</span></span><br><span class="line"><span class="type">int</span> iC = *itC; <span class="comment">//iC == 7</span></span><br></pre></td></tr></table></figure><ul><li>set.equal_range(elem); //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。<ul><li>函数返回两个迭代器，而这两个迭代器被封装在pair中。</li><li><pre class="highlight"><code class="cpp">pair&lt; set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator &gt; pairIt = setInt.<span class="built_in">equal_range</span>(<span class="number">5</span>);  <span class="comment">//pair是什么？</span>&lt;!--code￼<span class="number">48</span>--&gt;</code></pre></li></ul></li></ul><h3 id="1028-map和multimap容器"><a class="markdownIt-Anchor" href="#1028-map和multimap容器"></a> 10.2.8 map和multimap容器</h3><p>1、map/multimap的简介</p><ul><li>map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</li><li>map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</li><li>map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。</li><li>map可以直接存取key所对应的value，支持[]操作符，如map[key]=value(将key键所对应的值修改为value)</li><li>multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</li></ul><p>2、map/multimap对象的默认构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map/multimap采用模板类实现，对象的默认构造形式：</span></span><br><span class="line">map&lt;T1,T2&gt; mapTT;</span><br><span class="line">multimap&lt;T1,T2&gt;  multimapTT;  </span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">char</span>&gt; mapA;</span><br><span class="line">map&lt;string,<span class="type">float</span>&gt; mapB;</span><br><span class="line"><span class="comment">//其中T1,T2还可以用各种指针类型或自定义类型</span></span><br></pre></td></tr></table></figure><p>3、map的插入与迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>(...);    <span class="comment">//往容器插入元素，返回pair</span></span><br></pre></td></tr></table></figure><p>在map中插入元素的三种方式：</p><p>假设  map mapStu;</p><p>一、通过pair的方式插入对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStu.<span class="built_in">insert</span>(<span class="built_in">pair</span>(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>) );</span><br></pre></td></tr></table></figure><p>二、通过value_type的方式插入对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStu.<span class="built_in">insert</span>(  map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>)  );</span><br></pre></td></tr></table></figure><p>三、通过数组的方式插入值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapStu[<span class="number">3</span>] = “小刘<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mapStu[5] = “小王&quot;</span>；</span><br></pre></td></tr></table></figure><p>前两种方法，采用的是insert()方法，该方法返回值为pair</p><p><strong>第三种方法</strong>非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为“小刘”的键值对插入到map中。若发现已存在3这个键，则修改这个键对应的value为“小刘”。</p><p><em><strong><u>如果键存在则修改，如果不存在则插入</u></strong></em></p><p>string strName = mapStu[2];   //取操作或插入操作</p><p>只有当mapStu存在2这个键时才是正确的取操作，<strong>否则会自动插入一个实例，键为2，值为初始化值。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapA;</span><br><span class="line">pair&lt;map&lt;<span class="type">int</span>,string&gt;::iterator, <span class="type">bool</span>&gt; pairResult = </span><br><span class="line">                        mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>)); <span class="comment">//插入方式一</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> iFirstFirst = (pairResult.first)-&gt;first; <span class="comment">//iFirst == 3;</span></span><br><span class="line">string strFirstSecond = (pairResult.first)-&gt;second; <span class="comment">//strFirstSecond为&quot;小张&quot;</span></span><br><span class="line"><span class="type">bool</span> bSecond = pairResult.second; <span class="comment">//bSecond == true;</span></span><br><span class="line">mapA.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>)); <span class="comment">//插入方式二</span></span><br><span class="line">mapA[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>; <span class="comment">//修改value</span></span><br><span class="line">mapA[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>; <span class="comment">//插入方式三</span></span><br><span class="line"> </span><br><span class="line">string str1 = mapA[<span class="number">2</span>]; <span class="comment">//执行插入 string() 操作，返回的str1的字符串内容为空。</span></span><br><span class="line">string str2 = mapA[<span class="number">3</span>]; <span class="comment">//取得value，str2为&quot;小刘&quot;</span></span><br></pre></td></tr></table></figure><p>使用迭代器遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>,string&gt;::iterator it=mapA.<span class="built_in">begin</span>(); it!=mapA.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; pr = *it;</span><br><span class="line">    <span class="type">int</span> iKey = pr.first;</span><br><span class="line">    string strValue = pr.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、map容器或者键所对应的值</p><p>方法一：使用[]</p><p>方法二：使用find()函数：成功返回对应的迭代器，失败返回end()的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, string&gt;::iterator it = mapS.find(3);</span><br></pre></td></tr></table></figure><p>方法三：使用at()函数，如果键值对不存在会抛出“out_of_range 异常”</p><p>5、map对象的拷贝构造与赋值</p><ul><li>map(const map &amp;mp);      //拷贝构造函数</li><li>map&amp; operator=(const map &amp;mp); //重载等号操作符</li><li>map.swap(mp); //交换两个集合容器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="function">map&lt;<span class="type">int</span> ,string&gt; <span class="title">mapB</span><span class="params">(mapA)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapC;</span><br><span class="line">mapC = mapA; <span class="comment">//赋值</span></span><br><span class="line"> </span><br><span class="line">mapC[<span class="number">3</span>] = <span class="string">&quot;老张&quot;</span>;</span><br><span class="line">mapC.<span class="built_in">swap</span>(mapA); <span class="comment">//交换</span></span><br></pre></td></tr></table></figure><p>6、map的大小</p><ul><li>map.size(); //返回容器中元素的数目</li><li>map.empty();//判断容器是否为空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (mapA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = mapA.<span class="built_in">size</span>(); <span class="comment">//iSize == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、map的删除</p><ul><li>map.clear(); //删除所有元素</li><li>map.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>map.erase(beg,end);     //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>map.erase(keyElem);     //删除容器中key为keyElem的对组。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br></pre></td></tr></table></figure><p>删除区间内的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator itBegin=mapA.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">++ itBegin;</span><br><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator itEnd=mapA.<span class="built_in">end</span>();</span><br><span class="line">mapA.<span class="built_in">erase</span>(itBegin,itEnd); <span class="comment">//此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。</span></span><br><span class="line"> </span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br></pre></td></tr></table></figure><p>删除容器中指定 的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapA.erase(5);    </span><br></pre></td></tr></table></figure><p>删除容器中指定位置的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapA.erase(mapA.begin());</span><br></pre></td></tr></table></figure><p>8、map的查找</p><ul><li>map.find(key);   查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</li><li>map.count(keyElem);   //返回容器中key为keyElem的对组个数。</li><li>map.lower_bound(elem);  //返回第一个&gt;=elem元素的迭代器。</li><li>map.upper_bound(elem);    //  返回第一个&gt;elem元素的迭代器。</li><li>map.equal_range(elem); //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator it=mapStu.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span>(it == mapStu.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找到了</span></span><br><span class="line">        pair&lt;<span class="type">int</span>, string&gt; pairStu = *it;</span><br><span class="line">       <span class="type">int</span> iID = pairStu.first; <span class="comment">//或   int  iID = it-&gt;first;</span></span><br><span class="line">        string strName = pairStu.second; <span class="comment">//或   string strName = it-&gt;second;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1029-总结"><a class="markdownIt-Anchor" href="#1029-总结"></a> 10.2.9 总结</h3><p>特点对比：</p><p><img src="/images/2024-08-19-12-14-02-image.png" alt="" /></p><p>底层实现：</p><p><img src="/images/2024-08-19-12-14-12-image.png" alt="" /></p><h2 id="103-算法"><a class="markdownIt-Anchor" href="#103-算法"></a> 10.3 算法</h2><h3 id="1031-排序算法"><a class="markdownIt-Anchor" href="#1031-排序算法"></a> 10.3.1 排序算法</h3><h4 id="10311-sort-排序函数"><a class="markdownIt-Anchor" href="#10311-sort-排序函数"></a> 10.3.1.1 sort() 排序函数</h4><ul><li><strong>sort() 函数是基于快速排序实现的</strong></li><li>sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：<ul><li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，<strong>sort() 只对 vector、deque 这 2个容器提供支持</strong></li><li>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持&lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符</li><li>sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须拷贝构造函数和赋值运算符的重载。</li><li><strong>sort() 排序是不稳定的</strong></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式实现自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式实现自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">myvector</span><span class="params">(a, a<span class="number">+8</span>)</span></span>;</span><br><span class="line">    <span class="comment">//调用第一种语法格式，对 32、71、12、45 进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>); <span class="comment">//(12 32 45 71) 26 80 53 33</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//(71 45 32 12) 26 80 53 33</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用第二种语法格式，通过自定义比较规则进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());<span class="comment">//12 26 32 33 45 53 71 80</span></span><br><span class="line">    <span class="comment">//输出 myvector 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10312-stable_sort排序算法"><a class="markdownIt-Anchor" href="#10312-stable_sort排序算法"></a> 10.3.1.2 stable_sort()排序算法</h4><ul><li><strong>stable_sort() 函数是基于归并排序实现的</strong></li><li><strong>stable_sort() 是稳定的排序算法</strong></li><li>stable_sort()函数与sort()函数的使用方法相同。</li></ul><h4 id="10313-partial_sort排序函数"><a class="markdownIt-Anchor" href="#10313-partial_sort排序函数"></a> 10.3.1.3 partial_sort()排序函数</h4><p>1、引入</p><ul><li><p><strong>假设这样一种情境，有一个存有 100 万个元素的容器，但我们只想从中提取出值最小的 10 个元素，该如何实现呢？</strong></p><ul><li>通过前面的学习，可能会想到使用 sort() 或者 stable_sort() 排序函数，即通过对容器中存储的 100 万个元素进行排序，就可以成功筛选出最小的 10 个元素。但仅仅为了提取 10 个元素，却要先对 100 万个元素进行排序，可想而知这种实现方式的效率是非常低的。</li><li>对于解决类似的问题，C++ STL 标准库提供了更高效的解决方案，使用 partial_sort()。</li></ul></li><li><p>partial sort 可直译为“部分排序”，该函数可以从指定区域中提取出部分数据，并对它们进行排序。</p></li></ul><p>2、语法格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照默认的升序排序规则，对 [first, last) 范围的数据进行筛选并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//按照 comp 排序规则，对 [first, last) 范围的数据进行筛选并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                   Compare comp)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中，first、middle 和 last 都是随机访问迭代器，comp 参数用于自定义排序规则。</span></span><br><span class="line"><span class="comment">partial_sort() 函数会以交换元素存储位置的方式实现部分排序的。</span></span><br><span class="line"><span class="comment">具体来说，partial_sort() 会将 [first, last) 范围内最小（或最大）的 middle-first 个元素移动到 </span></span><br><span class="line"><span class="comment">[first, middle) 区域中，并对这部分元素做升序（或降序）排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>需要注意的是，partial_sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 partial_sort() 函数：</p><ul><li>partial_sort() 函数只适用于 array、vector、deque 这 3 个容器。</li><li>当选用默认的升序排序规则时，容器中存储的元素类型必须支持 &lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li><li>partial_sort() 函数在实现过程中，需要交换某些元素的存储位置。因此，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::partial_sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//以默认的升序排序作为排序规则，将 myvector 中最小的 4 个元素移动到开头位置并排好序</span></span><br><span class="line">    <span class="built_in">partial_sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, myvector.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次排序:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n第二次排序:\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 以指定的 mycomp2 作为排序规则，将 myvector 中最大的 4 个元素移动到开头位置并排好序</span></span><br><span class="line">    <span class="built_in">partial_sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p><img src="/images/2024-08-19-12-14-23-image.png" alt="" /></p><h4 id="10314-merge函数"><a class="markdownIt-Anchor" href="#10314-merge函数"></a> 10.3.1.4 merge()函数</h4><p>功能：将两个<strong>已经排好序</strong>的序列合并为一个有序的序列</p><p>默认排序规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以默认的升序排序作为排序规则</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                      InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                      OutputIterator result)</span></span>;</span><br><span class="line"><span class="comment">//以自定义的 comp 规则作为排序规则</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                      InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                      OutputIterator result, Compare comp)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* firs1t为第一个容器的首迭代器，last1为第一个容器的末迭代器；</span></span><br><span class="line"><span class="comment">* first2为第二个容器的首迭代器，last2为容器的末迭代器；</span></span><br><span class="line"><span class="comment">* result为存放结果的容器，comapre为比较函数（可略写，默认为合并为一个升序序列）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>注意：使用的时候result，如果用的vector，必须先使用resize扩容</strong></p><h4 id="10315-revrese函数"><a class="markdownIt-Anchor" href="#10315-revrese函数"></a> 10.3.1.5 revrese()函数</h4><p>函数参数:reverse(first，last)</p><p>功能：反转容器</p><p>注意：</p><ul><li>string和vector和deque只能使用模板库算法里的反转函数</li><li>list可以使用算法里的和list类的reverse</li><li>stack和queue没有迭代器，自然不能使用算法里的reverse,其类也没有提供反转的成员函数</li><li>set和map的元素是按照键值排序的，不能修改键值，不可反转.</li></ul><h3 id="1032-查找算法"><a class="markdownIt-Anchor" href="#1032-查找算法"></a> 10.3.2 查找算法</h3><h4 id="10321-adjacent_find"><a class="markdownIt-Anchor" href="#10321-adjacent_find"></a> 10.3.2.1 adjacent_find()</h4><p>功能：在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>()); <span class="comment">//*it == 2</span></span><br></pre></td></tr></table></figure><h4 id="10322-binary_search"><a class="markdownIt-Anchor" href="#10322-binary_search"></a> 10.3.2.2 binary_search()</h4><p>功能：二分查找法，在有序序列中查找value,找到则返回true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bFind = <span class="built_in">binary_search</span>(setInt.<span class="built_in">begin</span>(),setInt.<span class="built_in">end</span>(),<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="10323-count"><a class="markdownIt-Anchor" href="#10323-count"></a> 10.3.2.3 count()</h4><p>功能：利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> iCount = <span class="built_in">count</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">end</span>(),<span class="number">2</span>); <span class="comment">//iCount==3</span></span><br></pre></td></tr></table></figure><h4 id="10324-find"><a class="markdownIt-Anchor" href="#10324-find"></a> 10.3.2.4 find()</h4><p>功能：find() 函数用于在指定范围内查找和目标元素值相等的第一个元素。</p><p>函数的语法格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。</p><p>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p><p>该函数会返回一个输入迭代器，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</p><p>find() 函数的底层实现，其实就是用<mark>运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持</mark>运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find() 函数作用于普通数组</span></span><br><span class="line">    <span class="type">char</span> stl[] =<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    <span class="comment">//调用 find() 查找第一个字符 &#x27;c&#x27;</span></span><br><span class="line">    <span class="type">char</span> * p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="comment">//判断是否查找成功</span></span><br><span class="line">    <span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl)) &#123;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find() 函数作用于容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10325-find_if"><a class="markdownIt-Anchor" href="#10325-find_if"></a> 10.3.2.5 find_if()</h4><p>功能：和 find() 函数相同，find_if() 函数也用于在指定区域内执行查找操作。不同的是，前者需要明确指定要查找的元素的值，而后者则允许自定义查找规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find_if</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以函数对象的形式定义一个 find_if() 函数的查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//调用 find_if() 函数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10325-search"><a class="markdownIt-Anchor" href="#10325-search"></a> 10.3.2.5 search()</h4><p>功能：search()函数用于在序列 A 中查找序列 B 第一次出现的位置。</p><p>例如，以如下两个序列为例：</p><p><img src="/images/2024-08-19-12-14-35-image.png" alt="" /></p><p>可以看到，序列 B 在序列 A 中出现了 2 次，借助 search() 函数，我们可以找到序列 A 中第 1 个 {1,2,3}。</p><p>search() 函数提供有以下 2 种语法格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找 [first1, last1) 范围内第一个 [first2, last2) 子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ForwardIterator first2, ForwardIterator last2)</span></span>;</span><br><span class="line"><span class="comment">//查找 [first1, last1) 范围内，和 [first2, last2) 序列满足 pred 规则的第一个子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        BinaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，各个参数的含义分别为：</p><ul><li>first1、last1：都为正向迭代器，其组合 [first1, last1) 用于指定查找范围（也就是上面例子中的序列 A）；</li><li>first2、last2：都为正向迭代器，其组合 [first2, last2) 用于指定要查找的序列（也就是上面例子中的序列 B）；</li><li>pred：用于自定义查找规则。该规则实际上是一个包含 2 个参数且返回值类型为 bool 的函数（第一个参数接收 [first1, last1) 范围内的元素，第二个参数接收 [first2, last2) 范围内的元素）。函数定义的形式可以是普通函数，也可以是函数对象。</li></ul><p>search() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和 last1 迭代器相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::search</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的形式定义一个匹配规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义一个匹配规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">18</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> myarr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">search</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), </span><br><span class="line">    myarr, myarr + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个&#123;1,2,3&#125;的起始位置为：&quot;</span> &lt;&lt; it - myvector.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,*it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> myarr2[] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第二种语法格式</span></span><br><span class="line">    it = <span class="built_in">search</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), </span><br><span class="line">    myarr2, myarr2 + <span class="number">3</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个&#123;2,3,4&#125;的起始位置为：&quot;</span> &lt;&lt; it - myvector.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p><img src="/images/2024-08-19-12-14-43-image.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-基本概念&quot;&gt;&lt;/a&gt; 一、基本概念&lt;/h2&gt;
&lt;p&gt;STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现</summary>
      
    
    
    
    <category term="C++ STL" scheme="https://xqc-1368.github.io/categories/C-STL/"/>
    
    
    <category term="C++" scheme="https://xqc-1368.github.io/tags/C/"/>
    
    <category term="C语言" scheme="https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="字符串" scheme="https://xqc-1368.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="STL" scheme="https://xqc-1368.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>MARKTEXT使用指南</title>
    <link href="https://xqc-1368.github.io/2024/08/19/MARKTEXT%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://xqc-1368.github.io/2024/08/19/MARKTEXT%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2024-08-19T04:23:45.795Z</published>
    <updated>2024-08-19T04:23:25.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="marktext使用指南"><a class="markdownIt-Anchor" href="#marktext使用指南"></a> MARKTEXT使用指南</h1><h2 id="1建立新文件"><a class="markdownIt-Anchor" href="#1建立新文件"></a> 1.建立新文件</h2><p>ctrl+j 调出侧边框</p><p>然后我们可以看到最左侧有三个符号，分别是便签纸 ，放大镜，字母H</p><p>然后我们来看一下第一个符号有什么作用，当我们按下 ctrl+t 的时候，我们会发现，左侧工作区多了一个Untitled(未命名),当我们每按下一次 ctrl+t 的时候，系统会自动生成一个新的未命名页面</p><p><em><u>为什么要有这一步呢，我举个简单的例子，比如我们同时在学习计算机网络和操作系统两门课，如果我们不想把这两门课自己记录的笔记搞混，最好的办法就是准备两个笔记本，这里一个页面就相当于一个笔记本</u></em></p><p>然后第二个放大镜图标是查找功能，这里我们先放一下，接下来回和其他功能放到一块讲</p><h2 id="2写作"><a class="markdownIt-Anchor" href="#2写作"></a> 2.写作</h2><p>首先我们点击那个左边三个图标中的H图标，切换到标题模式</p><p>首先我们来学习一下标题的使用</p><p>首先我们可以打一个#号，输入完之后我们会惊喜的发现左侧也出现了这个#号<img src="/images/2024-08-19-12-19-28-image.png" alt="" /></p><p>我们此时再去按一下空格，会进入标题输入模式，就像下面这样，你可能会好奇#号去哪了，让我们仔细观察，刚才输入#号的地方多了一个H1图标，这样就表示我们进入了标题输入模式</p><p><img src="/images/2024-08-19-12-19-38-image.png" alt="" /></p><p>下面让我们看看输入一些东西会发生什么吧<img src="/images/2024-08-19-12-19-46-image.png" alt="" /></p><p>到这一步你可能还会疑惑这有什么用，先别着急，答案马上揭晓，限免我们继续类比思考，H1是一个#号，那H2是不是就是两个#,恭喜你，猜对了！</p><p>下面让我们按一下回车换行，回到正常的文字输入模式，上一行是标题模式，只要你在上一行写，他都会出现在左侧，这不是我们的目的</p><p>首先我们输入两个#</p><p><img src="/images/2024-08-19-12-19-55-image.png" alt="" /></p><p>然后还是老规矩按一下空格，然后我们就能看到H2了，然后继续在上面写<img src="/images/2024-08-19-12-20-03-image.png" alt="" /></p><p>我们可以看到，我们已经把标题写好了，以后只要往标题里面写对应内容就好了，同时左边的生成的标题文字是可以点击的，点击哪个标题，系统就会跳到对应标题处，这样就可以很轻松的知道自己笔记写到哪了</p><p>学会上面的基本操作之后，我再演示一下如何生成同级标题，如果你想和食谱同级就输一个#，如果想和红烧排骨同级就输入两个#,演示如下<img src="/images/2024-08-19-12-20-14-image.png" alt="" /></p><p>下面来讲如何插入代码块，这里假如我们要在红烧排骨里面写代码，我们就先在红烧排骨后面点一下，然后多按几下换行，为插入代码预留足够的空间，按下ctrl+shift+k,我们会看到这样的场景</p><p><img src="/images/2024-08-19-12-20-24-image.png" alt="" /></p><p>然后我们输入要用的语言，比如这里我们用javascript,当我们只输入到了java的时候就跳出补全了</p><p><img src="/images/2024-08-19-12-20-32-image.png" alt="" /></p><p>这时候我们啥也不要干，只按上下键进行选择就好了，选好后按回车确认，然后在框里写的代码就有高亮语法了</p><p><img src="/images/2024-08-19-12-20-41-image.png" alt="" /></p><p>如果要跳出代码块按 ctrl+shift+n 就欧克了</p><p>还有一个功能是插入列表，快捷键是 ctrl+shift+t<img src="/images/2024-08-19-12-20-53-image.png" alt="" /></p><p>定义好行和列点击ok就可以了<img src="/images/2024-08-19-12-21-01-image.png" alt="" /></p><p>还有一个是插入图片，这个我们平常一般都是插入截图，截好之后，找好地方，右键然后paste,或者ctrl+v就可以<img src="/images/2024-08-19-12-21-10-image.png" alt="" /></p><p>学会插图在听网课时可以帮我们节约非常多的时间</p><p>最后再教大家一个功能就是查找<img src="/images/2024-08-19-12-21-21-image.png" alt="" /></p><p>比如这是我之前做的python笔记，因为时间有点久了，所以找不到一些笔记在哪了</p><p>这时候我们可以按下 ctrl+f 输入关键词查找<img src="/images/2024-08-19-12-21-30-image.png" alt="" /></p><p>在里面输入关键字</p><p><img src="/images/2024-08-19-12-21-39-image.png" alt="" /></p><p>3.保存与关闭<br />假如我们写好了一篇文章，我们按下 ctrl+s  <img src="/images/2024-08-19-12-21-48-image.png" alt="" /></p><p>系统会让我们选择保存地址，我们一定要牢记自己保存到哪了，这样以后才能继续在刚才的笔记上做修改和增加</p><p>好了，下面让我们再次打开它吧，首先打开编辑器，选open fil<img src="/images/2024-08-19-12-21-58-image.png" alt="" /></p><p>找到保存的地址，找到对应文件双击就OK了</p><p><img src="/images/2024-08-19-12-22-12-image.png" alt="" /></p><p>最后我要提醒一点，Marktext没有返回上一步的功能，所以你最好写一段保存一段，不然写了半天，不小心误删了，可是很痛苦的，如果写一段保存一段，还能再最后退出的时候选择不保存留住大部分内容</p><p>好了，祝你在Marktext的世界玩的愉快<br />————————————————</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;marktext使用指南&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#marktext使用指南&quot;&gt;&lt;/a&gt; MARKTEXT使用指南&lt;/h1&gt;
&lt;h2 id=&quot;1建立新文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="Markdown" scheme="https://xqc-1368.github.io/categories/Markdown/"/>
    
    
    <category term="Markdown" scheme="https://xqc-1368.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
