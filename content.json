{"meta":{"title":"XQC1368的emo小屋","subtitle":"嬛嬛，朕emo啦！！","description":"菜坤日常","author":"XQC1368","url":"https://XQC-1368.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-08-16T06:03:33.337Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://xqc-1368.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-08-16T05:54:24.517Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"https://xqc-1368.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2024-08-15T14:02:09.917Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://xqc-1368.github.io/books/index.html","excerpt":"","text":""},{"title":"仓库","date":"2024-08-16T06:00:06.900Z","updated":"2024-08-16T06:00:06.900Z","comments":false,"path":"repository/index.html","permalink":"https://xqc-1368.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-08-16T03:54:10.618Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"https://xqc-1368.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-08-16T08:33:55.126Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://xqc-1368.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-08-15T14:02:09.921Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"https://xqc-1368.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"10 数位DP：数字计数","slug":"10 数位DP：数字计数","date":"2024-08-17T06:53:17.229Z","updated":"2024-08-17T14:32:09.030Z","comments":true,"path":"2024/08/17/10 数位DP：数字计数/","permalink":"https://xqc-1368.github.io/2024/08/17/10%20%E6%95%B0%E4%BD%8DDP%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/","excerpt":"","text":"10数位DP：数字计数 [ZJOI2010] 数字计数 题目描述 给定两个正整数 aaa 和 bbb，求在 [a,b][a,b][a,b] 中的所有整数中，每个数码(digit)各出现了多少次。 输入格式 仅包含一行两个整数 a,ba,ba,b，含义如上所述。 输出格式 包含一行十个整数，分别表示 0∼90\\sim 90∼9 在 [a,b][a,b][a,b] 中出现了多少次。 样例 #1 样例输入 #1 11 99 样例输出 #1 19 20 20 20 20 20 20 20 20 20 提示 数据规模与约定 对于 30%30\\%30% 的数据，保证 a≤b≤106a\\le b\\le10^6a≤b≤106； 对于 100%100\\%100% 的数据，保证 1≤a≤b≤10121\\le a\\le b\\le 10^{12}1≤a≤b≤1012。 数位DP主要通过记忆化搜索实现，记忆化搜索的本质就是把条件对应的结论记下来，相同条件一定最后对应相同的结论，条件的个数也就决定了DP的维数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define int long long//注意都要开long longusing namespace std;int ay[20];//ay来存这个数每个位子上的数码，倒序存放int dp[20][2][20][2];//zero=1表示前面是否全部都是前导零//limit=1 表示前面对本位有没有限制//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；/*记忆化搜索。pos是当前为从高到低位置。limit表示当前位之前的所有位置是否和ay[pos]相等， 1是相等，0是不相等。sum表示当前数字出现的次数。zero表示之前是否都是前导0。target是当前在算的数码。*/int dfs(int pos,int limit,int sum,int zero,int target)&#123; int ret=0; if(pos==0)return sum;//递归终止条件 if(dp[pos][limit][sum][zero]!=-1)return dp[pos][limit][sum][zero]; //记搜检索：检索是否已经被记录 int maxnum=limit?ay[pos]:9;/* 由于我们是从高位到低位枚举的，所以如果之前一位的数码和最大数的数码相同， 这一位就只能枚举到ay[pos]； 否则如果之前一位比最大数的数码小，那这一位就可以从0~9枚举了。*/ for(int i=0;i&lt;=maxnum;i++) &#123; ret+=dfs(pos-1,limit &amp;&amp;(i==maxnum),sum+((i==target) &amp;&amp; (i||!zero)),zero &amp;&amp; (i==0),target); /* 继续搜索，数位减一（到下一个位置，倒序存储，从高位到低位）， limit的更新要看之前有没有相等，且这一位有没有相等； sum的更新要看之前是否为前导0或者这一位不是0； zero的更新就看之前是否为前导0且这一位继续为0； target继续传进去。 */ &#125; dp[pos][limit][sum][zero]=ret;//记忆化，把搜到的都记下来 return ret;&#125;int part(int a,int d)&#123; int len=0; while(a) &#123; ay[++len]=a%10; a/=10; &#125; memset(dp, -1, sizeof dp);//初始化 dfs(len,1,0,1,d); //开始在第len位上，最高位只能枚举到ay[pos]所以limit是0，sum=0，有前导0。&#125;signed main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=0;i&lt;=9;i++) &#123; cout&lt;&lt;part(b,i)-part(a-1,i)&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 再来看一道题： [SCOI2009] windy 数 题目背景 windy 定义了一种 windy 数。 题目描述 不含前导零且相邻两个数字之差至少为 222 的正整数被称为 windy 数。windy 想知道，在 aaa 和 bbb 之间，包括 aaa 和 bbb ，总共有多少个 windy 数？ 输入格式 输入只有一行两个整数，分别表示 aaa 和 bbb。 输出格式 输出一行一个整数表示答案。 样例 #1 样例输入 #1 11 10 样例输出 #1 19 样例 #2 样例输入 #2 125 50 样例输出 #2 120 提示 数据规模与约定 对于全部的测试点，保证 1≤a≤b≤2×1091 \\leq a \\leq b \\leq 2 \\times 10^91≤a≤b≤2×109。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;int ay[100];int len=0;int dp[100][100];//dp[i][j]表示搜到第i位，前一位是j，的！limit方案totnum；//zero=1表示前面是否全部都是前导零//limit=1 表示前面对本位有没有限制//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；int dfs(int pos,int prenum,int st,int limit)&#123;//pos当前位置,pre前一位数,st判断前面是否全是0,limit最高位限制 if(pos&gt;len)return 1;//搜完了 if(limit==0 &amp;&amp; dp[pos][prenum]!=-1)return dp[pos][prenum]; //没有最高位限制且已经搜过了 int maxnum=limit?ay[len+1-pos]:9;//当前位最大数字 int ret=0; for(int i=0;i&lt;=maxnum;i++)//从0枚举到最大数字 &#123; if(abs(i-prenum)&lt;2)continue;//不符合题意，继续 if(i==0 &amp;&amp; st==1)ret+=dfs(pos+1,-2,st,limit &amp;&amp; (i==maxnum)); //如果有前导0，下一位随意 else ret+=dfs(pos+1,i,0,limit &amp;&amp; (i==maxnum)); //如果没有前导0，继续按部就班地搜 &#125; if(limit==0 &amp;&amp; st==0)dp[pos][prenum]=ret;//没有最高位限制且没有前导0时记录结果 ，至于为什么要这样，我也不知道，其实可以都记下来的 return ret;&#125;int part(int a)&#123; len=0; while(a) &#123; ay[++len]=a%10; a/=10; &#125; memset(dp, -1, sizeof (dp)); return dfs(1,-2,1,1);&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;part(b)-part(a-1)&lt;&lt;endl; return 0;&#125; 咱就主打一个看注释吧。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"算法/动态规划/数位DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"09 区间DP的博弈论模型： Letter Picking","slug":"09 区间DP的博弈论模型： Letter Picking","date":"2024-08-17T06:53:17.224Z","updated":"2024-08-17T14:31:59.812Z","comments":true,"path":"2024/08/17/09 区间DP的博弈论模型： Letter Picking/","permalink":"https://xqc-1368.github.io/2024/08/17/09%20%E5%8C%BA%E9%97%B4DP%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%A8%A1%E5%9E%8B%EF%BC%9A%20Letter%20Picking/","excerpt":"","text":"区间DP的博弈论模型： Letter Picking Letter Picking 题面翻译 题目描述 Alice 和 Bob 在玩游戏。 给出一个长度为偶数的，非空的且仅含小写字母的字符串 sss。每个玩家还拥有一个初始为空的字符串。 Alice 先手，两名玩家交替行动。在一次行动中，玩家可以取 sss 首或尾字符，将其从 sss 中移除后加入到自己的字符串的 最前面。 当 sss 为空时游戏结束，拥有字典序更小的字符串的玩家获胜。若两名玩家的字符串相等则平局。 若 Alice 和 Bob 都足够聪明，判断谁会取胜，或者游戏为平局。 数据组数 t≤103t\\leq 10^3t≤103，∑∣s∣≤2×103\\sum|s|\\leq 2\\times 10^3∑∣s∣≤2×103。保证所有输入的 ∣s∣|s|∣s∣ 长度都为偶数。 题目描述 Alice and Bob are playing a game. Initially, they are given a non-empty string sss , consisting of lowercase Latin letters. The length of the string is even. Each player also has a string of their own, initially empty. Alice starts, then they alternate moves. In one move, a player takes either the first or the last letter of the string sss , removes it from sss and prepends (adds to the beginning) it to their own string. The game ends when the string sss becomes empty. The winner is the player with a lexicographically smaller string. If the players’ strings are equal, then it’s a draw. A string aaa is lexicographically smaller than a string bbb if there exists such position iii that aj=bja_j = b_jaj​=bj​ for all j&lt;ij &lt; ij&lt;i and ai&lt;bia_i &lt; b_iai​&lt;bi​ . What is the result of the game if both players play optimally (e. g. both players try to win; if they can’t, then try to draw)? 输入格式 The first line contains a single integer ttt ( 1≤t≤10001 \\le t \\le 10001≤t≤1000 ) — the number of testcases. Each testcase consists of a single line — a non-empty string sss , consisting of lowercase Latin letters. The length of the string sss is even. The total length of the strings over all testcases doesn’t exceed 200020002000 . 输出格式 For each testcase, print the result of the game if both players play optimally. If Alice wins, print “Alice”. If Bob wins, print “Bob”. If it’s a draw, print “Draw”. 样例 #1 样例输入 #1 1232forcesabba 样例输出 #1 12AliceDraw 提示 One of the possible games Alice and Bob can play in the first testcase: Alice picks the first letter in sss : s=s=s= “orces”, a=a=a= “f”, b=b=b= “”; Bob picks the last letter in sss : s=s=s= “orce”, a=a=a= “f”, b=b=b= “s”; Alice picks the last letter in sss : s=s=s= “orc”, a=a=a= “ef”, b=b=b= “s”; Bob picks the first letter in sss : s=s=s= “rc”, a=a=a= “ef”, b=b=b= “os”; Alice picks the last letter in sss : s=s=s= “r”, a=a=a= “cef”, b=b=b= “os”; Bob picks the remaining letter in sss : s=s=s= “”, a=a=a= “cef”, b=b=b= “ros”. Alice wins because “cef” &lt; “ros”. Neither of the players follows any strategy in this particular example game, so it doesn’t show that Alice wins if both play optimally. 定义状态： 对于区间i~j，博弈后的结果，记1为先手胜，0为先手平，-1为先手负 考虑先手： 以上为先手必获胜的结果，当先手出招时候，后手想使用反制手段，但是发现后手的每一种选择都是使结果导向先手方胜利，那么后手方没办法只能输； 接下来讨论先手出招，但后手通过反制手段，但因为选择当中没有使后手方获胜的情况，但存在若干个平手的情况，于是后手方退而求其次，使最终结果导向平局的情况； 当然这里讨论的是先手不输的情况，先手不输的情况包括先手赢和先手平两种，如果用if+先手赢+else if+先手不输 来把先手赢的情况再第二种情况之前拒之门外，那么第二种情况就是先手不输的情况 即为 附上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longint dp[2005][2005] = &#123;0&#125;;int solve(string s)&#123; int n = s.size() - 1; for (int i = 1, j = 2; j &lt;= n; i++, j++) // 1 start &#123; if (s[i] == s[j]) dp[i][j] = 0; else dp[i][j] = 1; &#125; for (int k = 2; 2 * k &lt;= n; k++) for (int i = 1, j = 2 * k; j &lt;= n; i++, j++) &#123; if ((s[i] &lt; s[i + 1] &amp;&amp; dp[i + 2][j] == 0 || dp[i + 2][j] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[i] &lt; s[j] || dp[i + 1][j - 1] == 1) || (s[j] &lt; s[j - 1] &amp;&amp; dp[i][j - 2] == 0 || dp[i][j - 2] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[j] &lt; s[i] || dp[i + 1][j - 1] == 1)) &#123; dp[i][j] = 1; &#125; else if (((s[i] &lt;= s[i + 1] &amp;&amp; dp[i + 2][j] == 0 || dp[i + 2][j] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[i] &lt;= s[j] || dp[i + 1][j - 1] == 1)) || (s[j] &lt;= s[j - 1] &amp;&amp; dp[i][j - 2] == 0 || dp[i][j - 2] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[j] &lt;= s[i] || dp[i + 1][j - 1] == 1)) &#123; dp[i][j] = 0; &#125; else dp[i][j] = -1; &#125; // for(int i=1;i&lt;=n;i++) // &#123; // for(int j=1;j&lt;=n;j++) // &#123; // cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; // &#125; // cout&lt;&lt;endl; // &#125; return dp[1][n];&#125;signed main(void)&#123; int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) &#123; string temp, s = &quot;0&quot;; cin &gt;&gt; temp; s += temp; int ans = solve(s); if (ans == 0) cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl; if (ans == 1) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; if (ans == -1) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"08 四边形不等式优化的环形DP：石子合并","slug":"08 四边形不等式优化的环形DP： 石子合并","date":"2024-08-17T06:53:17.221Z","updated":"2024-08-17T14:32:04.714Z","comments":true,"path":"2024/08/17/08 四边形不等式优化的环形DP： 石子合并/","permalink":"https://xqc-1368.github.io/2024/08/17/08%20%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96%E7%9A%84%E7%8E%AF%E5%BD%A2DP%EF%BC%9A%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/","excerpt":"","text":"环形DP+四边形不等式优化的区间DP：石子合并 [NOI1995] 石子合并 题目描述 在一个圆形操场的四周摆放 NNN 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 222 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出一个算法,计算出将 NNN 堆石子合并成 111 堆的最小得分和最大得分。 输入格式 数据的第 111 行是正整数 NNN，表示有 NNN 堆石子。 第 222 行有 NNN 个整数，第 iii 个整数 aia_iai​ 表示第 iii 堆石子的个数。 输出格式 输出共 222 行，第 111 行为最小得分，第 222 行为最大得分。 样例 #1 样例输入 #1 1244 5 9 4 样例输出 #1 124354 提示 1≤N≤1001\\leq N\\leq 1001≤N≤100，0≤ai≤200\\leq a_i\\leq 200≤ai​≤20。 考虑的难点主要有两个： 1.区间dp处理环形dp的思路是什么？ 2.区间dp的优化方法：四边形不等式； 先解决问题1： 环形dp的处理方法就是将原来的数组扩充两倍，将n+1项写成第1项，将n+2项写成第2项······以此类推。 12345678910111213int n,stone[500],pre[500]=&#123;0&#125;; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;stone[i]; stone[i+n]=stone[i]; &#125; for(int i=1;i&lt;=2*n;i++) &#123; pre[i]=pre[i-1]+stone[i]; //cout&lt;&lt;pre[i]&lt;&lt;&quot; &quot;; &#125; //cout&lt;&lt;endl; 以n=4为例，最后要输出的是 dp[1][4]，dp[2][5]，dp[3][6]，dp[4][7]，dp[5][8]的最小值/最大值，即所有长度为n的区间的最值 1234567int minn=INT_MAX,maxn=0; for(int i=1,j=n;j&lt;=2*n;i++,j++) &#123; minn=min(minn,dpmin[i][j]); maxn=max(maxn,dp[i][j]); &#125; cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxn&lt;&lt;endl; 再解决问题2： 先介绍方法： 12345678910111213141516for (int i = 1; i &lt;= n; ++i) m[i][i] = i; // 初始化边界决策点for (int d = 2; d &lt;= n; ++d) for (int l = 1, r = d; r &lt;= n; ++l，++ r) &#123; dp[l][r] = INF; for (int k = m[l][r - 1]; k &lt;= m[l + 1][r];++k) // 利用结论，缩小了枚举范围 if (dp[l][k] + dp[k + 1][r] + w(l, r) &lt; dp[l][r]) &#123; dp[l][r] = dp[l][k] + dp[k + 1][r] + w(l, r); // 更新dp数组 m[l][r] = k; // 更新决策点 &#125; &#125; 运用最优决策点的关系，可以实现优化。 然而，我们由上面的文章可以看到，四边形不等式的使用条件其一是w（l，r）满足区间单调性，这个只能数学证明，而且很容易看出来。 其二是，m这个用于标记最佳决策点的数组，在每一行，每一列上都实现单调不下降。本题中，求最大值的时候，m数组不符合这个条件（怎么发现的呢，假设符合条件，然后敲一遍代码，敲完后把m数组打印出来结果如下） 于是就不符合，只能使用简单的区间dp完成。 而求最小值的时候，m数组符合这个条件（运行截图如下），于是就可以使用四边形不等式 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int dp[500][500]=&#123;0&#125;;int dpmin[500][500]=&#123;0&#125;;int m[500][500]=&#123;0&#125;;int m1[500][500]=&#123;0&#125;;signed main(void)&#123; int n,stone[500],pre[500]=&#123;0&#125;; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;stone[i]; stone[i+n]=stone[i]; &#125; for(int i=1;i&lt;=2*n;i++) &#123; pre[i]=pre[i-1]+stone[i]; &#125; //m数组初始化 for(int i=1;i&lt;=2*n;i++) &#123; m[i][i]=i; m1[i][i]=i; &#125; for(int e=2;e&lt;=2*n;e++) &#123; for(int i=1,j=e;j&lt;=2*n;i++,j++) &#123; dpmin[i][j]=INT_MAX; for(int k=i;k&lt;=j-1;k++) &#123; if(dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]&gt;dp[i][j] &amp;&amp; k+1&lt;=j &amp;&amp; i&lt;=k) &#123; dp[i][j]=dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]; m[i][j]=k; &#125; &#125; for (int k = m1[i][j - 1]; k &lt;= m1[i + 1][j]; k++) &#123; if (dpmin[i][k] + dpmin[k + 1][j] + pre[j] - pre[i - 1] &lt; dpmin[i][j] &amp;&amp; k + 1 &lt;= j &amp;&amp; i &lt;= k) &#123; dpmin[i][j] = dpmin[i][k] + dpmin[k + 1][j] + pre[j] - pre[i - 1]; m1[i][j] = k; &#125; &#125; &#125; &#125; int minn=INT_MAX,maxn=0; for(int i=1,j=n;j&lt;=2*n;i++,j++) &#123; minn=min(minn,dpmin[i][j]); maxn=max(maxn,dp[i][j]); &#125; cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxn&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"环形DP的四边形不等式优化","slug":"算法/动态规划/环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"环形DP的四边形不等式优化","slug":"环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/tags/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"}]},{"title":"07 二进制优化多重背包问题：樱花","slug":"07 二进制优化多重背包问题：樱花","date":"2024-08-17T06:53:17.218Z","updated":"2024-08-17T14:31:50.109Z","comments":true,"path":"2024/08/17/07 二进制优化多重背包问题：樱花/","permalink":"https://xqc-1368.github.io/2024/08/17/07%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E6%A8%B1%E8%8A%B1/","excerpt":"","text":"二进制优化多重背包问题：樱花 樱花 题目背景 《爱与愁的故事第四弹·plant》第一章。 题目描述 爱与愁大神后院里种了 nnn 棵樱花树，每棵都有美学值 Ci(0≤Ci≤200)C_i(0 \\le C_i \\le 200)Ci​(0≤Ci​≤200)。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 Pi(0≤Pi≤100)P_i(0 \\le P_i \\le 100)Pi​(0≤Pi​≤100) 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 Ti(0≤Ti≤100)T_i(0 \\le T_i \\le 100)Ti​(0≤Ti​≤100)。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。 输入格式 共 n+1n+1n+1行： 第 111 行：现在时间 TsT_sTs​（几时：几分），去上学的时间 TeT_eTe​（几时：几分），爱与愁大神院子里有几棵樱花树 nnn。这里的 TsT_sTs​，TeT_eTe​ 格式为：hh:mm，其中 0≤hh≤230 \\leq hh \\leq 230≤hh≤23，0≤mm≤590 \\leq mm \\leq 590≤mm≤59，且 hh,mm,nhh,mm,nhh,mm,n 均为正整数。 第 222 行到第 n+1n+1n+1 行，每行三个正整数：看完第 iii 棵树的耗费时间 TiT_iTi​，第 iii 棵树的美学值 CiC_iCi​，看第 iii 棵树的次数 PiP_iPi​（Pi=0P_i=0Pi​=0 表示无数次，PiP_iPi​ 是其他数字表示最多可看的次数 PiP_iPi​）。 输出格式 只有一个整数，表示最大美学值。 样例 #1 样例输入 #1 12346:50 7:00 32 1 03 3 14 5 4 样例输出 #1 111 提示 100%100\\%100% 数据：Te−Ts≤1000T_e-T_s \\leq 1000Te​−Ts​≤1000（即开始时间距离结束时间不超过 100010001000 分钟），n≤10000n \\leq 10000n≤10000。保证 Te,TsT_e,T_sTe​,Ts​ 为同一天内的时间。 样例解释：赏第一棵樱花树一次，赏第三棵樱花树 222 次。 这是一个普通背包，多重背包，完全背包的混合 其他的背包正常做就行，但由于平时都是把多重背包一个物品最多取n件拆成n个这种的一件物品。时间会消耗得很厉害。于是就出现了二进制优化： 一个正整数n，可以被分解成1,2,4,…,2(k-1),n-2k+1的形式。其中，k是满足n-2^k+1&gt;0的最大整数。 例如，假设给定价值为2，数量为10的物品，依据二进制优化思想可将10分解为1+2+4+3，则原来价值为2，数量为10的物品可等效转化为价值分别为1x2，2x2，4x2，3x2，即价值分别为2，4，8，6，数量均为1的物品。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;vector&lt;int&gt; t,c,p;int dp[100000]=&#123;0&#125;;int T,n;int exchage(string st,string ed)&#123; if(st[1]==&#x27;:&#x27;)st=&quot;0&quot;+st; if(ed[1]==&#x27;:&#x27;)ed=&quot;0&quot;+ed; int hs=stoi(st.substr(0,2)),hed=stoi(ed.substr(0,2)); int ms=stoi(st.substr(3,5)),med=stoi(ed.substr(3,5)); if(hed&lt;hs)hed+=24; int ret=(hed-hs)*60+med-ms; return ret;&#125;signed main(void)&#123; string st,ed; cin&gt;&gt;st&gt;&gt;ed&gt;&gt;n; T=exchage(st,ed); //cout&lt;&lt;T&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; int tempt,tempc,tempp; cin&gt;&gt;tempt&gt;&gt;tempc&gt;&gt;tempp; if(tempp==1 || tempp==0) &#123; t.push_back(tempt); c.push_back(tempc); p.push_back(tempp); &#125; else if(tempp&gt;1) &#123; int x=0; while (tempp &gt; pow(2, x)) &#123; t.push_back(tempt * pow(2, x)); c.push_back(tempc * pow(2, x)); p.push_back(1); tempp -= pow(2, x); x++; &#125; t.push_back(tempt * tempp); c.push_back(tempc * tempp);//注意，数量（2个，4个...）绑定后相应的价值和重量也会发生改变 p.push_back(1); &#125; &#125; for(int i=0;i&lt;t.size();i++) &#123; if(p[i]==0)//complete package &#123; for(int j=t[i];j&lt;=T;j++) &#123; dp[j]=max(dp[j],dp[j-t[i]]+c[i]); &#125; &#125; else &#123; for(int j=T;j&gt;=t[i];j--) &#123; dp[j]=max(dp[j],dp[j-t[i]]+c[i]); &#125; &#125; &#125; cout&lt;&lt;dp[T]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"多重背包DP的二进制优化","slug":"算法/动态规划/多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"多重背包DP的二进制优化","slug":"多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}]},{"title":"06 树形DP：金明的预算方案","slug":"06 树形DP：金明的预算方案","date":"2024-08-17T06:53:17.215Z","updated":"2024-08-17T14:31:45.547Z","comments":true,"path":"2024/08/17/06 树形DP：金明的预算方案/","permalink":"https://xqc-1368.github.io/2024/08/17/06%20%E6%A0%91%E5%BD%A2DP%EF%BC%9A%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/","excerpt":"","text":"树形DP：金明的预算方案 其实这道题不用树形dp，也可以使用普通的背包dp，但是鉴于树形dp的简单题一题难求，于是我们用树形dp做。 P1064 [NOIP2006 提高组] 金明的预算方案 题目描述 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 nnn 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 000 个、111 个或 222 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 nnn 元。于是，他把每件物品规定了一个重要度，分为 555 等：用整数 1∼51 \\sim 51∼5 表示，第 555 等最重要。他还从因特网上查到了每件物品的价格（都是 101010 元的整数倍）。他希望在不超过 nnn 元的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第 jjj 件物品的价格为 vjv_jvj​，重要度为wjw_jwj​，共选中了 kkk 件物品，编号依次为 j1,j2,…,jkj_1,j_2,\\dots,j_kj1​,j2​,…,jk​，则所求的总和为： vj1×wj1+vj2×wj2+⋯+vjk×wjkv_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times w_{j_k}vj1​​×wj1​​+vj2​​×wj2​​+⋯+vjk​​×wjk​​。 请你帮助金明设计一个满足要求的购物单。 输入格式 第一行有两个整数，分别表示总钱数 nnn 和希望购买的物品个数 mmm。 第 222 到第 (m+1)(m + 1)(m+1) 行，每行三个整数，第 (i+1)(i + 1)(i+1) 行的整数 viv_ivi​，pip_ipi​，qiq_iqi​ 分别表示第 iii 件物品的价格、重要度以及它对应的的主件。如果 qi=0q_i=0qi​=0，表示该物品本身是主件。 输出格式 输出一行一个整数表示答案。 样例 #1 样例输入 #1 1234561000 5800 2 0400 5 1300 5 1400 3 0500 2 0 样例输出 #1 12200 提示 数据规模与约定 对于全部的测试点，保证 1≤n≤3.2×1041 \\leq n \\leq 3.2 \\times 10^41≤n≤3.2×104，1≤m≤601 \\leq m \\leq 601≤m≤60，0≤vi≤1040 \\leq v_i \\leq 10^40≤vi​≤104，1≤pi≤51 \\leq p_i \\leq 51≤pi​≤5，0≤qi≤m0 \\leq q_i \\leq m0≤qi​≤m，答案不超过 2×1052 \\times 10^52×105。 定义状态：dp【i】【j】=以后序遍历的方式遍历到节点 i 时，还剩的空间为 j 时的最佳answer。 首先，我们需要构建一个树：（对于测试样例）注意一开始为了统摄所有根节点，我们建立一个0号节点来统摄。 这是这个dp数组在测试案例的情况下的最后输出结果，（后面可能会用到） 状态转移方程：xbcl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;vector&lt;int&gt; point_to[61];int v[100]=&#123;0&#125;, p[100]=&#123;0&#125;, q[100]=&#123;0&#125;;int dp[100][3200]=&#123;0&#125;;int n, m;void dfs(int nowpoint,int nowweight)&#123;//第一个参数表示当前节点，第二个参数表示当前还剩的重量 if(nowweight&lt;=0)return ;//如果当前还剩的重量已经小于0，那么直接返回 for(int i=0;i&lt;point_to[nowpoint].size();i++) &#123;//遍历每一个当前节点的子节点 int child = point_to[nowpoint][i];//child为子节点 for (int j = nowweight-v[child]; j &gt;= 0; j--) &#123; dp[child][j] = dp[nowpoint][j] + p[child]*v[child]; &#125;/*把当前0~nowweight-v[child]的所有项给直接搬过来。再加上p[child]*v[child]即题目规定的权值其中0~nowweight-v[child]记录着遍历过他的哥哥节点（前面的兄弟节点）后，所得出的最佳答案为什么把0~nowweight-v[child]直接搬过来加？首先我们要知道dp[父节点]【0~nowweight-v[child]】表示的是在父亲只有该子节点的所有哥哥节点的时候，而完全不取该子节点的有关权值的时候的最优解。因为我们现在在讨论该子节点取的情况下的最优解，而取该子节点势必会消耗v[child]的限额，于是我们给该子节点预留v[child]，那么取完该节点后剩下0~nowweight-v[child]，在递归到叶子节点（即下一行程序的dfs）返回后0~nowweight-v[child]一一顺序对应v[child]~nowweight于是对应原来父节点集合的v[child]~nowweight元素比大小（下面一个循环干的事），最终得到父节点nowpoint的最优值集合*/ dfs(child, nowweight - v[child]); for (int k = nowweight; k &gt;= v[child]; k--) &#123; dp[nowpoint][k] = max(dp[nowpoint][k], dp[child][k - v[child]]); &#125; &#125;/*这时候你会问了，对于兄弟节点之间，取两个，三个等等在哪里体现。其实，这在搬过来加权值的时候已经体现了；如处理样例中5号这个节点的时候，我们把00000000···00000 1200 1200 1200···1200（十一（因为包括首尾）个）搬过来在5号节点这个节点的权值1000加上去，dp第五行自然也就变成了1000 1000···1000 2200 2200··2200了*/&#125;signed main(void)&#123; cin&gt;&gt;n&gt;&gt;m; n/=10; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;p[i]&gt;&gt;q[i]; v[i]/=10; point_to[q[i]].push_back(i);//建树的过程，point_to是二维数组，用point_to[i]记录i号节点指向的所有节点 &#125; dfs(0,n); cout&lt;&lt;dp[0][n]*10&lt;&lt;endl; return 0;&#125; 总结： 树状dp主要解决树形最优解问题。 步骤： 0.递归终止条件： 剩下限重小于0，返回即可； 1.遍历每一个子节点： （1）搬来加权值：把父节点剪掉子节点的重量的部分照搬，加上子节点的权值，成为子节点的那一行的数组； （2）递归：往下递归一层，就更新传参，更新当前节点的参数，更新当前限重。 （3）高位搬回去比较。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"算法/动态规划/树形DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"05 单调队列优化DP：华科A题","slug":"05 单调队列优化DP：华科A题","date":"2024-08-17T06:53:17.210Z","updated":"2024-08-17T14:31:40.881Z","comments":true,"path":"2024/08/17/05 单调队列优化DP：华科A题/","permalink":"https://xqc-1368.github.io/2024/08/17/05%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%EF%BC%9A%E5%8D%8E%E7%A7%91A%E9%A2%98/","excerpt":"","text":"单调队列 “如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理 单调队列是一种主要用于解决”滑动区间“的最值问题的数据结构 即，在长度为 的序列中，求每个长度为 的区间的区间最值。它的时间复杂度是 ，在这个问题中比 的ST表和线段树要优。 单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素可能成为某个区间最值时才保留它。 形象地打个比方，上面的序列可以看成学校里各个年级XCPC选手，数字越大代表能力越强。每个选手只能在大学四年间参赛，毕业了就没有机会了。那么，每一年的王牌选手都在哪个年级呢？ 一开始的时候，大三大四的学长都比较菜，大二的最强，而大一的等大二的毕业后还有机会上位，所以队列里有两个数。 一年过去了，原本大一的成为大二，却发现新进校的新生非常强，自己再也没有机会成为最大值了，所以弹出队列。 又过了一年，新入校的新生尽管能力只有1，但理论上只要后面的人比他还菜，还是可能成为区间最大值的，所以入队。 终于，原本的王牌毕业了，后面的人以为熬出头了，谁知道这时一个巨佬级别的新生进入了集训队，这下其他所有人都没机会了。 （这只是比方，现实中各位选手的实力是会增长的，不符合这个模型ovo） 总之，观察就会发现，我们维护的这个队列总是单调递减的。如果维护区间最小值，那么维护的队列就是单调递增的。这就是为什么叫单调队列。 例题：单调队列优化动态规划的应用 选择数字 题目描述 给定一行 nnn 个非负整数 a1⋯ana_1 \\cdots a_na1​⋯an​。现在你可以选择其中若干个数，但不能有超过 kkk 个连续的数字被选择。你的任务是使得选出的数字的和最大。 输入格式 第一行两个整数 nnn，kkk。 以下 nnn 行，每行一个整数表示 aia_iai​。 输出格式 输出一个值表示答案。 样例 #1 样例输入 #1 1234565 212345 样例输出 #1 112 提示 对于 20%20\\%20% 的数据，n≤10n \\le 10n≤10。 对于另外 20%20\\%20% 的数据，k=1k=1k=1。 对于 60%60\\%60% 的数据，n≤1000n \\le 1000n≤1000。 对于 100%100\\%100% 的数据，1≤n≤1000001 \\le n \\le 1000001≤n≤100000，1≤k≤n1 \\le k \\le n1≤k≤n，0≤0 \\le0≤ 数字大小 ≤1,000,000,000\\le 1,000,000,000≤1,000,000,000。 时间限制 500500500 ms。 这种题是很典型的单调队列优化DP。 我们把问题转化为删除若干个数，且删除的数间隔不超过k，求删除数的最小值。设dp[i]表示在删除第i个数的情况下， 前i个数中删除数的最小和。那么很容易想到转移方程： 这是因为，如果要删除某个数，除非它是前 k+1个数之一，否则在它之前的k+1个数中，至少要删除一个。最后的答案在最后 k+1个数里找最小值，然后用总和去减即可，因为最后 k+1个数中至少有一个是要删除的。 这个朴素方法是O（mn）的，为了优化它，我们可以使用单调队列。注意到，我们不断地在求dp的区间最小值，而且区间长度是固定的m+1 ，这正好符合滑动窗口的模型。只不过，我们需要动态地进行整个过程，即，在维护单调队列的过程中求出dp。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxsize = 100005;int dp[maxsize] = &#123;0&#125;;deque&lt;int&gt; q;signed main()&#123; int n,k,a[maxsize],sum=0; cin&gt;&gt;n&gt;&gt;k; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; sum+=a[i]; &#125; //看作删除若干个数，但是不能有间隔超过k； //dp[i]表示，删除a[i]的情况下，完成删除的最小值 for(int i=1;i&lt;=n;i++) &#123; if(i&lt;=k+1) dp[i]=a[i]; else dp[i]=dp[q.front()]+a[i]; if(!q.empty() &amp;&amp; q.front()&lt;i-k) q.pop_front(); while (!q.empty() &amp;&amp; dp[q.back()] &gt; dp[i]) &#123; q.pop_back(); &#125; q.push_back(i); &#125; int emin=LONG_LONG_MAX; for(int i=n-k;i&lt;=n;i++) &#123; emin=min(dp[i],emin); &#125; cout&lt;&lt;sum-emin&lt;&lt;endl;&#125; 注意，在这个过程中的易错点是： 进入队列的是元素下标不是元素内容！！，且每一次循环不一定一定有元素从头部出队。 另一个例题：华中科技大学2023新生赛A题 [HUSTFC 2023] 简单的加法乘法计算题 题目描述 JokerShaco 有一个数字 xxx，最开始 x=0x=0x=0，他想要把 xxx 变成 yyy。为了达到这个目标，他可以利用两个集合 AAA 和 BBB。其中集合 AAA 包含 nnn 个元素，分别是从 111 到 nnn 的所有正整数；集合 BBB 包含 mmm 个元素。每次它可以对 xxx 进行如下任意次操作： 选择 AAA 中的一个元素 aaa，令 xxx 加上 aaa。 选择 BBB 中的一个元素 bbb，令 xxx 乘以 bbb。 已知 yyy，nnn，mmm 和 BBB 中 mmm 个元素的具体值，JokerShaco 想知道让 xxx 变成 yyy 的最少操作次数。 输入格式 第一行包含三个整数 y (1≤y≤5⋅106)y\\ (1\\le y\\le 5\\cdot 10^6)y (1≤y≤5⋅106)，n (1≤n≤5⋅106)n\\ (1\\le n\\le 5\\cdot 10^6)n (1≤n≤5⋅106) 和 m (1≤m≤10)m\\ (1\\le m\\le 10)m (1≤m≤10)，其含义如题目所述。 第二行包含 mmm 个正整数，其中第 iii 个表示 BBB 中的第 iii 个元素 bi (1≤bi≤5⋅106)b_i\\ (1\\le b_i\\le 5\\cdot 10^6)bi​ (1≤bi​≤5⋅106)。 输出格式 输出一个整数，表示让 xxx 变成 yyy 的最少操作次数。在题目条件下可知一定能将 xxx 变成 yyy。 样例 #1 样例输入 #1 1210 3 12 样例输出 #1 13 样例 #2 样例输入 #2 12100 6 32 3 5 样例输出 #2 13 初步想法是利用线性动态规划进行，dp[i]表示y=i的时候需要走的最少步骤数，状态转移方程为： dp[i]=min( minE(k from i-1 to i-n) {dp[k]+1} , minE(r from 1 to m) if(dp[i]%b[r]=0）dp[i]/b[r] ) 可行代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxsize=5000005;int dp[maxsize]=&#123;0&#125;;deque &lt;int&gt; dq;signed main()&#123; long long b[11]; long long y,n,m; cin&gt;&gt;y&gt;&gt;n&gt;&gt;m; for(long long i=1;i&lt;=m;i++) &#123; cin&gt;&gt;b[i]; &#125; for(int j=1;j&lt;maxsize;j++) &#123; dp[j]=INT_MAX; &#125; for (long long i = 1; i &lt;= y; i++) &#123; if(i&lt;=n) &#123; dp[i]=1; &#125; else &#123; dp[i]=min(dp[i],dp[dq.front()]+1); for (long long r = 1; r &lt;= m; r++) &#123; if (i % b[r] == 0) &#123; dp[i] = min(dp[i], dp[i / b[r]] + 1); &#125; &#125; &#125; if(!dq.empty() &amp;&amp; dq.front()&lt;=i-n) &#123; dq.pop_front(); &#125; while(!dq.empty() &amp;&amp; dp[dq.back()]&gt;dp[i]) &#123; dq.pop_back(); &#125; dq.push_back(i);//注意队列中始终是位置，而不是元素内容 &#125; cout&lt;&lt;dp[y]&lt;&lt;endl;&#125; 特定类型的题型：多重背包的单调队列优化 宝物筛选 题目描述 终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。 这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。 小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 WWW 的采集车，洞穴里总共有 nnn 种宝物，每种宝物的价值为 viv_ivi​，重量为 wiw_iwi​，每种宝物有 mim_imi​ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。 输入格式 第一行为一个整数 nnn 和 WWW，分别表示宝物种数和采集车的最大载重。 接下来 nnn 行每行三个整数 vi,wi,miv_i,w_i,m_ivi​,wi​,mi​。 输出格式 输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。 样例 #1 样例输入 #1 123454 203 9 35 9 19 4 28 1 3 样例输出 #1 147 提示 对于 30%30\\%30% 的数据，n≤∑mi≤104n\\leq \\sum m_i\\leq 10^4n≤∑mi​≤104，0≤W≤1030\\le W\\leq 10^30≤W≤103。 对于 100%100\\%100% 的数据，n≤∑mi≤105n\\leq \\sum m_i \\leq 10^5n≤∑mi​≤105，0≤W≤4×1040\\le W\\leq 4\\times 10^40≤W≤4×104，1≤n≤1001\\leq n\\le 1001≤n≤100。 多重背包的原始状态转移方程： f(i,j)=max(f(i−1,j),f(i−1,j−v)+w,⋯,f(i−1,j−sv)+sw) f(i,j−v)=max(f(i−1,j−v),f(i−1,j−2v)+w,⋯,f(i−1,j−(s+1)v)+(s)w) f(i,j−2v)=max(f(i−1,j−2v),f(i−1,j−3v)+w,⋯,f(i−1,j−(s+2)v)+sw) … 此处我们取 r = j % v f(i,r+sv)=max(f(i−1,r+sv),f(i−1,r+(s−1)v)+w,⋯,f(i−1,r)+sw) ⋯ f(i,r+2v)=max(f(i−1,r+2v),f(i−1,r+v)+w,f(i−1,r)+2w) f(i,r+v)=max(f(i−1,r+v),f(i−1,r)+w) f(i,r)=f(i−1,r) 朴素二维数组代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxsize=4e2+5;int dp[maxsize][maxsize]=&#123;0&#125;;int v[105],w[105],m[105],n,W;signed main()&#123; cin&gt;&gt;n&gt;&gt;W; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i]; &#125; for(int i=1;i&lt;=n;i++)//当前考虑到第i件物品 &#123; for(int r=0;r&lt;w[i];r++)//考虑余数r，余数可能为0~w[i]-1中的任意一个数字 &#123; deque&lt;int&gt; q; for(int j=r;j&lt;=W;j+=w[i]) &#123; while(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i]) q.pop_front(); while (!q.empty() &amp;&amp; dp[i - 1][q.back()] + (j - q.back()) / w[i] * v[i] &lt;= dp[i - 1][j]) q.pop_back(); q.push_back(j); dp[i][j] = dp[i - 1][q.front()] + (j - q.front()) / w[i] * v[i]; &#125; &#125; &#125; cout&lt;&lt;dp[n][W]&lt;&lt;endl; return 0; &#125; 一维数组空间优化代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxsize=4e4+5;int dp[maxsize]=&#123;0&#125;,g[maxsize]=&#123;0&#125;;int v[10005],w[10005],m[10005],n,W;signed main()&#123; cin&gt;&gt;n&gt;&gt;W; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i]; &#125; for(int i=1;i&lt;=n;i++)//当前考虑到第i件物品 &#123; for(int r=0;r&lt;w[i];r++)//考虑余数r，余数可能为0~w[i]-1中的任意一个数字 &#123; deque&lt;int&gt; q; memcpy(g,dp,sizeof(dp)); for(int j=r;j&lt;=W;j+=w[i]) &#123; while(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i]) q.pop_front(); while (!q.empty() &amp;&amp; g[q.back()] + (j - q.back()) / w[i] * v[i] &lt;= g[j]) q.pop_back(); q.push_back(j); dp[j] = g[q.front()] + (j - q.front()) / w[i] * v[i]; &#125; &#125; &#125; cout&lt;&lt;dp[W]&lt;&lt;endl; return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP的单调队列优化","slug":"算法/动态规划/DP的单调队列优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP的单调队列优化","slug":"DP的单调队列优化","permalink":"https://xqc-1368.github.io/tags/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"}]},{"title":"04 状态压缩DP：吃奶酪+Vitamin","slug":"04 状态压缩DP：吃奶酪+Vitamin","date":"2024-08-17T06:53:17.207Z","updated":"2024-08-17T14:31:30.692Z","comments":true,"path":"2024/08/17/04 状态压缩DP：吃奶酪+Vitamin/","permalink":"https://xqc-1368.github.io/2024/08/17/04%20%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP%EF%BC%9A%E5%90%83%E5%A5%B6%E9%85%AA+Vitamin/","excerpt":"","text":"吃奶酪 题目描述 房间里放着 nnn 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0)(0,0)(0,0) 点处。 输入格式 第一行有一个整数，表示奶酪的数量 nnn。 第 222 到第 (n+1)(n + 1)(n+1) 行，每行两个实数，第 (i+1)(i + 1)(i+1) 行的实数分别表示第 iii 块奶酪的横纵坐标 xi,yix_i, y_ixi​,yi​。 输出格式 输出一行一个实数，表示要跑的最少距离，保留 222 位小数。 样例 #1 样例输入 #1 1234541 11 -1-1 1-1 -1 样例输出 #1 17.41 提示 数据规模与约定 对于全部的测试点，保证 1≤n≤151\\leq n\\leq 151≤n≤15，∣xi∣,∣yi∣≤200|x_i|, |y_i| \\leq 200∣xi​∣,∣yi​∣≤200，小数点后最多有 333 位数字。 提示 对于两个点 (x1,y1)(x_1,y_1)(x1​,y1​)，(x2,y2)(x_2, y_2)(x2​,y2​)，两点之间的距离公式为 (x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1​−x2​)2+(y1​−y2​)2​。 2022.7.132022.7.132022.7.13：新增加一组 Hack\\text{Hack}Hack 数据。 本题使用状态压缩动态规划：状态压缩DP用于解决N小于21的图论问题（本身需要搜索解决的） 理解状压DP： DP[ j ][ S ]表示已走过S的二进制表示的路径，目前终点为 j ； 比如S是00110101表示已走过第一个点，第三个点，第五个点，第六个点。 而假如所给输入一共有n个点，单独表示第一个点记为1&lt;&lt;0,单独表示第二个点记为1&lt;&lt;1由此类推单独表示第n个点为1&lt;&lt;(n-1)，表示已经走过n个点中所有的点，为(1&lt;&lt;n)-1因此，最外层循环枚举 00000000~11111111这所有的情况 核心部分代码： 123456for(int S=1;S&lt;(1&lt;&lt;n);S++)//S for(int i=1;i&lt;=n;i++)//i if(S &amp; (1&lt;&lt;(i-1)))//2 for(int j=1;j&lt;=n;j++) if (!(S &amp; (1 &lt;&lt; (j - 1))) &amp;&amp; G[i][j]!=-1)//3 dp[j][S | (1 &lt;&lt; (j - 1))] = min(dp[j][S | (1 &lt;&lt; (j - 1))] , dp[i][S] + G[i][j]); 状态转移方程为： if(S的j-1项为0) ： dp[j][S的j-1项置1]=minE(i from 1 to n and S的第i项为1) {dp[i][S]+G[i][j]}其中G为邻接表 总体思路： 以j为终点 枚举每个可能的i 到 j，所需要的权值，求最小； //S的一层循环提供了每个可能的已走过的路径： //i一层循环枚举了目前处于第i个点，但是第i个点不一定在当前的S状态下被走过，所以我们需要判断语句//2，来知晓是否被走过，如果没被走过，则不用再往下考虑。 S&amp;(1&lt;&lt;(i-1)) 表示S从右往左数第（i-1）位为1； 为什么要i-1，因为我们想最大化利用空间，S最右边是第零位，即S=00000001 = =1&lt;&lt;(1-1)以此类推； //j这层循环中枚举了每个在当前的S的状态下，还未到达过的点，即S为0的位置，//3处判断表示当前已走过路径的S的（j-1）位未走过（即为0），并且G[i][j]!=-1表示当前枚举的i可以到达j，G是一个整体的邻接表。 接下来填充dp[ j ][ S | (1 &lt;&lt; ( j - 1 ) ) ]位置的数字，即dp当中，以j位置结尾，已走过路径为当前的S在第（j-1）位加上1，即路径上的第j位表示走过 的数字等于每一个以i结尾，已走过路径为S的dp表格值加上i到j的权值的和的最小值，于是，我们求出整个dp表格 最后关于如何寻找最值位置的问题： 1234for(int i=1;i&lt;=n;i++) &#123; ans = ans &gt; dp[i][(1 &lt;&lt; n) - 1] ? dp[i][(1 &lt;&lt; n) - 1] : ans; &#125; ans为输出的最短路径规划，遍历每一个终点，寻找走过（1&lt;&lt;n）-1即走过11111111的路径的所有终点状态，即找以1号位置结尾的11111111，以2号位置结尾的11111111········ 于是，我们求出了答案； 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define maxsize 17double dp[16][66000];//n最大值为15，因此取2的15次方大小，为了保险我取了16次方int main()&#123; int n; double x[maxsize]=&#123;0&#125;,y[maxsize]=&#123;0&#125;,G[maxsize][maxsize]=&#123;0&#125;; cin&gt;&gt;n; for(int i=0;i&lt;maxsize;i++) for(int j=0;j&lt;maxsize;j++) G[i][j]=-1; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; if(i==j)continue; G[i][j] =G[j][i]= sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j])); &#125; for(int i=0;i&lt;16;i++) for(int j=0;j&lt;66000;j++) &#123; dp[i][j]=DBL_MAX; &#125; for(int i=1;i&lt;=n;i++) &#123; dp[i][1 &lt;&lt; (i-1)] = sqrt((x[i]) * (x[i]) + (y[i]) * (y[i])); &#125; for(int S=1;S&lt;(1&lt;&lt;n);S++) &#123; for(int i=1;i&lt;=n;i++) &#123; if(S &amp; (1&lt;&lt;(i-1))) &#123; for(int j=1;j&lt;=n;j++) &#123; if (!(S &amp; (1 &lt;&lt; (j - 1))) &amp;&amp; G[i][j]!=-1) &#123; dp[j][S | (1 &lt;&lt; (j - 1))] = dp[j][S | (1 &lt;&lt; (j - 1))] &gt; dp[i][S] + G[i][j] ? dp[i][S] + G[i][j] : dp[j][S | (1 &lt;&lt; (j - 1))]; &#125; &#125; &#125; &#125; &#125; double ans=INT_MAX; for(int i=1;i&lt;=n;i++) &#123; ans = ans &gt; dp[i][(1 &lt;&lt; n) - 1] ? dp[i][(1 &lt;&lt; n) - 1] : ans; &#125; printf(&quot;%.2lf&quot;,ans); return 0;&#125; 上面的题目是对图论的dp方法，下面的例题显然可以看出的状压dp Vitamins 题面翻译 数据有nnn组数,每组数有一个价值cic_ici​和一个字符串S,字符串S中包含3个字母A,B,C，问集齐ABC三个字母的最小价值（一个字母可以有多个） 样例 #1 样例输入 #1 1234545 C6 B16 BAC4 A 样例输出 #1 115 样例 #2 样例输入 #2 123210 AB15 BA 样例输出 #2 1-1 样例 #3 样例输入 #3 123456510 A9 BC11 CA4 A5 B 样例输出 #3 113 样例 #4 样例输入 #4 12345676100 A355 BCA150 BC160 AC180 B190 CA 样例输出 #4 1250 样例 #5 样例输入 #5 12325 BA11 CB 样例输出 #5 116 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define maxsize 1005#define int long longint c[maxsize] = &#123;0&#125;, a[maxsize] = &#123;0&#125;, dp[10] = &#123;0&#125;;void mark(int x, string s)&#123; for (int i = 0; i &lt; s.size(); i++) &#123; a[x] = a[x] | (1 &lt;&lt; ((long long)s[i] - 65)); &#125;&#125;signed main()&#123; int n; string s; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; c[i] &gt;&gt; s; mark(i, s); &#125; for (int j = 0; j &lt; 10; j++) &#123; dp[j] = LONG_LONG_MAX / pow(10, 10); &#125; for (int i = 1; i &lt;= n; i++) &#123; dp[0] = 0; for (int st = (1 &lt;&lt; 3) - 1; st &gt;= 0; st--) &#123; dp[st | a[i]] = min(dp[st | a[i]], dp[st] + c[i]); &#125; &#125; if (dp[(1 &lt;&lt; 3) - 1] == (long long)(LONG_LONG_MAX / pow(10, 10))) dp[(1 &lt;&lt; 3) - 1] = -1; cout &lt;&lt; dp[(1 &lt;&lt; 3) - 1] &lt;&lt; endl; return 0;&#125; 第一次实现了状压dp可视化！！！！","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"算法/动态规划/状压DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"https://xqc-1368.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"03 区域DP：三素数数","slug":"03 区域DP：三素数数","date":"2024-08-17T06:53:17.204Z","updated":"2024-08-17T13:31:16.692Z","comments":true,"path":"2024/08/17/03 区域DP：三素数数/","permalink":"https://xqc-1368.github.io/2024/08/17/03%20%E5%8C%BA%E5%9F%9FDP%EF%BC%9A%E4%B8%89%E7%B4%A0%E6%95%B0%E6%95%B0/","excerpt":"","text":"区域DP：三素数数 三素数数 题目背景 蛟川书院的一道练习题QAQ 题目描述 如果一个数的所有连续三位数字都是大于100的素数，则该数称为三素数数。比如113797是一个6位的三素数数。 输入格式 一个整数n（3 ≤ n ≤ 10000），表示三素数数的位数。 输出格式 一个整数，表示n位三素数的个数m，要求输出m除以10^9 + 9的余数。 样例 #1 样例输入 #1 14 样例输出 #1 1204 提示 区域动归QAQ 设dp[k][i][j]表示到了第k位，这个数字是i，上一个数字是j的方案数 初始化 dp[2][0→9][0→9]=1 枚举第几位i，现在的数字now，之前的数字pre，上上个数字last 如果last∗100+pre+10+now是素数，那么dp[i][now][pre]+=dp[i−1][pre][last] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define int long longusing namespace std;vector&lt;int&gt; prime;int dp[10001][11][11]=&#123;0&#125;;const int MOD=1e9+9;vector&lt;bool&gt; is_prime(1001); // 0表示质数，1表示不是质数void get_prime(int n)//欧拉筛板子&#123; is_prime[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (is_prime[i] == 0) prime.push_back(i); for (auto j : prime) &#123; if (i * j &gt; n) break; is_prime[i * j] = 1; if (i % j == 0) break; &#125; &#125; for(int i=0;i&lt;=100;i++)is_prime[i]=1; //仅需要统计101~999的质数，剩下的不属于这个范围&#125;int combine(int a,int b,int c)&#123; return a*100+b*10+c;&#125;signed main()&#123; int n; cin&gt;&gt;n; get_prime(1000); for(int i=0;i&lt;=9;i++) for(int j=0;j&lt;=9;j++) dp[2][i][j]=1; for(int k=3;k&lt;=n;k++) &#123; for(int i=1;i&lt;=9;i+=2) &#123; for(int j=0;j&lt;=9;j++) &#123; for(int l=0;l&lt;=9;l++) &#123; if(is_prime[combine(l,j,i)]==0) dp[k][i][j]=(dp[k][i][j]+dp[k-1][j][l])%MOD; &#125; &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;=9;i++)for(int j=0;j&lt;=9;j++)ans=(ans+dp[n][i][j])%MOD; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 另一道题目：Colo. 题目描述 小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 n，宽度为 1 的网格图上画画，从左往右第 i 个方格被涂成了一种颜色 a_i。 你觉得他的随意涂鸦太难看了，想要保留恰好 k 种颜色（你不能保留没在网格图上出现的颜色），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。 此外，小 Y 使用的第 i 种颜色有一个价值 b_i，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。 你需要求出你能够获得的最大的价值是多少。 输入格式 第一行两个整数 n,k，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。 第二行 n 个整数 a_i，表示小 Y 画出来的网格图从左往右第 i 个格子的颜色。 第三行 n 个整数 b_i，表示第 i 种颜色的价值。 输出格式 一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 -1。 样例 #1 样例输入 #1 1235 21 2 1 3 25 3 1 100 100 样例输出 #1 16 样例 #2 样例输入 #2 12310 31 3 4 2 9 3 4 2 5 11 5 2 3 9 8 1 2 3 10 样例输出 #2 1-1 提示 【样例解释 #1】 对于第一组样例，我们可以选择 1 号和 3 号颜色保留，剩下的网格图即为 [1,1,3]，满足单调不下降这一个限制，获得的价值即为 b_1+b_3=5+1=6，可以证明这是最优的办法。 【数据范围】 对于所有测试数据，满足 1 \\le n \\le 500，1 \\le k \\le 500，1 \\le a_i \\le n，1 \\le b_i \\le 10^9。 各测试点的附加限制如下表所示。 本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 \\text{Subtask}。 测试点 n,k \\le 特殊性质 1 \\sim 3 10 无 4 \\sim 5 100 无 6 \\sim 10 500 不同的颜色不超过 10 种 11 \\sim 15 500 每种颜色出现的次数不超过 2 次 16 \\sim 20 500 无 首先是输入部分代码 在输入时候用bucket的方式记录每一种颜色的对应第一个和最后一个位置（后面有用） 记录方式用桶的方式便于查询 12345678910111213cin&gt;&gt;n&gt;&gt;k;for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(bucket[a[i]].begin ==inf)&#123; bucket[a[i]].begin =i; bucket[a[i]].last =i; &#125; else &#123; bucket[a[i]].last =i; &#125; &#125;for (int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; 接下来记录遍历每个颜色（对于每个颜色i） ，看看有哪些颜色（即j）在原数组中的位置是完全在他前面的，即 j 颜色的last小于 i 颜色的begin，(并且j&lt;i由循环条件可知默认成立)。如果有的话加入到数组g的第 i 项指向的（可以这么理解）数组中去。表示在取 i 颜色时候，可以取 j 颜色作为他的前驱 1234567891011121314long long g[505][505]=&#123;0&#125;; for(int i=1;i&lt;=n;i++)&#123; count=0; if(bucket[i].begin ==inf)continue; for(int j=1;j&lt;i;j++)&#123; if(bucket[j].begin ==inf)continue; if(bucket[i].begin &gt;bucket[j].last )&#123; g[i][count]=j; count++; &#125; &#125; &#125; 最重要的部分：填表 表格含义如下 123456789for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) dp[1][i]=b[i]; for(int i=2;i&lt;=k;i++)//i循环 for(int j=i;j&lt;=n;j++)//j循环 if(bucket[j].begin !=inf &amp;&amp; g[j][0]!=0) for(int p=0;g[j][p]!=0;p++)//p循环 if(dp[i-1][g[j][p]] !=0) dp[i][j]=max(dp[i][j],dp[i-1][g[j][p]]+b[j]);//# 以样例二为例 关键数组信息 第一行循环设置递推初始调件； 第二个 i 循环，遍历从第二行到第k行，因为问的是选k个，再往下遍历没有意义 第三个 j 循环，遍历第 i 列到最后的值，ij用来定位每个位置 以上好像都是废话。。 第四个p循环，遍历当前所在位置的上一行中所有可能成为该位置前驱的位置，#处表示取这些通过状态转移方程到该位置的所有值的最大值 最后，遍历第k行找出所有可能情况的最大值，没有，则输出-1 123456long long maxf=0; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) maxf=max(maxf,dp[k][i]); if(maxf==0)maxf=-1; cout&lt;&lt;maxf&lt;&lt;endl; 完整代码附上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define inf -1using namespace std;long long g[505][505]=&#123;0&#125;; typedef struct&#123; long long begin; long long last;&#125;edge;edge bucket[505];int main(void)&#123; long long n,k,a[505],b[505],dp[505][505]=&#123;0&#125;,count; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;=n;i++)&#123; bucket[i].begin =inf; bucket[i].last =inf; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(bucket[a[i]].begin ==inf)&#123; bucket[a[i]].begin =i; bucket[a[i]].last =i; &#125; else &#123; bucket[a[i]].last =i; &#125; &#125; for (int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; for(int i=1;i&lt;=n;i++)&#123; count=0; if(bucket[i].begin ==inf)continue; for(int j=1;j&lt;i;j++)&#123; if(bucket[j].begin ==inf)continue; if(bucket[i].begin &gt;bucket[j].last )&#123; g[i][count]=j; count++; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) dp[1][i]=b[i]; for(int i=2;i&lt;=k;i++) for(int j=i;j&lt;=n;j++) if(bucket[j].begin !=inf &amp;&amp; g[j][0]!=0) for(int p=0;g[j][p]!=0;p++) if(dp[i-1][g[j][p]] !=0) dp[i][j]=max(dp[i][j],dp[i-1][g[j][p]]+b[j]); long long maxf=0; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) maxf=max(maxf,dp[k][i]); if(maxf==0)maxf=-1; cout&lt;&lt;maxf&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区域DP","slug":"算法/动态规划/区域DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9FDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区域DP","slug":"区域DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E5%9F%9FDP/"}]},{"title":"02 区间DP：涂色","slug":"02 区间DP：涂色","date":"2024-08-17T06:53:17.201Z","updated":"2024-08-17T06:36:14.454Z","comments":true,"path":"2024/08/17/02 区间DP：涂色/","permalink":"https://xqc-1368.github.io/2024/08/17/02%20%E5%8C%BA%E9%97%B4DP%EF%BC%9A%E6%B6%82%E8%89%B2/","excerpt":"","text":"[CQOI2007] 涂色 题目描述 假设你有一条长度为 555 的木板，初始时没有涂过任何颜色。你希望把它的 555 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 555 的字符串表示这个目标：RGBGR\\texttt{RGBGR}RGBGR。 每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 RRRRR\\texttt{RRRRR}RRRRR，第二次涂成 RGGGR\\texttt{RGGGR}RGGGR，第三次涂成 RGBGR\\texttt{RGBGR}RGBGR，达到目标。 用尽量少的涂色次数达到目标。 输入格式 输入仅一行，包含一个长度为 nnn 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。 输出格式 仅一行，包含一个数，即最少的涂色次数。 样例 #1 样例输入 #1 1AAAAA 样例输出 #1 11 样例 #2 样例输入 #2 1RGBGR 样例输出 #2 13 提示 40%40\\%40% 的数据满足 1≤n≤101\\le n\\le 101≤n≤10。 100%100\\%100% 的数据满足 1≤n≤501\\le n\\le 501≤n≤50。 区间dp的plus版：我愿称之为完全区间dp 把从i到j的所有情况列在对应表格中；我们发现： GBBR可以分解为（此处为常规区间dp） G+BBR GB+BR GBB+R 这3种情况（隔板法分割把区间一分为二） 当然也会出现不用讨论分隔直接完成的：比如RGBBR相对于RGBB就可以相等； 首先赋初值，对角线为初值，赋1； 然后我们可以手动填上第二个斜线上的数字，我们可以看见，因为s[2]==s[3]，所以只要在刷一个的时候范围刷大刷到另一个所在位置即可，故dp[ i ][ j ] = =dp[ i-1 ][ j ]==dp[i+1][ j ] 所以当区间 i~j 首末数字相等时，可以直接 ”刷过来“ ，即等于下面的或者左边的； 当区间 i~j 首末数字不相等时候，则用区间dp对当前空格位置代表的字符串切分，比出一个最小值 例如GBBR可以分解为（此处为常规区间dp） G+BBR dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ] GB+BR dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ] GBB+R dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ] 这3种情况（隔板法分割把区间一分为二） 因此：dp[ 1 ][ 4 ]=max{ dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ] , dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ] , dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ] }; 由此我们得到对于任意一个dp[ i ][ j ]的状态转移方程 dp[ i ][ j ]= case1: dp[ i-1 ][ j ] or dp[i+1][ j ] ( if s[ i ]==s[ j ] ) case 2: maxE(k from i to j-1){dp[ i ][ k ]+dp[ k+1 ][ j ]} ( if s[ i ]!=s[ j ] ) 由此我们就可以很愉快的敲代码了 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define maxsize 55using namespace std;int dp[maxsize][maxsize]=&#123;0&#125;;int main() &#123; string s; memset(dp,0x3f,sizeof(dp)); cin&gt;&gt;s; for(int i=0;i&lt;s.size();i++) dp[i][i]=1; for(int p=0;p&lt;s.size()-1;p++)//注意见下 for(int i=0,j=p+1;j&lt;s.size();i++,j++) &#123; if(s[i]==s[j])dp[i][j]=dp[i+1][j]; else &#123; dp[i][j]=dp[i][i]+dp[i+1][j]; for(int k=i;k&lt;j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]); &#125; &#125; cout&lt;&lt;dp[0][s.size()-1]&lt;&lt;endl; return 0; &#125; 这里的p是指对第2~n个主对角线方向的斜线的遍历（第一个斜线即主对角线已经遍历过了）","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚","slug":"01 背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚","date":"2024-08-17T06:53:17.196Z","updated":"2024-08-17T14:31:12.026Z","comments":true,"path":"2024/08/17/01 背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚/","permalink":"https://xqc-1368.github.io/2024/08/17/01%20%E8%83%8C%E5%8C%85DP%EF%BC%9AMake_Full_Use_Of%E6%A8%A1%E5%9E%8B%EF%BC%9Akkksc03%E8%80%83%E5%89%8D%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/","excerpt":"","text":"kkksc03考前临时抱佛脚 题目背景 kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。 题目描述 这次期末考试，kkksc03 需要考 444 科。因此要开始刷习题集，每科都有一个习题集，分别有 s1,s2,s3,s4s_1,s_2,s_3,s_4s1​,s2​,s3​,s4​ 道题目，完成每道题目需要一些时间，可能不等（A1,A2,…,As1A_1,A_2,\\ldots,A_{s_1}A1​,A2​,…,As1​​，B1,B2,…,Bs2B_1,B_2,\\ldots,B_{s_2}B1​,B2​,…,Bs2​​，C1,C2,…,Cs3C_1,C_2,\\ldots,C_{s_3}C1​,C2​,…,Cs3​​，D1,D2,…,Ds4D_1,D_2,\\ldots,D_{s_4}D1​,D2​,…,Ds4​​）。 kkksc03 有一个能力，他的左右两个大脑可以同时计算 222 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。 由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。 输入格式 本题包含 555 行数据：第 111 行，为四个正整数 s1,s2,s3,s4s_1,s_2,s_3,s_4s1​,s2​,s3​,s4​。 第 222 行，为 A1,A2,…,As1A_1,A_2,\\ldots,A_{s_1}A1​,A2​,…,As1​​ 共 s1s_1s1​ 个数，表示第一科习题集每道题目所消耗的时间。 第 333 行，为 B1,B2,…,Bs2B_1,B_2,\\ldots,B_{s_2}B1​,B2​,…,Bs2​​ 共 s2s_2s2​ 个数。 第 444 行，为 C1,C2,…,Cs3C_1,C_2,\\ldots,C_{s_3}C1​,C2​,…,Cs3​​ 共 s3s_3s3​ 个数。 第 555 行，为 D1,D2,…,Ds4D_1,D_2,\\ldots,D_{s_4}D1​,D2​,…,Ds4​​ 共 s4s_4s4​ 个数，意思均同上。 输出格式 输出一行,为复习完毕最短时间。 样例 #1 样例输入 #1 123451 2 1 3 54 362 4 3 样例输出 #1 120 提示 1≤s1,s2,s3,s4≤201\\leq s_1,s_2,s_3,s_4\\leq 201≤s1​,s2​,s3​,s4​≤20。 1≤A1,A2,…,As1,B1,B2,…,Bs2,C1,C2,…,Cs3,D1,D2,…,Ds4≤601\\leq A_1,A_2,\\ldots,A_{s_1},B_1,B_2,\\ldots,B_{s_2},C_1,C_2,\\ldots,C_{s_3},D_1,D_2,\\ldots,D_{s_4}\\leq601≤A1​,A2​,…,As1​​,B1​,B2​,…,Bs2​​,C1​,C2​,…,Cs3​​,D1​,D2​,…,Ds4​​≤60。 本题为背包dp的 “ 简单 ” 变式：虽然简单变一变本蒟蒻已经不会了。 一开始的思路是贪心算法：对每一组而言先排序，然后从后向前把元素往两个空脑子里丢，哪个脑子目前内容比较少就丢哪个。 代码如下，喜提零分（听取蛙声一片） 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#include &lt;algorithm&gt;#include &lt;queue&gt;const int maxsize = 25;int n, inp;int min_time(int a[],int n)&#123; if(n==1)return a[0]; int lsum=0,rsum=0; sort(a,a+n); for(int i=n-1;i&gt;=0;i--) &#123; if(lsum&gt;rsum)rsum+=a[i]; else lsum+=a[i]; &#125; return max(lsum,rsum);&#125;int main()&#123; int sum_time=0,na,nb,nc,nd; int a[maxsize],b[maxsize],c[maxsize],d[maxsize]; cin&gt;&gt;na&gt;&gt;nb&gt;&gt;nc&gt;&gt;nd; for(int i=0;i&lt;na;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;nb;i++) cin&gt;&gt;b[i]; for (int i = 0; i &lt; nc; i++) cin &gt;&gt; c[i]; for (int i = 0; i &lt; nd; i++) cin &gt;&gt; d[i]; cout &lt;&lt; min_time(a, na) + min_time(b, nb) + min_time(c, nc) + min_time(d, nd) &lt;&lt; endl; return 0;&#125; 注意：以上代码为错误代码！！！！！！！！！ 因为可以找到一组hack数据 12//在某一行：10 10 6 6 5 3 按照贪心算法 10 6 5 10 6 3 max为21 但是实际上： 10 10 6 6 5 3 max为20 于是验证了贪心的不可行性，而这种退一步达到全局最优解的情况，就应该使用dp 这道题使用的是最基本的背包dp。我们由以上思路可以知晓，当两个脑子处理的内容大小最接近 的时候将会达到本组最优解。于是我给第一个脑子一个容量预算为sum/2（即背包容量），在运算过程中不能超过这个预算。通过将每个选择装进背包的物品的v等价于其重量w这种方法，由此得出最大化利用sum/2的背包空间所能装得下的处理总量，即dp[ sum/2 ]; 而max（sum-dp[ sum/2 ]，dp[ sum/2 ]）即为某一组耗时。 1234567891011121314int dynamic_programming(int sum,int homework[],int n)&#123; if(n==1)return homework[1]; int dp[2501]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=sum/2;j&gt;=homework[i];j--) &#123; dp[j]=max(dp[j],dp[j-homework[i]]+homework[i]); &#125; &#125; return max(sum - dp[sum / 2], dp[sum / 2]); // return sum - dp[sum / 2];&#125; 此外由于int是除以2（在正数范围内）向下取整的特性，可以数学证明sum-dp[ sum/2 ]总是大于dp[ sum/2 ]，所以注释行也还可以那样输出。 最后，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int a[5];int dynamic_programming(int sum,int homework[],int n)&#123; if(n==1)return homework[1]; int dp[2501]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=sum/2;j&gt;=homework[i];j--) &#123; dp[j]=max(dp[j],dp[j-homework[i]]+homework[i]); &#125; &#125; return max(sum - dp[sum / 2], dp[sum / 2]); // return sum - dp[sum / 2];&#125;int main()&#123; int b[21] = &#123;0&#125;,ans=0; for (int i = 1; i &lt;= 4; i++) cin &gt;&gt; a[i]; for(int i=1;i&lt;=4;i++) &#123; int sum=0; memset(b,0,sizeof(b)); for(int j=1;j&lt;=a[i];j++) &#123; cin&gt;&gt;b[j]; sum+=b[j]; &#125; ans+=dynamic_programming(sum,b,a[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包DP","slug":"算法/动态规划/背包DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包DP","slug":"背包DP","permalink":"https://xqc-1368.github.io/tags/%E8%83%8C%E5%8C%85DP/"}]},{"title":"11 期望DP：收集邮票","slug":"11 期望DP：收集邮票","date":"2024-08-17T06:53:17.192Z","updated":"2024-08-17T14:32:13.333Z","comments":true,"path":"2024/08/17/11 期望DP：收集邮票/","permalink":"https://xqc-1368.github.io/2024/08/17/11%20%E6%9C%9F%E6%9C%9BDP%EF%BC%9A%E6%94%B6%E9%9B%86%E9%82%AE%E7%A5%A8/","excerpt":"","text":"11期望DP 收集邮票 题目描述 有 nnn 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 nnn 种邮票中的哪一种是等概率的，概率均为 1/n1/n1/n。但是由于凡凡也很喜欢邮票，所以皮皮购买第 kkk 次邮票需要支付 kkk 元钱。 现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。 输入格式 一行，一个数字 NNN（N≤10000N \\le 10000N≤10000）。 输出格式 输出要付出多少钱，保留二位小数。 样例 #1 样例输入 #1 13 样例输出 #1 121.25 定义状态 众所周知，期望DP的定义状态一般都为已经……还需要……的期望 由于本题需要求的就是 自己得到所有种类的邮票需要花费的钱数目的期望。 那么我们就可以定义一个 ex ，它的意义是： ex(i)ex(i)ex(i)：已经收集到了 i 种邮票，还需要花费的钱数的期望。 但是题目中有一个条件 皮皮购买第k张邮票需要支付k元钱 这意味着购买价格是与购买次数有关的。 所以我们还需要定义一个状态 num ，它的意义是：num(i)num(i)num(i)： 已经收集到了 i 种邮票，还需要购买的次数的期望。 初始化：num(n)=0num(n)=0num(n)=0，ex(n)=0ex(n)=0ex(n)=0 这个应该不需要我讲吧qwq 状态转移 首先吧这个写在前面 期望公式：E(X)=∑pi​⋅xiE(X)= \\sum pi​⋅xiE(X)=∑pi​⋅xi​ ，其中 pi​ 是事件 i 发生的概率，xi​ 是权值。 发现 num 的转移是比较简单的，先考虑 num。有以下两种情况： 买到之前买到过的邮票种类，此时 x=num(i)+1x=num(i)+1x=num(i)+1（种类总数不变），p=inp=\\frac{i}{n}p=ni​​ 买到之前没有买到过的，此时 x=num(i+1)+1x=num(i+1)+1x=num(i+1)+1（总种类数量+1），p=n−inp=\\frac{n-i}{n}p=nn−i​​ 注：以上的 x 指的是次数。 根据公式，我们就可以得到关于 num 的公式： num(i)=(num(i)+1)×in+(num(i+1)+1)×n−innum(i)=(num(i)+1)×\\frac{i}{n}+(num(i+1)+1)×\\frac{n-i}{n}num(i)=(num(i)+1)×ni​+(num(i+1)+1)×nn−i​ 化简之后得到状态转移方程： num(i)=num(i+1)×n−in+11−n−in​num(i)= \\frac{num(i+1)×\\frac{n-i}{n}+1}{1−\\frac{n-i}{n}}​ num(i)=1−nn−i​num(i+1)×nn−i​+1​​ 得到 num 后，我们再思考 ans 的转移，同样是以上的两种情况 买到之前买到过的邮票种类：此时 x=ex(i)+num(i)+1x=ex(i)+num(i)+1x=ex(i)+num(i)+1（种类+1，总花费=之前花费+本次花费），p=inp=\\frac{i}{n}p=ni​ 买到之前没有买到过的，此时x=ex(i+1)+num(i+1)+1x=ex(i+1)+num(i+1)+1x=ex(i+1)+num(i+1)+1（同上），p=n−inp=\\frac{n-i}{n}p=nn−i​ 然后我们又轻松地得到了关于 ex 的公式： ex(i)=(ex(i)+num(i)+1)×in​+(ex(i+1)+num(i+1)+1)×​n−inex(i)=(ex(i)+num(i)+1)×\\frac{i}{n}​+(ex(i+1)+num(i+1)+1)×​\\frac{n-i}{n}ex(i)=(ex(i)+num(i)+1)×ni​​+(ex(i+1)+num(i+1)+1)×​nn−i​ 请自行化简 既然我们有了转移方程，那就开写呗 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;double num[10005]=&#123;0&#125;,ex[10005]=&#123;0&#125;;signed main()&#123; int n; cin&gt;&gt;n; num[n]=0;ex[n]=0; for(int i=n-1;i&gt;=0;i--) &#123; double p=(double)n/(n-i); num[i]=p+num[i+1]; ex[i]=p*num[i]+ex[i+1]; &#125; // for(int i=0;i&lt;=n;i++)cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; // for(int i=0;i&lt;=n;i++)cout&lt;&lt;ex[i]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; printf(&quot;%.2lf&quot;,ex[0]); //cout&lt;&lt;ex[0]&lt;&lt;&quot;\\n&quot;; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"期望DP","slug":"算法/动态规划/期望DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"期望DP","slug":"期望DP","permalink":"https://xqc-1368.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"}]},{"title":"CSS定位","slug":"09 CSS定位","date":"2024-08-17T02:28:01.411Z","updated":"2024-08-17T02:19:44.500Z","comments":true,"path":"2024/08/17/09 CSS定位/","permalink":"https://xqc-1368.github.io/2024/08/17/09%20CSS%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"定位 今日目标 能够说出 为什么要用定位 能够说出 定位的 4 种分类 能够说出 4 种定位各自的特点 能够说出 为什么常用子绝父相布局 能够写出 淘宝轮播图布局 能够说出 显示隐藏的 3 种方式以及区别 1. 定位(position) 介绍 1.1 为什么使用定位 我们先来看一个效果，同时思考一下用标准流或浮动能否实现类似的效果？ 场景1： 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子. 场景2：当我们滚动窗口的时候，盒子是固定屏幕某个位置的。 结论：要实现以上效果，标准流 或 浮动都无法快速实现 所以： 1.浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 2.定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 1.2 定位组成 定位：将盒子定在某一个位置，所以定位也是在摆放盒子， 按照定位的方式移动盒子 定位也是用来布局的，它有两部分组成： 定位 = 定位模式 + 边偏移 定位模式 用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 1.2.1 边偏移（方位名词） 边偏移 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性。 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 1.2.2 定位模式 (position) 在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 123选择器 &#123; position: 属性值; &#125; 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个： 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 1.3 定位模式介绍 1.3.1. 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none，静态定位static，不要定位的时候用。 语法： 123选择器 &#123; position: static; &#125; 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 1.3.2. 相对定位(relative) - 重要 相对定位是元素在移动位置的时候，是相对于它自己原来的位置来说的（自恋型）。 语法： 123选择器 &#123; position: relative; &#125; 相对定位的特点：（务必记住） 1.它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。 2.原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。 因此，相对定位并没有脱标。它最典型的应用是给绝对定位当爹的。。。 效果图： 1.3.3. 绝对定位(absolute) - 重要 1.3.3.1 绝对定位的介绍 绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的（拼爹型）。 语法： 123选择器 &#123; position: absolute; &#125; 完全脱标 —— 完全不占位置； 父元素没有定位，则以浏览器为准定位（Document 文档）。 父元素要有定位 元素将依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的特点总结：（务必记住） 1.如果没有祖先元素或者祖先元素没有定位，则以浏览器为基准定位（Document 文档）。 2.如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。 3.绝对定位不再占有原先的位置。所以绝对定位是脱离标准流的。（脱标） 1.3.3.2 定位口诀 —— 子绝父相 弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。 这个**“子绝父相”太重要了，是我们学习定位的口诀**，是定位中最常用的一种方式这句话的意思是：子级是绝对定位的话，父级要用相对定位。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 ①子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 ②父盒子需要加定位限制子盒子在父盒子内显示。 ③父盒子布局时，需要占有位置，因此父亲只能是相对定位。 这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。 总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。 疑问：为什么在布局时，子级元素使用绝对定位时，父级元素就要用相对定位呢？ 观察下图，思考一下在布局时，左右两个方向的箭头图片以及父级盒子的定位方式。 分析： 方向箭头叠加在其他图片上方，应该使用绝对定位，因为绝对定位完全脱标，完全不占位置。 父级盒子应该使用相对定位，因为相对定位不脱标，后续盒子仍然以标准流的方式对待它。 如果父级盒子也使用绝对定位，会完全脱标，那么下方的广告盒子会上移，这显然不是我们想要的。 结论：父级要占有位置，子级要任意摆放，这就是子绝父相的由来。 1.3.4. 固定定位(fixed) - 重要 固定定位是元素固定于浏览器可视区的位置。（认死理型） 主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。 语法： 123选择器 &#123; position: fixed; &#125; 固定定位的特点：（务必记住）： 1.以浏览器的可视窗口为参照点移动元素。 跟父元素没有任何关系 不随滚动条滚动。 2.固定定位不在占有原先的位置。 固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。（认死理型） 完全脱标—— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 固定定位举例： 提示：IE 6 等低版本浏览器不支持固定定位。 小tip：固定在版心右侧 12345.fixed&#123; position:fixed; left:50%; margin-left:版面宽度的一半&#125; 1.3.5 粘性定位(sticky) - 了解 粘性定位可以被认为是相对定位和固定定位的混合。 Sticky 粘性的 语法： 1234选择器 &#123; position: sticky; top: 10px; &#125; 粘性定位的特点： 1.以浏览器的可视窗口为参照点移动元素（固定定位特点） 2.粘性定位占有原先的位置（相对定位特点） 3.必须添加 top 、left、right、bottom 其中一个才有效 跟页面滚动搭配使用。 兼容性较差，IE 不支持。 1.3.6 定位总结 定位模式 是否脱标 移动位置 是否常用 static 静态定位 否 不能使用边偏移 很少 relative 相对定位 否 (占有位置) 相对于自身位置移动 基本单独使用 absolute绝对定位 是（不占有位置） 带有定位的父级 要和定位父级元素搭配使用 fixed 固定定位 是（不占有位置） 浏览器可视区 单独使用，不需要父级 sticky 粘性定位 否 (占有位置) 浏览器可视区 当前阶段少 一定记住 相对定位、固定定位、绝对定位 两个大的特点： 1. 是否占有位置（脱标否） 2. 以谁为基准点移动位置。 学习定位重点学会子绝父相。 注意： 边偏移需要和定位模式联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 2. 综合案例：学成在线-hot 模块添加 2. 1 案例截图： 2.2 案例分析 一个大的 li 中包含 一个课程图片，课程介绍文字信息，还有hot的小图标； hot图片重叠在课程图片上面—— 脱标，不占位置，需要使用绝对定位； hot图片重叠在li的右上方 —— 需要使用边偏移确定准确位置。 2.3 案例小结 子绝父相 —— 子元素使用绝对定位，父元素使用相对定位； 与浮动的对比： 绝对定位：脱标，利用边偏移指定准确位置； 浮动：脱标，不能指定准确位置，让多个块级元素在一行显示。 课堂练习：模拟老师的随堂案例完成哈根达斯案例（5 分钟）。 结构修改： 123456789101112131415&lt;!-- 修改.box-bd里面的li标签内容，添加一个hot图标 --&gt;&lt;li&gt; &lt;!-- 添加hot小图片 --&gt; &lt;em&gt; &lt;img src=&quot;images/hot.png&quot; alt=&quot;&quot;&gt; &lt;/em&gt; &lt;img src=&quot;images/pic.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt; Think PHP 5.0 博客系统实战项目演练 &lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt;&lt;/li&gt; 样式修改： 123456789101112131415161718192021222324252627.box-bd ul li &#123; /* 子绝父相 */ /* 父元素相对定位 */ position: relative; float: left; width: 228px; height: 270px; background-color: #fff; margin-right: 15px; margin-bottom: 15px;&#125;.box-bd ul li &gt; img &#123; width: 100%;&#125;.box-bd ul li h4 &#123; margin: 20px 20px 20px 25px; font-size: 14px; color: #050505; font-weight: 400;&#125;.box-bd ul li em &#123; /* 子元素绝对定位 */ position: absolute; top: 4px; right: -4px;&#125; 3. 定位(position)的应用 3.1. 固定定位小技巧： 固定在版心左侧位置。 小算法： 1.让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。 2.让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。 案例效果： 123456789101112131415161718192021222324&lt;style&gt; .w &#123; width: 800px; height: 1400px; background-color: pink; margin: 0 auto; &#125; .fixed &#123; position: fixed; /* 1. 走浏览器宽度的一半 */ left: 50%; /* 2. 利用margin 走版心盒子宽度的一半距离 */ margin-left: 405px; width: 50px; height: 150px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt; &lt;div class=&quot;w&quot;&gt;版心盒子 800像素&lt;/div&gt;&lt;/body&gt; 3.2. 堆叠顺序（z-index） 在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴) 语法： 123选择器 &#123; z-index: 1; &#125; z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。如下图所示： 案例演示：堆叠顺序。 4. 定位(position)的拓展 4.1 绝对定位的盒子居中：注意不能用margin：0 auto 注意：加了绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中。 但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 盒子居中定位示意图 4.2 定位特殊特性 绝对定位和固定定位也和浮动类似。 1.行内元素添加绝对或者固定定位，可以直接设置高度和宽度。 2.块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。 前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 4.3 脱标的盒子不会触发外边距塌陷 浮动元素、**绝对定位(固定定位）**元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的） 也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。 4.4 绝对定位（固定定位）会完全压住盒子 浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片） 但是绝对定位（固定定位） 会压住下面标准流所有的内容。 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素 5. 综合案例 - 淘宝轮播图(重点) 5.1 效果图 5.2 布局分析 5.3 步骤 大盒子我们类名为： tb-promo 淘宝广告 里面先放一张图片。 左右两个按钮 用链接就好了。 左箭头 prev 右箭头 next ​ 左按钮样式（border-radius：左上，右上，右下，左下）， ​ 右按钮定位，提取左右按钮共同的样式代码（并集选择器） 底侧小圆点ul 继续做。 类名为 promo-nav ​ 中间长方形椭圆 ul的定位（水平居中，离底部15px） ​ 长方形需要五个小圆点，ul无序列表，li浮动，椭圆中小圆点的样式 5.4 知识点：圆角矩形设置4个角 圆角矩形可以为4个角分别设置圆度， 但是是有顺序的 1234border-top-left-radius:20px;border-top-right-radius:20px;border-bottom-right-radius:20px;border-bottom-left-radius:20px; 如果4个角，数值相同 1border-radius: 15px; 里面数值不同，我们也可以按照简写的形式，具体格式如下: 1border-radius: 左上角 右上角 右下角 左下角; 还是遵循的顺时针。 5.5 代码参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;淘宝轮播图做法&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; &#125; .tb-promo &#123; position: relative; width: 520px; height: 280px; background-color: pink; margin: 100px auto; &#125; .tb-promo img &#123; width: 520px; height: 280px; &#125; /* 并集选择器可以集体声明相同的样式 */ .prev, .next &#123; position: absolute; /* 绝对定位的盒子垂直居中 */ top: 50%; margin-top: -15px; /* 加了绝对定位的盒子可以直接设置高度和宽度 */ width: 20px; height: 30px; background: rgba(0, 0, 0, .3); text-align: center; line-height: 30px; color: #fff; text-decoration: none; &#125; .prev &#123; left: 0; /* border-radius: 15px; */ border-top-right-radius: 15px; border-bottom-right-radius: 15px; &#125; .next &#123; /* 如果一个盒子既有left属性也有right属性，则默认会执行 left属性 同理 top bottom 会执行 top */ right: 0; /* border-radius: 15px; */ border-top-left-radius: 15px; border-bottom-left-radius: 15px; &#125; .promo-nav &#123; position: absolute; bottom: 15px; left: 50%; margin-left: -35px; width: 70px; height: 13px; /* background-color: pink; */ background: rgba(255,255,255, .3); border-radius: 7px; &#125; .promo-nav li &#123; float: left; width: 8px; height: 8px; background-color: #fff; border-radius: 50%; margin: 3px; &#125; /* 不要忘记选择器权重的问题 */ .promo-nav .selected &#123; background-color: #ff5000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tb-promo&quot;&gt; &lt;img src=&quot;images/tb.jpg&quot; alt=&quot;&quot;&gt; &lt;!-- 左侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;prev&quot;&gt; &lt; &lt;/a&gt; &lt;!-- 右侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;next&quot;&gt; &gt; &lt;/a&gt; &lt;!-- 小圆点 --&gt; &lt;ul class=&quot;promo-nav&quot;&gt; &lt;li class=&quot;selected&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. 网页布局总结 通过盒子模型，清楚知道大部分html标签是一个盒子。 通过CSS浮动、定位 可以让每个盒子排列成为网页。 一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。 6.1. 标准流 可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。 6.2. 浮动 可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局 6.3. 定位 定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 7. 元素的显示与隐藏 目的（本质） ​ 让一个元素在页面中消失或者显示出来 场景 ​ 类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 7.1. display 显示（重点） display 设置或检索对象是否及如何显示。 123display: none 隐藏对象display：block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： display 隐藏元素后，不再占有原来的位置。 后面应用及其广泛，搭配 JS 可以做很多的网页特效。实际开发场景： 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 7.2. visibility 可见性 （了解） visibility 属性用于指定一个元素应可见还是隐藏。 123visibility：visible ; 元素可视visibility：hidden; 元素隐藏 特点：visibility 隐藏元素后，继续占有原来的位置。（停职留薪） 如果隐藏元素想要原来位置， 就用 visibility：hidden 如果隐藏元素不想要原来位置， 就用 display：none (用处更多 重点） 7.3. overflow 溢出（重点） overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。 但是如果有定位的盒子， 请慎用overflow:hidden 因为它会隐藏多余的部分。 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 7.4. 显示与隐藏总结 属性 区别 用途 display 显示 （重点） 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 可见性 （了解） 隐藏对象，保留位置 使用较少 overflow 溢出（重点） 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 8 综合案例：土豆网鼠标经过显示遮罩 8.1. 效果图 8.2. 案例目标 1.练习元素的显示与隐藏 2.练习元素的定位 8.3. 核心原理 原先半透明的黑色遮罩看不见， 鼠标经过 大盒子，就显示出来。 遮罩的盒子不占有位置， 就需要用绝对定位 和 display 配合使用。 8.4. 代码参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;仿土豆网显示隐藏遮罩案例&lt;/title&gt; &lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .mask &#123; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面遮罩层显示出来 */ .tudou:hover .mask &#123; /* 而是显示元素 */ display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS绝对定位","slug":"CSS绝对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS相对定位","slug":"CSS相对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS定位注意事项","slug":"CSS定位注意事项","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AE%9A%E4%BD%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"CSS子绝父相","slug":"CSS子绝父相","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8/"},{"name":"CSS元素显示与隐藏","slug":"CSS元素显示与隐藏","permalink":"https://xqc-1368.github.io/tags/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"name":"CSS溢出处理","slug":"CSS溢出处理","permalink":"https://xqc-1368.github.io/tags/CSS%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/"}]},{"title":"CSS浮动布局","slug":"08 CSS 浮动布局 float","date":"2024-08-17T02:28:01.400Z","updated":"2024-08-17T02:11:10.177Z","comments":true,"path":"2024/08/17/08 CSS 浮动布局 float/","permalink":"https://xqc-1368.github.io/2024/08/17/08%20CSS%20%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80%20float/","excerpt":"","text":"一、浮动 1、传统网页布局的三种方式 ​ CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)： 普通流（标准流） 浮动 定位 这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。 注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。 2、标准流（普通流/文档流） 所谓的标准流: 就是标签按照规定好默认方式排列 块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等 以上都是标准流布局，我们前面学习的就是标准流，标准流是最基本的布局方式。 3、为什么需要浮动？ ​ 总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式. ​ 浮动最典型的应用：可以让多个块级元素一行内排列显示。 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 4、什么是浮动？ ​ float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 语法： 1选择器 &#123; float: 属性值; &#125; 5、浮动特性 加了浮动之后的元素,会具有很多特性,需要我们掌握的. 1、浮动元素会脱离标准流(脱标：浮动的盒子不再保留原先的位置) 2、浮动的元素会一行内显示并且元素顶部对齐 注意： ​ 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。 3、浮动的元素会具有行内块元素的特性 如果行内元素or块元素有了浮动，则都自动转换为行内块元素 ​ 浮动元素的大小根据内容来决定 ​ 浮动的盒子中间是没有缝隙的 6、浮动元素经常和标准流父级搭配使用 为了约束浮动元素位置, 我们网页布局一般采取的策略是: ​ 先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧 二、常见网页布局 浮动布局注意点 1、浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置 2、一个元素浮动了，理论上其余的兄弟元素也要浮动。 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流. 三、清除浮动 1、为什么需要清除浮动？ ​ 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。 2、清除浮动本质 清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度 注意： 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。 父级有了高度，就不会影响下面的标准流了 3、清除浮动样式 语法： 1选择器&#123;clear:属性值;&#125; 我们实际工作中， 几乎只用 clear: both; 清除浮动的策略是: 闭合浮动. 4、清除浮动的多种方式 自动设置父div的高度 4.1、额外标签法（不常用） 额外标签法也称为隔墙法，是 W3C 推荐的做法。 使用方式： ​ 额外标签法会在浮动元素末尾添加一个空的标签。 1例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;，或者其他标签（如&lt;br /&gt;等）。 ​ 优点： 通俗易懂，书写方便 ​ 缺点： 添加许多无意义的标签，结构化较差 ​ 注意： 要求这个新的空标签必须是块级元素。 总结: ​ 1、清除浮动本质是? ​ 清除浮动的本质是清除浮动元素脱离标准流造成的影响 ​ 2、清除浮动策略是? ​ 闭合浮动. 只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子. ​ 3、额外标签法? ​ 隔墙法, 就是在最后一个浮动的子元素后面添 ​ 4、加一个额外标签, 添加 清除浮动样式. ​ 实际工作可能会遇到,但是不常用 4.2、父级添加 overflow 属性 可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。 例如： 1overflow:hidden | auto | scroll; 优点：代码简洁 缺点：无法显示溢出的部分 注意：是给父元素添加代码 4.3、父级添加after伪元素 :after 方式是额外标签法的升级版。给父元素添加： 12345678910.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; /* IE6、7 专有 */ *zoom: 1;&#125; 在父元素里面写成： 123&lt;div class=&quot;原有类 clearfix&quot;&gt; ......&lt;/div&gt; 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站： 百度、淘宝网、网易等 4.4、父级添加双伪元素 给父元素添加 12345678910.clearfix:before,.clearfix:after &#123; content:&quot;&quot;; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 在父元素里面写成： 123&lt;div class=&quot;原有类 clearfix&quot;&gt; ......&lt;/div&gt; 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 总结 为什么需要清除浮动？ 父级没高度。 子盒子浮动了。 影响下面布局了，我们就应该清除浮动了。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS浮动float","slug":"CSS浮动float","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B5%AE%E5%8A%A8float/"},{"name":"CSS清除浮动","slug":"CSS清除浮动","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"}]},{"title":"CSS盒子模型","slug":"07 CSS 盒子模型 BoxModel","date":"2024-08-17T02:28:01.389Z","updated":"2024-08-17T02:05:56.499Z","comments":true,"path":"2024/08/17/07 CSS 盒子模型 BoxModel/","permalink":"https://xqc-1368.github.io/2024/08/17/07%20CSS%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%20BoxModel/","excerpt":"","text":"一、盒子模型 1、网页布局的本质 网页布局的核心本质： 就是利用 CSS 摆盒子。 网页布局过程： 先准备好相关的网页元素，网页元素基本都是盒子 Box 。 利用 CSS 设置好盒子样式，然后摆放到相应位置。 往盒子里面装内容 2、盒子模型（Box Model）组成 ​ 盒子模型：把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 ​ CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 实际内容 3、边框（border） 3.1、边框的使用 1、border可以设置元素的边框。边框有三部分组成：边框宽度(粗细) 边框样式 边框颜色； 2、语法： 1border : border-width || border-style || border-color; 边框样式 border-style 可以设置如下值： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 3、边框的合写分写 边框简写： 1border: 1px solid red; 边框分开写法： 1border-top: 1px solid red; /* 只设定上边框， 其余同理 */ 3.2、表格的细线边框 123456789101112&lt;style&gt; table&#123; width:500px; height:249px; &#125; table,td,th&#123; border:1px solid pink; border-collapse:collaspe; font-size:14px; text-align:center; &#125;&lt;/style&gt; 1、border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 2、语法： 1border-collapse:collapse; collapse 单词是合并的意思 border-collapse: collapse; 表示相邻边框合并在一起 3.3、边框会影响盒子实际大小 边框会额外增加盒子的实际大小。因此我们有两种方案解决： 测量盒子大小的时候,不量边框。 如果测量的时候包含了边框,则需要 width/height 减去边框宽度 4、内边距（padding） 4.1、内边距的使用方式 1、padding 属性用于设置内边距，即边框与内容之间的距离。 2、语法： 合写属性： 分写属性： 4.2、内边距会影响盒子实际大小 1、当我们给盒子指定 padding 值之后，发生了 2 件事情： 内容和边框有了距离，添加了内边距。 padding影响了盒子实际大小。 2、内边距对盒子大小的影响： 如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。 如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小。 3、解决方案： ​ 如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。 利用padding撑开盒子做法：导航栏字数不同时候 5、外边距（margin） 5.1、外边距的使用方式 123&lt;style&gt; p&#123;margin-top:30px;&#125;&lt;/style&gt; margin 属性用于设置外边距，即控制盒子和盒子之间的距离。 5.2、外边距典型应用 外边距可以让块级盒子水平居中的两个条件： 盒子必须指定了宽度（width）。 盒子左右的外边距都设置为 auto 。 常见的写法，以下三种都可以： 123margin-left: auto; margin-right: auto;margin: auto;margin: 0 auto; 注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。 5.3、外边距合并 使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。 主要有两种情况: 1、相邻块元素垂直外边距的合并 ​ 当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。 解决方案： 尽量只给一个盒子添加 margin 值。 2、嵌套块元素垂直外边距的塌陷 ​ 对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方案： 可以为父元素定义上边框。 .father&#123; border:1px solid transparent; &#125; &lt;!--code￼7--&gt; 可以为父元素添加 overflow:hidden。(不会使盒子变大) .father&#123; overflow:hidden; &#125; &lt;!--code￼8--&gt; ​ 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了 二、盒子模型的其他样式 1、圆角边框 在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。 border-radius 属性用于设置元素的外边框圆角。 语法： 1border-radius:length; 参数值可以为数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius 兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用 2、盒子阴影 CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。 语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 1box-shadow:10px 10px 10px -4px rgba(0,0,0,.3) 3、文字阴影 在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。 语法： 1text-shadow: h-shadow v-shadow blur color; 1text-shadow: 5px 5px 6px rgba(0,0,0,.3)","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS盒子模型","slug":"CSS盒子模型","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"name":"CSS边框样式","slug":"CSS边框样式","permalink":"https://xqc-1368.github.io/tags/CSS%E8%BE%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/"},{"name":"CSS内边距padding","slug":"CSS内边距padding","permalink":"https://xqc-1368.github.io/tags/CSS%E5%86%85%E8%BE%B9%E8%B7%9Dpadding/"},{"name":"CSS外边距margin","slug":"CSS外边距margin","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%96%E8%BE%B9%E8%B7%9Dmargin/"},{"name":"CSS清除内外边距","slug":"CSS清除内外边距","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E5%86%85%E5%A4%96%E8%BE%B9%E8%B7%9D/"},{"name":"CSS圆角边框","slug":"CSS圆角边框","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/"},{"name":"CSS盒子阴影","slug":"CSS盒子阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1/"}]},{"title":"CSS显示模式","slug":"06 CSS 元素的显示模式","date":"2024-08-17T02:28:01.364Z","updated":"2024-08-17T02:37:08.439Z","comments":true,"path":"2024/08/17/06 CSS 元素的显示模式/","permalink":"https://xqc-1368.github.io/2024/08/17/06%20CSS%20%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、css的显示模式 1、什么是元素的显示模式 定义： ​ 元素显示模式就是元素（标签）以什么方式进行显示，比如自己占一行，比如一行可以放多个。 作用： ​ 网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。 2、元素显示模式的分类 2.1、块元素 常见的块元素： 1&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; ​ 标签是最典型的块元素。 块级元素的特点： 比较霸道，自己独占一行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： ​ 文字类的元素内不能放块级元素 12&lt;p&gt; 标签主要用于存放文字，因此 &lt;p&gt; 里面不能放块级元素，特别是不能放&lt;div&gt; 同理， &lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 2.2、行内元素 常见的行内元素： 1&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; ​ 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 12345&lt;style&gt; span&#123; background-color:hotpink; &#125;&lt;/style&gt; 注意： 链接里面不能再放链接 特殊情况链接 &lt;a&gt; 里面可以放块级元素，但是给 &lt;a&gt; 转换一下块级模式最安全 2.3、行内块元素 常见的行内块标签： 1&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt; ​ 它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 行内块元素的特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。 一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点）。 123456&lt;style&gt; input&#123; width:250px; height:39px; &#125;&lt;/style&gt; 2.4、元素显示模式总结 ​ 学习元素显示模式的主要目的就是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。 3、元素显示模式的转换 简单理解: ​ 一个模式的元素需要另外一种模式的特性 ​ 比如想要增加链接 &lt;a&gt; 的触发范围。 转换方式 转换为块元素：display:block; 转换为行内元素：display:inline; 转换为行内块：display: inline-block; 123456789101112131415161718&lt;style&gt; a&#123; height:150px; width:150px; background-color:pink; display:block; &#125; div&#123; background-color:purple; display:inline; &#125; span&#123; height:300px; width:30px; background-color:blue; display:inline-block; &#125;&lt;/style&gt; 案例，小米侧边栏 4、单行文字垂直居中的代码 解决方案: ​ 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中 实现： line-height:40px; 简单理解: ​ 行高的上空隙和下空隙把文字挤到中间了， ​ 如果行高小于盒子高度,文字会偏上， ​ 如果行高大于盒子高度,则文字偏下。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS显示模式","slug":"CSS显示模式","permalink":"https://xqc-1368.github.io/tags/CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"},{"name":"CSS块元素","slug":"CSS块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS行内元素","slug":"CSS行内元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"},{"name":"CSS行内块元素","slug":"CSS行内块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0/"}]},{"title":"CSS选择器","slug":"05 CSS 选择器 Selector","date":"2024-08-17T02:28:01.343Z","updated":"2024-08-17T01:57:46.906Z","comments":true,"path":"2024/08/17/05 CSS 选择器 Selector/","permalink":"https://xqc-1368.github.io/2024/08/17/05%20CSS%20%E9%80%89%E6%8B%A9%E5%99%A8%20Selector/","excerpt":"","text":"一、选择器分类 基本语法架构： CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明 CSS声明总是以分号 ; 结束，声明总以大括号 &#123;&#125; 括起来: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 标签选择器 1234p &#123; color:red; text-align:center;&#125; 类选择器 class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以一个点 . 号显示： 在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。 1.center &#123;text-align:center;&#125; 1在标签里面加上：class=&quot;nounderline gray&quot;就可以用了 你也可以指定特定的 HTML 元素使用 class。 在以下实例中, 所有的 p 元素使用 class=“center” 让该元素的文本居中: 1p.center &#123;text-align:center;&#125; id选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 以下的样式规则应用于元素属性 id=“para1”: 12345#para1&#123; text-align:center; color:red;&#125; 通配符选择器 1234*&#123; 属性1：属性值1 ; ......&#125; 二、css的复合选择器 1、什么是复合选择器？ ​ 在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。 ​ 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签） ​ 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等 2、后代选择器 (重要） 定义： ​ 后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 语法：(在head里面) 1234567891011121314&lt;style&gt; ol li &#123; color:pink; &#125; ol li a&#123; color:red; &#125;nav为class名 .nav li a&#123; color:yellow; &#125;&lt;/style&gt; ​ 上述语法表示选择元素 1 里面的所有元素 2 (后代元素)。 语法说明： 元素1 和 元素2 中间用空格隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可 元素1 和 元素2 可以是任意基础选择器 3、子选择器 (重要） 定义： ​ 子元素选择器（子选择器）只能选择作为某元素的最近一级子元素。 ​ （简单理解就是选亲儿子元素） 语法： 12345&lt;style&gt; .nav&gt;a&#123; color:red; &#125;&lt;/style&gt; ​ 上述语法表示选择元素1 里面的所有直接后代(子元素) 元素2。 语法说明： 元素1 和 元素2 中间用 大于号 隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 必须是亲儿子，其孙子、重孙之类都不归他管. 你也可以叫他 亲儿子选择器 例子： 4、并集选择器 (重要） 定义： ​ 并集选择器可以选择多组标签, 同时为他们定义相同的样式，通常用于集体声明。并集选择器是各选择器通过英文逗号（,）连接而成，任何形式的选择器都可以作为并集选择器的一部分。 语法： 1234567891011&lt;style&gt; div,p&#123; color:pink; &#125;或者 div, p, .pig li&#123; color:pink; &#125;&lt;/style&gt; ​ 上述语法表示选择元素1 和 元素2。 语法说明： 元素1 和 元素2 中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 例子： 5、伪类选择器 定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法： ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 6、链接伪类选择器 定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法：（请按照LVHA顺序书写，不能换序） 123456789101112131415&lt;style&gt; a:link&#123; color:#333 text-decoration:none; &#125; a:visited&#123; color:orange; &#125; a:hover&#123; color:skyblue; &#125; a:active&#123; color:green; &#125;&lt;/style&gt; ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 ​ a:link 没有点击过的(访问过的)链接 ​ a:visited 点击过的(访问过的)链接 ​ a:hover 鼠标经过的那个链接 ​ a:active 鼠标正在按下还没有弹起鼠标的那个链接 链接伪类选择器注意事项 ​ 为了确保生效，请按照 LVHA 的循顺序声明 :link－:visited－:hover－:active。 ​ 记忆法：love hate 或者 lv 包包 hao 。 ​ 因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 12345&lt;style&gt; a&#123; color:red; &#125;&lt;/style&gt; 链接伪类选择器实际工作开发中的写法：(重要) 7、:focus 伪类选择器 定义： ​ :focus 伪类选择器用于选取获得焦点的表单元素。 ​ 焦点就是光标，一般情况 类表单元素才能获取 例子： 123456&lt;style&gt; input:focus&#123; background-color:pink; color:red; &#125;&lt;/style&gt; 复合选择器总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS复合选择器","slug":"CSS复合选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS伪元素选择器","slug":"CSS伪元素选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS链接伪类选择器","slug":"CSS链接伪类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS属性选择器","slug":"CSS属性选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS类选择器","slug":"CSS类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS标签选择器","slug":"CSS标签选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSSID选择器","slug":"CSSID选择器","permalink":"https://xqc-1368.github.io/tags/CSSID%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS通配符选择器","slug":"CSS通配符选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%9A%E9%85%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS后代选择器","slug":"CSS后代选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS子选择器","slug":"CSS子选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS并集选择器","slug":"CSS并集选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"CSS背景","slug":"04 CSS 背景 background","date":"2024-08-17T02:28:01.319Z","updated":"2024-08-17T01:54:26.951Z","comments":true,"path":"2024/08/17/04 CSS 背景 background/","permalink":"https://xqc-1368.github.io/2024/08/17/04%20CSS%20%E8%83%8C%E6%99%AF%20background/","excerpt":"","text":"一、背景基础 CSS 背景属性用于定义HTML元素的背景。 CSS 属性定义背景效果: background-color background-color 属性定义了元素的背景颜色，页面的背景颜色使用在body的选择器中: 1body &#123;background-color:#b0c4de;&#125; 二、css的背景样式 通过 CSS 背景属性，可以给页面元素添加背景样式。 背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 1、背景颜色 样式名称： ​ background-color 定义元素的背景颜色 使用方式： 1background-color:颜色值; 其他说明： ​ 元素背景颜色默认值是 transparent（透明） 1background-color:transparent; 2、背景图片 样式名称： ​ background-image 定义元素的背景图片 使用方式： 1background-image:url(images/logo.png) 其他说明： ​ 实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置. (精灵图也是一种运用场景) ​ 注意：背景图片后面的地址，千万不要忘记加 URL， 同时里面的路径不要加引号。 3、背景平铺 样式名称： ​ background-repeat 设置元素背景图像的平铺 1background-repeat:repeat|no-repeat|repeat-x|repeat-y 使用方式： 4、背景图片位置 样式名称： ​ background-position 属性可以改变图片在背景中的位置 使用方式： ​ ​ 参数代表的意思是：x 坐标和 y 坐标。 可以使用 方位名词 或者 精确单位 其他说明： 1、参数是方位名词 ​ 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致 ​ 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 2、参数是精确单位 ​ 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标 ​ 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中 1background-poisition:20px 50px; 3、参数是混合单位 ​ 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标 wzry成长守护平台案例 虞姬皮肤全屏背景案例 5、背景图片固定 样式名称： ​ background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。 使用方式： ​ 其他说明： ​ background-attachment 后期可以制作视差滚动的效果。 6、背景样式合写 背景合写样式： ​ background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置; 使用方式： 7、背景色半透明 CSS3 提供了背景颜色半透明的效果。 使用方式： 最后一个参数是 alpha 透明度，取值范围在 0~1之间 我们习惯把 0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明，盒子里面的内容不受影响 CSS3 新增属性，是 IE9+ 版本浏览器才支持的，但是现在实际开发,我们不太关注兼容性写法了,可以放心使用 8、背景总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS背景","slug":"CSS背景","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF/"},{"name":"CSS背景平铺","slug":"CSS背景平铺","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%B9%B3%E9%93%BA/"},{"name":"CSS背景图片位置","slug":"CSS背景图片位置","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/"}]},{"title":"CSS字体","slug":"03 CSS 字体 font","date":"2024-08-17T02:28:01.297Z","updated":"2024-08-17T01:55:51.059Z","comments":true,"path":"2024/08/17/03 CSS 字体 font/","permalink":"https://xqc-1368.github.io/2024/08/17/03%20CSS%20%E5%AD%97%E4%BD%93%20font/","excerpt":"","text":"一、CSS 字体 CSS字体属性定义字体，加粗，大小，文字样式。 Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 字体系列 font-family 属性设置文本的字体系列。 font-family 属性应该设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，他将尝试下一种字体。 注意: 如果字体系列的名称超过一个字，它必须用引号，如Font Family：“宋体”。 多个字体系列是用一个逗号分隔指明： 1p&#123;font-family:&quot;Times New Roman&quot;, Times, serif;&#125; 字体样式 主要是用于指定斜体文字的字体样式属性。 这个属性有三个值： 正常 - 正常显示文本 斜体 - 以斜体字显示的文字 倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）字体大小 123p.normal &#123;font-style:normal;&#125;p.italic &#123;font-style:italic;&#125;p.oblique &#123;font-style:oblique;&#125;/*没什么用*/ 字体大小 font-size 属性设置文本的大小。 能否管理文字的大小，在网页设计中是非常重要的。但是，你不能通过调整字体大小使段落看上去像标题，或者使标题看上去像段落。 绝对大小： 设置一个指定大小的文本 不允许用户在所有浏览器中改变文本大小 确定了输出的物理尺寸时绝对大小很有用 相对大小： 相对于周围的元素来设置大小 允许用户在浏览器中改变文字大小 如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。 设置字体大小像素(绝对大小): 123h1 &#123;font-size:40px;&#125;h2 &#123;font-size:30px;&#125;p &#123;font-size:14px;&#125; 用em来设置字体大小(相对大小): 1h1 &#123;font-size:2.5em;&#125; font-weight 属性 123p.normal &#123;font-weight:normal;&#125;p.thick &#123;font-weight:bold;&#125;p.thicker &#123;font-weight:900;&#125; 属性值 值 描述 normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100 200 300 400 500 600 700 800900 定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold。 inherit 规定应该从父元素继承字体的粗细。 font复合属性 font 简写属性在一个声明中设置所有字体属性。 可设置的属性是（按顺序）： “font-style font-variant font-weight font-size/line-height font-family” font-size和font-family的值是必需的。如果缺少了其他值，默认值将被插入，如果有默认值的话。 123456789p.ex1&#123; font:15px arial,sans-serif;&#125;p.ex2&#123; font:italic bold 12px/30px Georgia, serif;&#125; 二、CSS 文本格式 文本颜色 颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 参阅 CSS 颜色值 查看完整的颜色值。 一个网页的背景颜色是指在主体内的选择： 123body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式 文本排列属性是用来设置文本的水平对齐方式。 文本可居中或对齐到左或右,两端对齐. 当text-align设置为&quot;justify&quot;，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。 123h1 &#123;text-align:center;&#125;p.date &#123;text-align:right;&#125;p.main &#123;text-align:justify;&#125; 文本修饰 text-decoration 属性用来设置或删除文本的装饰。 从设计的角度看 text-decoration属性主要是用来删除链接的下划线： 1a &#123;text-decoration:none;&#125; 也可以这样装饰文字： 123h1 &#123;text-decoration:overline;&#125;h2 &#123;text-decoration:line-through;&#125;h3 &#123;text-decoration:underline;&#125; 文本转换 文本转换属性是用来指定在一个文本中的大写和小写字母。 可用于所有字句变成大写或小写字母，或每个单词的首字母大写。 123p.uppercase &#123;text-transform:uppercase;&#125;p.lowercase &#123;text-transform:lowercase;&#125;p.capitalize &#123;text-transform:capitalize;&#125; 文本缩进 文本缩进属性是用来指定文本的第一行的缩进。 1p &#123;text-indent:50px;&#125; 三、文字阴影 在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。 语法： 1text-shadow: h-shadow v-shadow blur color; 1text-shadow: 5px 5px 6px rgba(0,0,0,.3)","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS文本格式属性","slug":"CSS文本格式属性","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%B1%9E%E6%80%A7/"},{"name":"CSS文本修饰","slug":"CSS文本修饰","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/"},{"name":"CSS文本对齐","slug":"CSS文本对齐","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS字体font","slug":"CSS字体font","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93font/"}]},{"title":"CSS配套工具","slug":"02 CSS 配套实用工具emmet，PS","date":"2024-08-17T02:28:01.281Z","updated":"2024-08-17T01:45:51.423Z","comments":true,"path":"2024/08/17/02 CSS 配套实用工具emmet，PS/","permalink":"https://xqc-1368.github.io/2024/08/17/02%20CSS%20%E9%85%8D%E5%A5%97%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7emmet%EF%BC%8CPS/","excerpt":"","text":"一、emmet语法 1、简介 ​ Emmet语法的前身是Zen coding,它使用缩写,来提高html/css的编写速度, Vscode内部已经集成该语法。 作用： ​ 快速生成HTML结构语法 ​ 快速生成CSS样式语法 2、快速生成HTML结构语法 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成&lt;div&gt;&lt;/div&gt; 如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 如果生成的div 类名是有顺序的， 可以用 自增符号 $ 如果想要在生成的标签内部写内容可以用 { } 表示 3、快速生成CSS样式语法 CSS 基本采取简写形式即可 ​ 比如 w200 按tab 可以 生成 width: 200px; ​ 比如 lh26px 按tab 可以生成 line-height: 26px; 4、快速格式化代码 Vscode 快速格式化代码: shift+alt+f 也可以设置 当我们 保存页面的时候自动格式化代码: 1）文件 ------.&gt;【首选项】----------&gt;【设置】； 2）搜索emmet.include; 3）在settings.json下的【工作区设置】中添加以下语句： ​ “editor.formatOnType”: true, ​ “editor.formatOnSave”: true 二、PS 基本操作 ​ 因为网页美工大部分效果图都是利用 PS（Photoshop）来做的，所以以后我们大部分切图工作都是在 PS 里面完成。 ​ 部分操作： 文件→打开 ：可以打开我们要测量的图片 Ctrl+R：可以打开标尺，或者 视图→标尺 右击标尺，把里面的单位改为像素 Ctrl+ 加号(+)可以放大视图， Ctrl+ 减号(-)可以缩小视图 按住空格键，鼠标可以变成小手，拖动 PS 视图 用选区拖动 可以测量大小 Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区 三、PS 切图 1、图层切图 1最简单的切图方式：右击图层 → 导出 → 切片。 2、切片切图 2.1、利用切片选中图片 1利用切片工具手动划出 2.2、导出选中的图片 1文件菜单 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储 。 3、PS插件切图 ​ Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 官网：http://www.cutterman.cn/zh/cutterman 注意：Cutterman 插件要求你的 PS 必须是完整版，不能是绿色版，所以大家需要安装完整版本。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"emmet","slug":"emmet","permalink":"https://xqc-1368.github.io/tags/emmet/"},{"name":"PS","slug":"PS","permalink":"https://xqc-1368.github.io/tags/PS/"}]},{"title":"CSS简介","slug":"01 CSS 注释，三大特性，三种样式表","date":"2024-08-17T02:27:57.504Z","updated":"2024-08-17T02:32:33.313Z","comments":true,"path":"2024/08/17/01 CSS 注释，三大特性，三种样式表/","permalink":"https://xqc-1368.github.io/2024/08/17/01%20CSS%20%E6%B3%A8%E9%87%8A%EF%BC%8C%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E4%B8%89%E7%A7%8D%E6%A0%B7%E5%BC%8F%E8%A1%A8/","excerpt":"","text":"CSS (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS 文件扩展名为 .css。 一、CSS 注释 注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它。 CSS注释以 /* 开始, 以 */ 结束, 实例如下: 12/*这是个注释*/ /*这是另一个注释*/ 二、css三大特性 1、层叠性 ​ 相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题 ​ 层叠性原则: 样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 2、继承性 ​ CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。 子元素可以继承父元素的样式： ​ （text-，font-，line-这些元素开头的可以继承，以及color属性） 继承性口诀：龙生龙，凤生凤，老鼠生的孩子会打洞 行高的继承性： 123body &#123; font:12px/1.5 Microsoft YaHei；&#125; 行高可以跟单位也可以不跟单位 如果子元素没有设置行高，则会继承父元素的行高为 1.5 此时子元素的行高是：当前子元素的文字大小 * 1.5 body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高 3、优先级 当同一个元素指定多个选择器，就会有优先级的产生。 选择器相同，则执行层叠性 选择器不同，则根据选择器权重执行 选择器优先级计算表格： 优先级注意点: 权重是有4组数字组成,但是不会有进位。 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推… 等级判断从左向右，如果某一位数值相同，则判断下一位数值。 可以简单记忆法: 通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。 a链接浏览器默认制定了一个样式：蓝色下划线 a &#123;color:blue;&#125;因此需要手动指定样式 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。 权重虽然可以叠加，但是不存在进位 div ul li ------&gt; 0,0,0,3 .nav ul li ------&gt; 0,0,1,2 a:hover -----—&gt; 0,0,1,1 .nav a ------&gt; 0,0,1,1 案例1：继承权重为0 案例2：权重叠加 三、CSS 三种样式表 当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。 如何插入样式表？ 插入样式表的方法有三种: 外部样式表(External style sheet) 内部样式表(Internal style sheet) 内联样式(Inline style) 外部样式表 当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 标签链接到样式表。 标签在（文档的）头部： 1234&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;/*href后面跟css文件路径*/&lt;/head&gt; 内部样式表 当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 1234567&lt;head&gt;&lt;style&gt;hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125;&lt;/style&gt;&lt;/head&gt; 内联样式（行内样式） 由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。 要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距： 1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS注释","slug":"CSS注释","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B3%A8%E9%87%8A/"},{"name":"CSS的插入","slug":"CSS的插入","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9A%84%E6%8F%92%E5%85%A5/"},{"name":"CSS优先级问题","slug":"CSS优先级问题","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"}]},{"title":"CSS杂项","slug":"10 CSS杂项","date":"2024-08-17T02:27:56.205Z","updated":"2024-08-17T02:27:36.920Z","comments":true,"path":"2024/08/17/10 CSS杂项/","permalink":"https://xqc-1368.github.io/2024/08/17/10%20CSS%E6%9D%82%E9%A1%B9/","excerpt":"","text":"CSS杂项 学习目标： ​ 能够使用精灵图 ​ 能够使用字体图标 ​ 能够写出 CSS 三角 ​ 能够写出常见的 CSS 用户界面样式 ​ 能够说出常见的布局技巧 1. 精灵图（重点） 1.1 为什么需要精灵图 一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。 为什么使用精灵图（目的）： ​ 为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。 核心原理： ​ 将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。 精灵图举例: 1.2 精灵图（sprites）的使用 使用精灵图核心： 精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。 这个大图片也称为 sprites 精灵图 或者 雪碧图 移动背景图片位置， 此时可以使用 background-position 。 移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同 因为一般情况下都是往上往左移动，所以数值是负值。 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。 使用精灵图核心总结： 精灵图主要针对于小的背景图片使用。 主要借助于背景位置来实现—background-position 。 一般情况下精灵图都是负值。（千万注意网页中的坐标： x轴右边走是正值，左边走是负值， y轴同理。） 1.3 案例：拼出自己名字 1.3.1 案例效果 1.3.2 代码参考 结构 1234&lt;span class=&quot;p&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;i&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;k&lt;/span&gt; 样式 12345678910111213141516171819202122232425262728span &#123; display: inline-block; background: url(images/abcd.jpg) no-repeat;&#125;.p &#123; width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px;&#125;.i &#123; width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px;&#125;.n &#123; width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px;&#125;.k &#123; width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px;&#125; 2. 字体图标 2.1 字体图标的产生 字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标。 精灵图是有诸多优点的，但是缺点很明显。 1.图片文件还是比较大的。 2.图片本身放大和缩小会失真。 3.一旦图片制作完毕想要更换非常复杂。 此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。 字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。 2.2 字体图标的优点 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器，请放心使用 注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。 总结： 1.如果遇到一些结构和样式比较简单的小图标，就用字体图标。 2.如果遇到一些结构和样式复杂一点的小图片，就用精灵图。 使用步骤 字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为： 1.字体图标的下载 2.字体图标的引入 （引入到我们html页面中） 3.字体图标的追加 （以后添加新的小图标） 2.3 字体图标的下载 推荐下载网站： icomoon 字库 http://icomoon.io 推荐指数 ★★★★★ IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 阿里 iconfont 字库 http://www.iconfont.cn/ 推荐指数 ★★★★★ 这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 AI制作图标上传生成。 重点是，免费！ 2.4 字体图标的引入 下载完毕之后，注意原先的文件不要删，后面会用。 把下载包里面的 fonts 文件夹放入页面根目录下 字体文件格式 不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。 1).TureType( .ttf )格式.ttf字体是Windows和Mac的最常见的字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+； 2).Web Open Font Format( .woff )格式woff字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+； 3).Embedded Open Type( .eot )格式.eot字体是IE专用字体，支持这种字体的浏览器有IE4+； 4).SVG( .svg )格式.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+； 2.在 CSS 样式中全局声明字体： 简单理解把这些字体文件通过css引入到我们页面中。 一定注意字体文件路径的问题 复制过来： 12345678910@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?7kkyc2&#x27;); src: url(&#x27;fonts/icomoon.eot?7kkyc2#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?7kkyc2&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?7kkyc2&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?7kkyc2#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal;&#125; html 标签内添加小图标。 给标签定义字体。 123span &#123; font-family: &quot;icomoon&quot;;&#125; 甚至可以改变颜色： 注意：务必保证 这个字体和上面@font-face里面的字体保持一致 2.5 字体图标的追加 如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。 把压缩包里面的 selection.json 从新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。 2.6 字体图标加载的原理： 3. CSS 三角 3.1 介绍 网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标。 一张图， 你就知道 CSS 三角是怎么来的了, 做法如下： 123456789div &#123; width: 0; height: 0; border: 50px solid transparent; border-color: red green blue black;/*以下两句话为了照顾兼容性而写*/ line-height:0; font-size: 0;&#125; 我们用css 边框可以模拟三角效果 宽度高度为0 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了 为了照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0; 3.2 案例：京东三角 3.2.1效果图 3.2.2 代码参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS 三角制作&lt;/title&gt; &lt;style&gt; .box1 &#123; width: 0; height: 0; /* border: 10px solid pink; */ border-top: 10px solid pink; border-right: 10px solid red; border-bottom: 10px solid blue; border-left: 10px solid green; &#125; .box2 &#123; width: 0; height: 0; border: 50px solid transparent; border-left-color: pink; margin: 100px auto; &#125; .jd &#123; position: relative; width: 120px; height: 249px; background-color: pink; &#125; .jd span &#123; position: absolute; right: 15px; top: -10px; width: 0; height: 0; /* 为了照顾兼容性 */ line-height: 0; font-size: 0; border: 5px solid transparent; border-bottom-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;jd&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. CSS 用户界面样式 什么是界面样式 所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓 防止表单域拖拽 4.1 鼠标样式 cursor 123li &#123; cursor: pointer; &#125; 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 4.2 轮廓线 outline 给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。 123input &#123; outline: none; &#125; 4.3 防止拖拽文本域 resize 实际开发中，我们文本域右下角是不可以拖拽的。(文本域尽量把两个textarea标签，放到一行书写，不然会出现莫名空格) 123textarea&#123; resize: none;&#125; vertical-align 属性应用 5. vertical-align 属性应用 CSS 的 vertical-align 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 官方解释： 用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。（如果是块元素应该先转换为行内块元素） 语法：图文中线对齐，在图的样式中加： 1vertical-align : baseline | top | middle | bottom 5.1 图片、表单和文字对齐 图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。 此时可以给图片、表单这些行内块元素的 vertical-align 属性设置为 middle 就可以让文字和图片垂直居中对齐了。 5.2 解决图片底部默认空白缝隙问题 bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。 主要解决方法有两种： 1.给图片添加 vertical-align:middle | top| bottom 等。 （提倡使用的） 2.把图片转换为块级元素 display: block; 6. 溢出的文字省略号显示 6.1 单行文本溢出显示省略号 单行文本溢出显示省略号–必须满足三个条件： 12345678/*1. 先强制一行内显示文本*/ white-space: nowrap; （ 默认 normal 自动换行）/*2. 超出的部分隐藏*/ overflow: hidden;/*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; 6.2 多行文本溢出显示省略号（了解） 多行文本溢出显示省略号，有较大兼容性问题，适合于webKit浏览器或移动端（移动端大部分是webkit内核） 1234567891011121314/*1. 超出的部分隐藏 */overflow: hidden;/*2. 文字用省略号替代超出的部分 */text-overflow: ellipsis;/* 3. 弹性伸缩盒子模型显示 */display: -webkit-box;/* 4. 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。 7. 常见布局技巧 巧妙利用一个技术更快更好的布局： margin负值的运用 文字围绕浮动元素 行内块的巧妙运用 CSS三角强化 7.1. margin负值运用 1.让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框 2.鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index） 7.2 文字围绕浮动元素 效果 布局示意图 巧妙运用浮动元素不会压住文字的特性 7.3 行内块巧妙运用 页码在页面中间显示: 把这些链接盒子转换为行内块， 之后给父级指定 text-align:center; 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中 7.4. CSS 三角强化 案例 7.4.1 原理 12345678910111213141516171819202122232425&lt;style&gt; .box1 &#123; width: 0; height: 0; /* 把上边框宽度调大 */ /* border-top: 100px solid transparent; border-right: 50px solid skyblue; */ /* 左边和下边的边框宽度设置为0 */ /* border-bottom: 0 solid blue; border-left: 0 solid green; */ /* 1.只保留右边的边框有颜色 */ border-color: transparent red transparent transparent; /* 2. 样式都是solid */ border-style: solid; /* 3. 上边框宽度要大， 右边框 宽度稍小， 其余的边框该为 0 */ border-width: 100px 50px 0 0 ; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt; 7.4.2 案例效果 7.4.3 代码参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS三角强化的巧妙运用&lt;/title&gt; &lt;style&gt; .price &#123; width: 160px; height: 24px; line-height: 24px; border: 1px solid red; margin: 0 auto; &#125; .miaosha &#123; position: relative; float: left; width: 90px; height: 100%; background-color:red; text-align: center; color: #fff; font-weight: 700; margin-right: 8px; &#125; .miaosha i &#123; position: absolute; right: 0; top: 0; width: 0; height: 0; border-color: transparent #fff transparent transparent; border-style: solid; border-width: 24px 10px 0 0; &#125; .origin &#123; font-size: 12px; color: gray; text-decoration: line-through; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;price&quot;&gt; &lt;span class=&quot;miaosha&quot;&gt; ¥1650 &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 8. CSS 初始化 不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS 初始化 简单理解： CSS初始化是指重设浏览器的样式。 (也称为CSS reset） 每个网页都必须首先进行 CSS初始化。 这里我们以 京东CSS初始化代码为例。 Unicode编码字体： 把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。 比如： 黑体 \\9ED1\\4F53 宋体 \\5B8B\\4F53 微软雅黑 \\5FAE\\8F6F\\96C5\\9ED1","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS精灵图","slug":"CSS精灵图","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS字体图标","slug":"CSS字体图标","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"},{"name":"CSS三角绘制","slug":"CSS三角绘制","permalink":"https://xqc-1368.github.io/tags/CSS%E4%B8%89%E8%A7%92%E7%BB%98%E5%88%B6/"}]},{"title":"HTML列表","slug":"05 HTML 列表 list","date":"2024-08-16T14:35:51.896Z","updated":"2024-08-16T14:35:38.344Z","comments":true,"path":"2024/08/16/05 HTML 列表 list/","permalink":"https://xqc-1368.github.io/2024/08/16/05%20HTML%20%E5%88%97%E8%A1%A8%20list/","excerpt":"","text":"列表 表格是用来显示数据的，那么列表就是用来布局的。 表格是用来显示数据的，那么列表就是用来布局的。 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。 根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。 无序： ​&lt;ul&gt; 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 &lt;li&gt; 标签定义。无序列表的基本语法格式如下： 12345&lt;ul&gt;&lt;li&gt;列表项1&lt;/li&gt;&lt;li&gt;列表项2&lt;/li&gt;&lt;li&gt;列表项3&lt;/li&gt;...&lt;/ul&gt; 无序列表的各个列表项之间没有顺序级别之分，是并列的。 &lt;ul&gt;&lt;/ul&gt; 中只能嵌套 &lt;li&gt;&lt;/li&gt;，直接在 &lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。 有序： ​ 有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，&lt;ol&gt; 标签用于定义有序列表，列表排序以数字来显示，并且使用 标签来定义列表项。有序列表的基本语法格式如下： 1234567&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ... &lt;/ol&gt; &lt;ol&gt;&lt;/ol&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ol&gt;&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。 自定义： 自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，&lt;dl&gt; 标签用于定义描述列表（或定义列表），该标签会与 &lt;dt&gt;（定义项目/名字）和 &lt;dd&gt;（描述每一个项目/名字）一起使用。语法如下： 12345&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 列表总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML列表","slug":"HTML列表","permalink":"https://xqc-1368.github.io/tags/HTML%E5%88%97%E8%A1%A8/"}]},{"title":"HTML表格","slug":"04 HTML 表格 table","date":"2024-08-16T14:34:44.300Z","updated":"2024-08-16T14:34:30.647Z","comments":true,"path":"2024/08/16/04 HTML 表格 table/","permalink":"https://xqc-1368.github.io/2024/08/16/04%20HTML%20%E8%A1%A8%E6%A0%BC%20table/","excerpt":"","text":"表格 表格的主要作用 1.表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理 2.表格不是用来布局页面的,而是用来展示数据的。 3.表格的具体用法： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ... &lt;/table&gt; 1. 是用于定义表格的标签。 2. 标签用于定义表格中的行，必须嵌套在 标签中。 3. 用于定义表格中的单元格，必须嵌套在标签中。 4.字母 td 指表格数据（table data），即数据单元格的内容。 表头单元格标签： 4.表头标签的具体实现： 12345&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; ... &lt;/tr&gt; ... &lt;/table&gt; (1).一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示. 标签表示 HTML 表格的表头部分(table head 的缩写) (2)一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示. 标签表示 HTML 表格的表头部分(table head 的缩写) 5.表头单元格也是单元格，常用于表格第一行突出重要性，表头单元格里面的文字会加粗居中 表格属性： 1.表格标签这部分属性我们实际开发我们不常用，后面通过 CSS 来设置. ​ ​ 思路： 先制作表格的结构. 1.第一行里面是 th 表头单元格 2.第二行开始里面是 td 普通单元格单元格里面可以放任何元素 3.文字链接图片等都可以 后书写表格属性 1.用到宽度高度边框cellpadding 和 cellspacing 2.表格浏览器中对齐 align 表格结构标签： 使用场景: 因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分. 在表格标签中，分别用：标签 表格的头部区域、标签 表格的主体区域. 这样可以更好的分清表格结构。 总结: 1. ：用于定义表格的头部。 内部必须拥有 标签。 一般是位于第一行。 2. ：用于定义表格的主体，主要用于放数据本体 。 3. 以上标签都是放在&lt;table&gt;&lt;/table&gt; 标签中。 合并单元格： 特殊情况下,可以把多个单元格合并为一个单元格 1.合并单元格方式 2.目标单元格 3.合并单元格的步骤 如下图： 合并单元格方式： 跨行合并：rowspan=“合并单元格的个数” ​ 最上侧单元格为目标单元格, 写合并代码 跨列合并：colspan=“合并单元格的个数” ​ 最左侧单元格为目标单元格, 写合并代码 比如：。删除多余的单元格。 表格总结 ​ 表格学习整体可以分为三大部分: 表格的相关标签 ​ table thead body tr th td 表格的相关属性 ​ cellspacing cellpadding width height border 合并单元格 ​ rowspan collspan","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML表格","slug":"HTML表格","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E6%A0%BC/"}]},{"title":"HTML表单","slug":"03 HTML 表单 form","date":"2024-08-16T14:32:38.946Z","updated":"2024-08-16T14:47:39.876Z","comments":true,"path":"2024/08/16/03 HTML 表单 form/","permalink":"https://xqc-1368.github.io/2024/08/16/03%20HTML%20%E8%A1%A8%E5%8D%95%20form/","excerpt":"","text":"表单 表单的组成： 在 HTML 中，一个完整的表单通常由表单域、表单控件（也称为表单元素）和 提示信息3个部分构成。 表单域： 表单域是一个包含表单元素的区域。 在 HTML 标签中， &lt;form&gt;标签用于定义表单域，以实现用户信息的收集和传递。 &lt;form&gt;会把它范围内的表单元素信息提交给服务器. 实现代码： 123&lt;form action=“url地址” method=“提交方式” name=“表单域名称&quot;&gt;各种表单元素控件&lt;/form&gt;` 表单域的常用属性： 表单控件(表单元素) &lt;input&gt; 表单元素 在英文单词中，input 是输入的意思，而在表单元素中 &lt;input&gt; 标签用于收集用户信息。在 &lt;input&gt; 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。 1&lt;input type=&quot;属性值&quot; /&gt; 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型 type 属性的属性值及其描述如下： 除 type 属性外，&lt;input&gt;标签还有其他很多属性，其常用属性如下： &lt;label&gt; 标签 &lt;label&gt;标签为 input 元素定义标注（标签）。 &lt;label&gt;标签用于绑定一个表单元素, 当点击&lt;label&gt; 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验. 语法： 12&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; 核心： 标签的 for 属性应当与相关元素的 id 属性相同。 &lt;select&gt; 表单元素 使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用&lt;select&gt;标签控件定义下拉列表。 语法： 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ... &lt;/select&gt; &lt;textarea&gt; 表单元素 使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 &lt;textarea&gt; 标签。 在表单元素中，&lt;textarea&gt; 标签是用于定义多行文本输入的控件。 使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。 语法： &lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt; 文本内容 &lt;/textarea&gt; 通过 &lt;textarea&gt; 标签可以轻松地创建多行文本输入框。cols=“每行中的字符数” ，rows=“显示的行数”， 我们在实际开发中不会使用，都是用 CSS 来改变大小。 表单元素我们学习了三大组 input 输入表单元素 select 下拉表单元素 textarea 文本域表单元素.这三组表单元素都应该包含在form表单域里面,并且有 name 属性. 有三个名字非常相似的标签: 表单域 form 使用场景: 提交区域内表单元素给后台服务器 文件域 file 是input type 属性值 使用场景: 上传文件 文本域 textarea 使用场景: 可以输入多行文字, 比如留言板 网站介绍等… 我们当前阶段不需要提交表单元素,所以我们只负责表单元素的外观形态即可.","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML表单","slug":"HTML表单","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E5%8D%95/"}]},{"title":"HTML标签","slug":"02 HTML 标签 tag","date":"2024-08-16T11:40:19.107Z","updated":"2024-08-16T12:46:56.248Z","comments":true,"path":"2024/08/16/02 HTML 标签 tag/","permalink":"https://xqc-1368.github.io/2024/08/16/02%20HTML%20%E6%A0%87%E7%AD%BE%20tag/","excerpt":"","text":"一、HTML标签 1.HTML语法规则： 1.HTML 标签是由尖括号包围的关键词，例如 &lt;html&gt;。 2.HTML 标签通常是成对出现的，例如 &lt;html&gt; 和 &lt;/html&gt; ，我们称为双标签。 3.签:标签对中的第一个标签是开始标签，第二个标签是结束标签。 有些特殊的标签必须是单个标签（极少情况），例如&lt;br /&gt;，我们称为单标签。 2. 标签的关系： 双标签关系可以分为两类：包含关系和并列关系 包含标签 123456&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写 (1) 骨架构建快捷键 VSCode生成页面骨架结构： 输入! 按下 Tab 键。 利用插件在浏览器中预览页面：单击鼠标右键，在弹出窗口中点击“Open In Default Browser”。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;hello world&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;hello world!!!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (2) DOCTYPE &lt;!DOCTYPE html&gt; 文档类型声明标签,告诉浏览器这个页面采取html5版本来显示页面. (3) lang 语言种类 用来定义当前文档显示的语言。 en定义语言为英语 zh-CN定义语言为中文 简单来说,定义为en 就是英文网页, 定义为 zh-CN 就是中文网页 其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文 这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的 (4) 字符集 1.字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。 2.在&lt;head&gt;标签内，可以通过&lt;meta&gt; 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码。 3.&lt;meta charset=&quot; UTF-8&quot; /&gt; 4.charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符. 5.注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 &quot;UTF-8&quot;，不要写成 &quot;utf8&quot; 或 &quot;UTF8&quot;。 (5) 语义化标签 学习标签是有技巧的，重点是记住每个标签的语义。简单理解就是指标签的含义，即这个标签是用来干嘛的。 根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。 [1] 标签 &lt;h1&gt; - &lt;h6&gt; HTML 提供了 6 个等级的网页标题，即&lt;h1&gt; - &lt;h6&gt;。 具体实现： 1&lt;h1&gt; 我是一级标题 &lt;/h1&gt; [2] 段落标签 在 HTML 标签中，标签用于定义段落，它可以将整个网页分为若干个段落。 具体实现： 1&lt;p&gt; 我是一个段落标签 &lt;/p&gt; [3] 换行标签 如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br /&gt;。 具体实现： 1&lt;br /&gt; [4] 文本格式化标签： 在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。 语义 标签 加粗 &lt; strong &gt;&lt; /strong &gt;或者&lt; b&gt;&lt; /b &gt; 倾斜 &lt; em &gt;&lt; /em &gt;或者&lt; i &gt;&lt; /i &gt; 删除线 &lt; del &gt;&lt; /del &gt;或者&lt; s &gt;&lt; /s &gt; 下划线 &lt; ins &gt;&lt; /ins &gt;或者&lt; u &gt;&lt; /u &gt; [5] div和span标签 &lt;div&gt; 和 &lt;span&gt; 是没有语义的，它们就是一个盒子，用来装内容的。 具体实现： 12&lt;div&gt; 这是头部 &lt;/div&gt;&lt;span&gt; 今日价格 &lt;/span&gt; [6]图片标签 在 HTML 标签中，&lt;img&gt;标签用于定义 HTML 页面中的图像。 具体实现： 1&lt;img src=&quot;smiley-2.gif&quot; alt=&quot;Smiley face&quot; width=&quot;42&quot; height=&quot;42&quot;&gt; 解释： src 是标签的必须属性，它用于指定图像文件的路径和文件名。 属性 形式 功能 src URL 规定显示图像的 URL。 width pixels 规定图像的宽度 height pixels 规定图像的高度 alt text 规定图像的替代文本 图像标签的其他属性： 图像标签注意点： 1.图像标签可以拥有多个属性，必须写在标签名的后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.属性采取键值对的格式，即 key=“value&quot; 的格式，属性 =“属性值”。 分为相对路径和绝对路径： (6)链接标签： 链接的语法格式 1&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt; 文本或图像 &lt;/a&gt; 1.href：用于指定链接目标的url地址 2.target:用于指定链接页面的打开方式：_self默认值 _blank新窗口打开 3.#：空链接 在链接文本的 href 属性中，设置属性值为 #名字 的形式，如 &lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt; 找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如： &lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt; (7) 注释 如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字 具体实现： 1&lt;!-- 注释语句 --&gt; 快捷键: ctrl + / 一句话: 注释标签里面的内容是给程序猿看的, 这个代码是不执行不显示到页面中的. 添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的 (8) 特殊字符 在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。 重点记住：空格 、大于号、 小于号 这三个， 其余的使用很少，如果需要回头查阅即可。 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;nbsp; 空格","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML注释","slug":"HTML注释","permalink":"https://xqc-1368.github.io/tags/HTML%E6%B3%A8%E9%87%8A/"},{"name":"HTML特殊字符","slug":"HTML特殊字符","permalink":"https://xqc-1368.github.io/tags/HTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"}]},{"title":"HTML语言简介","slug":"01 HTML 简介","date":"2024-08-16T11:33:16.683Z","updated":"2024-08-16T11:32:36.314Z","comments":true,"path":"2024/08/16/01 HTML 简介/","permalink":"https://xqc-1368.github.io/2024/08/16/01%20HTML%20%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、网页开发网页的相关概念 1. 什么是网页： 1.网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 2.网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。 2. 网页的组成： 1.网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。 2.HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。 3. 网页的总结： 1.网页是图片、链接、文字、声音、视频等元素组成, 其实就是一个html文件(后缀名为html) 2.网页生成制作: 有前端人员书写 HTML 文件, 然后浏览器打开,就能看到了网页. 3.HTML: 超文本标记语言, 用来制作网页的一门语言. 有标签组成的. 比如 图片标签 链接标签 视频标签等… 4. 浏览器： 浏览器内核（渲染引擎） 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面 目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。 5. web标准： Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。 6. 为什么需要Web标准： 浏览器不同，它们显示页面或者排版就有些许差异 遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 1.让 Web 的发展前景更广阔。 2.内容能被更广泛的设备访问。 3.更容易被搜寻引擎搜索。 4.降低网站流量费用。 5.使网站更易于维护。 6.提高页面浏览速度。 7. web标准的构成： 主要包括 《结构Structure》 、《表现（Presentation）》和《行为（Behavior）》三个方面。 Web 标准提出的最佳体验方案：结构、样式、行为相分离。 简单理解：结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中 1.结构类似身体 2.表现类似外观装饰 3.行为类似行为动作 4.相比较而言, 三者中结构最重要. 二、查阅文档： 经常查阅文档是一个非常好的学习习惯。 推荐的网址： 百度: http://www.baidu.com W3C : http://www.w3school.com.cn/ MDN: https://developer.mozilla.org/zh-CN/","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"web标准","slug":"web标准","permalink":"https://xqc-1368.github.io/tags/web%E6%A0%87%E5%87%86/"}]},{"title":"浏览器生成信息","slug":"01 浏览器生成信息","date":"2024-08-16T03:21:02.986Z","updated":"2024-08-16T09:31:49.788Z","comments":true,"path":"2024/08/16/01 浏览器生成信息/","permalink":"https://xqc-1368.github.io/2024/08/16/01%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E4%BF%A1%E6%81%AF/","excerpt":"","text":"关键词：浏览器，Web服务器，网址（URL），HTTP，HTML，协议，URI，请求消息，解析器，Socket库，DNS服务器，域名 浏览器的具体工作步骤是： 解析URL（注意这个“解析”跟解析器没有关系） 生成HTTP请求消息 向DNS服务器查询域名对应的ip地址 委托操作系统内部的协议栈将消息发送给Web服务器，按照指定的顺序来调用Socket库中的程序组件。 一、输入URL，浏览器解析网址 1、统一资源定位器 URL 浏览器：具备多种客户端功能的综合性客户端软件 FTP：文件传输协议 域名：像www.glasscom.com这样用句点（.）分隔的名称 URL：统一资源定位器 功能：不同的头，可以用以判断使用哪种功能。访问Web服务器的时候，用“http”，访问FTP服务器的时候用“ftp:“ 格式：协议（http:，ftp:，file:，mailto:，）//服务器名称+数据源路径 ![Web浏览器解析URL的过程](/images/2024-07-24-22-38-54-Web浏览器解析URL的过程.jpg) - Web服务器和FTP服务器： 用http协议访问Web服务器：http://用户名(可省略):密码(可省略)@Web服务器域名:端口号(可省略)/文件的路径名 1http://user:password@www.glasscom.com:80/dir/file.html 用FTP协议下载和上传文件：ftp://用户名(可省略):密码(可省略)@FTP服务器域名:端口号(可省略)/文件的路径名 1ftp://user:password@ftp.glasscom.com:21/dir/file/html 服务器读取客户端本地文件：file://计算机名(可省略)/文件路径名 1file://localhost/c:/path/file1.zip 发送邮件的URL：邮件地址 1mailto:tone@glasscom.com 省略文件名情况： 比如http://www.lab.glasscom.com/dir/预先在dir文件夹下设置省略时访问的默认文件名，一般是index.html或者default.html，遇到这种情况直接访问默认页面 2、浏览器解析HTTP协议的URL HTTP协议 功能：定义了客户端和服务器之间的交互 请求信息包括：”对什么“（URI，统一资源标识符）+“进行怎样的操作”（访问方法，包括GET方法，POST方法等） URI：访问的各种目标，可以是一个网页数据文件名（html文件），也可以是一个CGI程序（Web服务器调用其他的程序） GET方法：URI指定的是文件返回文件；URI指定的是CGI程序，返回输出结果 POST方法：向服务器发送数据，此时URI一般指向一个应用程序的文件名 HEAD方法：用于获取文件最后更新时间 注：超链接主要是GET方法，表单有POST也有GET 返回消息是状态码 二、生成HTTP请求消息 HTTP消息 请求消息 请求行（方法 URI HTTP版本）+消息头（请求附加信息）+消息体（POST方法消息体内有表单数据） 响应消息 状态行（HTTP 状态码 响应短语）＋消息头+消息体（从文件中读取的数据orCGI程序的输出数据） 状态码和响应短语表示内容一致，用途不同，状态码是一个数字，用来像程序告知执行结果；响应短语是文字，向人们告知执行结果。 每条请求消息只能写一个URI，所以最多只能获取一个文件。当网页包含图片时，会在网页相应位置嵌入图片标签，屏幕上会预留显示图片的空间，然后再次访问Web服务器请求图片。 所以，一个网页包含3张图片，一共要向Web服务器发送4条请求 三、向DNS服务器发起 查询 Web服务器的IP地址 请求 1、IP地址 需求：在委托操作系统发送消息时，需要提供通信对象的IP地址。所以需要根据域名查询IP地址。（如果Web服务器采用了虚拟主机功能，可能无法通过IP地址访问） 局域网是基于TCP/IP结构设计的，小的子网通过路由器组成一个大的网络 IP地址（一共32bit） 定义：网络号+主机号（xx栋+xx室） 子网掩码：与IP地址等长，左半边全是1，右半边全是0，用以区分网络号和主机号 例如：10.11.12.13/255.255.255.0表示网络号是10.11.12，主机号是13 若为10.11.12.13/24，则表示子网掩码前24位为1 特殊情况：主机号比特全为0，表示代表整个子网。主机号比特全为1，表示对整个子网每个主机进行广播 2、Socket库提供查询功能，解析器向DNS服务器发起查询 Socket库：可以让其他应用程序调用操作系统网络功能的库。 解析器（DNS解析器，DNS客户端）：是一段程序，包含在Socket库中，通过DNS查询IP地址的操作是 域名解析 解析器工作过程：一行代码内存地址=gethostbyname('域名') 解析器工作的内部原理： 1.当网络应用程序（浏览器）调用解析器时，程序的控制流程就会转移（原程序暂停，被调用的程序运行）到解析器内 2.解析器会生成发送给DNS服务器的查询消息，这个过程与生成要发送给Web服务器的HTTP请求类似。 3.之后委托给操作系统内部的协议栈来执行发送功能，协议栈执行发送消息操作网卡将消息发送给DNS服务器。 4.之后按照上述相反的过程层层返回 注意：与发送其他消息不同的是，我们的终端预先已知DNS服务器的IP地址，不需要再去查询 四、DNS查询到 Web服务器地址 的过程 DNS服务器的功能： 接收来自客户端的查询消息，然后根据消息内容返回IP地址。 解析器（DNS终端）向DNS服务器发送的查询消息包括： 域名（服务器名称，邮件服务器名称（即邮件地址中@之后的部分，不是邮件服务器的域名）） Class（始终为IN） 记录类型（A对应记录得到的是IP地址，MX对应记录得到的是邮件服务器） 注：当记录类型为MX时，DNS服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级。DNS服务器再次在自己内部用邮件服务器的域名搜索，可以找到邮件服务器的IP地址。 域名的层次结构 域名：越靠右表示层级越高 比如www.lab.glasscom.com表示：com集团，glasscom部，lab科，的www。 子域：下级域 建树：下级域的DNS服务器IP地址要注册到上级域的DNS服务器上 根域：其实域名应该是www.lab.glasscom.com.最后有一个点，表示注册在根域之下，不过根域一般省略。但是根域DNS服务器注册在互联网所有DNS服务器上。 工作原理：客户端访问最近的一台DNS服务器，该服务器经过以下反复找寻环节后可以响应解析器的查询消息。（注意：反复找寻的操作是第一个DNS服务器干的活） 实际的访问过程： 上级域和下级域共享一个DNS服务器，常有跳过一级查询 DNS服务器有缓存功能，若已缓存则直接返回，缓存有有效期 五、委托协议栈发送消息 收发数据：TCP协议、UDP协议。 TCP协议收发数据过程（由协议栈执行）： （1）创建套接字（创建套接字阶段） （2）将管道连接到服务器端的套接字上（连接阶段） （3）收发数据（通信阶段） （4）断开管道并删除套接字（断开阶段） 套接字：数据通信管道两端的数据出入口 创建套接字： 管道在连接是由客户端发起的，在断开是由服务器or客户端任意一方发起 调用socket：创建套接字，返回描述符，放到指定内存中。 描述符：用来识别不同的套接字的标识符 连接阶段： 调用connect组件，需要： 描述符 IP地址 端口号：当同时指定IP地址和端口号时，就可以识别出某台具体计算机上的套接字 注：在创建套接字时，协议栈会为这个套接字分配一个端口号；在执行连接操作时，会将这个随便分配的端口号通知服务器。 描述符和端口号的区别 描述符：用来在一台计算机内部识别套接字的机制 端口号：让通信的另一方能够识别出套接字的机制。预先约定：Web是80号端口，电子邮件是25端口。 通信阶段 调用write，需要： 描述符 发送的数据 调用read，需要： 指定接收到的内存地址：接收缓冲区（位于应用程序的内存空间） 断开操作 HTTP要求Web服务器先断开，HTTP1.1（能在一次连接中收发多个请求和响应）要求浏览器先断开","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xqc-1368.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Web服务器","slug":"Web服务器","permalink":"https://xqc-1368.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"DNS服务器","slug":"DNS服务器","permalink":"https://xqc-1368.github.io/tags/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://xqc-1368.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"URL","slug":"URL","permalink":"https://xqc-1368.github.io/tags/URL/"},{"name":"URI","slug":"URI","permalink":"https://xqc-1368.github.io/tags/URI/"},{"name":"请求消息","slug":"请求消息","permalink":"https://xqc-1368.github.io/tags/%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/"},{"name":"域名","slug":"域名","permalink":"https://xqc-1368.github.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"Socket库","slug":"Socket库","permalink":"https://xqc-1368.github.io/tags/Socket%E5%BA%93/"},{"name":"解析器","slug":"解析器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A3%E6%9E%90%E5%99%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-08-16T02:59:19.785Z","updated":"2024-08-16T02:59:19.904Z","comments":true,"path":"2024/08/16/hello-world/","permalink":"https://xqc-1368.github.io/2024/08/16/hello-world/","excerpt":"","text":"本博客所有文章除特别声明外，均采用Hexo制作。 这是题名为HelloWorld的主页。文件信息来源于documentation。如果遇到问题，也许可以在troubleshooting上找到答案。 快速开始 创建新帖 系统会自动在 scaffolds 文件夹中搜寻名为 My New Post 的文件，根据其中的内容生成新的.md 文章文件。 1$ hexo new &quot;My New Post&quot; 更多信息: Writing 启动服务器 启动本地服务器，用于预览主题 1$ hexo server 或者 1$ hexo s 更多信息: 服务器 生成静态文件 在发布之前，需要先生成静态文件 生成网站静态文件到默认设置的 public 文件夹 1$ hexo generate 或者 1$ hexo g 更多信息: 启动 部署到服务器 将文件部署到服务器上 1$ hexo deploy 或者 1$ hexo d 更多信息: 部署 清除文件 清除缓存文件 (db.json) 和已生成的静态文件 (public) 1$ hexo clean","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"算法/动态规划/数位DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"环形DP的四边形不等式优化","slug":"算法/动态规划/环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"},{"name":"多重背包DP的二进制优化","slug":"算法/动态规划/多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"树形DP","slug":"算法/动态规划/树形DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"},{"name":"DP的单调队列优化","slug":"算法/动态规划/DP的单调队列优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"},{"name":"状压DP","slug":"算法/动态规划/状压DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"},{"name":"区域DP","slug":"算法/动态规划/区域DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9FDP/"},{"name":"背包DP","slug":"算法/动态规划/背包DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"},{"name":"期望DP","slug":"算法/动态规划/期望DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"},{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://xqc-1368.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"环形DP的四边形不等式优化","slug":"环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/tags/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"},{"name":"多重背包DP的二进制优化","slug":"多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"树形DP","slug":"树形DP","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"DP的单调队列优化","slug":"DP的单调队列优化","permalink":"https://xqc-1368.github.io/tags/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"},{"name":"状压DP","slug":"状压DP","permalink":"https://xqc-1368.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"区域DP","slug":"区域DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E5%9F%9FDP/"},{"name":"背包DP","slug":"背包DP","permalink":"https://xqc-1368.github.io/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"期望DP","slug":"期望DP","permalink":"https://xqc-1368.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"},{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS绝对定位","slug":"CSS绝对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS相对定位","slug":"CSS相对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS定位注意事项","slug":"CSS定位注意事项","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AE%9A%E4%BD%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"CSS子绝父相","slug":"CSS子绝父相","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8/"},{"name":"CSS元素显示与隐藏","slug":"CSS元素显示与隐藏","permalink":"https://xqc-1368.github.io/tags/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"name":"CSS溢出处理","slug":"CSS溢出处理","permalink":"https://xqc-1368.github.io/tags/CSS%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/"},{"name":"CSS浮动float","slug":"CSS浮动float","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B5%AE%E5%8A%A8float/"},{"name":"CSS清除浮动","slug":"CSS清除浮动","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS盒子模型","slug":"CSS盒子模型","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"name":"CSS边框样式","slug":"CSS边框样式","permalink":"https://xqc-1368.github.io/tags/CSS%E8%BE%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/"},{"name":"CSS内边距padding","slug":"CSS内边距padding","permalink":"https://xqc-1368.github.io/tags/CSS%E5%86%85%E8%BE%B9%E8%B7%9Dpadding/"},{"name":"CSS外边距margin","slug":"CSS外边距margin","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%96%E8%BE%B9%E8%B7%9Dmargin/"},{"name":"CSS清除内外边距","slug":"CSS清除内外边距","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E5%86%85%E5%A4%96%E8%BE%B9%E8%B7%9D/"},{"name":"CSS圆角边框","slug":"CSS圆角边框","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/"},{"name":"CSS盒子阴影","slug":"CSS盒子阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1/"},{"name":"CSS显示模式","slug":"CSS显示模式","permalink":"https://xqc-1368.github.io/tags/CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"},{"name":"CSS块元素","slug":"CSS块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS行内元素","slug":"CSS行内元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"},{"name":"CSS行内块元素","slug":"CSS行内块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS复合选择器","slug":"CSS复合选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS伪元素选择器","slug":"CSS伪元素选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS链接伪类选择器","slug":"CSS链接伪类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS属性选择器","slug":"CSS属性选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS类选择器","slug":"CSS类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS标签选择器","slug":"CSS标签选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSSID选择器","slug":"CSSID选择器","permalink":"https://xqc-1368.github.io/tags/CSSID%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS通配符选择器","slug":"CSS通配符选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%9A%E9%85%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS后代选择器","slug":"CSS后代选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS子选择器","slug":"CSS子选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS并集选择器","slug":"CSS并集选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS背景","slug":"CSS背景","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF/"},{"name":"CSS背景平铺","slug":"CSS背景平铺","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%B9%B3%E9%93%BA/"},{"name":"CSS背景图片位置","slug":"CSS背景图片位置","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/"},{"name":"CSS文本格式属性","slug":"CSS文本格式属性","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%B1%9E%E6%80%A7/"},{"name":"CSS文本修饰","slug":"CSS文本修饰","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/"},{"name":"CSS文本对齐","slug":"CSS文本对齐","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90/"},{"name":"CSS字体font","slug":"CSS字体font","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93font/"},{"name":"emmet","slug":"emmet","permalink":"https://xqc-1368.github.io/tags/emmet/"},{"name":"PS","slug":"PS","permalink":"https://xqc-1368.github.io/tags/PS/"},{"name":"CSS注释","slug":"CSS注释","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B3%A8%E9%87%8A/"},{"name":"CSS的插入","slug":"CSS的插入","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9A%84%E6%8F%92%E5%85%A5/"},{"name":"CSS优先级问题","slug":"CSS优先级问题","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"},{"name":"CSS精灵图","slug":"CSS精灵图","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS字体图标","slug":"CSS字体图标","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"},{"name":"CSS三角绘制","slug":"CSS三角绘制","permalink":"https://xqc-1368.github.io/tags/CSS%E4%B8%89%E8%A7%92%E7%BB%98%E5%88%B6/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML列表","slug":"HTML列表","permalink":"https://xqc-1368.github.io/tags/HTML%E5%88%97%E8%A1%A8/"},{"name":"HTML表格","slug":"HTML表格","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E6%A0%BC/"},{"name":"HTML表单","slug":"HTML表单","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E5%8D%95/"},{"name":"HTML注释","slug":"HTML注释","permalink":"https://xqc-1368.github.io/tags/HTML%E6%B3%A8%E9%87%8A/"},{"name":"HTML特殊字符","slug":"HTML特殊字符","permalink":"https://xqc-1368.github.io/tags/HTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"web标准","slug":"web标准","permalink":"https://xqc-1368.github.io/tags/web%E6%A0%87%E5%87%86/"},{"name":"Web服务器","slug":"Web服务器","permalink":"https://xqc-1368.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"DNS服务器","slug":"DNS服务器","permalink":"https://xqc-1368.github.io/tags/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://xqc-1368.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"URL","slug":"URL","permalink":"https://xqc-1368.github.io/tags/URL/"},{"name":"URI","slug":"URI","permalink":"https://xqc-1368.github.io/tags/URI/"},{"name":"请求消息","slug":"请求消息","permalink":"https://xqc-1368.github.io/tags/%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/"},{"name":"域名","slug":"域名","permalink":"https://xqc-1368.github.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"Socket库","slug":"Socket库","permalink":"https://xqc-1368.github.io/tags/Socket%E5%BA%93/"},{"name":"解析器","slug":"解析器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A3%E6%9E%90%E5%99%A8/"}]}