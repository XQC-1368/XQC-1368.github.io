{"meta":{"title":"XQC1368的emo小屋","subtitle":"嬛嬛，朕emo啦！！","description":"菜坤日常","author":"XQC1368","url":"https://XQC-1368.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-08-16T05:54:24.517Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"https://xqc-1368.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2024-08-15T14:02:09.917Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://xqc-1368.github.io/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2024-08-16T06:03:33.337Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://xqc-1368.github.io/404.html","excerpt":"","text":""},{"title":"仓库","date":"2024-08-16T06:00:06.900Z","updated":"2024-08-16T06:00:06.900Z","comments":false,"path":"repository/index.html","permalink":"https://xqc-1368.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-08-15T14:02:09.921Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"https://xqc-1368.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-08-16T08:33:55.126Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://xqc-1368.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-08-16T03:54:10.618Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"https://xqc-1368.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"最小生成树","slug":"最小生成树","date":"2024-08-18T12:16:49.145Z","updated":"2024-08-18T12:16:00.672Z","comments":true,"path":"2024/08/18/最小生成树/","permalink":"https://xqc-1368.github.io/2024/08/18/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"最小生成树1. Kruskal算法Kruskal算法的思想比Prim好理解一些。 先把边按照权值进行排序， 用贪心的思想优先选取权值较小的边，并依次连接， 若出现环则跳过此边（用并查集来判断是否存在环）继续搜，直到已经使用的边的数量比总点数少一即可。 证明：刚刚有提到：如果某个连通图属于最小生成树，那么所有从外部连接到该连通图的边中的一条最短的边必然属于最小生成树。所以不难发现，当最小生成树被拆分成彼此独立的若干个连通分量的时候，所有能够连接任意两个连通分量的边中的一条最短边必然属于最小生成树 123456789101112131415161718192021void kruskal()&#123; sort(edge_set,edge_set+m,cmp); for(int i=0;i&lt;m;i++) &#123; fax=find(edge_set[i].a); fay=find(edge_set[i].b); if(fax!=fay) &#123; ans += edge_set[i].weight; fa[fax] = fay; cnt++; &#125; if (cnt==n-1) &#123; flag=1; break; &#125; &#125;&#125; 例题： 【模板】最小生成树题目描述如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。 输入格式第一行包含两个整数 $N,M$，表示该图共有 $N$ 个结点和 $M$ 条无向边。 接下来 $M$ 行每行包含三个整数 $X_i,Y_i,Z_i$，表示有一条长度为 $Z_i$ 的无向边连接结点 $X_i,Y_i$。 输出格式如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。 样例 #1样例输入 #11234564 51 2 21 3 21 4 32 3 43 4 3 样例输出 #117 提示数据规模： 对于 $20\\%$ 的数据，$N\\le 5$，$M\\le 20$。 对于 $40\\%$ 的数据，$N\\le 50$，$M\\le 2500$。 对于 $70\\%$ 的数据，$N\\le 500$，$M\\le 10^4$。 对于 $100\\%$ 的数据：$1\\le N\\le 5000$，$1\\le M\\le 2\\times 10^5$，$1\\le Z_i \\le 10^4$。 样例解释： 所以最小生成树的总边权为 $2+2+3=7$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct &#123; int a; int b; int weight;&#125;edge;edge edge_set[200001];int fa[5005];int n, m, u, v, w,cnt=0,fax,fay,ans=0,flag=0;bool cmp(edge p,edge q)&#123; return p.weight&lt;q.weight;&#125;int find(int x)&#123; if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];&#125;void kruskal()&#123; sort(edge_set,edge_set+m,cmp); for(int i=0;i&lt;m;i++) &#123; fax=find(edge_set[i].a); fay=find(edge_set[i].b); if(fax!=fay) &#123; ans += edge_set[i].weight; fa[fax] = fay; cnt++; &#125; if (cnt==n-1) &#123; flag=1; break; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; edge temp; temp.a=u; temp.b=v; temp.weight=w; edge_set[i]=temp; &#125; for(int i=1;i&lt;=n;i++) &#123; fa[i]=i; &#125; kruskal(); if(flag==0)cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl; else printf(&quot;%d&quot;,ans);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"生成树","slug":"生成树","permalink":"https://xqc-1368.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"kruskal算法","slug":"kruskal算法","permalink":"https://xqc-1368.github.io/tags/kruskal%E7%AE%97%E6%B3%95/"}]},{"title":"同余：欧拉定理及扩展定理，费马小定理","slug":"04-1同余：欧拉定理及其扩展，费马小定理","date":"2024-08-18T12:07:25.644Z","updated":"2024-08-19T01:55:22.213Z","comments":true,"path":"2024/08/18/04-1同余：欧拉定理及其扩展，费马小定理/","permalink":"https://xqc-1368.github.io/2024/08/18/04-1%E5%90%8C%E4%BD%99%EF%BC%9A%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95%EF%BC%8C%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","excerpt":"","text":"在一些计数的问题中，常常要求对结果取模，但是在计算非常庞大的次幂的时候，无法直接取模，可以先把底数对 p 取模，指数对$ \\varphi(p)$ 取模，再计算次幂，有效地降低时间复杂度。第二章 同余0x20 同余0x21 整数的取余运算0x21.1 整数的取余运算（模运算）定义：带余除法，设 a , b 是整数，且 b &gt; 0，使得 a=bq+r，且 0≤r&lt;b ，称 q 为商， r 为余数。 显然带余除法中的商和余数都是唯一的，在下文中将商记为 a / b ，将余数记为 a % b ，/ 与 % 的运算优先级与乘除法相同。 定义以下运算： 取模运算：a % p (或a mod p)，表示 a 除以 p 的余数。模 p 加法：(a+b)%p ，其结果是a + b 算术和除以p的余数，也就是说，( a + b ) = k p + r ，则( a + b ) % p = r 。模 p 减法：( a − b ) % p，其结果是a − b算术差除以p的余数。模 p 乘法：( a ∗ b ) % p，其结果是a ∗ b 算术乘法除以p的余数。 模运算有如下简单性质： $a \\% b = a-b\\times \\lfloor\\frac{a}{b}\\rfloor$，即若 a % b = c ，则 a = b x + c ，$x= \\lfloor\\frac{a}{b}\\rfloor$。 n % p 得到结果的正负由被除数 n 决定,与 p 无关。 结合率： $((a+b) \\% p + c) \\% p = (a + (b+c) \\% p) \\% p$ $((a\\times b) \\% p\\times c)\\% p = (a\\times (b\\times c) \\% p) \\% p$ 交换率： $(a + b) \\% p = (b+a) \\% p$ $(a\\times b) \\% p = (b\\times a) \\% p$ 分配率： $((a +b)\\% p\\times c) \\% p = ((a \\times c) \\% p + (b\\times c) \\% p) \\% p$ 若$a\\%p=x,a\\%q=x,\\gcd(p,q)=1$，则$a\\%(p×q)=x$ 更多关于模运算性质以及同余详见本文 0x22同余。 0x21.2 整数模意义下的加减乘乘方运算 $(a+b) \\%c=(a\\%c+b\\%c)\\%c$$(a-b)\\%c=(a\\%c-b\\%c+c)\\%c$$(a \\times b)\\%c=(a\\%c)\\times (b\\%c)\\%c$$(a^b) \\% p = ((a \\% p)^b) \\% p$计算减法的时候，通常需要加上模数 c，防止出现负数。 $O(nlogn)$ 的 大数快速幂算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int mod;char s[20000001];int qqpow(int a, int b)&#123; int ret=1; while(b) &#123; if(b&amp;1)ret=(ret*a)%mod; a=(a*a)%mod; b&gt;&gt;=1; &#125; return ret;&#125; int qpow(int a, char *b, int len)&#123; int ret=1; while(len&gt;0) &#123; if(b[len-1]!=&#x27;0&#x27;) ret=(ret*qqpow(a,b[len-1]-&#x27;0&#x27;))%mod; a=(qqpow(a,10))%mod; len--; &#125; return ret;&#125;int read(char s[])&#123; int len=0; char ch; while((ch=getchar())!=&#x27;\\n&#x27;) &#123; s[len++]=ch; &#125; return len;&#125;signed main()&#123; int a; scanf(&quot;%lld %lld&quot;,&amp;a,&amp;mod); getchar(); int len; len=read(s); cout&lt;&lt;qpow(a,s,len); return 0;&#125; 对应题目改编自洛谷 【模板】扩展欧拉定理题目背景出题人也想写有趣的题面，可惜并没有能力。 题目描述给你三个正整数，$a,m,b$，你需要求：$a^b \\bmod m$ 输入格式一行三个整数，$a,m,b$ 输出格式一个整数表示答案 样例 #1样例输入 #112 7 4 样例输出 #112 样例 #2样例输入 #21998244353 12345 98765472103312450233333333333 样例输出 #215333 提示注意输入格式，$a,m,b$ 依次代表的是底数、模数和次数 【样例 $1$ 解释】$2^4 \\bmod 7 = 2$ 【数据范围】对于 $100\\%$ 的数据，$1\\le a \\le 10^9$，$1\\le b \\le 20000000，1\\le m \\le 10^8$。 改了什么捏，当然是把b的数据范围改了。嘻嘻 那就可以过了 然而原题的数据范围是$1≤b≤10^{20000000}$ 0x22 同余若正整数 a 和 b 除以 m 的余数相等，则称 a ，b 模 m 同余，记作$a\\equiv b\\ (\\text{mod}\\ m)$。 即 a % m = b % m 0x21.1 同余的性质同余的基本性质： 性质21.1.1 ： (自反性)：$a≡a(mod m)$ 性质21.1.2 ： (对称性)：$若 a≡b(\\mod\\ m)，则 b≡a(\\mod\\ m)$ 性质21.1.3 ： (传递性)：$若 a≡b(\\mod\\ m),b≡c(\\mod\\ m)，则 a≡c(mod m)$ 性质21.1.4 ： (同加性)：$若 a≡b(mod m)，则 a±c≡b±c(mod m)$ 性质21.1.5 ： (同乘性)： $若 a≡b(\\mod \\ m)，则 a×c≡b×c(\\mod\\ m)$，$若 a≡b(\\mod\\ m),c≡d(\\mod\\ m)，则 a×c≡b×d(\\mod\\ m)$ 性质21.1.6 ： (同幂性)：$a^c≡b^c(\\mod\\ m)$ 性质21.1.7 ： (不满足同除性)：若 $a≡b(mod m)$不满足$a÷c≡b÷c(mod m)$ 性质21.1.8 ： (满足同除性)： 若$a≡b(mod m)$，$c ∣ a ， c ∣ b$ , 则 $\\cfrac{a}{c}≡\\cfrac{b}{c}\\ \\pmod {\\cfrac{m}{\\gcd(m,c)} } $ 或者可以换一种表述方式： 若 $ca≡cb (\\mod m)$则 $a≡b \\pmod {\\frac{m}{\\gcd(m,c)} }$ 例如：$\\gcd(c,m)=1\\Longrightarrow a\\equiv b\\pmod m$ 该性质会在取遍剩余系会用到。 推论21.1.9 ：若$ a≡b(modm) ， m’\\ |\\ m$， 则$a≡b \\pmod {m’}$ 推论21.1.10 ： $a≡b \\pmod {m_i} (i=1..k)$等价于 $a≡b \\pmod M =\\mathrm{lcm}(m1,m2,..mk)$ 推论21.1.12 ：$a≡b(modm)$ 且 $c≡d(modm)$ $\\Longrightarrow a+c\\equiv b+d\\pmod m$推论21.1.13 ：$a≡b(modm) $且 $c≡d(modm) \\Longrightarrow a-c\\equiv b-d\\pmod m$ 0x21.2 费马小定理若 p 是质数，则对于任意的整数 a 都有$a^p≡a \\pmod p$。若 $gcd(a,p)=1 $，即 a 不是 p 的倍数，则有 $a^{p−1}≡1\\pmod p$ 费马小定理降幂：$a^k\\equiv a^{k\\mod(p-1)}\\;(\\mod \\;p)$ 费马大定理： m &gt; 2 时， $x^m + y^m = z^m$无正整数解当m = 2 ，对于式子 $a^2+b^2=c^2$ （n 为任意正整数）：当 a 为奇数时：$a=2n+1,c=n^2+(n+1)^2,b=c-1$当 a 为偶数时：$a=2n+2,c=1+(n-1)^2,b=c-2$ 0x21.3 欧拉定理欧拉定理定理21.3.1 ： 若正整数 a , n 互质，则 $a^{\\varphi(n)}≡1(\\mod\\ n) $其中$ \\varphi(n)$是欧拉函数。推论21.3.2： $\\exists x\\in N^{*},a^x\\equiv 1(\\mod m) \\iff \\gcd(a,m)=1$ 欧拉降幂（拓展欧拉定理）若 a 与 m 互质：$a^b\\equiv a^{b\\mod\\varphi(m)}\\pmod m$ 若不保证 a 与 m 互质：$b&gt; \\varphi(m) 时：a^b\\equiv a^{b\\mod \\varphi(m)+\\varphi(m)}\\;\\pmod m$ 在一些计数的问题中，常常要求对结果取模，但是在计算非常庞大的次幂的时候，无法直接取模，可以先把底数对 p 取模，指数对 $\\varphi(p)$取模，再计算次幂，有效地降低时间复杂度。 欧拉函数的性质0x14 互质与欧拉函数0x14.1 欧拉函数定义: ∀a,b∈N 若$ gcd ⁡ ( a , b ) = 1 ,$则称 a , b 互质。 对于三个数或更多的数，把gcd ⁡ ( a , b , c ) = 1称之为 a , b , c 互质。 把 $gcd ⁡ ( a , b ) = gcd ⁡ ( a , c ) = gcd ⁡ ( b , c ) = 1$称之为 a , b , c 两两互质。显然 a , b , c 两两互质是优于 a , b , c 互质的。 性质14.1.1：int 范围内的数 n 中， $1\\sim n$中与 n 互质的个数最多只有$1600（\\quad max ⁡ { φ ( 1 ∼ 2147483647 ) }\\quad )$ 欧拉函数 定义：1 ⋯ N中与 N 互质的数的个数，被称为欧拉函数，记作 $\\varphi(N)$，phi。 如果 n 是一个素数，那么 $φ(n)=n−1$ （所有小于 n 的都互素） 如果 n 是素数的 k 次幂，即$n = p^k$，那么 $φ(p^k) = p^k - p^{k-1}$（除了 p的倍数以外，与 1 ∼ n 中的任意数都互素） 我们可以的到下列结论： 由算数基本定理（唯一分解定理）得 N= p_{1}^{k_{1}} \\times p_{2}^{k_{2}} \\times p_{3}^{k_{3}} \\times \\cdots \\ p_{m}^{k_{m}}则有： \\varphi(N)=N \\times \\prod_{p\\mid N}(1-\\frac{1}{p}) 其中，如果 p是素数,则$φ( p) =p\\times (1- \\frac{1}{p}) = p-1$ 我们可以利用这个性质在分解质因数的同时 $ O(\\sqrt n)$使用公式求解欧拉函数 123456789101112inline int euler_one(int n)&#123; int ans = n; for(int i = 2; i * i &lt;= n; ++ i)&#123; if(n % i == 0)&#123; ans = ans / i * (i - 1); while(n % i == 0)n /= i; &#125; &#125; if(n &gt; 1)ans = ans / n * (n - 1); return ans;&#125; 由此我们得到了上面那道题的真实数据范围条件$（1≤b≤10^{20000000}）$下的$a^b\\mod m$的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int mod;string s;int qmul(int x,int y,int mod)&#123; int z=(long double)x/mod*y; int res=(unsigned long long)x*y-(unsigned long long)z*mod; return (res+mod)%mod;&#125;int qpow(int a,int b,int mod)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=qmul(ans,a,mod); a=qmul(a,a,mod); b&gt;&gt;=1; &#125; return ans;&#125;int varphi(int n)//求varphi(n)&#123; if(n==1)return 1; int ans=n; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; ans=ans/i*(i-1); while(n%i==0)n/=i; &#125; &#125; if(n&gt;1)//n 此时为 超过 输入时的n开根号 的唯一一个质数//比如n=21，n经过前面了这里变成7 ans=ans/n*(n-1); return ans;&#125;void EEt(int a,string b,int mod)&#123; int b_mod=0; int tmod=varphi(mod);//! //cout&lt;&lt;tmod&lt;&lt;endl; for(int i=0;i&lt;b.length();i++) &#123; b_mod=b_mod*10+b[i]-&#x27;0&#x27;; if(b_mod&gt;=tmod) &#123; b_mod%=tmod; &#125; &#125; //cout&lt;&lt;b_mod&lt;&lt;endl; int bb=0; //cout&lt;&lt;&quot;tmod&quot;&lt;&lt;tmod&lt;&lt;endl; if(b.length()&lt;=10)bb=stol(b,nullptr,10); //cout&lt;&lt;bb&lt;&lt;&quot;bb&quot;&lt;&lt;endl; if(bb!=0 &amp;&amp; bb&lt;=tmod)&#123;printf(&quot;%lld&quot;,qpow(a,bb,mod));&#125; else &#123; b_mod = b_mod + tmod; printf(&quot;%lld&quot;, qpow(a, b_mod, mod)); return; &#125;&#125; signed main()&#123; int a; scanf(&quot;%lld %lld&quot;,&amp;a,&amp;mod); getchar(); cin&gt;&gt;s; EEt(a,s,mod); return 0;&#125; 0x51.1 线性筛法求欧拉函数我们注意到在线性筛中，每一个合数都是被最小的质因子筛掉，筛法求素数的同时也得到了每个数的最小质因子，这是线性筛求欧拉函数的关键。 1.考虑$n=p^k_j,\\varphi(n)$ 显然有$\\varphi(p^k_j)=p^k_j-p^{k-1}_j=p_j^{k-1}\\times(p_j-1)$ 2.考虑$n=i\\times p_j$当$p_j\\mid i$ 即$i$含有因子$p_j$,由于$i=\\frac{n}{p_j}$，由唯一分解定理： \\begin{align} \\varphi(n) & =n\\times \\prod_{i=1}^{s}\\frac{p_i-1}{p_i} \\\\[2ex] & =p_1\\times i\\times \\prod_{i=1}^{s}\\frac{p_i-1}{p_i} \\\\[2ex] & =p_1\\times \\varphi(i) \\end{align}测试 \\begin{aligned} f_Y(y) & = f_X[h(y)]|h'(y)| \\\\[2ex] & = f_X[h(y)]h'(y) \\\\[2ex] & = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\\\[2ex] & = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\\\[2ex] & = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\\\[2ex] & = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\\\[2ex] & = 1 \\end{aligned} \\tag{1}3.考虑 $n=i\\times p_j$，$\\varphi(n)$，当 $i$ 不整除$p_j$ 即 $i$ 与 $p_j$ 互质，积性函数显然有性质： \\varphi(n)=\\varphi(i)\\times \\varphi(p_j)=\\varphi(i)\\times(p_j-1)由于我们仅在在线性筛的框架上增加了一些细节，所以时间复杂度依然是O(n)的。 威尔逊定理：解决带有“！”的问题0x21.4 威尔逊定理威尔逊定理 定理21.4.1： 当 p 为质数时有： $(p-1)!\\equiv p-1\\equiv -1(\\mod\\;p)$， $(p-2)!\\equiv 1\\pmod p$ 其中 定理21.4.1 实际上就等价于：若 p 是质数，则 (p−1)!+1 能够被 p 整除。n 为素数时： $(n-1)!\\mod n=1$n 为合数时：除 n = 4 以外，$(n-1)!\\mod n=0$ 威尔逊定理的逆命题 定理21.4.2： 若一个数 p，满足条件$(p−1)!+1$可以被 p 整除，那么 p 是素数。 即：p 可整除 (p-1)!+1 是 p 为质数的充要条件。 $例题：杭州电子科技大学HDU$ Problem B. Fansblog（HDU 6608 19多校） 给定一个质数$P(10^9≤P≤10^{14})$， Q 是 最大的那个小于 P 的质数，求 $Q\\ !\\ \\%P$ Solution 根据威尔逊定理 $(P-1)!\\equiv P-1\\equiv -1(\\mod P)$，所以显然可以构造答案 Q ! 我们知道P&gt;Q，则有$(P-1)!\\equiv1\\times 2\\times······\\times Q \\times (Q+1)\\times······\\times (P-1)\\equiv P-1(\\mod P)$ 则有：$Q!\\equiv\\cfrac{P-1}{(Q+1)\\times······\\times (P-1)}\\equiv\\cfrac{1}{(Q+1)\\times······\\times (P-2)}(\\mod P)$ 即求$(Q+1)\\times······\\times (P-2)$的逆元，当然目前还不会求","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://xqc-1368.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"name":"扩展欧拉定理","slug":"扩展欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"威尔逊定理","slug":"威尔逊定理","permalink":"https://xqc-1368.github.io/tags/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"}]},{"title":"同余：拓展欧几里得定理","slug":"04.2 同余：拓展欧几里得","date":"2024-08-18T12:07:25.641Z","updated":"2024-08-18T12:07:12.096Z","comments":true,"path":"2024/08/18/04.2 同余：拓展欧几里得/","permalink":"https://xqc-1368.github.io/2024/08/18/04.2%20%E5%90%8C%E4%BD%99%EF%BC%9A%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"","text":"0x22 拓展欧几里德0x22.1 裴蜀（Bézout）定理(用于求解“不定方程”的相关问题)内容：设 a , b是不全为零的整数 ，对于任意整数 x , y ，满足 $gcd ⁡ ( a , b)| (ax+by)$ ，且存在整数x，y使得： $a x + b y = gcd ⁡ ( a , b )$ 推论1：(感觉不像推论) $\\gcd(a,b)\\mid c⟺∃x,y∈Z,ax+by=c$ 方程$ ax+by=d(d=gcd(a,b)) $即为丢番图方程。 逆定理推论 设 a,b 是不全为零的整数，若d&gt;0是a,b 的公因数，且存在整数 x,y , 使得ax+by=d，则 d=gcd(a,b)。 特殊地，设a,b 是不全为零的整数，若存在整数 x,y , 使得ax+by=1，则 a,b互质 推论2：$\\forall a,b,z\\in\\mathbb{N^{*}},\\gcd(a,b)=1\\\\exists x,y\\in\\mathbb{N^{}} ,ax+by=ab−a−b+z$ 即两互质的数 a , b，表示不出的最大的数为ab−a−b。 推论2 进一步的结论：对自然数 a、b和整数n，a 与 !b 互素，考察不定方程：ax+by=n. 其中 x 和 y 为自然数。如果方程有解，称 n 可以被 a、b 表示。 记C= ab−a−b。由 a 与 b 互素，C 必然为奇数。则有结论： 对任意的整数 n，n与C-n中有且仅有一个可以被表示。 即：可表示的数与不可表示的数在区间 [0,C]表示；负数不可被表示，大于 C 的数可被表示。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"拓展欧几里得定理","slug":"拓展欧几里得定理","permalink":"https://xqc-1368.github.io/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/"},{"name":"裴蜀定理","slug":"裴蜀定理","permalink":"https://xqc-1368.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"}]},{"title":"整除：最大公约数和最小公倍数","slug":"03-2 整除：最大公约数与最小公倍数","date":"2024-08-18T12:07:25.636Z","updated":"2024-08-18T12:01:36.840Z","comments":true,"path":"2024/08/18/03-2 整除：最大公约数与最小公倍数/","permalink":"https://xqc-1368.github.io/2024/08/18/03-2%20%E6%95%B4%E9%99%A4%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/","excerpt":"","text":"0x13 最大公因数与最小公倍数0x13.1 约数 约数，又称因数。整数a aa除以整数 b ( b ≠ 0 ) 除得的商正好是整数而没有余数，我们就说a 能被b整除，或b 能整除a 。a 称为b 的倍数，b称为a 的约数。 唯一分解定理，任何一个大于 1 11 的数都可以被分解成有限个质数乘积的形式 N = \\prod_{i=1}^{m}p_i^{C_i}其中$ p_1 &lt; p_2 &lt; ··· &lt; p_m$为质数，$C_i$为正整数 N 的正约数个数为： $(c1+1)\\times (c2+1)\\times \\cdots (c_m+1)=\\prod{i=1}^{m}(c_i+1)$ $N^M$的正约数个数为：$ (M\\times {c1}+1)\\times (M\\times {c_2}+1)\\times \\cdots (M\\times {c_m}+1)=\\prod{i=1}^{m}(M\\times {c_i}+1)$ N 的所有正约数和为： $ (1+p1+p_1^2+\\cdots +p_1^{c_1})\\times\\cdots\\times(1+p_m+p_m^2+\\cdots +p_m^{c_m})=\\prod{i=1}^{m}(\\sum_{j=0}^{c_i}(p_i)^j)$ 随机数据下，约数个数的期望是$O(\\ln\\ n)$ 试除法 - 求 n的正约数集合 显然约数总是成对出现（除了完全平方数，只有一个$ \\sqrt{n}$ ），所以只需要枚举到$\\sqrt{n}$ 即可。 1234567for(int i=1;i*i&lt;=n;i++) if(n%i==0) &#123; diver.emplace_back(i); if(n/i!=i) diver.emplace_back(n/i); &#125; a useful conclusion: 推论：一个整数 n 的约数个数上界为 $2\\sqrt{n}$ 倍数法 - 求 1 ∼ n 1\\sim n1∼n 中每个数的正约数集合 按照埃氏筛的形式枚举倍数，时间复杂度为$O(n+\\cfrac n 2+\\cfrac n 3+\\cdots+\\cfrac n n)≈n\\times \\log n=O(n\\log n)$ 时间复杂度为$O(n\\log n)$ 可以求出求 $1\\sim n$中每个数的正约数集合，但并不能求出具体某个数的因子是谁，常用于一些于因子有关的计算，如计算 $\\sum{i=1}^{n}\\sum{d \\mid n}d$ 或是$ \\sum{i=1}^{n}\\sum{d \\mid n}f(d) $ ，可以使用倍数法在$O(n\\log n)$的复杂度下计算。 1234567891011int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++ i)&#123; for(int j = 1 ;j * i &lt;= n; ++ j)&#123; factor[i * j].push_back(j); &#125; &#125; return 0;&#125; 推论：$1\\sim n$中每个数的约数的总和大概为$n \\log n$。 0x13.2 最大公约数 两个数 a 和 b 的最大公约数$ \\tt (Greatest Common Divisor) $是指同时整除 a和 b 的最大因数，记为 $\\gcd(a, b)$。 一个约定俗成的定理：任何非零整数和零的最大公约数为它本身。 有如下基本性质： 性质13.2.1：$ \\gcd(a,b)=\\gcd(b,a)$ 性质13.2.2： $\\gcd(a,b)=\\gcd(a-b,b)\\quad(a ≥b)$ 性质13.2.3：$\\gcd(a,b)=\\gcd(a\\bmod b,b)$ 性质13.2.4：$\\gcd(a,b,c)=\\gcd(\\gcd(a,b),c)$ 性质13.2.5：$\\gcd(ka,kb)=k\\ \\gcd(a,b)$ 性质13.2.6：$\\gcd(k,ab)=1 \\iff \\gcd(k,a)=1\\ \\&amp;\\&amp;\\ \\gcd(k,b)=1$ 特别地，如果 a , b 的$\\gcd(a,b)=1$，则称这两个数互质（互素）。 辗转相除法（又称欧几里德算法） 理论基础：$ \\forall a,b\\in\\N,b\\neq 0,\\gcd(a,b)=\\gcd(b,a\\ \\mathrm{mod}\\ b)$ 时间复杂度 $ O(\\log n)$ 最坏情况：斐波那契数列相邻的两项，因为斐波那契数列相邻的两项一定互质。欧几里德算法由于存在大量的取模运算，对于大整数耗时较大。 Code ```cint gcd(int a, int b){ return b == 0 ? a : gcd(b, a % b);} 123456789101112131415161718192021222324252627282930313233343536373839- 更相减损法 &gt; 理论基础： &gt; &gt; $\\gcd(n,m)=\\gcd(n,n-m)$- 石头算法：Stein 算法（可看作更相减损法的应用） ( Stein 在德语中是石头的意思 ) 渐近时间，空间复杂度均与欧几里德算法相同。&gt; 理论基础：$\\gcd(ka,kb)=k \\times \\gcd(a,b)$最大特点：只有移位和加减法计算，避免了大整数的取模运算。&gt; 具体原理：&gt; &gt; 设x，y为非0奇数，有以下结论：&gt; &gt; 1.$gcd(x,0)=x$&gt; 2.$gcd(2x,2y)=2gcd(x,y)$&gt; 3.$gcd(2x,y)=gcd(x,y)$&gt; 4.$gcd(x,y)=gcd(|x-y|,min(x,y))$很显然，第4个式子两个奇数相减会出来一个偶数，那么就可以继续往下除二了。代码实现：```cint gcd(int a,int b)&#123; if(a&lt;b)&#123;a^=b;b^=a;a^=b;&#125;//交换a，b的值交换后恒有a&gt;b if(!b)return a; if(!(a&amp;1)&amp;&amp;!(b&amp;1))return 2*gcd(a&gt;&gt;1,b&gt;&gt;1); else if(!(a&amp;1))return gcd(a&gt;&gt;1,b); else if(!(b&amp;1))return gcd(a,b&gt;&gt;1); else return gcd(a-b,b);&#125; 提前用位运算交换，很方便 0x13.3 最小公倍数 两个数 a和 b的最小公倍数 $\\tt (Leatest Common Multiple)$是指同时被 a 和 b 整除的最小倍数，记为 $\\text{lcm}(a, b)$。特殊的，当a 和 b 互素时， $\\text{lcm}(a, b) = ab$。 性质13.3.1：$\\forall a, b \\in N,\\gcd(a, b) \\times \\text{lcm}(a, b) = a \\times b$ 可以使用 gcd ⁡ , lcm 的定义证明 性质13.3.1 ，证明略。 123int lcm(int a,int b)&#123; return a / gcd(a,b) * b;//先除后乘，以免溢出64位整数&#125; 重要性质：gcd 与 lcm 的指数最值表示法由唯一分解定理得，若 $n=p_1^{α_1}\\times p_2^{α_2}\\times p_3^{α_3}\\times \\cdots\\times p_k^{α_k}$ $m=p_1^{β_1}\\times p_2^{β_2}\\times p_3^{β_3}\\times \\cdots\\times p_k^{β_k}$ ​则 $n\\times m=p_1^{α_1+β_1}\\times p_2^{α_2+β_2}\\times p_3^{α_3+β_3}\\times \\cdots\\times p_k^{α_k+β_k}$ $\\gcd(n,m)=p_1^{min{α_1,β_1}}\\times p_2^{min{α_1,β_1}}\\times \\cdots\\times p_k^{min{α_k,β_k}}$ $\\text{lcm}(n,m)=p_1^{max{α_1,β_1}}\\times p_2^{max{α_1,β_1}}\\times \\cdots\\times p_k^{max{α_k,β_k}}$ 0x13.4 GCD 与 LCM 的一些性质与定理性质13.4.1：$fib_n$表示斐波那契数列的第n项 $\\gcd\\left(fib{n},fib{m}\\right)=fib_{\\gcd(n,m)}$ 性质13.4.2： $\\gcd(a^m−1,a^n−1)=a^{\\gcd(n,m)}−1\\ (a&gt;1,n&gt;0,m&gt;0)$ 性质13.4.3： $\\gcd(a^m−b^m,a^n−b^n)=a^{\\gcd(m,n)}−b^{\\gcd(m,n)}\\quad \\ (gcd(a,b)=1)$ 性质13.4.4： $\\gcd(a,b)=1,\\gcd(a^m,b^n)=1$ 性质13.4.5： $(a+b)\\mid ab\\Longrightarrow \\gcd(a,b)\\neq 1$ a,b不互质，因为互质就提不出来公因子了。 性质13.4.6： 设$G=\\gcd(C_n^1,C_n^2,…C_n^{n-1})$ n 为素数，G = nn 非素且有一个素因子 p ，G = pn 有多个素因子，G = 1性质13.4.7： $(n+1)\\text{lcm}(C_n^0,C_n^1,\\cdots ,C_n^n)=\\text{lcm}(1,2,\\cdots ,n+1)$ 性质13.4.8：$\\displaystyle\\sum^n{i=1}\\gcd(i,n)=\\sum{d|n}d\\varphi(\\frac{n}{d})$性质13.4.8： 在 $Fibonacc$ 数列中求相邻两项的 ⁡ $\\gcd$时，辗转相减次数等于辗转相除次数。 0x13.5 补充知识： $Fibonacc$ 数列及其推论基本性质定理： \\begin{align} fib_n&= \\\\&0 \\quad(n=0); \\\\&1 \\quad(n=1); \\\\&fib_{n-1}+fib_{n-2} \\quad(n=2); \\end{align}推导结论：性质13.5.1： $\\sum{i=1}^{n}{f{i}}=f_{n+2}-1$ 性质13.5.2：$\\sum{i=1}^{n}{f{2i-1}}=f_{2n}$ 性质13.5.3： $\\sum{i=1}^{n}{f{2i}}=f_{2n+1}-1$ 性质13.5.4：$\\sum{i=1}^{n}{(f{n})^2}=f{n}f{n+1}$ 性质13.5.5：$f{n+m}=f{n-1}f{m-1}+f{n}f_{m}$ 性质13.5.6： $(f{n})^2=(-1)^{(n-1)}+f{n-1}f_{n+1}$ 性质13.5.7：$f{2n-1}=(f{n})^2-(f_{n-2})^2$ 性质13.5.8：$f{n}=\\cfrac{f{n+2}+f_{n-2}}{3}$ 性质13.5.9： $\\frac{f{i}}{f{i-1}} \\approx \\dfrac{\\sqrt{5}-1}{2} \\approx 0.618 $ 性质13.5.10：$f_{n}=\\cfrac{\\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n}-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}}{\\sqrt{5}}$ ​ Modified GCD题目描述Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it’s an easy task to calculate the GCD between two positive integers. A common divisor for two positive numbers is a number which both numbers are divisible by. But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor $ d $ between two integers $ a $ and $ b $ that is in a given range from $ low $ to $ high $ (inclusive), i.e. $ low&lt;=d&lt;=high $ . It is possible that there is no common divisor in the given range. You will be given the two integers $ a $ and $ b $ , then $ n $ queries. Each query is a range from $ low $ to $ high $ and you have to answer each query. 输入格式The first line contains two integers $ a $ and $ b $ , the two integers as described above ( $ 1&lt;=a,b&lt;=10^{9} $ ). The second line contains one integer $ n $ , the number of queries ( $ 1&lt;=n&lt;=10^{4} $ ). Then $ n $ lines follow, each line contains one query consisting of two integers, $ low $ and $ high $ ( $ 1&lt;=low&lt;=high&lt;=10^{9} $ ). 输出格式Print $ n $ lines. The $ i $ -th of them should contain the result of the $ i $ -th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query. 样例输入 #1123459 2731 510 119 11 样例输出 #11233-19 解决这题首先要来看一个命题： a,b 所有公共的约数一定是 gcd(a,b) 的约数。 若要求解a，b的每一个公约数，只需先求出他们的最大公约数，然后再求出这个数的所有因子即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define int long longusing namespace std;vector&lt;int&gt; diver;int gcd(int a,int b)&#123; if(a&lt;b)&#123;a^=b;b^=a;a^=b;&#125;//交换a，b的值交换后恒有a&gt;b if(!b)return a; if(!(a&amp;1)&amp;&amp;!(b&amp;1))return 2*gcd(a&gt;&gt;1,b&gt;&gt;1); else if(!(a&amp;1))return gcd(a&gt;&gt;1,b); else if(!(b&amp;1))return gcd(a,b&gt;&gt;1); else return gcd(a-b,b);&#125;signed main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int grst_com_div=gcd(a,b); //cout&lt;&lt;grst_com_div&lt;&lt;endl; int n; for(int i=1;i*i&lt;=grst_com_div;i++) if(grst_com_div%i==0) &#123; diver.emplace_back(i); if(grst_com_div/i!=i) diver.emplace_back(grst_com_div/i); &#125;//求出最大公约数的所有因子 sort(diver.begin(),diver.end()) ; //对所有因子排序 //for(auto j:diver)cout&lt;&lt;j&lt;&lt;&quot; &quot;; cin&gt;&gt;n; while(n--)//回答n次询问 &#123; int l,r,ans=-1; cin&gt;&gt;l&gt;&gt;r; int i=0,j=diver.size()-1; while(i&lt;=j)//二分查找解决确定区间问题 &#123; int mid=j+(i-j)/2; if(diver[mid]&gt;=l &amp;&amp; diver[mid]&lt;=r) &#123; ans=diver[mid]; i = mid + 1; &#125; else if(diver[mid]&lt;l) i=mid+1; else j=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"最大公约数gcd","slug":"最大公约数gcd","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0gcd/"},{"name":"最小公倍数lcm","slug":"最小公倍数lcm","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm/"},{"name":"辗转相除法","slug":"辗转相除法","permalink":"https://xqc-1368.github.io/tags/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/"}]},{"title":"整除：素数算法和筛法","slug":"03-1整除： 素数算法和筛法","date":"2024-08-18T12:07:25.633Z","updated":"2024-08-18T12:01:28.019Z","comments":true,"path":"2024/08/18/03-1整除： 素数算法和筛法/","permalink":"https://xqc-1368.github.io/2024/08/18/03-1%E6%95%B4%E9%99%A4%EF%BC%9A%20%E7%B4%A0%E6%95%B0%E7%AE%97%E6%B3%95%E5%92%8C%E7%AD%9B%E6%B3%95/","excerpt":"","text":"整除，素数和筛法0x00整除，讲解了一些整除的基础知识，理解这些内容是我们学习接下来的内容的基础。 整除的定义：若整数 n 除以整数 d 的余数为 0，即 d 能整除 n ，则称 d 是 n 的约数，n 是 d 的倍数，记为 $d\\mid n$ 性质1.1： $a\\mid b,b\\mid c \\Rightarrow a | c$ 性质1.2：$a∣b⇒a∣bc$，c 为任意的整数。 性质1.3： $a ∣ b , a ∣ c ⇒ a ∣ k b ± lc $（k 与 l ll 均为任意的整数）。（都有公因子 a，正确性显然） 性质1.3推论：$k_1 , k_2互质，则 k_1+k_2与k_1×k_2互质$（仅有a=1能整除$k_1,k_2k_1,k_2 $​能同时整除 $k_1+k_2与k_1×k_2$） 性质1.4：$a∣b,b∣a⇒a=±b$ 性质1.5：$ a = k b ± c ⇒ a , b $ 的公因数与 b , c 的公因数完全相同 性质1.6：若 $ a ∣ b c $，且 a与 c 互质，则 $a\\mid b$ 0x10 整除相关0x11 素数（质数）定义： 素数（又称质数）是只有 1 和它本身两个因数的数。 规定 1 既非素数也非合数。特殊的，2是唯一的偶素数。 素数定理：设 π ( x )为 1 到 x 中素数的个数。 其中： π ( n ) =-1+\\sum_{k=1}^x\\lfloor \\cos^2\\lfloor\\pi\\cfrac{(n-1)!+1}{n}\\rfloor \\rfloor尝试求极限发现（其中$ \\ln(x)$ 表示x 的自然对数）： $ \\lim_{x-&gt;∞}\\cfrac{π(x)}{(\\frac{x}{\\ln(x)})}=1$ 即可得到定理： 定理2.1： 在自然数集中，小于 n 的质数约有 $ \\cfrac {n}{\\ln(n)} $ 个。 由该定理可知，是 int 范围内的素数的个数并不会很多，其中 int 范围内的素数间距大概是 $10^2$的数量级。 定理2.2： $（伯特兰 — 切比雪夫定理）$若整数 n &gt; 3，则至少存在一个质数 p ，符合 $n &lt; p &lt; 2 n − 2$。另一个稍弱说法是：对于所有大于 1的整数 n，至少存在一个质数 p，符合 $n &lt; p &lt; 2n$。 接下来介绍的四种算法均为单个素数的判定方法。 1.试除法试除法是最常用的判断素数的方法。 一个数如果不是素数，则一定能被一个小于它自己的数整除。假设一个数能整除 $n$ 即$ a ∣ n $那么 $\\frac{n}{a} $ 也必定能整除 $n$，不妨设$ a \\le \\frac{n}{a}$，则有$a^2\\le n$，即$a \\le \\sqrt n$。 时间复杂度：$O(\\sqrt{n})$ 12345678inline bool is_prime(int x)&#123; if(x &lt; 2) return false; for(register int i = 2; i * i &lt;= x; ++ i) if(x % i == 0) return false; return true;&#125; 2.kn+i 法 一个大于 1 的整数如果不是素数，那么一定有素因子，因此在枚举因子时只需要考虑可能为素数的因子即可。$ k n + i$法即枚举形如 $k n + i $的数，例如取 $k=6$，那么$6n+3,6n+4,6n+6$ 都不可能为素数（显然它们分别有因子 $2 , 3 , 2 , 6$一定不是素数），因此我们只需要枚举形如$6 n + 1 , 6 n + 5 $ 的数即可，这样整体的时间复杂度就会降低了$\\frac{2}{3} $ ，也就是 $O(n^\\frac{1}{3})$ 下面是$kn+i $法 $k = 30$ 版本的模板： 1234567bool isPrime(ll n)&#123; if(n == 2 || n == 3 || n == 5)return 1; if(n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n == 1) return 0; ll c = 7, a[8] = &#123;4,2,4,2,4,6,2,6&#125;; while(c * c &lt;= n) for(auto i : a)&#123;if(n % c == 0)return 0; c += i;&#125; return 1;&#125; 3.预处理法 对于多组数据，如果 n是合数，那么它必然有一个小于等于 $\\sqrtn$的素因子，只需要对 $ \\sqrt n$内的素数进行测试即可，也就是预处理求出 $\\sqrt n$ ​中的素数，假设该范围内素数的个数为 s （ $s=\\dfrac{n}{\\ln n}$），那么时间复杂度为 $O(\\dfrac{n}{\\ln n})$ 4.Miller−Rabin 判定法对于一个很大的数 n（例如十进制表示有 100 位），如果还是采用试除法进行判定，时间复杂度必定难以承受，目前比较稳定的大素数测试算法是米勒-拉宾（$\\tt Miller-RabinMiller−Rabin$）素数测试算法，该素数测试算法可以通过控制迭代次数来间接控制正确率。 $\\tt Miller-RabinMiller−Rabin$ 判定法是基于费马小定理的，即如果一个数 p 为素数的条件是对于所有和 p互素的正整数 a满足以下等式： $a^{p-1}\\equiv 1\\ (\\mod p)$。（费马小定理的相关概念定理性质详见本文 0x21.2 费马小定理） 然而我们不可能试遍所有和 p 互素的正整数，这样的话复杂度反而更高，事实上我们只需要取比 p 小的几个素数进行测试就行了。 具体判断 n 是否为素数的算法如下： 如果 n==2，返回true；如果 n&lt;2 || !(n &amp; 1), 返回false；否则跳到 (2) 。 令 $n = m *(2 ^ k) + 1$，其中 m 为奇数，则$n - 1 = m \\times (2 ^ k)$ 。 枚举小于 n的素数 p（至多枚举 10个），对每个素数执行费马测试，费马测试如下：计算 $pre = p ^ m % n$ ，如果pre 等于1，则该测试失效，继续回到 3) 测试下一个素数；否则进行 k次计算$ next = pre ^ 2 \\mod n$，如果 next == 1 &amp;&amp; pre != 1 &amp;&amp; pre != n-1则n必定是合数，直接返回；k次计算结束判断pre 的值，如果不等于 1，必定是合数。 10次判定完毕，如果 n都没有检测出是合数，那么 n为素数。 时间复杂度为$ O(k\\log n)$ 以下为该方法的证明： \\begin{align} x^{k\\times2^e}-1&=(x^{k\\times 2^{e-1}})^2-1\\\\ &=(x^{k\\times 2^{e-1}}+1)\\times(x^{k\\times 2^{e-1}}-1)\\\\ &=(x^{k\\times 2^{e-1}}+1)(x^{k\\times 2^{e-2}}+1)(x^{k\\times 2^{e-2}}-1)\\\\ &=·······\\\\ &=(x^{k\\times 2^{e-1}}+1)······(x^{2k}+1)(x^{k}+1)(x^{k}-1) \\end{align}如果p是素数，$1&lt;=a&lt;=p$，那么根据费马小定理可以得到：$a^{p-1}\\equiv1(\\mod p)$ 设$p-1= k\\times2^e$： $(a^k-1)(a^k+1)(a^{2k}+1)(a^{4k}+1)······(a^{k\\times2^{e-1}})\\equiv0(\\mod n)$ 也就是： $a^k\\equiv1\\mod n$ 或 $a^{k\\times2^i}\\equiv-1\\mod n(i\\in{0,…,e-1})$ 如果要检验$n$是否为素数，我们设$n-1=k\\times2^e$，求出使得 $e$ 最大的 $k$，接着为我们选择$a$，如果这些式子都不成立，那么当然这个数$n$是合数，否则继续选择$a$。 要判断n是否为素数，对于一定范围内的n，只要以一定范围内a为底就可以保证这是一个确定性算法了。下面详细说明： if n &lt; 1 373 653 a = 2 and 3. if n &lt; 9 080 191 a = 31 and 73. if n &lt; 4 759 123 141 a = 2, 7, and 61. if n &lt; 2 152 302 898 747 a = 2, 3, 5, 7, and 11. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int qmul(int a,int b ,int mod)&#123; a%=mod; b%=mod; int c=(long double)a*b/mod; int ans=a*b-c*mod; return (ans%mod+mod)%mod;&#125;int qpow(int flor,int m,int n)&#123; int ret=1; while(m) &#123; if(m%2==1)ret=qmul(ret,flor,n); flor=qmul(flor,flor,n); m/=2; &#125; return (ret+n)%n;&#125;bool miller_rabbin_one(int n)&#123; if(n==2)return true; if(n&lt;2 || n%2==0)return false; int m=n-1; int k=0; while(m%2==0) &#123; m/=2;k++;&#125; int recordk=k;//记录k的值 vector&lt;int&gt; primes = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23,29,31,37&#125;;//12个质数可以检验long long范围的所有数 for (int inode : primes) &#123; if(n==inode)return true; int pre=qpow(inode,m,n),next=pre; if(pre==1) continue; k=recordk; while(k--) &#123; next=qmul(pre,pre,n); if(next==1 &amp;&amp; pre!=1 &amp;&amp; pre!=n-1)return false; pre=next; &#125; if(pre!=1)return false; &#125; return true;&#125; 0x11.2 素数的筛法 通过上文的学习，我们了解了判断单个数是否为素数的四种常用方法，那么对于一个很大范围内的所有数的素数判定，若我们直接对于每一个数都使用一次素数判定法，如此庞大的时间复杂度我们是无法承担的，因此引入了对于大规模数的素数判定方法：质数筛法。 质数筛法一般分为埃氏筛和线性筛。 埃氏筛没有线性筛时间复杂度好，不常用，但是他的时间复杂度分析方法却比较常用。 埃氏筛法 Eratosthenes 筛法 （埃拉托色尼筛法） 显然如果 x xx 是合数，那么 x xx 的倍数也一定是合数。利用这个结论，我们可以避免很多次不必要的检测。 我们可以从小到大枚举分析每一个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。 12345678910int v[N];void primes(int n&#123; memset(v, 0, sizeof v); for(int i = 2;i &lt;= n; ++ i)&#123; if(v[i])continue; cout &lt;&lt; i &lt;&lt; endl; for(int j = i;j &lt;= n / i; ++ j) v[i * j] = 1; &#125;&#125; 埃氏筛的时间复杂度为$O(n\\log\\log n)≈O(n)$这里的⁡$ \\log$以10为底），因为我们这里外层循环 $O ( n )$，内层循环上界为$\\frac{n}{i} $， 随着 i 的增加，$\\frac n i\\in{n,\\frac{n}{2},\\frac{n}{3},\\frac{n}{4},\\frac{n}{5}…,\\frac{n}{n}}$ ，而调和级数 $f(n) = 1+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}…+\\frac{1}{n}≈loglogn$，所以整体的算法时间复杂度为 $O(n\\log \\log n)$。 线性筛法（欧拉筛法） 在欧拉筛我们可以保证每个数一定只会被它的最小质因子筛掉一次。由于 primes 数组中的质数是递增的。我们从小到大枚举 primes 数组，当第一次枚举到一个质数 primes [ j ] 满足$\\text{primes}[ j ] \\mid i$ 时， primes[ j ] 一定是 i 的最小质因子，primes[j] 也一定是 $i\\times\\text{primes}[j]$ 的最小质因子，而接下来的$i\\times \\text{primes}[j+1]$的最小质因子应该是 primes [ j ] 而不是` primes [ j + 1 ] ，故此时直接 break 即可。（这解释的太好了吧） 那么对于任意一个合数 x ，假设 x 的最小质因子为 y ，那么当枚举到$\\frac{x}{y}&lt;x $ 的时候一定会把 x 筛掉，即在枚举到 x 之前一定能把合数 x 筛掉，所以一定能把所有的合数都筛掉。 由于 保证每个合数只都被自己的最小质因子筛掉一遍 ，所以时间复杂度是 O ( n ) 的。（注意到筛法求素数的同时也得到了每个数的最小质因子，这是后面筛法求欧拉函数的关键） 12345678910111213141516171819202122vector&lt;int&gt; prime; //记录比i小的所有素数void get_prime(int n)&#123; vector&lt;bool&gt; mark(n+5); //建立一个长度为n+1的动态数组用于标记是否不为素数 //初始化为0，默认全部为素数； mark[1] = 1; // 1不是素数 for (int i = 2; i &lt;= n; i++) &#123; if (mark[i] == 0) prime.push_back(i);//经历了腥风血雨之后依然屹立不倒的是素数 for (auto j : prime)//j遍历prime中元素，即遍历比i小的所有质数 &#123; if (j * i &gt; n)//超出讨论范围，不讨论 break; mark[i * j] = 1; if (i % j == 0)//* break; &#125; &#125; return;&#125; 对代码中*的解释： “最小质因数 j× 最大因数（非自己）：i = 这个合数：i*j” 我们必须保证在内层循环中枚举的每一个prime是合数i*j的最小质因子才行。 那就要保证i质因数分解之后不能有比j小的数字。 我们假设一下如果我们运行到某一个i%j==0的情况不实行break；（比如i=4，j=2） 那么继续运行把i=4,j=3 ，即43的最小质因数必不是3，因为我总能找到2，使得2&lt;3为最小质因数 prime[ij]=12也给标记了，但事实上，12 的最小质因子不是3 而是2，那么到i=6,j=2的时候就会又标记一次，造成浪费 真不行就看链接内容吧：线性筛质数（欧拉筛） 例题：线性筛 复合 埃氏筛：黄题 素数密度题目描述给定区间 $[L,R]$（$1\\leq L\\leq R &lt; 2^{31}$，$R-L\\leq 10^6$），请计算区间中素数的个数。 输入格式第一行，两个正整数 $L$ 和 $R$。 输出格式一行，一个整数，表示区间中素数的个数。 样例 #1样例输入 #112 11 样例输出 #115 纯纯线性筛会空间溢出：（错误代码） 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;vector&lt;int&gt; prime;signed main()&#123; int L,R;int minn=0,maxn; scanf(&quot;%d %d&quot;,&amp;L,&amp;R); vector&lt;bool&gt; is_prime(R + 1); //是质数为0，否则为1； is_prime[1]=1; for(int i=2;i&lt;=R;i++) &#123; if(is_prime[i]==0)prime.emplace_back(i); for(auto num:prime) &#123; if(num*i&gt;R)break; is_prime[i*num]=1; if(i%num==0)break; &#125; if(i==L-1)minn=prime.size(); &#125; maxn=prime.size(); printf(&quot;%d&quot;,maxn-minn); return 0;&#125; 于是我们经过思考看题解发现：判定L~R区间的是否为质数，只需要线性筛到$\\sqrt{n}$ 即可在通过埃氏筛法确定L~R的所有素数，于是我们边欧筛边埃筛； 所以筛法的时候我们只要筛[2,R​]就行了注意1不是质数（不过数据里好像没有）在得到[2,$\\sqrt{R}$​]中的质数的时候顺便将[L,R]中的数筛去离散一下就存的下了 时间复杂度：O(反正极限数据只要0.2s不到)空间：O($\\sqrt{R}$+(R−L))≈O(1e6) 这里转换了算法，本来是用prime数组大小相减得到答案，现在改为用is_prime数组来求： 突破口就在于我们的l和r区间很小，我们就能够最后用循环遍历is_prime数组，以求出总素数数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define int long longusing namespace std;vector&lt;int&gt; prime;signed main()&#123; int L,R; scanf(&quot;%d %d&quot;,&amp;L,&amp;R); if(L==1)L=2;//特判L=1情况 vector&lt;bool&gt; is_prime_of_ltor(R-L+5); vector&lt;bool&gt; is_prime(sqrt(R) + 1); //是质数为0，否则为1； is_prime[1]=1; for(int i=2;i&lt;=sqrt(R);i++) &#123; if(is_prime[i]==0)prime.emplace_back(i); for(auto num:prime) &#123; if(num*i&gt;sqrt(R))break; is_prime[i*num]=1; if(i%num==0)break; &#125;//以下为增加部分 if(is_prime[i]==0) &#123; int j; if(L%i==0)j=L/i; else j=L/i+1; for(;j*i&lt;=R;j++) &#123; if(j*i!=i) is_prime_of_ltor[j*i-L]=1; &#125; &#125;//以上为增加部分 &#125; int ans=0;//以下为修改部分 for(int i=0;i&lt;=R-L;i++)ans+=(1-is_prime_of_ltor[i]); printf(&quot;%d&quot;,ans); return 0;&#125; 0x12 $ Z^ $与 $(Z^_p,^.)$结构$Z^*$，即正整数集。 $(Z^*_p,^.)$,$Z_p$的剩余类群，即$(1,2, \\dots,p-1)$，与 p 互素的数，即 $U（Z_p）$ 0x12.1 唯一分解定理（算数基本定理）任何一个大于 1的数都可以被分解成有限个质数乘积的形式 \\prod_{i=1}^{m}p_i^{C^i}=p_1^{C_1}\\times p_2^{C_i}\\times \\cdots \\times P_n^{C_n}其中 $p_1 &lt; p_2 &lt; ··· &lt; p_m$ 为质数，$C_i$为正整数。显然 n 最多仅有一个大于 $\\sqrt n$ 的质因子（若有两个的话，他们的乘积就大于n 了）。试除法类似埃式筛，我们直接枚举因子然后把当前因子全部除尽即可，时间复杂度$O(\\sqrt n)$ 1234567891011121314int c[N],p[N];void divide(int n) &#123; cnt = 0; for(int i = 2; i * i &lt;= n; ++ i) &#123; if(n % i == 0) &#123; p[ ++ cnt] = i,c[cnt] = 0; while(n % i == 0) n /= i,c[cnt] ++ ; &#125; &#125; if(n &gt; 1)//如果n是质数 p[ ++ cnt] = n,c[cnt] = 1; for(int i = 1;i &lt;= cnt; ++ i) cout &lt;&lt; p[i] &lt;&lt; &quot;^&quot; &lt;&lt; c[i] &lt;&lt; endl;&#125; Pollard Rho 算法：用于寻找某个质因子/最大质因子 对于数据较大的情况，如 $n ≥ 10^{18}$，有用来分解其因数的 $\\tt Pollard\\ Rho$算法。 Pollard-rho算法是一个大数分解的随机算法，能够在 $O(n ^\\frac{1}{4})$的时间内找到 n 的一个素因子 p ，然后再递归计算 n’ =$ \\frac{n}{p}$，直到 n 为素数(因此还需要miller-rabbin判断素数or筛法判素)为止，通过这样的方法将 n 进行素因子分解。 Pollard-rho 的策略为：从 $[2, n)$中随机选取 k 个数$x_1、x_2、x_3、…、x_k$，求任意两个数$x_i、x_j$的差和 n 的最大公约数，即 $d = \\gcd(x_i - x_j, n)$，如果 1 &lt; d &lt; n，则 d为 n的一个因子，直接返回 d即可。 然后来看如何选取这 k个数，我们采用生成函数法，令 $x_1= rand()\\%(n-1) + 1$，$ x_i = (x_i-1 ^ 2 + 1 ) \\mod n$，很明显，这个序列是有循环节的，如图所示： 我们需要做的就是在它进入循环的时候及时跳出循环，因为$x_1$是随机选的，$x_1$选的不好可能使得这个算法永远都找不到 n 的一个范围在 $( 1 , n ) $的因子，这里采用步进法，保证在进入环的时候直接跳出循环。 基于Floyd算法优化的Pollard Rho为了判断环的存在,可以用一个简单的Floyd判圈算法,也就是”龟兔赛跑”. 假设乌龟为t,兔子为$r$,初始时$t=r=1$.假设兔子的速度是乌龟的一倍. 过了时间i后$,t=i,r=2i$.此时两者得到的数列值$xt​=x_i​,x_r​=x{2i}​$. 假设环的长度为c,在环内恒有$:xi​=x_i+c​$. 如果龟兔”相遇”,此时有:$x_r​=x_t​$,也就是$x_i​=x_2i​=x{i+kc}$​.此时两者路径之差正好是环长度的整数倍。 这样以来,我们得到了一套基于Floyd判圈算法的Pollard Rho 算法. 例题：【模板】Pollard-Rho题目描述Miller Rabin 算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。 Pollard rho 是一个非常玄学的方式，用于在 $O(n^{1/4})$ 的期望时间复杂度内计算合数 $n$ 的某个非平凡因子。事实上算法导论给出的是 $O(\\sqrt p)$，$p$ 是 $n$ 的某个最小因子，满足 $p$ 与 $n/p$ 互质。但是这些都是期望，未必符合实际。但事实上 Pollard rho 算法在实际环境中运行的相当不错。 这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出 Prime；如果不是质数，输出它最大的质因子是哪个。 输入格式第一行，$T$ 代表数据组数（不大于 $350$） 以下 $T$ 行，每行一个整数 $n$，保证 $2 \\le n \\le {10}^{18}$。 输出格式输出 $T$ 行。 对于每组测试数据输出结果。 样例 #1样例输入 #112345676213134889712345676543211000000000000 样例输出 #1123456PrimePrime674146495 提示2018.8.14 新加数据两组，时限加大到 2s，感谢 @whzzt 2022.12.22 加入新的数据，感谢 @ftt2333 和 Library Checker by @will7101 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#define int long longusing namespace std;int ans,T;int qmul(int a,int b ,int mod)&#123; a%=mod; b%=mod; int c=(long double)a*b/mod; int ans=a*b-c*mod; return (ans%mod+mod)%mod;&#125;int qpow(int flor,int m,int n)&#123; int ret=1; while(m) &#123; if(m%2==1)ret=qmul(ret,flor,n); flor=qmul(flor,flor,n); m/=2; &#125; return (ret+n)%n;&#125;bool miller_rabbin_one(int n)&#123; if(n==2)return true; if(n&lt;2 || n%2==0)return false; int m=n-1; int k=0; while(m%2==0) &#123; m/=2;k++;&#125; int recordk=k; vector&lt;int&gt; primes = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23,29,31,37&#125;; for (int inode : primes) &#123; if(n==inode)return true; int pre=qpow(inode,m,n),next=pre; if(pre==1) continue; k=recordk; while(k--) &#123; next=qmul(pre,pre,n); if(next==1 &amp;&amp; pre!=1 &amp;&amp; pre!=n-1)return false; pre=next; &#125; if(pre!=1)return false; &#125; return true;&#125;int f(int x, int c, int n)&#123; return (qmul(x , x ,n)+ c) % n;&#125;int gcd(int x, int y)//卡常时gcd的优化&#123; if (!x) return y; if (!y) return x; int t = __builtin_ctzll(x | y); x &gt;&gt;= __builtin_ctzll(x); do &#123; y &gt;&gt;= __builtin_ctzll(y); if (x &gt; y) swap(x, y); y -= x; &#125; while (y); return x &lt;&lt; t;&#125;int pollard_rho(int N)&#123; if (N %2==0) return 2; if (miller_rabbin_one(N) == true) return N; int t=rand()%(N+1); int c = rand() % (N + 1) ; int tur=t;int rab=t; while (true) &#123; tur = f(tur, c, N); rab = f(f(rab, c, N), c, N); int d = gcd(abs(tur - rab), N); if (d &gt; 1&amp;&amp; d&lt;N) return d; if(tur==rab)return pollard_rho(N); &#125;&#125;void find_max_primeofn(int N)//深度优先搜索求最大质因数&#123; if(N&lt;=1)return; if(miller_rabbin_one(N)) &#123; ans=max(ans,N); return; &#125; int u=pollard_rho(N); find_max_primeofn(u); find_max_primeofn(N/u);&#125;signed main()&#123; srand(time(NULL)); scanf(&quot;%lld&quot;,&amp;T); while(T--) &#123; int N; scanf(&quot;%lld&quot;,&amp;N); if (miller_rabbin_one(N) == true) printf(&quot;Prime\\n&quot;); else &#123; ans=0;find_max_primeofn(N); printf(&quot;%lld\\n&quot;,ans); &#125; &#125; return 0;&#125; 0x12.2 Z ∗ Z^*Z∗ 结构中的一些定理推论12.2.1： 若 n=p_1^{α_1}\\times p_2^{α_2}\\times p_3^{α_3}\\times \\cdots\\times p_k^{α_k} \\\\m=p_1^{β_1}\\times p_2^{β_2}\\times p_3^{β_3}\\times \\cdots\\times p_k^{β_k}则 \\begin{array}{l} n\\times m=p_1^{α_1+β_1}\\times p_2^{α_2+β_2}\\times p_3^{α_3+β_3}\\times \\cdots\\times p_k^{α_k+β_k} \\\\\\gcd(n,m)=p_1^{\\min\\{α_1,β_1\\}}\\times p_2^{\\min\\{α_1,β_1\\}}\\times \\cdots\\times p_k^{\\min\\{α_k,β_k\\}} \\\\\\text{lcm}(n,m)=p_1^{\\max\\{α_1,β_1\\}}\\times p_2^{\\max\\{α_1,β_1\\}}\\times \\cdots\\times p_k^{\\max\\{α_k,β_k\\}} \\end{array}定理12.2.2：：$ (p-1)!+1 \\equiv0\\ (\\mod p)$ 定理12.2.3： $((n+1)(n+2)…(n+k))\\%k≠0$ 0x12.3$(Z^_p,^.)$结构定理12.3.1：$(Z^_p,^.)$是循环群，即存在$a\\in Z^_p$，使得$Z^_p={ a^n|n=1,2,\\cdots,p-1}$ 这样的 a称为 p 的原根。 素数一定有原根，原根不唯一，部分合数也有原根 1000000007 的原根为5 998244353 的原根为 3 原根详见0x60原根","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/categories/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/categories/%E7%B4%A0%E6%95%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/tags/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"素数判定","slug":"素数判定","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A/"},{"name":"Miller-Rabin素性检验","slug":"Miller-Rabin素性检验","permalink":"https://xqc-1368.github.io/tags/Miller-Rabin%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/"},{"name":"Pollard-Rho","slug":"Pollard-Rho","permalink":"https://xqc-1368.github.io/tags/Pollard-Rho/"},{"name":"埃氏筛法","slug":"埃氏筛法","permalink":"https://xqc-1368.github.io/tags/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/"},{"name":"线性筛法（欧拉筛法）","slug":"线性筛法（欧拉筛法）","permalink":"https://xqc-1368.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%EF%BC%88%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%89/"}]},{"title":"快速乘","slug":"02 快速乘","date":"2024-08-18T12:07:25.626Z","updated":"2024-08-18T11:58:23.778Z","comments":true,"path":"2024/08/18/02 快速乘/","permalink":"https://xqc-1368.github.io/2024/08/18/02%20%E5%BF%AB%E9%80%9F%E4%B9%98/","excerpt":"","text":"02快速乘因为我们知道乘法有的时候会溢出，即使是 long long 也可能在乘法时因为结果过大溢出（当模数也是 long long ）。所以我们需要寻找一种能高效完成乘法操作并且不会爆 long long 的算法，也就是快速乘。本文也将对几种常用快速乘及其优化技巧做个总结。 1. 复杂度为 O(log) 的快速乘：我们知道乘法其实就是把很多个加法运算合到一起。现在我们的乘法会爆范围，那我们就把它转化为加法。但是我们不可能一个一个的加，这样复杂度会是 O(n) 级别。所以我们模仿2进制加法操作来完成。 12345678inline ll ksc(ll x,ll y,ll p)&#123;//计算x乘y的积 ll res=0;//加法初始化 while(y)&#123; if(y&amp;1)res=(res+x)%p;//模仿二进制 x=(x&lt;&lt;1)%p; y&gt;&gt;=1;//将x不断乘2达到二进制 &#125;return res;&#125;// ll 表示 long long 当然我们不一定要仿照2进制，也可以是其他进制，只要中间算每一位上数字代表值时不会爆 longlong 就行！ 2. 优秀的 STL 结构：__int128__int128是c++自带的一个数据类型，顾名思义，它可以装下 $2^{128} $级别的大数据，而且可以直接进行各种加减乘除之类的操作（复杂度很接近 O(1) ），不过它需要手写输出（但其实我们只需要在运算时用一下就可以了，就像下面这样：） 1long long ans=((__int128)x*y)%p 不过有一点遗憾的就是：联赛中基本上不会允许使用这个数据类型的 3. 非常优秀的 O(1) 快速乘这个东西最初我感觉很不靠谱，但它就是能算出来正确答案。它就是用 long double 来进行优化取模运算。让我们先看一代码实现吧： 123456789inline ll ksc(ll x,ll y,ll p)&#123; ll z=(ld)x/p*y; ll res=(ull)x*y-(ull)z*p; return (res+p)%p;&#125;// ll 表示 long long// ld 表示 long double// ull 表示 unsigned long long// 一种自动溢出的数据类型（存满了就会自动变为0） 看到这份代码有没有感到十分奇怪？ 它中间是直接用了乘法操作的啊！这不直接爆掉了吗？ 但是它就是可以算出正确答案来。因为它其实很巧妙的运用了自动溢出这个操作，我们的代码中的 $z$ 就表示 $⌊x×y/p⌋$ ，所以我们要求的就变成了 $x×y−⌊x×y/p⌋×p$ ，虽然这两个部分都是会溢出的，但（unsigned）保证了它们溢出后的差值基本不变，所以即使它会溢出也不会影响最终结果的！ 4. 关于快速乘的灵活转化：我们知道快速乘的原理其实就是乘法转加法（上面这种不算），但是这是可以根据题目性质灵活转变的，我们如何转成加法决定了我们的复杂度，就像如果模数并没有超过int范围很多，那我们适当的运用乘法分配律可以让复杂度非常接近 O(1) ： 12345inline ll ksc(ll x, ll y, ll P)&#123; ll L=x*(y&gt;&gt;25)%P*(1&lt;&lt;25)%P; ll R=x*(y&amp;((1&lt;&lt;25)-1))%P; return (L+R)%P;&#125; 在保证运算不会爆long long的前提下，我们可以尽量优化其复杂度，就像上述代码在模数小于 $10^{12} $的情况下完全变成了 O(1) 级别，在某些题目中会十分优秀！ 5. 一些经常需要快速乘的算法：Miller rabin 判大质数Pollard Rho 大数因子寻找BSGS 大步小步算法","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"快速乘","slug":"快速乘","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/"}]},{"title":"快速幂","slug":"01 快速幂","date":"2024-08-18T12:07:25.620Z","updated":"2024-08-18T11:58:17.845Z","comments":true,"path":"2024/08/18/01 快速幂/","permalink":"https://xqc-1368.github.io/2024/08/18/01%20%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂快速幂（Exponentiation by squaring，平方求幂）是一种简单而有效的小算法，它可以以O(logn)的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。 让我们先来思考一个问题：7的10次方，怎样算比较快？ 方法1：最朴素的想法，77=49，497=343，… 一步一步算，共进行了9次乘法。 这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。 方法2：先算7的5次方，即77777，再算它的平方，共进行了5次乘法。 但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。 方法3：先算77得49，则7的5次方为49497，再算它的平方，共进行了*4次乘法。 模仿这样的过程，我们得到一个在O(logn) 时间内计算出幂的算法，也就是快速幂。 递归快速幂 12345678910111213//递归快速幂int qpow(int a, int n)&#123; if (n == 0) return 1; else if (n % 2 == 1) return qpow(a, n - 1) * a; else &#123; int temp = qpow(a, n / 2); return temp * temp; &#125;&#125; 在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是步步取模，如果MOD较大，还应当开long long。 123456789101112131415//递归快速幂（对大素数取模）#define MOD 1000000007typedef long long ll;ll qpow(ll a, ll n)&#123; if (n == 0) return 1; else if (n % 2 == 1) return qpow(a, n - 1) * a % MOD; else &#123; ll temp = qpow(a, n / 2) % MOD; return temp * temp % MOD; &#125;&#125; 非递归快速幂 1234567891011//非递归快速幂int qpow(int a, int n)&#123; int ans = 1; while(n)&#123; if(n&amp;1) //如果n的当前末位为1 ans *= a; //ans乘上当前的a a *= a; //a自乘 n &gt;&gt;= 1; //n往右移一位 &#125; return ans;&#125; 最初ans为1，然后我们一位一位算： 1010的最后一位是0，所以a^1这一位不要。然后1010变为101，a变为a^2。 101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。 10的最后一位是0，跳过，右移，自乘。 然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。 这里的位运算符，&gt;&gt;是右移，表示把二进制数往右移一位，相当于/2；&amp;是按位与，&amp;1可以理解为取出二进制数的最后一位，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。 以上内容摘自知乎用户Pecco南大计院大佬； 例题： 【模板】快速幂题目描述给你三个整数 $a,b,p$，求 $a^b \\bmod p$。 输入格式输入只有一行三个整数，分别代表 $a,b,p$。 输出格式输出一行一个字符串 a^b mod p=s，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。 样例 #1样例输入 #112 10 9 样例输出 #112^10 mod 9=7 提示样例解释 $2^{10} = 1024$，$1024 \\bmod 9 = 7$。 数据规模与约定 对于 $100\\%$ 的数据，保证 $0\\le a,b &lt; 2^{31}$，$a+b&gt;0$，$2 \\leq p \\lt 2^{31}$。 按照上面思路，代码如下： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longsigned main(void)&#123; int a,b,p; int cona,conb; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; cona=a;conb=b; int ans=1; while(b) &#123; if(b&amp;1)ans=(ans*a)%p; a=a*a%p; b&gt;&gt;=1; &#125; printf(&quot;%lld^%lld mod %lld=%lld\\n&quot;,cona,conb,p,ans); return 0;&#125; 例题2：费马小定理和线性算法的应用【模板】模意义下的乘法逆元题目背景这是一道模板题 题目描述给定 $n,p$ 求 $1\\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。 这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\\equiv1\\pmod p$ 的解。 输入格式一行两个正整数 $n,p$。 输出格式输出 $n$ 行，第 $i$ 行表示 $i$ 在模 $p$ 下的乘法逆元。 样例 #1样例输入 #1110 13 样例输出 #112345678910179108112534 提示$ 1 \\leq n \\leq 3 \\times 10 ^ 6$，$n &lt; p &lt; 20000528 $。 输入保证 $ p $ 为质数。 一、逆元的概念 单位元 和 逆元，我们在初中和高中的时候其实就已经接触到了，只不过到了大学才系统性的给他们更加官方的命名。接下来，我们首先来了解下什么是单位元，什么是逆元。 1、单位元 【定义1】在一个集合中，对于某种运算 （注意：这里代表通用运算的表示符号，并不是特指乘法），如果对于任何的集合元素 ，和元素 运算，得到还是集合元素 本身，则称 为这个运算下的单位元。 2、逆元 【定义2】在一个集合中，对于某种运算 ，如果任意两个元素的运算结果等于单位元，则称这两个元素互为逆元。 先是费马小定理： 12345678910ll fpm(ll x, ll power, ll mod) &#123; x %= mod; ll ans = 1; for (; power; power &gt;&gt;= 1, (x *= x) %= mod) if(power &amp; 1) (ans *= x) %= mod; return ans;&#125;int main() &#123; ll x = fpm(a, p - 2, p); //x为a在mod p意义下的逆元&#125; 但是，这个做法会tle 于是我们用线代的知识： 123inv[1] = 1;for(int i = 2; i &lt; p; ++ i) inv[i] = (p - p / i) * inv[p % i] % p; 完整代码如下： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longint n_e[20000528]=&#123;0&#125;;signed main(void)&#123; int n,p; n_e[1]=1; cin&gt;&gt;n&gt;&gt;p; cout&lt;&lt;n_e[1]&lt;&lt;&quot;\\n&quot;; for(int i=2;i&lt;=n;i++) &#123; n_e[i]=((p-(p/i))*n_e[p%i])%p; cout&lt;&lt;n_e[i]&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"快速幂","slug":"快速幂","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"差分","slug":"差分","date":"2024-08-18T12:07:25.616Z","updated":"2024-08-18T11:48:39.750Z","comments":true,"path":"2024/08/18/差分/","permalink":"https://xqc-1368.github.io/2024/08/18/%E5%B7%AE%E5%88%86/","excerpt":"","text":"差分算法1、介绍一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。 所以差分往往应用于线性的场合，即一维数组的环境，但是除此之外，差分还可以应用于二维数组，但是相比较一维数组，应用的较少。 2、定义差分可以简单的看成序列中每个元素与其前一个元素的差。 3、差分与前缀和 12345678910111213141516171819202122const int N = 100010;int n; //n数组长度//定义两个一维整形数组 a为原数组，b为差分数组int a[N],b[N]; //根据定义可知b[i] = a[i] - a[i-1];//稍微具体b[1] = a[1];b[2] = a[2] - a[1];b[3] = a[3] - a[2];...b[i] = a[i] - a[i-1];//转化一下，求数组b的前缀和,根据上面公式可得 b[1]+b[2]+b[3]+...+b[i]= a[1]+(a[2]-a[1])+(a[3]-a[2])+...+(a[i]-a[i-1])= a[i]//由此可知，原序列为差分序列的前缀和序列a[i] = b[1]+b[2]+b[3]+...+b[i]; 一般地，我们认为原序列就是差分序列的前缀和，所以把差分看做前缀和的逆运算 二、一维差分1、定义一维差分是指给定一个长度为n的序列a，要求支持操作pro(l,r,c)表示对a[l]~a[r]区间上的每一个值都加上或减去常数c，并求修改后的序列a。 2、作用让一个序列中某个区间内的所有值均加上或减去一个常数。 可以将对a数组任意区间的同一操作优化到O(1)。 12345//区间[l,r]中的所有值都加上常数cb[l] += c;b[r+1] -= c; //想象下：因为：b[l]=a[l]-a[l-1];，而前面的b[1]~b[l-1]都没有发生变化，所以$a[l-1]=b[1]+…+b[l-1]$不变，所以只可能是a[l]加了c。若要使a[l]~a[r]区间都加上c，则： 12345b[l+1]=a[l+1]-a[l]......b[r]=a[r]-a[r-1] 这中间所有的b中元素统统不变（被减数和减数同时加了c） 而 b[r+1]=a[r+1]-a[r] 因为要使得a[r]+c，而a[r+1]不变，则有b[r+1]-=c 最后对b数组求前缀和，所以以上程序可以实现在a[l]~a[r]里面同时加上c 12345for(int i = 1; i &lt;= n; i++)&#123; b[i] += b[i-1]; printf(&quot;%d &quot;,b[i]);&#125; 例题： 语文成绩题目背景语文考试结束了，成绩还是一如既往地有问题。 题目描述语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？ 输入格式第一行有两个整数 n，p，代表学生数与增加分数的次数。 第二行有 n 个数，a_1 \\sim a_n，代表各个学生的初始成绩。 接下来 p 行，每行有三个数，x，y，z，代表给第 x 个到第 y 个学生每人增加 z 分。 输出格式输出仅一行，代表更改分数后，全班的最低分。 样例 #1样例输入 #112343 21 1 11 2 12 3 1 样例输出 #112 提示对于 40\\% 的数据，有 n \\le 10^3。 对于 60\\% 的数据，有 n \\le 10^4。 对于 80\\% 的数据，有 n \\le 10^5。 对于 100\\% 的数据，有 n \\le 5\\times 10^6，p \\le n，学生初始成绩 \\le 100，z \\le 100。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"差分","slug":"差分","permalink":"https://xqc-1368.github.io/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"单调栈基础：奶牛排队","slug":"单调栈基础：奶牛排队","date":"2024-08-18T11:46:37.853Z","updated":"2024-08-18T12:19:18.409Z","comments":true,"path":"2024/08/18/单调栈基础：奶牛排队/","permalink":"https://xqc-1368.github.io/2024/08/18/%E5%8D%95%E8%B0%83%E6%A0%88%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%A5%B6%E7%89%9B%E6%8E%92%E9%98%9F/","excerpt":"","text":"单调栈引入何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。 为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。 过程插入将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。 例如，栈中自顶向下的元素为 0,11,45,81。 插入元素 14时为了保证单调性需要依次弹出元素 0,11，操作后栈变为 !14,45,81。 用伪代码描述如下： 1234insert xwhile !sta.empty() &amp;&amp; sta.top()&lt;x sta.pop()sta.push(x) 实现 1234insert xwhile !sta.empty() &amp;&amp; sta.top()&lt;x sta.pop()sta.push(x) 使用可以用于从乱序数组某一元素出发，向左可以找到第一个小于他的数，或者第一个大于他的数，向右可以找到第一个小于他，或者大于他的数字（大于等于，小于等于也可以实现），而且能实现对每一个数组中元素，都找到对应的第一个大于他or小于他的数字，由此生成一个新数组。 以下为经典的奶牛排队问题 [USACO09MAR] Look Up S题目描述约翰的 $N(1\\le N\\le10^5)$ 头奶牛站成一排，奶牛 $i$ 的身高是 $H_i(1\\le H_i\\le10^6)$。现在，每只奶牛都在向右看齐。对于奶牛 $i$，如果奶牛 $j$ 满足 $i&lt;j$ 且 $H_i&lt;H_j$，我们可以说奶牛 $i$ 可以仰望奶牛 $j$。 求出每只奶牛离她最近的仰望对象。 Input 输入格式第 $1$ 行输入 $N$，之后每行输入一个身高 $H_i$。 输出格式共 $N$ 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 $0$。 样例 #1样例输入 #112345676 3 2 6 1 1 2 样例输出 #11234563 3 0 6 6 0 提示【输入说明】$6$ 头奶牛的身高分别为 3,2,6,1,1,2。 【输出说明】奶牛 #1,#2 仰望奶牛 #3，奶牛 #4,#5 仰望奶牛 #6，奶牛 #3 和 #6 没有仰望对象。 【数据规模】 对于 $20\\%$ 的数据：$1\\le N\\le10$； 对于 $50\\%$ 的数据：$1\\le N\\le10^3$； 对于 $100\\%$ 的数据：$1\\le N\\le10^5,1\\le H_i\\le10^6$。 用单调栈完成： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef struct &#123; long long number,watch,height;&#125;cow;int main()&#123; int n; stack&lt;cow&gt; st; cin&gt;&gt;n; cow a[n]; for (int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i].height ; a[i].number =i+1; &#125; for (int i=0;i&lt;n;i++) &#123; while(!st.empty() &amp;&amp; st.top().height&lt;a[i].height ) &#123;//奶牛按照身高进入单调栈，栈底小，栈顶大 a[st.top().number-1].watch =a[i].number ;//被pop出单调栈的奶牛意味着他的右侧最近的比他大的奶牛是a【i】可以将他的箭头指向那个元素 st.pop(); &#125; st.push(a[i]); &#125; while(!st.empty() ) &#123; a[st.top().number-1].watch =0; st.pop();//剩下没出栈的奶牛的右边都没有比他高的奶牛了，根据题意，赋值为0； &#125; for (int i=0;i&lt;n;i++) &#123; cout&lt;&lt;a[i].watch &lt;&lt;endl; &#125; return 0;&#125; 注意，这里的关键是我去遍历到a[i]时候，所确定的不是a[i]仰望的奶牛，而是仰望a[i]的奶牛，a[i]是”被看“的奶牛！ 奶牛排队题目描述奶牛在熊大妈的带领下排成了一条直队。 显然，不同的奶牛身高不一定相同…… 现在，奶牛们想知道，如果找出一些连续的奶牛，要求最左边的奶牛 $A$ 是最矮的，最右边的 $B$ 是最高的，且 $B$ 高于 $A$ 奶牛。中间如果存在奶牛，则身高不能和 $A,B$ 奶牛相同。问这样的奶牛最多会有多少头？ 从左到右给出奶牛的身高，请告诉它们符合条件的最多的奶牛数（答案可能是 $0,2$，但不会是 $1$）。 输入格式第一行一个正整数 $N$，表示奶牛的头数。 接下来 $N$ 行，每行一个正整数，从上到下表示从左到右奶牛的身高 $h_i$。 输出格式一行一个整数，表示最多奶牛数。 样例 #1样例输入 #1123456512341 样例输出 #114 提示样例解释取第 $1$ 头到第 $4$ 头奶牛，满足条件且为最多。 数据范围对于全部的数据，满足 $2 \\le N \\le 10^5$，$1 \\le h_i &lt;2^{31}$。 题中的“左边最矮”“右边最高”等信息让我们考虑使用单调栈来快速处理。 首先用单调栈处理出每头奶牛左边第一个身高大于等于它的奶牛位置+1的位置（watchlefthigh元素）以及右边第一个身高小于等于它的奶牛位置−1的位置（watchrightlow元素）。为什么呢？这样做，我们就框定了每头奶牛分别作为合题奶牛组的左端点A和右端点B时，剩余的端点B，A可取的范围。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef struct &#123; long long number,watchrightlow,height,watchlefthigh;&#125;cow;int main()&#123; int n,max=0; stack&lt;cow&gt; st; scanf(&quot;%d&quot;,&amp;n); cow a[n]; //输入部分 for (int i=0;i&lt;n;i++) &#123; scanf(&quot;%ld&quot;,&amp;a[i].height); a[i].number =i; &#125; //第一次单调栈 for (int i=0;i&lt;n;i++) &#123; while(!st.empty() &amp;&amp; st.top().height&gt;=a[i].height ) &#123; a[st.top().number].watchrightlow =a[i].number-1 ; st.pop(); &#125; st.push(a[i]); &#125; while(!st.empty() ) &#123; a[st.top().number].watchrightlow =n-1; st.pop(); &#125;//第二次单调栈 for (int i=n-1;i&gt;=0;i--) &#123; while(!st.empty() &amp;&amp; st.top().height&lt;=a[i].height ) &#123; a[st.top().number].watchlefthigh =a[i].number+1 ; st.pop(); &#125; st.push(a[i]); &#125; while(!st.empty() ) &#123; a[st.top().number].watchlefthigh =0; st.pop(); &#125;//检索重合区域 for(int i=n-1;i&gt;=0;i--) &#123; for (int j=i;j&gt;=a[i].watchlefthigh ;j--) &#123; if(a[j].watchrightlow &gt;=i) &#123; max=max&gt;i-j+1?max:i-j+1; &#125; &#125; &#125; if(max==1)max=0;//处理特殊情况（题意） cout&lt;&lt;max&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"算法/数据结构/栈","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://xqc-1368.github.io/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://xqc-1368.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"栈基础：后缀表达式求值","slug":"栈基础：后缀表达式求值","date":"2024-08-18T11:46:37.837Z","updated":"2024-08-18T11:43:07.200Z","comments":true,"path":"2024/08/18/栈基础：后缀表达式求值/","permalink":"https://xqc-1368.github.io/2024/08/18/%E6%A0%88%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/","excerpt":"","text":"后缀表达式题目描述所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。 如：$\\texttt{3(5-2)+7}$ 对应的后缀表达式为：$\\texttt{3.5.2.-7.+@}$。在该式中，@ 为表达式的结束符号。. 为操作数的结束符号。 输入格式输入一行一个字符串 $s$，表示后缀表达式。 输出格式输出一个整数，表示表达式的值。 样例 #1样例输入 #113.5.2.-*7.+@ 样例输出 #1116 提示数据保证，$1 \\leq |s| \\leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。 以下为c++用stl写的代码 123456789101112131415161718192021222324252627int main()&#123; cin&gt;&gt;c; int a=0,b=0; int i,j; for(int k=0;k&lt;c.length();k++) &#123; if(c[k]==&#x27;@&#x27;) break; else if(c[k]==&#x27;.&#x27;)&#123; q.push(a); b=0,a=0; &#125; else if(c[k]&lt;=&#x27;9&#x27;&amp;&amp;c[k]&gt;=&#x27;0&#x27;)&#123; a=b*10+c[k]-&#x27;0&#x27;; b=a; &#125; else&#123; if(c[k]==&#x27;-&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j-i); if(c[k]==&#x27;+&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j+i); if(c[k]==&#x27;*&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j*i); if(c[k]==&#x27;/&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j/i); &#125; &#125; cout&lt;&lt;q.top()&lt;&lt;endl;&#125; 以下为c语言（掺了一点c++的水，关键部分还是用c语言和cpp共有的函数写的）原始人代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define maxsize 100using namespace std;typedef struct sttack&#123; int st[maxsize]; int top;&#125;stack;stack *init_stack()&#123; stack *st; st = (stack*)malloc(sizeof(stack)); st-&gt;top =-1; return st;&#125;int push(stack *s,int x)&#123; if(s-&gt;top+1&gt;=maxsize ) &#123; return 0; &#125; else &#123; s-&gt;top++; s-&gt;st[s-&gt;top]=x; &#125; return 1;&#125;int pop(stack *s)&#123; long long ret; if(s-&gt;top&lt;=-1)&#123; return 0; &#125; else&#123; ret=s-&gt;st [s-&gt;top ]; s-&gt;top--; &#125; return ret;&#125;void printstack(stack *s)&#123; while((*s).top !=-1)&#123; printf(&quot;%d&quot;,(*s).st [s-&gt;top]); s-&gt;top--; &#125;&#125;int main(void)&#123; stack *st; st = init_stack(); char ch[15],c; int i=0; long long tar,a1,a2; cin&gt;&gt;c; while(c!=&#x27;@&#x27;) &#123; if(c&gt;=&#x27;0&#x27; &amp;&amp; c&lt;=&#x27;9&#x27;) &#123; while(c!=&#x27;.&#x27;) &#123; ch[i]=c; i++; cin&gt;&gt;c; &#125; i=0; tar=atol(ch); push(st,tar); memset(ch,0,sizeof(ch));//memset函数用于清空字符串ch的值 &#125; else if(c==&#x27;+&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a1+a2); &#125; else if(c==&#x27;-&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a2-a1); &#125; else if(c==&#x27;*&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a1*a2); &#125; else if(c==&#x27;/&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a2/a1); &#125; cin&gt;&gt;c; &#125; cout&lt;&lt;st-&gt;st [st-&gt;top ]&lt;&lt;endl; free(st);return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"算法/数据结构/栈","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://xqc-1368.github.io/tags/%E6%A0%88/"}]},{"title":"03二叉树的节点距离（LCA）+深度标记：二叉树问题","slug":"03二叉树的节点距离（LCA）+深度标记：二叉树问题","date":"2024-08-18T09:06:00.750Z","updated":"2024-08-18T09:40:10.964Z","comments":true,"path":"2024/08/18/03二叉树的节点距离（LCA）+深度标记：二叉树问题/","permalink":"https://xqc-1368.github.io/2024/08/18/03%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%EF%BC%88LCA%EF%BC%89+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"[JLOI2009] 二叉树问题题目描述如下图所示的一棵二叉树的深度、宽度及结点间距离分别为： 深度：$4$ 宽度：$4$ 结点 8 和 6 之间的距离：$8$ 结点 7 和 6 之间的距离：$3$ 其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。 给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。 输入格式第一行是一个整数，表示树的结点个数 $n$。接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上存在一条连接 $u, v$ 的边。最后一行有两个整数 $x, y$，表示求 $x, y$ 之间的距离。 输出格式输出三行，每行一个整数，依次表示二叉树的深度、宽度和 $x, y$ 之间的距离。 样例 #1样例输入 #1123456789101110 1 2 1 3 2 42 53 63 75 85 96 108 6 样例输出 #1123448 提示对于全部的测试点，保证 $1 \\leq u, v, x, y \\leq n \\leq 100$，且给出的是一棵树。 相当于分解成三个问题是吧。 1.求最大深度（深度优先搜索算法解决） MY思路1234567891011121314151617181920void depth(int p)&#123; if(bi[p].lchild !=-1) &#123; dep++; depth(bi[p].lchild); &#125; if(bi[p].rchild !=-1) &#123; dep++; depth(bi[p].rchild); &#125; if(bi[p].lchild ==-1 &amp;&amp; bi[p].rchild ==-1 &amp;&amp; dep&gt;ans1) &#123; ans1=dep; &#125; dep--; return;&#125; dalao思路1234567struct node&#123; int father; //爸爸 int left; //左儿子 int right; //右儿子 int deep; //深度 int data; //记录节点走过没&#125;a[10001]; 直接在结构体里面定义了一个深度属性 1a[y].deep=a[x].deep+1;//遍历树，后一项深度等于前一项加一 2.最大宽度 my思路(迭代版本 广度优先搜索)123456789101112131415161718192021222324252627282930void breath()&#123; q.push(bi[1]); int siz=q.size(); for(int j=0;j&lt;ans1-1;j++) &#123; for (int i=0;i&lt;siz;i++) &#123; if(q.front().lchild!=-1) &#123; q.push(bi[q.front().lchild]); &#125; if(q.front().rchild!=-1) &#123; q.push(bi[q.front().rchild]); &#125; q.pop(); if(q.size()&gt;ans2) &#123; ans2=q.size(); &#125; &#125; siz=q.size(); &#125; cout&lt;&lt;ans2&lt;&lt;endl;&#125; dalao思路直接利用第一题的deep，deep相同的在一个桶数组中加在一起 1234for(int i=1;i&lt;=n;i++) //把每一个深度有多少个节点记录 sum[a[i].deep]++; sort(sum+1,sum+1+100); cout&lt;&lt;maxx&lt;&lt;endl&lt;&lt;sum[100]&lt;&lt;endl&lt;&lt;num+num1; //sum[100]是最大的宽度节点个数 3.路径长度 my思路（深度优先搜索）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void search(int node,int come)//come表示这个节点是怎么被寻找到的（方便回溯） 1：父节点找左子树，2：父节点找右子树3：左子树找父节点4：右子树找父节点 &#123; if(node==node2) &#123; ans3=pathlen; return; &#125; else &#123; if(bi[node].lchild !=-1 &amp;&amp; come!=3) &#123; top++; path[top]=bi[node].lchild; pathlen++; search(bi[node].lchild ,1); &#125; if(bi[node].rchild !=-1 &amp;&amp; come !=4) &#123; top++; path[top]=bi[node].rchild; pathlen++; search(bi[node].rchild ,2); &#125; if(bi[node].father !=-1 &amp;&amp; come!=1&amp;&amp;come!=2) &#123; top++; path[top]=bi[node].father;pathlen+=2; if(bi[bi[node].father].lchild!=-1 &amp;&amp; bi[bi[node].father].lchild==node) &#123; search(bi[node].father ,3); &#125; else if(bi[bi[node].father].rchild!=-1 &amp;&amp; bi[bi[node].father].rchild==node) &#123; search(bi[node].father ,4); &#125; &#125; &#125; if(come==1|| come==2) &#123; pathlen--; &#125; else if(come==3 || come==4)pathlen-=2; top--; return;&#125; dalao思路（lca算法）普及一下 最近公共祖先简单引入对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。 红色的都是是A和B的公共祖先，但只有最近的C才是最近公共祖先。 LCA问题是树上的一个经典问题，在很多方面有着广泛的应用，比如求LCP（最长公共前缀），接下来我们就来介绍他的几种算法。 LCA的算法 暴力枚举法如果我们要求a和b的最近公共祖先，就沿着父亲的方向把a的所有祖先都标记一下（类似并查集找父亲，但是没有路径压缩），然后在从b开始往上找祖先，碰到第一个被标记的点，就是a和b的最近公共祖先。 C是最近公共祖先。 求一个对点的LCA时间复杂度高达O（N）。求m个点对的LCA时间复杂度高达O（mN）。当m和n都高达10万的时候，超时了！！！ 宝宝难以承受！！！！！ 求m个点对的最近公共祖先是可以优化的，一般有两种：1、离线算法（Tarjan离线算法）：所谓的离线算法指的是把所有问题收集起来以后一起去算，最后一起回答。2、在线算法（倍增算法）：所谓的在线算法就是来一个点对，处理一个点对。 Tarjan离线算法Robert Tarjan设计了求解的应用领域的许多问题的广泛有效的算法和数据结构。 他已发表了超过228篇理论文章（包括杂志，一些书中的一些章节文章等）。Robert Tarjan以在数据结构和图论上的开创性工作而闻名。 他的一些著名的算法包括 Tarjan最近共同祖先离线算法 ，Tarjan的强连通分量算法等。其中Hopcroft-Tarjan平面嵌入算法是第一个线性时间平面算法。Tarjan也开创了重要的数据结构如：斐波纳契堆和splay树（splay发明者还有Daniel Sleator）。另一项重大贡献是分析了并查集。他是第一个证明了计算反阿克曼函数的乐观时间复杂度的科学家。（此段来自百度百科，有删改） 简单的介绍一下tarjan算法：tarjan算法是离线算法，它必须先将所有的要查询的点对存起来，然后在搜的时候输出结果。tarjan算法很经典，因为算法的思想很巧妙，利用了并查集思想，在dfs下，将查询一步一步的搜出来。 基本思路： 下面给出真代码： 123456789101112131415161718192021int f[N],n,m,ans[N],check[N]; vector&lt;int&gt; a[N],b[N],id[N];int find(int x) &#123; return x==f[x] ? x : f[x]=find(f[x]); &#125;void tarjan(int x) &#123; f[x]=x; check[x]=1; for(int i=0; i&lt;a[x].size(); i++) &#123; int v=a[x][i]; if(!check[v]) &#123; tarjan(v); f[v]=x; &#125; &#125; for(int i=0; i&lt;b[x].size(); i++) &#123; int v=b[x][i]; if(!check[v]) continue; ans[id[x][i]]=find(v); &#125;&#125; 我们在深度优先遍历的时候，先遍历x节点的左子树，当遍历到u的时候，发现v没有被遍历过，那么就不去管lca(u,v)这个问题，然后我们把已经遍历的x子树的所有节点都合并到他的父亲（即father指向父亲），然后当我们遍历到v的时候，发现u已经遍历过了，那么此时u在并查集里的father就是u和v的最近公共祖先. 时间复杂度：由于每个点只遍历一次，每个问题只枚举2次，所以时间复杂度是O（N+2Mα(N))。α(N)为并查集查询一次根所需要的时间。 倍增算法首先一个小问题，给你两个点a和b，你如何快速的回答这两个点在树里面是否具有祖先和后代的关系。暴力算法又是o（N），明显太浪费时间！ 引入时间戳的概念：所谓的时间戳就是在给一棵树进行深度优先遍历的同时，记录下计入每个点的时候和离开每个点的时间。 如图所示，每个节点的左边是进入的时间，右边是离开的时间。 如果a是b的祖先，只要满足 (in[a]&lt;=in[b]) and (out[b]&lt;=out[a])也就是我们只需要一次深搜，接下来对于任何询问a和b是否有祖先关系的时候，我们只要O(1)的时间就能回答这个问题。 建立倍增数组：定义f[i][j]为与节点i距离为2^j的祖先的编号。明显的f[i][0]就是每个点直接的父亲。另有递推关系：f[i][j]=f[f[i][j-1],j-1]。于是我们只需要在nlogn的时间内就可以求出f数组的值。 如果f[i][j]不存在，我们就令f[i][j]=根，方便我们计算接下来如何求a和b的最近公共祖先呢？1、如果a是b的祖先，那么输出a2、如果b是a的祖先，那么输出b3、for i:=20 downto 0 doif f[a][i]不是b的祖先，那么令 a=f[a][i];循环结束的时候，f[a][0]就是最近公共祖先。 12345678int lca(int x,int y) &#123; if(ancestor(x,y)) return x; if(ancestor(y,x)) return y; for(int i=20; i&gt;=0; i--) if(!ancestor(f[x][i],y)) x=f[x][i]; return f[x][0]; &#125; 1234567891011int lca(int x,int y)&#123; //最最重要！！！求最近公共祖先 a[x].data=1; //把x的节点记录已走过 while(a[x].father!=0)&#123; //遍历至根节点 x=a[x].father; //更新遍历爸爸 a[x].data=1; //记录已走过 &#125; while(a[y].data!=1)&#123; //遍历至x节点已走过的节点，找到最近公共祖先 y=a[y].father; &#125; return y;&#125; 上面最后一个代码是实现本题目的代码哦 完结！","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://xqc-1368.github.io/tags/BFS/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"},{"name":"树上距离","slug":"树上距离","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E8%B7%9D%E7%A6%BB/"}]},{"title":"03 最近公共祖先（LCA）：倍增解法","slug":"03 最近公共祖先（LCA）：倍增解法","date":"2024-08-18T09:06:00.743Z","updated":"2024-08-18T09:39:55.993Z","comments":true,"path":"2024/08/18/03 最近公共祖先（LCA）：倍增解法/","permalink":"https://xqc-1368.github.io/2024/08/18/03%20%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89%EF%BC%9A%E5%80%8D%E5%A2%9E%E8%A7%A3%E6%B3%95/","excerpt":"","text":"最近公共祖先（LCA）问题——倍增解法【模板】最近公共祖先（LCA）题目描述如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 输入格式第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。 接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。 接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。 输出格式输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。 样例 #1样例输入 #1123456789105 5 43 12 45 11 42 43 23 51 24 5 样例输出 #11234544144 提示对于 $30\\%$ 的数据，$N\\leq 10$，$M\\leq 10$。 对于 $70\\%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。 对于 $100\\%$ 的数据，$1 \\leq N,M\\leq 500000$，$1 \\leq x, y,a ,b \\leq N$，不保证 $a \\neq b$。 样例说明： 该树结构如下： 第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。 第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。 第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。 第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。 第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。 故输出依次为 $4, 4, 1, 4, 4$。 倍增算法求LCA 第一步：预处理对数表数组 如果我们预处理一个数组，规定：lg2[i]表示log_2^i+1（别问为什么加一，不然不方便在O(n)的时间内求出，用到的时候-1即可） 使得：对数可以查表获得，则大大方便： 1234for(int i=1;i&lt;=n;i++)//deal array:lg2[i]+1 &#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i); &#125; 处理方法自己推： 1234lg2[1]:1 lg2[2]:2 lg2[3]:2 lg2[4]:3 lg2[5]:3 lg2[6]:3 lg2[7]:3 lg2[8]:4 lg2[9]:4 lg2[10]:4lg2[11]:4 lg2[12]:4 lg2[13]:4 lg2[14]:4 lg2[15]:4lg2[16]:5 lg2[17]:5 lg2[18]:5 lg2[19]:5 lg2[20]:5 解释如下：（ai生成，有删改） 这段代码定义了一个名为lg2的数组,用于计算以2为底的对数+1。具体来说,lg2[i]表示数字i的以2为底的对数+1的值。 在循环中,首先将lg2[0]赋值为0。然后,对于每个i(从1到n),将lg2[i]的值设置为lg2[i-1]+(1&lt;&lt;lg2[i-1]==i)。 这个循环的目的是计算2的整数次幂在lg2数组中的对应位置。具体来说,(1&lt;&lt;lg2[i-1])表示2的i-1次方,==i表示i是2的i-1次方的整数次幂。如果i是2的i-1次方的整数次幂,那么(1&lt;&lt;lg2[i-1])==i,否则(1&lt;&lt;lg2[i-1])!=i。因此,(1&lt;&lt;lg2[i-1]==i)的值为1或0,可以用来判断i是否是2的i-1次方的整数次幂。 最后,lg2[i]表示数字i的以2为底的对数+1,即log_2(i)+1。 第二步：通过一次dfs，预处理找2的i次方祖先数组fa和深度数组depth，后面会有用 123456789101112131415161718192021void predfs(int nowpoint,int father=0)&#123;//每递归到一个节点nowpoint,就完成nowpoint节点的depth[nowpoint]和//nowpoint的最高能跳到的2的i次方级祖先的编纂 depth[nowpoint]=depth[father]+1;//nowpoint的深度比其父的深度大1 fa[nowpoint][0]=father;//nowpoint的2的0次方级祖先，即nowpoint的1级祖先为父亲节点 for(int i=1;i&lt;=lg2[depth[nowpoint]];i++) &#123;//这个循环跑遍了nowpoint能大跃进到的每一个祖先节点的可能性 fa[nowpoint][i]=fa[fa[nowpoint][i-1]][i-1]; //意思是now的2^i祖先等于now的2^(i-1)祖先的2^(i-1)祖先//例如：nowpoint的4级祖先等于nowpoint的2级祖先的2级祖先 &#125; for(auto ip :ipoint[nowpoint] ) &#123;//遍历nowpoint的子节点，继续编纂 if(ip!=father) &#123; predfs(ip,nowpoint); &#125; &#125;&#125; 第三步，理解LCA算法： 以下开始正式说明：倍增算法 原理视频：https://www.bilibili.com/video/BV1nE411L7rz?vd_source=c6cac99ae3e57c727ad51765bee0a508 所谓倍增，就是按2的倍数来增大，也就是跳 1,2,4,8,16,32 …… 不过在这我们不是按从小到大跳，而是从大向小跳，即按……32,16,8,4,2,1来跳，如果大的跳不过去，再把它调小。这是因为从小开始跳，可能会出现“悔棋”的现象。拿 5 为例，从小向大跳，5=1+2+4,所以我们还要回溯一步，然后才能得出5=1+4；而从大向小跳，直接可以得出5=4+1。 如图：节点19的深度depth[19]=13，节点2的深度depth[2]=2 （如果认为0号节点深度为0的话） 则18号节点称为19号节点的1级祖先，即为$2^0$级祖先 同理：17号节点称为19号节点的2级祖先，即为$2^1$级祖先 同理：15号节点称为19号节点的4级祖先，即为$2^2$级祖先 同理：11号节点称为19号节点的8级祖先，即为$2^3$级祖先 所以如果有这样一种可能，一次性跳到 $2^{…32,16,8,4,2,1}$ 级祖先，则加快效率 一：使得蓝色箭头经过：先跳越$2^3$次（3这个数字通过：$floor(log_2^{depth[19]-depth[2]})$得到，本来理想状况下跳跃depth[19]-depth[2]=13-2=11个节点，由于要用2的……4，3，2，1次方去逼近最终取等depth[19]-depth[2]这个差值） 二：此时蓝色箭头已经跳跃到了11号点，再跳跃$2^{floor(log_2^{depth[11]-depth[2]})}$ 个点，即$2^1$=2个点，同理，再跳$2^0$=1个点，到3号点。于是此时：箭头与2就处于相同深度（如下图所示） 特判：此时，箭头与2就处于相同深度，如果此时，箭头恰好指向2号节点，即证明19号节点为2号节点的子节点，所以LCA为2号节点，直接返回2号节点作为结果 如果以上特判不成立： 三：下面开始做尝试，让两个端点（2，3节点）同时向上跳跃，优先尝试跳跃$2^1$（因为最多也只能向上跳这么多）再尝试跳跃$2^0$ 个，再尝试不跳越。看何时有跳跃后节点不重合情况（因为如下图：0号点和1号点都是2，3点的Common Ancester，所以重合并不能作为判断条件，而是应该寻找非重合的深度最浅的两点（在下图中不用跳即可到达这两点，即这两点恰好为2，3），让2，3处的箭头跳到这两个点，即有：这两个新确定的点的公共父节点为LCA） 12345678910111213141516171819202122232425int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) &#123; swap(x,y); &#125;//以上特判，用数学语言来说就是：不妨设x的深度 &gt;= y的深度 while(depth[x]&gt;depth[y]) &#123; x=fa[x][lg2[depth[x]-depth[y]]-1]; &#125; //先跳到同一深度 if(x==y)return x;//如果x是y的祖先，那他们的LCA肯定就是x了 else &#123; for(int i=lg2[depth[x]]-1;i&gt;=0;--i)//不断向上跳（lg就是之前说的常数优化） &#123; if(fa[x][i]!=fa[y][i]) &#123; //因为我们要跳到它们LCA的下面一层，所以它们肯定不相等，如果不相等就跳过去。 x=fa[x][i]; y=fa[y][i]; &#125; &#125; &#125; return fa[x][0];//返回父节点&#125; 完整代码（100unaccepted） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;vector&gt;#define int long longusing namespace std;const int N=5e5+5;vector&lt;int&gt; ipoint[N];int u,a[N]=&#123;0&#125;;int lg2[N]=&#123;0&#125;,depth[N],father[N][22];void dfs(int nowpoint,int fa=0)&#123; depth[nowpoint]=depth[fa]+1; father[nowpoint][0]=fa; for(int i=1;i&lt;=lg2[depth[nowpoint]]-1;i++) &#123; father[nowpoint][i]=father[father[nowpoint][i-1]][i-1]; &#125; for(auto ip:ipoint[nowpoint]) &#123; if(ip!=fa) dfs(ip,nowpoint); &#125; return;&#125;int LCA(int x, int y)&#123; if(depth[x]&lt;depth[y]) &#123; swap(x,y); &#125; while(depth[x]&gt;depth[y]) &#123; x=father[x][lg2[depth[x]-depth[y]]-1]; &#125; if(x==y)return x; for(int i=lg2[depth[x]]-1;i&gt;=0;i--) &#123; if(father[x][i]!=father[y][i]) &#123; x=father[x][i]; y=father[y][i]; &#125; &#125; return father[x][0];&#125;signed main(void)&#123; int n,m,s,edge1,edge2; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++)//deal array:lg2[i]+1 &#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i); &#125; for(int i=1;i&lt;=n-1;i++) &#123; scanf(&quot;%d %d&quot;, &amp;edge1, &amp;edge2); ipoint[edge1].emplace_back(edge2); ipoint[edge2].emplace_back(edge1); &#125; dfs(s); while(m--) &#123; scanf(&quot;%d %d&quot;,&amp;edge1,&amp;edge2); cout&lt;&lt;LCA(edge1,edge2)&lt;&lt;endl; &#125; return 0;&#125; LCA解决：树上两点距离公式lca处理树上任意两点间距离，即：dis[a]+dis[b]-2*dis[lca(a,b)] LCA解决：树上路径相交问题例题如下： 仓鼠找 sugar题目描述小仓鼠的和他的基（mei）友（zi）sugar 住在地下洞穴中，每个节点的编号为 $1\\sim n$。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（$a$）到餐厅（$b$），而他的基友同时要从他的卧室（$c$）到图书馆（$d$）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？ 小仓鼠那么弱，还要天天被 zzq 大爷虐，请你快来救救他吧！ 输入格式第一行两个正整数 $n$ 和 $q$，表示这棵树节点的个数和询问的个数。 接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$，表示节点 $u$ 到节点 $v$ 之间有一条边。 接下来 $q$ 行，每行四个正整数 $a$、$b$、$c$ 和 $d$，表示节点编号，也就是一次询问，其意义如上。 输出格式对于每个询问，如果有公共点，输出大写字母 Y；否则输出N。 样例 #1样例输入 #1123456789105 52 54 21 31 45 1 5 12 2 1 44 1 3 43 1 1 53 5 1 4 样例输出 #112345YNYYY 提示本题时限 1s，内存限制 128M，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。 $20\\%$ 的数据 $n, q\\le200$。 $40\\%$ 的数据 $n, q\\le 2\\times10^3$。 $70\\%$ 的数据 $n, q\\le 5\\times10^4$。 $100\\%$ 的数据 $1\\le n, q\\le10^5$。 先上结论： 如果两条路径相交，那么一定有一条路径的LCA在另一条路径上 而判断一个节点x，是否在路径s-t上需要满足如下几个条件 123- 条件一：deep[x]&gt;=deep[LCA(s,t)]- 条件二：LCA(s,x)=x或LCA(t,x)=x; 判断条件一：（以下一大段内容可以缩写为：不妨设depth[x]&gt;=depth[y]） 只需讨论两种情况： 假设要求算a-b和c-d两条路径是否相交，设： x=LCA(a,b); y=LCA(c,d); 则先比较：depth[x]和depth[y]的大小，如果depth[x]&gt;=depth[y]不做处理，如果depth[x]&lt;depth[y]则对应的交换x与y，a与c，b与d， 使得现在的x,a,b,这一组数有depth[x]&gt;depth[y] 然后再判断条件二是否成立即可； 样例代码（LCA部分和DFS部分不变，主程序如下） 12345678910111213141516171819202122232425262728293031323334353637int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin.tie(0); int n,q,v,u; cin&gt;&gt;n&gt;&gt;q; lg[0]=0; for(int i=1;i&lt;=n;i++) &#123; lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); &#125; for(int i=1;i&lt;=n-1;i++) &#123; cin&gt;&gt;u&gt;&gt;v; ipoint[u].emplace_back(v); ipoint[v].emplace_back(u); &#125; dfs(1); int a,b,c,d; for(int i=1;i&lt;=q;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; int x=LCA(a,b); int y=LCA(c,d); if(depth[x]&lt;depth[y]) &#123; swap(x,y); swap(a,c); swap(b,d); &#125; if(LCA(c,x)==x || LCA(d,x)==x) printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"}]},{"title":"02顺序二叉树+深度标记：二叉树深度","slug":"02顺序二叉树+深度标记：二叉树深度","date":"2024-08-18T09:06:00.734Z","updated":"2024-08-18T09:38:53.374Z","comments":true,"path":"2024/08/18/02顺序二叉树+深度标记：二叉树深度/","permalink":"https://xqc-1368.github.io/2024/08/18/02%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"【深基16.例3】二叉树深度题目描述有一个 $n(n \\le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 0 0。 建好这棵二叉树之后，请求出它的深度。二叉树的深度是指从根节点到叶子结点时，最多经过了几层。 输入格式第一行一个整数 $n$，表示结点数。 之后 $n$ 行，第 $i$ 行两个整数 $l$、$r$，分别表示结点 $i$ 的左右子结点编号。若 $l=0$ 则表示无左子结点，$r=0$ 同理。 输出格式一个整数，表示最大结点深度。 样例 #1样例输入 #11234567872 73 64 50 00 00 00 0 样例输出 #114 本蒟蒻的小记这道题的步骤划分为两个： 第一步：根据要求建树，对于这种1-7元素都有的这种树，除了传统的顺序存储，和传统的链式存储，还可以用数组顺序存储链式存储混合存储（即数组中的每个元素都是一个结构体，都有leftchild和rightchild的下标，通过下表实现“指向”的概念） 第二步：广度优先搜索算法：这个比较简单直接看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;queue&gt;#define max_size 1000005using namespace std;typedef struct bit&#123; long long depth=1; long long number; long long lchild; long long rchild;&#125;bitree;bitree bi[max_size];//树的数组是全局变量queue&lt;bitree&gt; q;//广搜需要队列long long bfs()//广度优先搜索算法部分&#123; q.push(bi[1]); long long max=0; while(!q.empty()) &#123; if(q.front().lchild!=-1) &#123; bi[q.front().lchild].depth =q.front().depth+1; q.push(bi[q.front().lchild]); &#125; if(q.front().rchild!=-1) &#123; bi[q.front().rchild].depth =q.front().depth+1; q.push(bi[q.front().rchild]); &#125; if(q.front().lchild==-1 &amp;&amp; q.front().rchild==-1 &amp;&amp; q.front().depth&gt;max) &#123; max=q.front().depth; &#125; q.pop(); &#125; return max;&#125;int main()&#123; long long n,lch,rch,ans; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)//这个循环实现了建树功能 &#123; cin&gt;&gt;lch&gt;&gt;rch; bi[i].number =i; bi[i].lchild =lch==0?-1:lch; bi[i].rchild =rch==0?-1:rch; &#125; ans=bfs(); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 完结撒花","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树的深度","slug":"树的深度","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"},{"name":"BFS","slug":"BFS","permalink":"https://xqc-1368.github.io/tags/BFS/"}]},{"title":"02 树的直径问题","slug":"02 树的直径问题","date":"2024-08-18T09:06:00.724Z","updated":"2024-08-18T09:37:52.249Z","comments":true,"path":"2024/08/18/02 树的直径问题/","permalink":"https://xqc-1368.github.io/2024/08/18/02%20%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"02 树的直径问题做法 1. 两次 DFS首先从任意节点 y开始进行第一次 DFS，到达距离其最远的节点，记为z，然后再从 z开始做第二次 DFS，到达距离 z最远的节点，记为 z’，则z~z’即为树的直径。 缺陷：不能处理负权边 以下代码来自OIWIKI 1234567891011121314151617181920212223242526const int N = 10000 + 10;int n, c, d[N];vector&lt;int&gt; E[N];void dfs(int u, int fa) &#123; for (int v : E[u]) &#123; if (v == fa) continue; d[v] = d[u] + 1; if (d[v] &gt; d[c]) c = v; dfs(v, u); &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); E[u].push_back(v), E[v].push_back(u); &#125; dfs(1, 0); d[c] = 0, dfs(c, 0); printf(&quot;%d\\n&quot;, d[c]); return 0;&#125; 做法2：树形dp1234567/ /树形dp结构伪代码描述void dfs(节点u)&#123; for()&#123; / /循环访问所有u的子节点 dfs(u的子节点); 用u的子节点信息更新节点u的信息; &#125;&#125; 二.用树形dp求树的直径： 既然是树形动态规划，我们就尝试用上面树形dp的框架来解决问题。1.首先，要确定维护的信息是什么？ 假设当前父节点是u ,u的所有儿子节点为 $v{1},…,v{n}$,那么这个信息必然要满足“只要知道了儿子节点 $v{1},…,v{n}$ 的该信息，就能确定 u 的该信息”。由于最终要求树上最远两个节点的距离，不妨做这样的定义：设d[x]为节点x到其子孙节点的最大距离、设f[x]为以x为根结点的一条最长路径的距离。即要维护的信息就是d[]，f[]。 2.如何维护上述信息？(1) 假设当前遍历到的节点是u，u的子节点是v{1},…,v{n}，对应的边权是w1,…,w_n.依据树形dp的“后序”思想，继续假设已经求得了u的所有子节点v{1},…,v{n}到其子孙节点的最大距离 d[v{1}],…,d[v_n] 。已知信息画成下图，其中红色箭头所示的边为虚拟的边，也可看成是一条路径。 (2) 根据已知信息求d[u]:若边权都是正值,则d[u]=max(d[v1]+w{1},d[v2]+w{2},…,d[ vn]+w_n)，若存在负的权值，则d[u]=max(0,w_1,d[v_1]+w{1},w2,d[v_2]+w{2},…,w_n,d[v_n]+w_n)，可见d[u]&gt;=0。 (3)确定f[u]的值：若边权都是正值，则f[u]=(d[ v_x]+w_x)+(d[ v_y]+ w_y ),其中(d[ v_x]+ w_x)和(d[ v_y]+w_y)分别是u能到达子孙节点的最远距离和次远距离。即f[u]=d[u]+(d[ v_y]+w_y)。 以上过程仅为原理解释，不作为下属程序参数和具体做法 真正的过程：我们记录当 $1$ 为树的根时，每个节点作为子树的根向下，所能延伸的最长路径长度$ d_1$与次长路径（与最长路径无公共边）长度$ d_2$，那么直径就是对于每一个点，该点 $d_1+d_2$ 能取到的值中的最大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;vector&gt;#define int long longusing namespace std;class edge&#123; public: int point; int weight; edge(int po,int wei):point(po),weight(wei)&#123;&#125;&#125;;const int N=5e5+1;vector&lt;edge&gt;ipoint[N];int d1[N],d2[N],ans=0;int n,u,v,w;void dfs(int nowpoint,int fa=0)&#123; d1[nowpoint]=d2[nowpoint]=0; for(edge ip : ipoint[nowpoint]) &#123; if(ip.point!=fa) &#123; dfs(ip.point,nowpoint); int tempd=d1[ip.point]+ip.weight; if(tempd&gt;d1[nowpoint]) &#123; d2[nowpoint]=d1[nowpoint]; d1[nowpoint]=tempd; &#125; else if(tempd&gt;d2[nowpoint]) &#123; d2[nowpoint]=tempd; &#125; &#125; &#125; ans=max(ans,d1[nowpoint]+d2[nowpoint]);&#125;signed main(void)&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; ipoint[u].emplace_back(edge(v,w)); ipoint[v].emplace_back(edge(u,w)); &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 如果需要求出一条直径上所有的节点，则可以在 DP 的过程中，记录下每个节点能向下延伸的最长路径与次长路径（定义同上）所对应的子节点，在求 ans 的同时记下对应的nowpoint 节点 ，使得 $ans=d_1[nowpoint]+d_2[nowpoint]$，即可分别沿着从 nowpoint 开始的最长路径的次长路径对应的子节点一路向某个方向（对于无根树，虽然这里指定了 1为树的根，但仍需记录每点跳转的方向；对于有根树，一路向上跳即可），遍历直径上所有的节点。 OIWIKI版本代码： 1234567891011121314151617181920212223242526const int N = 10000 + 10;int n, c, d[N];vector&lt;int&gt; E[N];void dfs(int u, int fa) &#123; for (int v : E[u]) &#123; if (v == fa) continue; d[v] = d[u] + 1; if (d[v] &gt; d[c]) c = v; dfs(v, u); &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); E[u].push_back(v), E[v].push_back(u); &#125; dfs(1, 0); d[c] = 0, dfs(c, 0); printf(&quot;%d\\n&quot;, d[c]); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"树形dp","slug":"树形dp","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"树的直径","slug":"树的直径","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"}]},{"title":"01树的重心 and 换根dp","slug":"01树的重心 and 换根dp","date":"2024-08-18T09:06:00.705Z","updated":"2024-08-18T09:37:21.513Z","comments":true,"path":"2024/08/18/01树的重心 and 换根dp/","permalink":"https://xqc-1368.github.io/2024/08/18/01%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%20and%20%E6%8D%A2%E6%A0%B9dp/","excerpt":"","text":"无根树——树的重心问题在后文中，我将用 mss（maximum subtree size）表示最大子树大小。用$ size_u(v)$表示以u为根节点时包含v的子树的大小。 此外，我们设整棵树大小为n。 1. 定义如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。 2. 引理引理1：例如，设 u 和 v 相邻，则 $size_u(v)+size_v(u)=n$。因为树上任意节点 w 要么在以 u 为根 v 所在的子树上，此时有 w=v 或有 w 与 v 进而与 u 连通；要么在以 v 为根 u 所在的子树上，此时此时有 w=u 或有 w 与 u 进而与 v 连通 。 引理2：设u，v, w 连通，则$size_u(v) &gt; size_v(w)$ 。 3. 性质 性质1: 某个点是树的重心等价于它最大子树大小不大于整棵树大小的一半。 性质2: 树至多有两个重心。如果树有两个重心，那么它们相邻。此时树一定有偶数个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。 性质3：树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。 性质4：往树上增加或减少一个叶子，如果原节点数是奇数，那么重心可能增加一个，原重心仍是重心；如果原节点数是偶数，重心可能减少一个，另一个重心仍是重心。 性质5：把两棵树通过一条边相连得到一棵新的树，则新的重心在较大的一棵树一侧的连接点与原重心之间的简单路径上。如果两棵树大小一样，则重心就是两个连接点。 找重心利用性质1，一趟dfs即可。 123456789101112131415int n, sz[MAXN], mss[MAXN]; // n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小vector&lt;int&gt; ctr; // 重心void dfs(int p, int fa = 0) // 找重心&#123; sz[p] = 1, mss[p] = 0; for (auto [to, w] : edges[p]) if (to != fa) &#123; dfs(to, p); mss[p] = max(mss[p], sz[to]); sz[p] += sz[to]; &#125; mss[p] = max(mss[p], n - sz[p]); if (mss[p] &lt;= n / 2) ctr.push_back(p);&#125; 变式例题：同时需要统计计算距离的情况——使用换根dp 洛谷 P1395 会议题目描述有一个村庄居住着 $n$ 个村民，有 $n-1$ 条路径使得这 $n$ 个村民的家联通，每条路径的长度都为 $1$。现在村长希望在某个村民家中召开一场会议，村长希望所有村民到会议地点的距离之和最小，那么村长应该要把会议地点设置在哪个村民的家中，并且这个距离总和最小是多少？若有多个节点都满足条件，则选择节点编号最小的那个点。 输入格式第一行，一个数 $n$，表示有 $n$ 个村民。 接下来 $n-1$ 行，每行两个数字 $a$ 和 $b$，表示村民 $a$ 的家和村民 $b$ 的家之间存在一条路径。 输出格式一行输出两个数字 $x$ 和 $y$。 $x$ 表示村长将会在哪个村民家中举办会议。 $y$ 表示距离之和的最小值。 样例 #1样例输入 #1123441 2 2 3 3 4 样例输出 #112 4 提示数据范围对于 $70\\%$ 数据 $n \\le 10^3$。 对于 $100\\%$ 数据 $n \\le 5 \\times 10^4$。 这一题知道思路后还是非常好理解的 我们为了使这棵树有一个确定的顺序,可以先定1为根(从1开始遍历,假如从i点走向j点就记i为j的父亲) 我们定义d[i]为所有点到i点的距离和,ct[i]为i点的子树的所有节点数 对于这一题,我们可以从点1开始找最佳点,所以我们可以先求d[1]的值,求d[1]时顺便还可以求出所有ct[i]的值,然后我们再考虑怎么求其他的d[i] 我们先看一张图 我们首先知道d[1]=16,我们来看d[2]应该怎么求,我们发现相对于d[1]来说,如果设2为最佳点,2,5,6其距离-1,剩下的1,4,3,7,8,9,10到其距离+1, 所以d[2]=d[1]+3×(−1)+7×1=20 我们发现3为2的子树加自己的节点数,即ct[2]+1,7则为其他点的数量,即n−(ct[2]+1), 再试着举几个例子,不难发现,如果y为x的子树: 则,d[y]=d[x]+(ct[y]+1)×(−1)+(n−(ct[y]+1))×1 所以我们直接从1开始遍历,然后一个个算,最后再求最小值就可以了 由此我们可以看出换根DP的套路： 1，指定某个节点为根节点。 2，第一次搜索完成预处理（如子树大小等），同时得到该节点的解。 3，第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。 根据以上想法，也即是先利用深搜求出d [1]，继而用递推公式求出d[ n ]： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N=5e4+5;vector &lt;int&gt; g[N];int sum=0;int v[N]=&#123;0&#125;;int n,d[N]=&#123;0&#125;,ct[N]=&#123;0&#125;;void dfs(int nowpoint,int dis,int fa=0)&#123; for(auto ip :g[nowpoint]) &#123; if(ip!=fa) &#123; dfs(ip,dis+1,nowpoint); ct[nowpoint]+=ct[ip]+1; &#125; &#125; d[1]+=dis; return;&#125;void calculate(int x,int fa=0)&#123; for(auto ip: g[x]) &#123; if(ip!=fa) &#123; d[ip]=d[x]-(ct[ip]+1)+(n-(ct[ip]+1)); calculate(ip,x); &#125; &#125; return;&#125;int main()&#123; int a,b; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++) &#123; cin&gt;&gt;a&gt;&gt;b; g[a].push_back(b); g[b].push_back(a); &#125; dfs(1,0); calculate(1); int minn=d[1],minnp=1; //cout&lt;&lt;d[1]&lt;&lt;&quot; &quot;; for(int i=2;i&lt;=n;i++) &#123; //cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;; if(d[i]&lt;minn) &#123; minn=d[i]; minnp=i; &#125; &#125; //cout&lt;&lt;endl; cout&lt;&lt;minnp&lt;&lt;&quot; &quot;&lt;&lt;minn&lt;&lt;endl; return 0;&#125; 变式例题：同时需要节点加权的情况 医院设置题目描述设有一棵二叉树，如图： 其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\\times20+2\\times40=136$；若医院建在 $3$ 处，则距离和 $=4\\times2+13+20+40=81$。 输入格式第一行一个整数 $n$，表示树的结点数。 接下来的 $n$ 行每行描述了一个结点的状况，包含三个整数 $w, u, v$，其中 $w$ 为居民人口数，$u$ 为左链接（为 $0$ 表示无链接），$v$ 为右链接（为 $0$ 表示无链接）。 输出格式一个整数，表示最小距离和。 样例 #1样例输入 #11234565 13 2 34 0 012 4 520 0 040 0 0 样例输出 #1181 提示数据规模与约定对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$0 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^5$。 即把原来的 ct（节点数）变成人口规模（size）即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; pt[105];int w[105],size[105],ds[105];int n,u,v,sumw;void dfs(int nowpoint,int dis,int fa=0)&#123; for(auto ip:pt[nowpoint]) &#123; if(ip!=fa) &#123; dfs(ip,dis+1,nowpoint); size[nowpoint]+=size[ip]+w[ip]; &#125; &#125; ds[1]+=w[nowpoint]*dis; return ;&#125;void dynamic_programming(int nowpoint,int fa=0)&#123; for(auto ip:pt[nowpoint]) &#123; if(ip!=fa) &#123; ds[ip]=ds[nowpoint]-size[ip]-w[ip]+(sumw-size[ip]-w[ip]); dynamic_programming(ip,nowpoint); &#125; &#125;&#125;int main(void)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;u&gt;&gt;v; sumw+=w[i]; if(u!=0)&#123;pt[i].emplace_back(u);pt[v].emplace_back(i);&#125; if(v!=0)&#123;pt[i].emplace_back(v);pt[u].emplace_back(i);&#125; &#125; dfs(1,0); dynamic_programming(1); //先以1为根求出ds[1],和size[1~n] int mindis=ds[1]; for(int i=2;i&lt;=n;i++) &#123; mindis=min(mindis,ds[i]); &#125; cout&lt;&lt;mindis&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"树的重心","slug":"树的重心","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"换根dp","slug":"换根dp","permalink":"https://xqc-1368.github.io/tags/%E6%8D%A2%E6%A0%B9dp/"},{"name":"树形dp","slug":"树形dp","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"}]},{"title":"01链式二叉树+遍历问题：求先序遍历","slug":"01链式二叉树+遍历问题：求先序遍历","date":"2024-08-18T09:06:00.699Z","updated":"2024-08-18T09:37:06.108Z","comments":true,"path":"2024/08/18/01链式二叉树+遍历问题：求先序遍历/","permalink":"https://xqc-1368.github.io/2024/08/18/01%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"[NOIP2001 普及组] 求先序排列题目描述给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \\le 8$）。 输入格式共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。 输出格式共一行一个字符串，表示一棵二叉树的先序。 样例 #1样例输入 #112BADCBDCA 样例输出 #11ABCD 提示【题目来源】 NOIP 2001 普及组第三题 以下为正文： 这道题本蒟蒻居然去建树，真的是太垃圾了我太菜了，但好在也学习了一下怎么建树，也是比较好的。 本题思路与大佬代码：模拟了好久，终于找出了套路，用的是DFS，其实就是递归； 我说一下这题的主要的方法（要点）， 1.后序遍历中，最后一个节点一定是根节点（对于每一颗子树也成立）； 2.既然这题要求先序遍历，那么我们只需一次输出访问的父节点即可； 这样的话，我们只要递归将一棵大树分成两颗子树，让后找他们的父节点，不断递归输出； 3.那么难点就在这了，如何通过一个中序和后序遍历中找出两段子树的后序遍历序列（后序，因为只有后序我们才方便找到父节点）呢？ 自己可以拿几个样例做一做，耐性点就会发现它的套路，我这里简单说一下： 在中序遍历中找到当前父节点后，我们可以分别求出他的左子树节点数和右子树节点数，因为中序遍历访问的顺序是左子树，父节点，右子树，所以可以直接计算出； 然后，由于我们对结点的访问一定是先访问一颗子树，在访问另一颗，所以在我们的原后序遍历串右边界中减掉右子树节点个数再减一即为新的左子树右边界，在原后序遍历串左边界加上左子树节点个数即为新的右子树左边界； 当然右子树右边界和左子树左边界这个非常好确定，就不在多说，自己看代码吧 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;char s1[10];char s2[10];int len;inline int find(char ch)&#123; for(int i=0;i&lt;len;i++) &#123; if(s1[i]==ch) return i; &#125;&#125;void dfs(int l1,int r1,int l2,int r2)&#123; int m=find(s2[r2]); cout&lt;&lt;s2[r2]; if(m&gt;l1) /*具有左子树*/dfs(l1,m-1,l2,r2-r1+m-1);//r1-m为右子树结点数 if(m&lt;r1) /*具有右子树*/dfs(m+1,r1,l2+m-l1,r2-1);//m-l1为左子树节点数&#125;int main()&#123; cin&gt;&gt;s1; cin&gt;&gt;s2; len=strlen(s1); dfs(0,len-1,0,len-1);&#125; 然而本蒟蒻的传统型建树代码效率也很高，也是AC捏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;string mid,post;typedef struct bit&#123;//二叉树结构体 char content; bit* lchild; bit *rchild;&#125;bitree;void freebypostertraversal(bitree* root)//释放内存空间函数&#123; if(root) &#123; freebypostertraversal(root-&gt;lchild ); freebypostertraversal(root-&gt;rchild ); free(root); &#125;&#125;void preordertraversal(bitree* root)//前序遍历函数&#123; if(root) &#123; cout&lt;&lt;root-&gt;content; preordertraversal(root-&gt;lchild ); preordertraversal(root-&gt;rchild ); &#125;&#125;bitree* mptopre(char inp,int start,int end,int startp,int endp)&#123;//m=中序遍历，p=后续遍历，to=到，pre=前序遍历 int start1,start2,end1,end2,trans,start4,start3,end3,end4; bitree *root=(bitree*)malloc(sizeof(bitree));//建立一个节点的内存 root-&gt;content =inp; for (int i=start;i&lt;=end ;i++) &#123; if(mid[i]==inp) &#123; trans=i; break; &#125; &#125;//这个循环是在中序遍历中找后序遍历的最后一项的根 start1=start; start2=trans+1; end1=trans-1; end2=end; start3=startp; end3=start3+end1-start1; start4=end3+1; end4=endp-1; if (end3&lt;start3)// 判断非空 &#123; root-&gt;lchild =NULL; &#125; else&#123; root-&gt;lchild=mptopre(post[end3],start1,end1,start3,end3); &#125; if (end4&lt;start4)// 判断非空 &#123; root-&gt;rchild =NULL; &#125; else&#123; root-&gt;rchild =mptopre(post[end4],start2,end2,start4,end4); &#125; return root;//返回指针实现连接 &#125;int main()&#123; cin&gt;&gt; mid&gt;&gt;post; bitree *root=mptopre(post[post.length() -1],0,mid.length() -1,0,post.length() -1); preordertraversal(root); freebypostertraversal(root); return 0;&#125; 完结撒花！","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链式二叉树","slug":"链式二叉树","permalink":"https://xqc-1368.github.io/tags/%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"遍历问题","slug":"遍历问题","permalink":"https://xqc-1368.github.io/tags/%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"}]},{"title":"04 树上差分：最大流问题","slug":"04 树上差分：最大流问题","date":"2024-08-18T09:06:00.687Z","updated":"2024-08-18T09:40:24.188Z","comments":true,"path":"2024/08/18/04 树上差分：最大流问题/","permalink":"https://xqc-1368.github.io/2024/08/18/04%20%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"LCA+树上差分 解决最大流问题：Max Flow P树上差分树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。这就是树上差分的基本操作。 树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs 遍历求出差分数组的前缀和，就可以达到降低复杂度的目的。 树上差分时需要求LCA，对点和边的树上差分原理相同，实现略有不同，这里分开来讲。 点差分设将两点u,v之间路径上的所有点权增加x，o=LCA(u,v),o的父亲节点为p，则操作如下：diff[u]+=x,diff[v]+=x,diff[o]-=x,diff[p]-=x;怎么样，是不是很简单！原理也很简单，举个例子： 设原树如下，现要将2,3之间路径上的所有点的权值增加3，设原权值均为0。 则操作后有： 这样，只要dfs一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点的最终权值！ 边差分思想一样，讲一下操作。 设将两点u,v之间路径上的所有边权增加x，o=LCA(u,v)，以每条边两端深度较大的节点存储该边的差分数组，则操作如下： diff[u]+=x,diff[v]+=x,diff[o]-=2*x; 再举个例子，还是上面那个图 则操作后有： 同样地，只要dfs一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点到父亲节点的边的最终权值了！ 例题： [USACO15DEC] Max Flow P题目描述Farmer John has installed a new system of $N-1$ pipes to transport milk between the $N$ stalls in his barn ($2 \\leq N \\leq 50,000$), conveniently numbered $1 \\ldots N$. Each pipe connects a pair of stalls, and all stalls are connected to each-other via paths of pipes. FJ is pumping milk between $K$ pairs of stalls ($1 \\leq K \\leq 100,000$). For the $i$th such pair, you are told two stalls $s_i$ and $t_i$, endpoints of a path along which milk is being pumped at a unit rate. FJ is concerned that some stalls might end up overwhelmed with all the milk being pumped through them, since a stall can serve as a waypoint along many of the $K$ paths along which milk is being pumped. Please help him determine the maximum amount of milk being pumped through any stall. If milk is being pumped along a path from $s_i$ to $t_i$, then it counts as being pumped through the endpoint stalls $s_i$ and $t_i$, as well as through every stall along the path between them. FJ 给他的牛棚的 $N$ 个隔间之间安装了 $N-1$ 根管道，隔间编号从 $1$ 到 $N$。所有隔间都被管道连通了。 FJ 有 $K$ 条运输牛奶的路线，第 $i$ 条路线从隔间 $s_i$ 运输到隔间 $t_i$。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 输入格式The first line of the input contains $N$ and $K$. The next $N-1$ lines each contain two integers $x$ and $y$ ($x \\ne y$) describing a pipe between stalls $x$ and $y$. The next $K$ lines each contain two integers $s$ and $t$ describing the endpoint stalls of a path through which milk is being pumped. 第一行输入两个整数 $N$ 和 $K$。 接下来 $N-1$ 行每行输入两个整数 $x$ 和 $y$，其中 $x \\ne y$。表示一根在牛棚 $x$ 和 $y$ 之间的管道。 接下来 $K$ 行每行两个整数 $s$ 和 $t$，描述一条从 $s$ 到 $t$ 的运输牛奶的路线。 输出格式An integer specifying the maximum amount of milk pumped through any stall in the barn. 一个整数，表示压力最大的隔间的压力是多少。 样例 #1样例输入 #11234567891011121314155 103 41 54 25 45 45 43 54 34 31 33 55 41 53 4 样例输出 #119 提示$2 \\le N \\le 5 \\times 10^4,1 \\le K \\le 10^5$ 以下程序中power为每个点流量大小的差分 对于每一次要求的两个端点，先用LCA算法求出其LCA，再对power的差分数组进行++和—操作，以下内容为主函数的一部分： 1234567891011121314151617181920 int x,y;cin&gt;&gt;n&gt;&gt;k;for(int i=1;i&lt;=n-1;i++)&#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ipoint[x].emplace_back(y); ipoint[y].emplace_back(x);&#125;for(int i=1;i&lt;=n;i++)&#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i);&#125;predfs(1);while(k--)&#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); int lca=LCA(x,y); ++power[x];++power[y]; --power[lca];--power[fa[lca][0]];&#125; 然后使用深度优先搜索实现对每一个节点的子树的差分数组求和操作，同时在算完每一个点时候，使用ans来统计最大流 在主函数中写：dfs(1); 123456789101112void dfs(int nowpoint,int father=0)&#123; for(auto ip: ipoint[nowpoint]) &#123; if(ip!=father) &#123; dfs(ip,nowpoint); power[nowpoint]+=power[ip]; &#125; &#125; ans=max(ans,power[nowpoint]);&#125; 最后输出ans即可 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;vector&gt;#define int long longusing namespace std;const int N=1e5+5;vector&lt;int&gt; ipoint[N]; int n,k,depth[N],fa[N][17],lg2[N]=&#123;0&#125;,power[N]=&#123;0&#125;,ans=-1e7;void predfs(int nowpoint,int father=0)&#123; depth[nowpoint]=depth[father]+1; fa[nowpoint][0]=father; for(int i=1;i&lt;=lg2[depth[nowpoint]];i++)//1 &#123; fa[nowpoint][i]=fa[fa[nowpoint][i-1]][i-1]; &#125; for(auto ip :ipoint[nowpoint] ) &#123; if(ip!=father) &#123; predfs(ip,nowpoint); &#125; &#125;&#125;int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) &#123; swap(x,y); &#125; while(depth[x]&gt;depth[y]) &#123; x=fa[x][lg2[depth[x]-depth[y]]-1]; &#125; if(x==y)return x; else &#123; for(int i=lg2[depth[x]]-1;i&gt;=0;--i) &#123; if(fa[x][i]!=fa[y][i]) &#123; x=fa[x][i]; y=fa[y][i]; &#125; &#125; &#125; return fa[x][0];&#125;void dfs(int nowpoint,int father=0)&#123; for(auto ip: ipoint[nowpoint]) &#123; if(ip!=father) &#123; dfs(ip,nowpoint); power[nowpoint]+=power[ip]; &#125; &#125; ans=max(ans,power[nowpoint]);&#125;signed main(void)&#123; int x,y; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n-1;i++) &#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ipoint[x].emplace_back(y); ipoint[y].emplace_back(x); &#125; for(int i=1;i&lt;=n;i++) &#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i); &#125; predfs(1); while(k--) &#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); int lca=LCA(x,y); ++power[x];++power[y]; --power[lca];--power[fa[lca][0]]; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"},{"name":"树上差分","slug":"树上差分","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"最大流","slug":"最大流","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"}]},{"title":"01 并查集，路径压缩优化，按秩合并优化","slug":"01 并查集，路径压缩优化，按秩合并优化","date":"2024-08-18T09:05:45.715Z","updated":"2024-08-18T09:36:48.404Z","comments":true,"path":"2024/08/18/01 并查集，路径压缩优化，按秩合并优化/","permalink":"https://xqc-1368.github.io/2024/08/18/01%20%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%EF%BC%8C%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/","excerpt":"","text":"并·查·集需要解决的问题： 【模板】并查集题目描述如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。 接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。 当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。 当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1样例输入 #1123456784 72 1 21 1 22 1 21 3 42 1 41 2 32 1 4 样例输出 #11234NYNY 提示对于 $30\\%$ 的数据，$N \\le 10$，$M \\le 20$。 对于 $70\\%$ 的数据，$N \\le 100$，$M \\le 10^3$。 对于 $100\\%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in { 1, 2 }$。 1.初始化因为我们在初始化的时候，每个节点的根节点初始化为它自己，即我爸爸是我自己，这就是根节点和其他节点的不同之处，当 r==fa[r] 的时候，就说明 r 是根节点. 12345void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125; 2.查（“查”的意思是查找一个结点的根节点.）初始化一个fa数组，里面存放每个节点的的父节点（ fa[i]=i 的父节点） fa数组可以表示一颗树，其目的是为了查根节点，根据这个数组，我们就可以“顺藤摸瓜”，找到每个节点的根节点。 假如你在一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root. 于是我们可以写出find函数（未经过路径压缩版本） 1234567int find(int x)&#123; if(x==fa[x]) return fa[x]; else return find(fa[x]);&#125; 路径压缩最简单的并查集效率是比较低的。例如，来看下面这个场景： 现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样： 然后我们又找来一个元素4，并需要执行merge(2,4)： 从2找到1，再找到3，然后fa[3]=4，于是变成了这样： 大家应该有感觉了，这样可能会形成一条长长的链，随着链越来越长，我们想要从底部找到根节点会变得越来越难。 怎么解决呢？我们可以使用路径压缩的方法。既然我们只关心一个元素对应的根节点，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样： 其实这说来也很好实现。只要我们在查询的过程中，把沿途的每个节点的父节点都设为根节点即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现： 合并（路径压缩）123456789int find(int x)&#123; if(x == fa[x]) return x; else&#123; fa[x] = find(fa[x]); //父节点设为根节点 return fa[x]; //返回父节点 &#125;&#125; 以上代码常常简写为一行： 1234int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x]));&#125; 注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。 路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。 3.并（“并”指把两个在同一连通分量的结点合并）比如有两个节点 x和y, 我们就查一下x的根节点和y的根节点（并的时候用到了查）是不是同一个节点（咱们的祖先是不是同一个人），如果是，那么x和y本来就是一家人，不用做任何操作。 如果发现x和y的祖先不同，必须有一个人要迁移户口，例如就让y的祖先做x祖先的儿子，这样x 和 y还是成为一家人了（实现了并操纵）。 代码如下： 1234567void merge(int x,int y)&#123; int fax=f_a(x);//找到i的祖先 int fay=f_a(y);//找到j的祖先 if(fax!=fay) fa[fax]=fay;//让i的祖先指向j的祖先&#125; 并查集的生动阐释： 以上题目的参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5;int fa[N];int n,m;void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;int f_a(int x)&#123; if(x==fa[x]) return fa[x]; else &#123; fa[x]=f_a(fa[x]); return fa[x]; &#125;&#125;void merge(int x,int y)&#123; int fax=f_a(x); int fay=f_a(y); if(fax!=fay) fa[fax]=fay;&#125;bool decide(int x,int y)&#123; return f_a(x)==f_a(y);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; init(); int z,x,y; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; if(z==1)merge(x,y); else if(z==2) &#123; bool result=decide(x,y); if(result)cout&lt;&lt;&quot;Y&quot;&lt;&lt;&quot;\\n&quot;; else cout&lt;&lt;&quot;N&quot;&lt;&lt;&quot;\\n&quot;; &#125; &#125; return 0;&#125; 例题：需要记录压缩路径长度，和集合总长度的变式 [NOI2002] 银河英雄传说题目背景公元 $5801$ 年，地球居民迁至金牛座 $\\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。 宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。 题目描述杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \\ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 M i j，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。 在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：C i j。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。 作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。 输入格式第一行有一个整数 $T$（$1 \\le T \\le 5 \\times 10^5$），表示总共有 $T$ 条指令。 以下有 $T$ 行，每行有一条指令。指令有两种格式： M i j：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。 C i j：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。 输出格式依次对输入的每一条指令进行分析和处理： 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。 样例 #1样例输入 #1123454M 2 3C 1 2M 2 4C 4 2 样例输出 #112-11 提示样例解释战舰位置图：表格中阿拉伯数字表示战舰编号。 解析： fa[]数组维护两个编号之间的连通性，dis[]维护编号为i的战舰到fa[i]之间的距离，num[]维护编号为i的战舰所在的那一列有多少战舰。 记录距离根节点的距离显得尤为重要，其中距离根节点的距离存储在dis数组内 1234567891011121314int find(int x)&#123; if(fa[x]!=x) &#123; int k=fa[x]; fa[x]=find(fa[x]); dis[x]+=dis[k];//这句话很难理解，//但是经过尝试可以发现，这很好的维护了数组dis，//以压缩后路径权值的方式维护了每一个节点到根节点的实际距离（配合下面的初始化）//（即上面的1,2,3）所以记住就好 num[x]=num[fa[x]];//x节点的队伍长度等于根节点的 &#125; return fa[x];&#125; 于是合并函数可以修改如下： 1234567891011void merge(int x,int y)&#123; int r1=find(x),r2=find(y);//直接把根节点插上，不多说 if(r1!=r2) &#123; fa[r1]=r2;//记录父亲 dis[r1]=num[r2];//原队列长度即是此节点到父亲的距离 num[r2]+=num[r1];//r2队列后放了num[r1]个战舰 num[r1]=num[r2];//r1所在的队列和r2所在的已经是同一个队列了 &#125;&#125; 每一次输出只用输出abs(dis[x]-dis[y])-1;即可 注意，这里是问中间有几个城市， 不算两边，所以要-1 完整代码如下： 1 按秩合并有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个菊花图（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并： 假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？ 当然是后者。因为如果把7的父节点设为8，会使树的深度（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。 这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。 我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的子树的深度）。一开始，把所有元素的rank（秩）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。 路径压缩和按秩合并如果一起使用，时间复杂度接近 $O(n)$ ，但是很可能会破坏rank的准确性。 初始化（按秩合并）12345678inline void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; rank[i] = 1; &#125;&#125; 合并（按秩合并）12345678910inline void merge(int i, int j)&#123; int x = find(i), y = find(j); //先找到两个根节点 if (rank[x] &lt;= rank[y]) fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) rank[y]++; //如果深度相同且根节点不同，则新的根节点的深度+1&#125; 为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)： 这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样： 显然树的深度增加了1。另一种合并方式同样会让树的深度+1。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"并查集的路径优化压缩","slug":"并查集的路径优化压缩","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%E5%8E%8B%E7%BC%A9/"},{"name":"并查集的按秩合并优化","slug":"并查集的按秩合并优化","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/"}]},{"title":"02 种类并查集","slug":"02 种类并查集","date":"2024-08-18T09:05:44.155Z","updated":"2024-08-18T09:37:37.392Z","comments":true,"path":"2024/08/18/02 种类并查集/","permalink":"https://xqc-1368.github.io/2024/08/18/02%20%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"种类并查集一般的并查集，维护的是具有连通性、传递性的关系，例如亲戚的亲戚是亲戚。但是，有时候，我们要维护另一种关系：敌人的敌人是朋友。种类并查集就是为了解决这个问题而诞生的。 我们先来看一个例题： （洛谷P1525 关押罪犯） [NOIP2010 提高组] 关押罪犯题目背景NOIP2010 提高组 T3 题目描述S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ 输入格式每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1&lt;a_j\\leq b_j\\leq N, 0 &lt; c_j\\leq 10^9$，且每对罪犯组合只出现一次。 输出格式共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。 样例 #1样例输入 #112345674 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884 样例输出 #113512 提示输入输出样例说明 罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。 数据范围 对于 $30\\%$ 的数据有 $N\\leq 15$。 对于 $70\\%$ 的数据有 $N\\leq 2000,M\\leq 50000$。 对于 $100\\%$ 的数据有 $N\\leq 20000,M\\leq 100000$。 我们开一个两倍大小的并查集。例如，假如我们要维护4个元素的并查集，我们改为开8个单位的空间： 我们用1~4维护朋友关系（就这道题而言，是指关在同一个监狱的狱友），用5~8维护敌人关系（这道题里是指关在不同监狱的仇人）。现在假如我们得到信息：1和2是敌人，应该怎么办？ 我们merge(1, 2+n), merge(1+n, 2);。这里n就等于4，但我写成n这样更清晰。对于1个编号为i的元素，i+n是它的敌人。所以这里的意思就是：1是2的敌人，2是1的敌人。 现在假如我们又知道2和4是敌人，我们merge(2, 4+n), merge(2+n, 4);： 发现了吗，敌人的敌人就是朋友，2和4是敌人，2和1也是敌人，所以这里，1和4通过2+n这个元素间接地连接起来了。这就是种类并查集工作的原理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read() //快速读入，可忽略&#123; int ans = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - &#x27;0&#x27;; c = getchar(); &#125; return ans;&#125;struct data //以结构体方式保存便于排序&#123; int a, b, w;&#125; C[100005];int cmp(data &amp;a, data &amp;b)&#123; return a.w &gt; b.w;&#125;int fa[40005], rank[40005]; //以下为并查集int find(int a)&#123; return (fa[a] == a) ? a : (fa[a] = find(fa[a]));&#125;int query(int a, int b)&#123; return find(a) == find(b);&#125;void merge(int a, int b)&#123; int x = find(a), y = find(b); if (rank[x] &gt;= rank[y]) fa[y] = x; else fa[x] = y; if (rank[x] == rank[y] &amp;&amp; x != y) rank[x]++;&#125;void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; rank[i] = 1; fa[i] = i; &#125;&#125;int main()&#123; int n = read(), m = read(); init(n * 2); //对于罪犯i，i+n为他的敌人 for (int i = 0; i &lt; m; ++i) &#123; C[i].a = read(); C[i].b = read(); C[i].w = read(); &#125; std::sort(C, C + m, cmp); for (int i = 0; i &lt; m; ++i) &#123; if (query(C[i].a, C[i].b)) //试图把两个已经被标记为“朋友”的人标记为“敌人” &#123; printf(&quot;%d\\n&quot;, C[i].w); //此时的怒气值就是最大怒气值的最小值 break; &#125; merge(C[i].a, C[i].b + n); merge(C[i].b, C[i].a + n); if (i == m - 1) //如果循环结束仍无冲突，输出0 puts(&quot;0&quot;); &#125; return 0;&#125; 刚才我说，种类并查集可以维护敌人的敌人是朋友这样的关系，这种说法不够准确，较为本质地说，种类并查集（包括普通并查集）维护的是一种循环对称的关系。 所以如果是三个及以上的集合，只要每个集合都是等价的，且集合间的每个关系都是等价的，就能够用种类并查集进行维护。例如下面这道题： [NOI2001] 食物链题目描述动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。 现有 $N$ 个动物，以 $1 \\sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 $X$ 和 $Y$ 是同类。 第二种说法是2 X Y，表示 $X$ 吃 $Y$。 此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话； 当前的话表示 $X$ 吃 $X$，就是假话。 你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。 输入格式第一行两个整数，$N,K$，表示有 $N$ 个动物，$K$ 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式一行，一个整数，表示假话的总数。 样例 #1样例输入 #112345678100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5 样例输出 #113 提示对于全部数据，$1\\le N\\le 5 \\times 10^4$，$1\\le K \\le 10^5$。 于是我们可以用一个三倍大小的并查集进行维护，用i+n表示i的捕食对象，而i+2n表示i的天敌。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;#define int long longconst int N = 3e5 + 5;int fa[N];int n, k;int find(int x)&#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;void merge(int x, int y)&#123; int r1 = find(x), r2 = find(y); if (r1 != r2) fa[r1] = r2;&#125;bool question(int x, int y)&#123; return find(x) == find(y);&#125;void init()&#123; for (int i = 1; i &lt;= 3 * n; i++) fa[i] = i;&#125;signed main()&#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); init(); int oper, x, y, ans = 0; for (int i = 1; i &lt;= k; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;oper, &amp;x, &amp;y); if (x &gt; n || y &gt; n) ans++; else if (oper == 1) &#123; if (question(x + n, y) || question(x + 2 * n, y)) &#123; ans++; &#125; else &#123; merge(x, y); merge(x + n, y + n); merge(x + 2 * n, y + 2 * n); &#125; &#125; else if (oper == 2) &#123; if (question(x, y) || question(x, y + n)) &#123; ans++; &#125; else &#123; merge(x + n, y); merge(x + 2 * n, y + n); merge(x, y + 2 * n); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"种类并查集","slug":"种类并查集","permalink":"https://xqc-1368.github.io/tags/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"10 数位DP：数字计数","slug":"10 数位DP：数字计数","date":"2024-08-17T06:53:17.229Z","updated":"2024-08-17T14:32:09.030Z","comments":true,"path":"2024/08/17/10 数位DP：数字计数/","permalink":"https://xqc-1368.github.io/2024/08/17/10%20%E6%95%B0%E4%BD%8DDP%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/","excerpt":"","text":"10数位DP：数字计数[ZJOI2010] 数字计数题目描述给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。 输入格式仅包含一行两个整数 $a,b$，含义如上所述。 输出格式包含一行十个整数，分别表示 $0\\sim 9$ 在 $[a,b]$ 中出现了多少次。 样例 #1样例输入 #111 99 样例输出 #119 20 20 20 20 20 20 20 20 20 提示数据规模与约定 对于 $30\\%$ 的数据，保证 $a\\le b\\le10^6$； 对于 $100\\%$ 的数据，保证 $1\\le a\\le b\\le 10^{12}$。 数位DP主要通过记忆化搜索实现，记忆化搜索的本质就是把条件对应的结论记下来，相同条件一定最后对应相同的结论，条件的个数也就决定了DP的维数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define int long long//注意都要开long longusing namespace std;int ay[20];//ay来存这个数每个位子上的数码，倒序存放int dp[20][2][20][2];//zero=1表示前面是否全部都是前导零//limit=1 表示前面对本位有没有限制//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；/*记忆化搜索。pos是当前为从高到低位置。limit表示当前位之前的所有位置是否和ay[pos]相等， 1是相等，0是不相等。sum表示当前数字出现的次数。zero表示之前是否都是前导0。target是当前在算的数码。*/int dfs(int pos,int limit,int sum,int zero,int target)&#123; int ret=0; if(pos==0)return sum;//递归终止条件 if(dp[pos][limit][sum][zero]!=-1)return dp[pos][limit][sum][zero]; //记搜检索：检索是否已经被记录 int maxnum=limit?ay[pos]:9;/* 由于我们是从高位到低位枚举的，所以如果之前一位的数码和最大数的数码相同， 这一位就只能枚举到ay[pos]； 否则如果之前一位比最大数的数码小，那这一位就可以从0~9枚举了。*/ for(int i=0;i&lt;=maxnum;i++) &#123; ret+=dfs(pos-1,limit &amp;&amp;(i==maxnum),sum+((i==target) &amp;&amp; (i||!zero)),zero &amp;&amp; (i==0),target); /* 继续搜索，数位减一（到下一个位置，倒序存储，从高位到低位）， limit的更新要看之前有没有相等，且这一位有没有相等； sum的更新要看之前是否为前导0或者这一位不是0； zero的更新就看之前是否为前导0且这一位继续为0； target继续传进去。 */ &#125; dp[pos][limit][sum][zero]=ret;//记忆化，把搜到的都记下来 return ret;&#125;int part(int a,int d)&#123; int len=0; while(a) &#123; ay[++len]=a%10; a/=10; &#125; memset(dp, -1, sizeof dp);//初始化 dfs(len,1,0,1,d); //开始在第len位上，最高位只能枚举到ay[pos]所以limit是0，sum=0，有前导0。&#125;signed main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=0;i&lt;=9;i++) &#123; cout&lt;&lt;part(b,i)-part(a-1,i)&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 再来看一道题： [SCOI2009] windy 数题目背景windy 定义了一种 windy 数。 题目描述不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？ 输入格式输入只有一行两个整数，分别表示 $a$ 和 $b$。 输出格式输出一行一个整数表示答案。 样例 #1样例输入 #111 10 样例输出 #119 样例 #2样例输入 #2125 50 样例输出 #2120 提示数据规模与约定对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 2 \\times 10^9$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;int ay[100];int len=0;int dp[100][100];//dp[i][j]表示搜到第i位，前一位是j，的！limit方案totnum；//zero=1表示前面是否全部都是前导零//limit=1 表示前面对本位有没有限制//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；int dfs(int pos,int prenum,int st,int limit)&#123;//pos当前位置,pre前一位数,st判断前面是否全是0,limit最高位限制 if(pos&gt;len)return 1;//搜完了 if(limit==0 &amp;&amp; dp[pos][prenum]!=-1)return dp[pos][prenum]; //没有最高位限制且已经搜过了 int maxnum=limit?ay[len+1-pos]:9;//当前位最大数字 int ret=0; for(int i=0;i&lt;=maxnum;i++)//从0枚举到最大数字 &#123; if(abs(i-prenum)&lt;2)continue;//不符合题意，继续 if(i==0 &amp;&amp; st==1)ret+=dfs(pos+1,-2,st,limit &amp;&amp; (i==maxnum)); //如果有前导0，下一位随意 else ret+=dfs(pos+1,i,0,limit &amp;&amp; (i==maxnum)); //如果没有前导0，继续按部就班地搜 &#125; if(limit==0 &amp;&amp; st==0)dp[pos][prenum]=ret;//没有最高位限制且没有前导0时记录结果 ，至于为什么要这样，我也不知道，其实可以都记下来的 return ret;&#125;int part(int a)&#123; len=0; while(a) &#123; ay[++len]=a%10; a/=10; &#125; memset(dp, -1, sizeof (dp)); return dfs(1,-2,1,1);&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;part(b)-part(a-1)&lt;&lt;endl; return 0;&#125; 咱就主打一个看注释吧。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"算法/动态规划/数位DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"09 区间DP的博弈论模型： Letter Picking","slug":"09 区间DP的博弈论模型： Letter Picking","date":"2024-08-17T06:53:17.224Z","updated":"2024-08-17T14:31:59.812Z","comments":true,"path":"2024/08/17/09 区间DP的博弈论模型： Letter Picking/","permalink":"https://xqc-1368.github.io/2024/08/17/09%20%E5%8C%BA%E9%97%B4DP%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%A8%A1%E5%9E%8B%EF%BC%9A%20Letter%20Picking/","excerpt":"","text":"区间DP的博弈论模型： Letter PickingLetter Picking题面翻译题目描述Alice 和 Bob 在玩游戏。 给出一个长度为偶数的，非空的且仅含小写字母的字符串 $s$。每个玩家还拥有一个初始为空的字符串。 Alice 先手，两名玩家交替行动。在一次行动中，玩家可以取 $s$ 首或尾字符，将其从 $s$ 中移除后加入到自己的字符串的 最前面。 当 $s$ 为空时游戏结束，拥有字典序更小的字符串的玩家获胜。若两名玩家的字符串相等则平局。 若 Alice 和 Bob 都足够聪明，判断谁会取胜，或者游戏为平局。 数据组数 $t\\leq 10^3$，$\\sum|s|\\leq 2\\times 10^3$。保证所有输入的 $|s|$ 长度都为偶数。 题目描述Alice and Bob are playing a game. Initially, they are given a non-empty string $s$ , consisting of lowercase Latin letters. The length of the string is even. Each player also has a string of their own, initially empty. Alice starts, then they alternate moves. In one move, a player takes either the first or the last letter of the string $s$ , removes it from $s$ and prepends (adds to the beginning) it to their own string. The game ends when the string $s$ becomes empty. The winner is the player with a lexicographically smaller string. If the players’ strings are equal, then it’s a draw. A string $a$ is lexicographically smaller than a string $b$ if there exists such position $i$ that $a_j = b_j$ for all $j &lt; i$ and $a_i &lt; b_i$ . What is the result of the game if both players play optimally (e. g. both players try to win; if they can’t, then try to draw)? 输入格式The first line contains a single integer $t$ ( $1 \\le t \\le 1000$ ) — the number of testcases. Each testcase consists of a single line — a non-empty string $s$ , consisting of lowercase Latin letters. The length of the string $s$ is even. The total length of the strings over all testcases doesn’t exceed $2000$ . 输出格式For each testcase, print the result of the game if both players play optimally. If Alice wins, print “Alice”. If Bob wins, print “Bob”. If it’s a draw, print “Draw”. 样例 #1样例输入 #11232forcesabba 样例输出 #112AliceDraw 提示One of the possible games Alice and Bob can play in the first testcase: Alice picks the first letter in $s$ : $s=$ “orces”, $a=$ “f”, $b=$ “”; Bob picks the last letter in $s$ : $s=$ “orce”, $a=$ “f”, $b=$ “s”; Alice picks the last letter in $s$ : $s=$ “orc”, $a=$ “ef”, $b=$ “s”; Bob picks the first letter in $s$ : $s=$ “rc”, $a=$ “ef”, $b=$ “os”; Alice picks the last letter in $s$ : $s=$ “r”, $a=$ “cef”, $b=$ “os”; Bob picks the remaining letter in $s$ : $s=$ “”, $a=$ “cef”, $b=$ “ros”. Alice wins because “cef” &lt; “ros”. Neither of the players follows any strategy in this particular example game, so it doesn’t show that Alice wins if both play optimally. 定义状态： 对于区间i~j，博弈后的结果，记1为先手胜，0为先手平，-1为先手负 考虑先手： 以上为先手必获胜的结果，当先手出招时候，后手想使用反制手段，但是发现后手的每一种选择都是使结果导向先手方胜利，那么后手方没办法只能输； 接下来讨论先手出招，但后手通过反制手段，但因为选择当中没有使后手方获胜的情况，但存在若干个平手的情况，于是后手方退而求其次，使最终结果导向平局的情况； 当然这里讨论的是先手不输的情况，先手不输的情况包括先手赢和先手平两种，如果用if+先手赢+else if+先手不输 来把先手赢的情况再第二种情况之前拒之门外，那么第二种情况就是先手不输的情况 即为 .png) 附上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longint dp[2005][2005] = &#123;0&#125;;int solve(string s)&#123; int n = s.size() - 1; for (int i = 1, j = 2; j &lt;= n; i++, j++) // 1 start &#123; if (s[i] == s[j]) dp[i][j] = 0; else dp[i][j] = 1; &#125; for (int k = 2; 2 * k &lt;= n; k++) for (int i = 1, j = 2 * k; j &lt;= n; i++, j++) &#123; if ((s[i] &lt; s[i + 1] &amp;&amp; dp[i + 2][j] == 0 || dp[i + 2][j] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[i] &lt; s[j] || dp[i + 1][j - 1] == 1) || (s[j] &lt; s[j - 1] &amp;&amp; dp[i][j - 2] == 0 || dp[i][j - 2] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[j] &lt; s[i] || dp[i + 1][j - 1] == 1)) &#123; dp[i][j] = 1; &#125; else if (((s[i] &lt;= s[i + 1] &amp;&amp; dp[i + 2][j] == 0 || dp[i + 2][j] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[i] &lt;= s[j] || dp[i + 1][j - 1] == 1)) || (s[j] &lt;= s[j - 1] &amp;&amp; dp[i][j - 2] == 0 || dp[i][j - 2] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[j] &lt;= s[i] || dp[i + 1][j - 1] == 1)) &#123; dp[i][j] = 0; &#125; else dp[i][j] = -1; &#125; // for(int i=1;i&lt;=n;i++) // &#123; // for(int j=1;j&lt;=n;j++) // &#123; // cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; // &#125; // cout&lt;&lt;endl; // &#125; return dp[1][n];&#125;signed main(void)&#123; int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) &#123; string temp, s = &quot;0&quot;; cin &gt;&gt; temp; s += temp; int ans = solve(s); if (ans == 0) cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl; if (ans == 1) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; if (ans == -1) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"08 四边形不等式优化的环形DP：石子合并","slug":"08 四边形不等式优化的环形DP： 石子合并","date":"2024-08-17T06:53:17.221Z","updated":"2024-08-17T14:32:04.714Z","comments":true,"path":"2024/08/17/08 四边形不等式优化的环形DP： 石子合并/","permalink":"https://xqc-1368.github.io/2024/08/17/08%20%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96%E7%9A%84%E7%8E%AF%E5%BD%A2DP%EF%BC%9A%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/","excerpt":"","text":"环形DP+四边形不等式优化的区间DP：石子合并[NOI1995] 石子合并题目描述在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。 输入格式数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。 第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。 输出格式输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。 样例 #1样例输入 #11244 5 9 4 样例输出 #1124354 提示$1\\leq N\\leq 100$，$0\\leq a_i\\leq 20$。 考虑的难点主要有两个： 1.区间dp处理环形dp的思路是什么？ 2.区间dp的优化方法：四边形不等式； 先解决问题1： 环形dp的处理方法就是将原来的数组扩充两倍，将n+1项写成第1项，将n+2项写成第2项······以此类推。 12345678910111213int n,stone[500],pre[500]=&#123;0&#125;; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;stone[i]; stone[i+n]=stone[i]; &#125; for(int i=1;i&lt;=2*n;i++) &#123; pre[i]=pre[i-1]+stone[i]; //cout&lt;&lt;pre[i]&lt;&lt;&quot; &quot;; &#125; //cout&lt;&lt;endl; 以n=4为例，最后要输出的是 dp[1][4]，dp[2][5]，dp[3][6]，dp[4][7]，dp[5][8]的最小值/最大值，即所有长度为n的区间的最值 1234567int minn=INT_MAX,maxn=0; for(int i=1,j=n;j&lt;=2*n;i++,j++) &#123; minn=min(minn,dpmin[i][j]); maxn=max(maxn,dp[i][j]); &#125; cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxn&lt;&lt;endl; 再解决问题2：先介绍方法： 12345678910111213141516for (int i = 1; i &lt;= n; ++i) m[i][i] = i; // 初始化边界决策点for (int d = 2; d &lt;= n; ++d) for (int l = 1, r = d; r &lt;= n; ++l，++ r) &#123; dp[l][r] = INF; for (int k = m[l][r - 1]; k &lt;= m[l + 1][r];++k) // 利用结论，缩小了枚举范围 if (dp[l][k] + dp[k + 1][r] + w(l, r) &lt; dp[l][r]) &#123; dp[l][r] = dp[l][k] + dp[k + 1][r] + w(l, r); // 更新dp数组 m[l][r] = k; // 更新决策点 &#125; &#125; 运用最优决策点的关系，可以实现优化。 然而，我们由上面的文章可以看到，四边形不等式的使用条件其一是w（l，r）满足区间单调性，这个只能数学证明，而且很容易看出来。 其二是，m这个用于标记最佳决策点的数组，在每一行，每一列上都实现单调不下降。本题中，求最大值的时候，m数组不符合这个条件（怎么发现的呢，假设符合条件，然后敲一遍代码，敲完后把m数组打印出来结果如下） 于是就不符合，只能使用简单的区间dp完成。 而求最小值的时候，m数组符合这个条件（运行截图如下），于是就可以使用四边形不等式 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int dp[500][500]=&#123;0&#125;;int dpmin[500][500]=&#123;0&#125;;int m[500][500]=&#123;0&#125;;int m1[500][500]=&#123;0&#125;;signed main(void)&#123; int n,stone[500],pre[500]=&#123;0&#125;; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;stone[i]; stone[i+n]=stone[i]; &#125; for(int i=1;i&lt;=2*n;i++) &#123; pre[i]=pre[i-1]+stone[i]; &#125; //m数组初始化 for(int i=1;i&lt;=2*n;i++) &#123; m[i][i]=i; m1[i][i]=i; &#125; for(int e=2;e&lt;=2*n;e++) &#123; for(int i=1,j=e;j&lt;=2*n;i++,j++) &#123; dpmin[i][j]=INT_MAX; for(int k=i;k&lt;=j-1;k++) &#123; if(dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]&gt;dp[i][j] &amp;&amp; k+1&lt;=j &amp;&amp; i&lt;=k) &#123; dp[i][j]=dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]; m[i][j]=k; &#125; &#125; for (int k = m1[i][j - 1]; k &lt;= m1[i + 1][j]; k++) &#123; if (dpmin[i][k] + dpmin[k + 1][j] + pre[j] - pre[i - 1] &lt; dpmin[i][j] &amp;&amp; k + 1 &lt;= j &amp;&amp; i &lt;= k) &#123; dpmin[i][j] = dpmin[i][k] + dpmin[k + 1][j] + pre[j] - pre[i - 1]; m1[i][j] = k; &#125; &#125; &#125; &#125; int minn=INT_MAX,maxn=0; for(int i=1,j=n;j&lt;=2*n;i++,j++) &#123; minn=min(minn,dpmin[i][j]); maxn=max(maxn,dp[i][j]); &#125; cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxn&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"环形DP的四边形不等式优化","slug":"算法/动态规划/环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"环形DP的四边形不等式优化","slug":"环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/tags/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"}]},{"title":"07 二进制优化多重背包问题：樱花","slug":"07 二进制优化多重背包问题：樱花","date":"2024-08-17T06:53:17.218Z","updated":"2024-08-17T14:31:50.109Z","comments":true,"path":"2024/08/17/07 二进制优化多重背包问题：樱花/","permalink":"https://xqc-1368.github.io/2024/08/17/07%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E6%A8%B1%E8%8A%B1/","excerpt":"","text":"二进制优化多重背包问题：樱花樱花题目背景《爱与愁的故事第四弹·plant》第一章。 题目描述爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \\le C_i \\le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $P_i(0 \\le P_i \\le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \\le T_i \\le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。 输入格式共 $n+1$行： 第 $1$ 行：现在时间 $T_s$（几时：几分），去上学的时间 $T_e$（几时：几分），爱与愁大神院子里有几棵樱花树 $n$。这里的 $T_s$，$T_e$ 格式为：hh:mm，其中 $0 \\leq hh \\leq 23$，$0 \\leq mm \\leq 59$，且 $hh,mm,n$ 均为正整数。 第 $2$ 行到第 $n+1$ 行，每行三个正整数：看完第 $i$ 棵树的耗费时间 $T_i$，第 $i$ 棵树的美学值 $C_i$，看第 $i$ 棵树的次数 $P_i$（$P_i=0$ 表示无数次，$P_i$ 是其他数字表示最多可看的次数 $P_i$）。 输出格式只有一个整数，表示最大美学值。 样例 #1样例输入 #112346:50 7:00 32 1 03 3 14 5 4 样例输出 #1111 提示$100\\%$ 数据：$T_e-T_s \\leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \\leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。 样例解释：赏第一棵樱花树一次，赏第三棵樱花树 $2$ 次。 这是一个普通背包，多重背包，完全背包的混合其他的背包正常做就行，但由于平时都是把多重背包一个物品最多取n件拆成n个这种的一件物品。时间会消耗得很厉害。于是就出现了二进制优化： 一个正整数n，可以被分解成1,2,4,…,2^(k-1),n-2^k+1的形式。其中，k是满足n-2^k+1&gt;0的最大整数。 例如，假设给定价值为2，数量为10的物品，依据二进制优化思想可将10分解为1+2+4+3，则原来价值为2，数量为10的物品可等效转化为价值分别为1x2，2x2，4x2，3x2，即价值分别为2，4，8，6，数量均为1的物品。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;vector&lt;int&gt; t,c,p;int dp[100000]=&#123;0&#125;;int T,n;int exchage(string st,string ed)&#123; if(st[1]==&#x27;:&#x27;)st=&quot;0&quot;+st; if(ed[1]==&#x27;:&#x27;)ed=&quot;0&quot;+ed; int hs=stoi(st.substr(0,2)),hed=stoi(ed.substr(0,2)); int ms=stoi(st.substr(3,5)),med=stoi(ed.substr(3,5)); if(hed&lt;hs)hed+=24; int ret=(hed-hs)*60+med-ms; return ret;&#125;signed main(void)&#123; string st,ed; cin&gt;&gt;st&gt;&gt;ed&gt;&gt;n; T=exchage(st,ed); //cout&lt;&lt;T&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; int tempt,tempc,tempp; cin&gt;&gt;tempt&gt;&gt;tempc&gt;&gt;tempp; if(tempp==1 || tempp==0) &#123; t.push_back(tempt); c.push_back(tempc); p.push_back(tempp); &#125; else if(tempp&gt;1) &#123; int x=0; while (tempp &gt; pow(2, x)) &#123; t.push_back(tempt * pow(2, x)); c.push_back(tempc * pow(2, x)); p.push_back(1); tempp -= pow(2, x); x++; &#125; t.push_back(tempt * tempp); c.push_back(tempc * tempp);//注意，数量（2个，4个...）绑定后相应的价值和重量也会发生改变 p.push_back(1); &#125; &#125; for(int i=0;i&lt;t.size();i++) &#123; if(p[i]==0)//complete package &#123; for(int j=t[i];j&lt;=T;j++) &#123; dp[j]=max(dp[j],dp[j-t[i]]+c[i]); &#125; &#125; else &#123; for(int j=T;j&gt;=t[i];j--) &#123; dp[j]=max(dp[j],dp[j-t[i]]+c[i]); &#125; &#125; &#125; cout&lt;&lt;dp[T]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"多重背包DP的二进制优化","slug":"算法/动态规划/多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"多重背包DP的二进制优化","slug":"多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}]},{"title":"06 树形DP：金明的预算方案","slug":"06 树形DP：金明的预算方案","date":"2024-08-17T06:53:17.215Z","updated":"2024-08-17T14:31:45.547Z","comments":true,"path":"2024/08/17/06 树形DP：金明的预算方案/","permalink":"https://xqc-1368.github.io/2024/08/17/06%20%E6%A0%91%E5%BD%A2DP%EF%BC%9A%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/","excerpt":"","text":"树形DP：金明的预算方案其实这道题不用树形dp，也可以使用普通的背包dp，但是鉴于树形dp的简单题一题难求，于是我们用树形dp做。 P1064 [NOIP2006 提高组] 金明的预算方案题目描述金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \\sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\\dots,j_k$，则所求的总和为： $v{j_1} \\times w{j1}+v{j2} \\times w{j2}+ \\dots +v{jk} \\times w{j_k}$。 请你帮助金明设计一个满足要求的购物单。 输入格式第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。 第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。 输出格式输出一行一个整数表示答案。 样例 #1样例输入 #11234561000 5800 2 0400 5 1300 5 1400 3 0500 2 0 样例输出 #112200 提示数据规模与约定对于全部的测试点，保证 $1 \\leq n \\leq 3.2 \\times 10^4$，$1 \\leq m \\leq 60$，$0 \\leq v_i \\leq 10^4$，$1 \\leq p_i \\leq 5$，$0 \\leq q_i \\leq m$，答案不超过 $2 \\times 10^5$。 定义状态：dp【i】【j】=以后序遍历的方式遍历到节点 i 时，还剩的空间为 j 时的最佳answer。 首先，我们需要构建一个树：（对于测试样例）注意一开始为了统摄所有根节点，我们建立一个0号节点来统摄。 这是这个dp数组在测试案例的情况下的最后输出结果，（后面可能会用到） 状态转移方程：xbcl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;vector&lt;int&gt; point_to[61];int v[100]=&#123;0&#125;, p[100]=&#123;0&#125;, q[100]=&#123;0&#125;;int dp[100][3200]=&#123;0&#125;;int n, m;void dfs(int nowpoint,int nowweight)&#123;//第一个参数表示当前节点，第二个参数表示当前还剩的重量 if(nowweight&lt;=0)return ;//如果当前还剩的重量已经小于0，那么直接返回 for(int i=0;i&lt;point_to[nowpoint].size();i++) &#123;//遍历每一个当前节点的子节点 int child = point_to[nowpoint][i];//child为子节点 for (int j = nowweight-v[child]; j &gt;= 0; j--) &#123; dp[child][j] = dp[nowpoint][j] + p[child]*v[child]; &#125;/*把当前0~nowweight-v[child]的所有项给直接搬过来。再加上p[child]*v[child]即题目规定的权值其中0~nowweight-v[child]记录着遍历过他的哥哥节点（前面的兄弟节点）后，所得出的最佳答案为什么把0~nowweight-v[child]直接搬过来加？首先我们要知道dp[父节点]【0~nowweight-v[child]】表示的是在父亲只有该子节点的所有哥哥节点的时候，而完全不取该子节点的有关权值的时候的最优解。因为我们现在在讨论该子节点取的情况下的最优解，而取该子节点势必会消耗v[child]的限额，于是我们给该子节点预留v[child]，那么取完该节点后剩下0~nowweight-v[child]，在递归到叶子节点（即下一行程序的dfs）返回后0~nowweight-v[child]一一顺序对应v[child]~nowweight于是对应原来父节点集合的v[child]~nowweight元素比大小（下面一个循环干的事），最终得到父节点nowpoint的最优值集合*/ dfs(child, nowweight - v[child]); for (int k = nowweight; k &gt;= v[child]; k--) &#123; dp[nowpoint][k] = max(dp[nowpoint][k], dp[child][k - v[child]]); &#125; &#125;/*这时候你会问了，对于兄弟节点之间，取两个，三个等等在哪里体现。其实，这在搬过来加权值的时候已经体现了；如处理样例中5号这个节点的时候，我们把00000000···00000 1200 1200 1200···1200（十一（因为包括首尾）个）搬过来在5号节点这个节点的权值1000加上去，dp第五行自然也就变成了1000 1000···1000 2200 2200··2200了*/&#125;signed main(void)&#123; cin&gt;&gt;n&gt;&gt;m; n/=10; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;p[i]&gt;&gt;q[i]; v[i]/=10; point_to[q[i]].push_back(i);//建树的过程，point_to是二维数组，用point_to[i]记录i号节点指向的所有节点 &#125; dfs(0,n); cout&lt;&lt;dp[0][n]*10&lt;&lt;endl; return 0;&#125; 总结： 树状dp主要解决树形最优解问题。 步骤： 0.递归终止条件： 剩下限重小于0，返回即可； 1.遍历每一个子节点： （1）搬来加权值：把父节点剪掉子节点的重量的部分照搬，加上子节点的权值，成为子节点的那一行的数组； （2）递归：往下递归一层，就更新传参，更新当前节点的参数，更新当前限重。 （3）高位搬回去比较。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"算法/动态规划/树形DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"05 单调队列优化DP：华科A题","slug":"05 单调队列优化DP：华科A题","date":"2024-08-17T06:53:17.210Z","updated":"2024-08-17T14:31:40.881Z","comments":true,"path":"2024/08/17/05 单调队列优化DP：华科A题/","permalink":"https://xqc-1368.github.io/2024/08/17/05%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%EF%BC%9A%E5%8D%8E%E7%A7%91A%E9%A2%98/","excerpt":"","text":"单调队列“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理 单调队列是一种主要用于解决”滑动区间“的最值问题的数据结构即，在长度为 的序列中，求每个长度为 的区间的区间最值。它的时间复杂度是 ，在这个问题中比 的ST表和线段树要优。 单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素可能成为某个区间最值时才保留它。 形象地打个比方，上面的序列可以看成学校里各个年级XCPC选手，数字越大代表能力越强。每个选手只能在大学四年间参赛，毕业了就没有机会了。那么，每一年的王牌选手都在哪个年级呢？ 一开始的时候，大三大四的学长都比较菜，大二的最强，而大一的等大二的毕业后还有机会上位，所以队列里有两个数。 一年过去了，原本大一的成为大二，却发现新进校的新生非常强，自己再也没有机会成为最大值了，所以弹出队列。 又过了一年，新入校的新生尽管能力只有1，但理论上只要后面的人比他还菜，还是可能成为区间最大值的，所以入队。 终于，原本的王牌毕业了，后面的人以为熬出头了，谁知道这时一个巨佬级别的新生进入了集训队，这下其他所有人都没机会了。 （这只是比方，现实中各位选手的实力是会增长的，不符合这个模型ovo） 总之，观察就会发现，我们维护的这个队列总是单调递减的。如果维护区间最小值，那么维护的队列就是单调递增的。这就是为什么叫单调队列。 例题：单调队列优化动态规划的应用 选择数字题目描述给定一行 $n$ 个非负整数 $a_1 \\cdots a_n$。现在你可以选择其中若干个数，但不能有超过 $k$ 个连续的数字被选择。你的任务是使得选出的数字的和最大。 输入格式第一行两个整数 $n$，$k$。 以下 $n$ 行，每行一个整数表示 $a_i$。 输出格式输出一个值表示答案。 样例 #1样例输入 #11234565 212345 样例输出 #1112 提示对于 $20\\%$ 的数据，$n \\le 10$。 对于另外 $20\\%$ 的数据，$k=1$。 对于 $60\\%$ 的数据，$n \\le 1000$。 对于 $100\\%$ 的数据，$1 \\le n \\le 100000$，$1 \\le k \\le n$，$0 \\le$ 数字大小 $\\le 1,000,000,000$。 时间限制 $500$ ms。 这种题是很典型的单调队列优化DP。 我们把问题转化为删除若干个数，且删除的数间隔不超过k，求删除数的最小值。设dp[i]表示在删除第i个数的情况下， 前i个数中删除数的最小和。那么很容易想到转移方程： 这是因为，如果要删除某个数，除非它是前 k+1个数之一，否则在它之前的k+1个数中，至少要删除一个。最后的答案在最后 k+1个数里找最小值，然后用总和去减即可，因为最后 k+1个数中至少有一个是要删除的。 这个朴素方法是O（mn）的，为了优化它，我们可以使用单调队列。注意到，我们不断地在求dp的区间最小值，而且区间长度是固定的m+1 ，这正好符合滑动窗口的模型。只不过，我们需要动态地进行整个过程，即，在维护单调队列的过程中求出dp。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxsize = 100005;int dp[maxsize] = &#123;0&#125;;deque&lt;int&gt; q;signed main()&#123; int n,k,a[maxsize],sum=0; cin&gt;&gt;n&gt;&gt;k; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; sum+=a[i]; &#125; //看作删除若干个数，但是不能有间隔超过k； //dp[i]表示，删除a[i]的情况下，完成删除的最小值 for(int i=1;i&lt;=n;i++) &#123; if(i&lt;=k+1) dp[i]=a[i]; else dp[i]=dp[q.front()]+a[i]; if(!q.empty() &amp;&amp; q.front()&lt;i-k) q.pop_front(); while (!q.empty() &amp;&amp; dp[q.back()] &gt; dp[i]) &#123; q.pop_back(); &#125; q.push_back(i); &#125; int emin=LONG_LONG_MAX; for(int i=n-k;i&lt;=n;i++) &#123; emin=min(dp[i],emin); &#125; cout&lt;&lt;sum-emin&lt;&lt;endl;&#125; 注意，在这个过程中的易错点是： 进入队列的是元素下标不是元素内容！！，且每一次循环不一定一定有元素从头部出队。 另一个例题：华中科技大学2023新生赛A题 [HUSTFC 2023] 简单的加法乘法计算题题目描述JokerShaco 有一个数字 $x$，最开始 $x=0$，他想要把 $x$ 变成 $y$。为了达到这个目标，他可以利用两个集合 $A$ 和 $B$。其中集合 $A$ 包含 $n$ 个元素，分别是从 $1$ 到 $n$ 的所有正整数；集合 $B$ 包含 $m$ 个元素。每次它可以对 $x$ 进行如下任意次操作： 选择 $A$ 中的一个元素 $a$，令 $x$ 加上 $a$。 选择 $B$ 中的一个元素 $b$，令 $x$ 乘以 $b$。 已知 $y$，$n$，$m$ 和 $B$ 中 $m$ 个元素的具体值，JokerShaco 想知道让 $x$ 变成 $y$ 的最少操作次数。 输入格式第一行包含三个整数 $y\\ (1\\le y\\le 5\\cdot 10^6)$，$n\\ (1\\le n\\le 5\\cdot 10^6)$ 和 $m\\ (1\\le m\\le 10)$，其含义如题目所述。 第二行包含 $m$ 个正整数，其中第 $i$ 个表示 $B$ 中的第 $i$ 个元素 $b_i\\ (1\\le b_i\\le 5\\cdot 10^6)$。 输出格式输出一个整数，表示让 $x$ 变成 $y$ 的最少操作次数。在题目条件下可知一定能将 $x$ 变成 $y$。 样例 #1样例输入 #11210 3 12 样例输出 #113 样例 #2样例输入 #212100 6 32 3 5 样例输出 #213 初步想法是利用线性动态规划进行，dp[i]表示y=i的时候需要走的最少步骤数，状态转移方程为： dp[i]=min( minE(k from i-1 to i-n) {dp[k]+1} , minE(r from 1 to m) if(dp[i]%b[r]=0）dp[i]/b[r] ) 可行代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxsize=5000005;int dp[maxsize]=&#123;0&#125;;deque &lt;int&gt; dq;signed main()&#123; long long b[11]; long long y,n,m; cin&gt;&gt;y&gt;&gt;n&gt;&gt;m; for(long long i=1;i&lt;=m;i++) &#123; cin&gt;&gt;b[i]; &#125; for(int j=1;j&lt;maxsize;j++) &#123; dp[j]=INT_MAX; &#125; for (long long i = 1; i &lt;= y; i++) &#123; if(i&lt;=n) &#123; dp[i]=1; &#125; else &#123; dp[i]=min(dp[i],dp[dq.front()]+1); for (long long r = 1; r &lt;= m; r++) &#123; if (i % b[r] == 0) &#123; dp[i] = min(dp[i], dp[i / b[r]] + 1); &#125; &#125; &#125; if(!dq.empty() &amp;&amp; dq.front()&lt;=i-n) &#123; dq.pop_front(); &#125; while(!dq.empty() &amp;&amp; dp[dq.back()]&gt;dp[i]) &#123; dq.pop_back(); &#125; dq.push_back(i);//注意队列中始终是位置，而不是元素内容 &#125; cout&lt;&lt;dp[y]&lt;&lt;endl;&#125; 特定类型的题型：多重背包的单调队列优化宝物筛选题目描述终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。 这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。 小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 $W$ 的采集车，洞穴里总共有 $n$ 种宝物，每种宝物的价值为 $v_i$，重量为 $w_i$，每种宝物有 $m_i$ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。 输入格式第一行为一个整数 $n$ 和 $W$，分别表示宝物种数和采集车的最大载重。 接下来 $n$ 行每行三个整数 $v_i,w_i,m_i$。 输出格式输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。 样例 #1样例输入 #1123454 203 9 35 9 19 4 28 1 3 样例输出 #1147 提示对于 $30\\%$ 的数据，$n\\leq \\sum m_i\\leq 10^4$，$0\\le W\\leq 10^3$。 对于 $100\\%$ 的数据，$n\\leq \\sum m_i \\leq 10^5$，$0\\le W\\leq 4\\times 10^4$，$1\\leq n\\le 100$。 多重背包的原始状态转移方程：f(i,j)=max(f(i−1,j),f(i−1,j−v)+w,⋯,f(i−1,j−sv)+sw) f(i,j−v)=max(f(i−1,j−v),f(i−1,j−2v)+w,⋯,f(i−1,j−(s+1)v)+(s)w) f(i,j−2v)=max(f(i−1,j−2v),f(i−1,j−3v)+w,⋯,f(i−1,j−(s+2)v)+sw) … 此处我们取 r = j % v f(i,r+sv)=max(f(i−1,r+sv),f(i−1,r+(s−1)v)+w,⋯,f(i−1,r)+sw) ⋯ f(i,r+2v)=max(f(i−1,r+2v),f(i−1,r+v)+w,f(i−1,r)+2w) f(i,r+v)=max(f(i−1,r+v),f(i−1,r)+w) f(i,r)=f(i−1,r) 朴素二维数组代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxsize=4e2+5;int dp[maxsize][maxsize]=&#123;0&#125;;int v[105],w[105],m[105],n,W;signed main()&#123; cin&gt;&gt;n&gt;&gt;W; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i]; &#125; for(int i=1;i&lt;=n;i++)//当前考虑到第i件物品 &#123; for(int r=0;r&lt;w[i];r++)//考虑余数r，余数可能为0~w[i]-1中的任意一个数字 &#123; deque&lt;int&gt; q; for(int j=r;j&lt;=W;j+=w[i]) &#123; while(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i]) q.pop_front(); while (!q.empty() &amp;&amp; dp[i - 1][q.back()] + (j - q.back()) / w[i] * v[i] &lt;= dp[i - 1][j]) q.pop_back(); q.push_back(j); dp[i][j] = dp[i - 1][q.front()] + (j - q.front()) / w[i] * v[i]; &#125; &#125; &#125; cout&lt;&lt;dp[n][W]&lt;&lt;endl; return 0; &#125; 一维数组空间优化代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxsize=4e4+5;int dp[maxsize]=&#123;0&#125;,g[maxsize]=&#123;0&#125;;int v[10005],w[10005],m[10005],n,W;signed main()&#123; cin&gt;&gt;n&gt;&gt;W; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i]; &#125; for(int i=1;i&lt;=n;i++)//当前考虑到第i件物品 &#123; for(int r=0;r&lt;w[i];r++)//考虑余数r，余数可能为0~w[i]-1中的任意一个数字 &#123; deque&lt;int&gt; q; memcpy(g,dp,sizeof(dp)); for(int j=r;j&lt;=W;j+=w[i]) &#123; while(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i]) q.pop_front(); while (!q.empty() &amp;&amp; g[q.back()] + (j - q.back()) / w[i] * v[i] &lt;= g[j]) q.pop_back(); q.push_back(j); dp[j] = g[q.front()] + (j - q.front()) / w[i] * v[i]; &#125; &#125; &#125; cout&lt;&lt;dp[W]&lt;&lt;endl; return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP的单调队列优化","slug":"算法/动态规划/DP的单调队列优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP的单调队列优化","slug":"DP的单调队列优化","permalink":"https://xqc-1368.github.io/tags/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"}]},{"title":"04 状态压缩DP：吃奶酪+Vitamin","slug":"04 状态压缩DP：吃奶酪+Vitamin","date":"2024-08-17T06:53:17.207Z","updated":"2024-08-17T14:31:30.692Z","comments":true,"path":"2024/08/17/04 状态压缩DP：吃奶酪+Vitamin/","permalink":"https://xqc-1368.github.io/2024/08/17/04%20%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP%EF%BC%9A%E5%90%83%E5%A5%B6%E9%85%AA+Vitamin/","excerpt":"","text":"吃奶酪题目描述房间里放着 $n$ 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$ 点处。 输入格式第一行有一个整数，表示奶酪的数量 $n$。 第 $2$ 到第 $(n + 1)$ 行，每行两个实数，第 $(i + 1)$ 行的实数分别表示第 $i$ 块奶酪的横纵坐标 $x_i, y_i$。 输出格式输出一行一个实数，表示要跑的最少距离，保留 $2$ 位小数。 样例 #1样例输入 #11234541 11 -1-1 1-1 -1 样例输出 #117.41 提示数据规模与约定对于全部的测试点，保证 $1\\leq n\\leq 15$，$|x_i|, |y_i| \\leq 200$，小数点后最多有 $3$ 位数字。 提示对于两个点 $(x_1,y_1)$，$(x_2, y_2)$，两点之间的距离公式为 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。 $2022.7.13$：新增加一组 $\\text{Hack}$ 数据。 本题使用状态压缩动态规划：状态压缩DP用于解决N小于21的图论问题（本身需要搜索解决的） 理解状压DP：DP[ j ][ S ]表示已走过S的二进制表示的路径，目前终点为 j ； 比如S是00110101表示已走过第一个点，第三个点，第五个点，第六个点。而假如所给输入一共有n个点，单独表示第一个点记为1&lt;&lt;0,单独表示第二个点记为1&lt;&lt;1由此类推单独表示第n个点为1&lt;&lt;(n-1)，表示已经走过n个点中所有的点，为(1&lt;&lt;n)-1因此，最外层循环枚举 00000000~11111111这所有的情况 核心部分代码： 123456for(int S=1;S&lt;(1&lt;&lt;n);S++)//S for(int i=1;i&lt;=n;i++)//i if(S &amp; (1&lt;&lt;(i-1)))//2 for(int j=1;j&lt;=n;j++) if (!(S &amp; (1 &lt;&lt; (j - 1))) &amp;&amp; G[i][j]!=-1)//3 dp[j][S | (1 &lt;&lt; (j - 1))] = min(dp[j][S | (1 &lt;&lt; (j - 1))] , dp[i][S] + G[i][j]); 状态转移方程为： if(S的j-1项为0) ： dp[j][S的j-1项置1]=minE(i from 1 to n and S的第i项为1) {dp[i][S]+G[i][j]}其中G为邻接表 总体思路： 以j为终点 枚举每个可能的i 到 j，所需要的权值，求最小； //S的一层循环提供了每个可能的已走过的路径： //i一层循环枚举了目前处于第i个点，但是第i个点不一定在当前的S状态下被走过，所以我们需要判断语句//2，来知晓是否被走过，如果没被走过，则不用再往下考虑。 S&amp;(1&lt;&lt;(i-1)) 表示S从右往左数第（i-1）位为1； 为什么要i-1，因为我们想最大化利用空间，S最右边是第零位，即S=00000001 = =1&lt;&lt;(1-1)以此类推； //j这层循环中枚举了每个在当前的S的状态下，还未到达过的点，即S为0的位置，//3处判断表示当前已走过路径的S的（j-1）位未走过（即为0），并且G[i][j]!=-1表示当前枚举的i可以到达j，G是一个整体的邻接表。 接下来填充dp[ j ][ S | (1 &lt;&lt; ( j - 1 ) ) ]位置的数字，即dp当中，以j位置结尾，已走过路径为当前的S在第（j-1）位加上1，即路径上的第j位表示走过 的数字等于每一个以i结尾，已走过路径为S的dp表格值加上i到j的权值的和的最小值，于是，我们求出整个dp表格 最后关于如何寻找最值位置的问题： 1234for(int i=1;i&lt;=n;i++) &#123; ans = ans &gt; dp[i][(1 &lt;&lt; n) - 1] ? dp[i][(1 &lt;&lt; n) - 1] : ans; &#125; ans为输出的最短路径规划，遍历每一个终点，寻找走过（1&lt;&lt;n）-1即走过11111111的路径的所有终点状态，即找以1号位置结尾的11111111，以2号位置结尾的11111111········ 于是，我们求出了答案； 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define maxsize 17double dp[16][66000];//n最大值为15，因此取2的15次方大小，为了保险我取了16次方int main()&#123; int n; double x[maxsize]=&#123;0&#125;,y[maxsize]=&#123;0&#125;,G[maxsize][maxsize]=&#123;0&#125;; cin&gt;&gt;n; for(int i=0;i&lt;maxsize;i++) for(int j=0;j&lt;maxsize;j++) G[i][j]=-1; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; if(i==j)continue; G[i][j] =G[j][i]= sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j])); &#125; for(int i=0;i&lt;16;i++) for(int j=0;j&lt;66000;j++) &#123; dp[i][j]=DBL_MAX; &#125; for(int i=1;i&lt;=n;i++) &#123; dp[i][1 &lt;&lt; (i-1)] = sqrt((x[i]) * (x[i]) + (y[i]) * (y[i])); &#125; for(int S=1;S&lt;(1&lt;&lt;n);S++) &#123; for(int i=1;i&lt;=n;i++) &#123; if(S &amp; (1&lt;&lt;(i-1))) &#123; for(int j=1;j&lt;=n;j++) &#123; if (!(S &amp; (1 &lt;&lt; (j - 1))) &amp;&amp; G[i][j]!=-1) &#123; dp[j][S | (1 &lt;&lt; (j - 1))] = dp[j][S | (1 &lt;&lt; (j - 1))] &gt; dp[i][S] + G[i][j] ? dp[i][S] + G[i][j] : dp[j][S | (1 &lt;&lt; (j - 1))]; &#125; &#125; &#125; &#125; &#125; double ans=INT_MAX; for(int i=1;i&lt;=n;i++) &#123; ans = ans &gt; dp[i][(1 &lt;&lt; n) - 1] ? dp[i][(1 &lt;&lt; n) - 1] : ans; &#125; printf(&quot;%.2lf&quot;,ans); return 0;&#125; 上面的题目是对图论的dp方法，下面的例题显然可以看出的状压dp Vitamins题面翻译数据有$n$组数,每组数有一个价值$c_i$和一个字符串S,字符串S中包含3个字母A,B,C，问集齐ABC三个字母的最小价值（一个字母可以有多个） 样例 #1样例输入 #11234545 C6 B16 BAC4 A 样例输出 #1115 样例 #2样例输入 #2123210 AB15 BA 样例输出 #21-1 样例 #3样例输入 #3123456510 A9 BC11 CA4 A5 B 样例输出 #3113 样例 #4样例输入 #412345676100 A355 BCA150 BC160 AC180 B190 CA 样例输出 #41250 样例 #5样例输入 #512325 BA11 CB 样例输出 #5116 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define maxsize 1005#define int long longint c[maxsize] = &#123;0&#125;, a[maxsize] = &#123;0&#125;, dp[10] = &#123;0&#125;;void mark(int x, string s)&#123; for (int i = 0; i &lt; s.size(); i++) &#123; a[x] = a[x] | (1 &lt;&lt; ((long long)s[i] - 65)); &#125;&#125;signed main()&#123; int n; string s; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; c[i] &gt;&gt; s; mark(i, s); &#125; for (int j = 0; j &lt; 10; j++) &#123; dp[j] = LONG_LONG_MAX / pow(10, 10); &#125; for (int i = 1; i &lt;= n; i++) &#123; dp[0] = 0; for (int st = (1 &lt;&lt; 3) - 1; st &gt;= 0; st--) &#123; dp[st | a[i]] = min(dp[st | a[i]], dp[st] + c[i]); &#125; &#125; if (dp[(1 &lt;&lt; 3) - 1] == (long long)(LONG_LONG_MAX / pow(10, 10))) dp[(1 &lt;&lt; 3) - 1] = -1; cout &lt;&lt; dp[(1 &lt;&lt; 3) - 1] &lt;&lt; endl; return 0;&#125; 第一次实现了状压dp可视化！！！！","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"算法/动态规划/状压DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"https://xqc-1368.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"03 区域DP：三素数数","slug":"03 区域DP：三素数数","date":"2024-08-17T06:53:17.204Z","updated":"2024-08-18T09:39:30.356Z","comments":true,"path":"2024/08/17/03 区域DP：三素数数/","permalink":"https://xqc-1368.github.io/2024/08/17/03%20%E5%8C%BA%E5%9F%9FDP%EF%BC%9A%E4%B8%89%E7%B4%A0%E6%95%B0%E6%95%B0/","excerpt":"","text":"区域DP：三素数数三素数数题目背景蛟川书院的一道练习题QAQ 题目描述如果一个数的所有连续三位数字都是大于100的素数，则该数称为三素数数。比如113797是一个6位的三素数数。 输入格式一个整数n（3 ≤ n ≤ 10000），表示三素数数的位数。 输出格式一个整数，表示n位三素数的个数m，要求输出m除以10^9 + 9的余数。 样例 #1样例输入 #114 样例输出 #11204 提示区域动归QAQ 设dp[k][i][j]表示到了第k位，这个数字是i，上一个数字是j的方案数 初始化 dp[2][0→9][0→9]=1 枚举第几位i，现在的数字now，之前的数字pre，上上个数字last 如果last∗100+pre+10+now是素数，那么dp[i][now][pre]+=dp[i−1][pre][last] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define int long longusing namespace std;vector&lt;int&gt; prime;int dp[10001][11][11]=&#123;0&#125;;const int MOD=1e9+9;vector&lt;bool&gt; is_prime(1001); // 0表示质数，1表示不是质数void get_prime(int n)//欧拉筛板子&#123; is_prime[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (is_prime[i] == 0) prime.push_back(i); for (auto j : prime) &#123; if (i * j &gt; n) break; is_prime[i * j] = 1; if (i % j == 0) break; &#125; &#125; for(int i=0;i&lt;=100;i++)is_prime[i]=1; //仅需要统计101~999的质数，剩下的不属于这个范围&#125;int combine(int a,int b,int c)&#123; return a*100+b*10+c;&#125;signed main()&#123; int n; cin&gt;&gt;n; get_prime(1000); for(int i=0;i&lt;=9;i++) for(int j=0;j&lt;=9;j++) dp[2][i][j]=1; for(int k=3;k&lt;=n;k++) &#123; for(int i=1;i&lt;=9;i+=2) &#123; for(int j=0;j&lt;=9;j++) &#123; for(int l=0;l&lt;=9;l++) &#123; if(is_prime[combine(l,j,i)]==0) dp[k][i][j]=(dp[k][i][j]+dp[k-1][j][l])%MOD; &#125; &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;=9;i++)for(int j=0;j&lt;=9;j++)ans=(ans+dp[n][i][j])%MOD; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 另一道题目：Colo.题目描述小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 n，宽度为 1 的网格图上画画，从左往右第 i 个方格被涂成了一种颜色 a_i。 你觉得他的随意涂鸦太难看了，想要保留恰好 k 种颜色（你不能保留没在网格图上出现的颜色），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。 此外，小 Y 使用的第 i 种颜色有一个价值 b_i，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。 你需要求出你能够获得的最大的价值是多少。 输入格式第一行两个整数 n,k，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。第二行 n 个整数 a_i，表示小 Y 画出来的网格图从左往右第 i 个格子的颜色。第三行 n 个整数 b_i，表示第 i 种颜色的价值。 输出格式一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 -1。 样例 #1样例输入 #11235 21 2 1 3 25 3 1 100 100 样例输出 #116 样例 #2样例输入 #212310 31 3 4 2 9 3 4 2 5 11 5 2 3 9 8 1 2 3 10 样例输出 #21-1 提示【样例解释 #1】对于第一组样例，我们可以选择 1 号和 3 号颜色保留，剩下的网格图即为 [1,1,3]，满足单调不下降这一个限制，获得的价值即为 b_1+b_3=5+1=6，可以证明这是最优的办法。 【数据范围】对于所有测试数据，满足 1 \\le n \\le 500，1 \\le k \\le 500，1 \\le a_i \\le n，1 \\le b_i \\le 10^9。 各测试点的附加限制如下表所示。 本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 \\text{Subtask}。 测试点 n,k \\le 特殊性质 1 \\sim 3 10 无 4 \\sim 5 100 无 6 \\sim 10 500 不同的颜色不超过 10 种 11 \\sim 15 500 每种颜色出现的次数不超过 2 次 16 \\sim 20 500 无 首先是输入部分代码 在输入时候用bucket的方式记录每一种颜色的对应第一个和最后一个位置（后面有用） 记录方式用桶的方式便于查询 12345678910111213cin&gt;&gt;n&gt;&gt;k;for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(bucket[a[i]].begin ==inf)&#123; bucket[a[i]].begin =i; bucket[a[i]].last =i; &#125; else &#123; bucket[a[i]].last =i; &#125; &#125;for (int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; 接下来记录遍历每个颜色（对于每个颜色i） ，看看有哪些颜色（即j）在原数组中的位置是完全在他前面的，即 j 颜色的last小于 i 颜色的begin，(并且j&lt;i由循环条件可知默认成立)。如果有的话加入到数组g的第 i 项指向的（可以这么理解）数组中去。表示在取 i 颜色时候，可以取 j 颜色作为他的前驱 1234567891011121314long long g[505][505]=&#123;0&#125;; for(int i=1;i&lt;=n;i++)&#123; count=0; if(bucket[i].begin ==inf)continue; for(int j=1;j&lt;i;j++)&#123; if(bucket[j].begin ==inf)continue; if(bucket[i].begin &gt;bucket[j].last )&#123; g[i][count]=j; count++; &#125; &#125; &#125; 最重要的部分：填表 表格含义如下 123456789for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) dp[1][i]=b[i]; for(int i=2;i&lt;=k;i++)//i循环 for(int j=i;j&lt;=n;j++)//j循环 if(bucket[j].begin !=inf &amp;&amp; g[j][0]!=0) for(int p=0;g[j][p]!=0;p++)//p循环 if(dp[i-1][g[j][p]] !=0) dp[i][j]=max(dp[i][j],dp[i-1][g[j][p]]+b[j]);//# 以样例二为例 关键数组信息 第一行循环设置递推初始调件； 第二个 i 循环，遍历从第二行到第k行，因为问的是选k个，再往下遍历没有意义 第三个 j 循环，遍历第 i 列到最后的值，ij用来定位每个位置 以上好像都是废话。。 第四个p循环，遍历当前所在位置的上一行中所有可能成为该位置前驱的位置，#处表示取这些通过状态转移方程到该位置的所有值的最大值 最后，遍历第k行找出所有可能情况的最大值，没有，则输出-1 123456long long maxf=0; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) maxf=max(maxf,dp[k][i]); if(maxf==0)maxf=-1; cout&lt;&lt;maxf&lt;&lt;endl; 完整代码附上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define inf -1using namespace std;long long g[505][505]=&#123;0&#125;; typedef struct&#123; long long begin; long long last;&#125;edge;edge bucket[505];int main(void)&#123; long long n,k,a[505],b[505],dp[505][505]=&#123;0&#125;,count; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;=n;i++)&#123; bucket[i].begin =inf; bucket[i].last =inf; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(bucket[a[i]].begin ==inf)&#123; bucket[a[i]].begin =i; bucket[a[i]].last =i; &#125; else &#123; bucket[a[i]].last =i; &#125; &#125; for (int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; for(int i=1;i&lt;=n;i++)&#123; count=0; if(bucket[i].begin ==inf)continue; for(int j=1;j&lt;i;j++)&#123; if(bucket[j].begin ==inf)continue; if(bucket[i].begin &gt;bucket[j].last )&#123; g[i][count]=j; count++; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) dp[1][i]=b[i]; for(int i=2;i&lt;=k;i++) for(int j=i;j&lt;=n;j++) if(bucket[j].begin !=inf &amp;&amp; g[j][0]!=0) for(int p=0;g[j][p]!=0;p++) if(dp[i-1][g[j][p]] !=0) dp[i][j]=max(dp[i][j],dp[i-1][g[j][p]]+b[j]); long long maxf=0; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) maxf=max(maxf,dp[k][i]); if(maxf==0)maxf=-1; cout&lt;&lt;maxf&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区域DP","slug":"算法/动态规划/区域DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9FDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区域DP","slug":"区域DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E5%9F%9FDP/"}]},{"title":"02 区间DP：涂色","slug":"02 区间DP：涂色","date":"2024-08-17T06:53:17.201Z","updated":"2024-08-18T09:38:36.708Z","comments":true,"path":"2024/08/17/02 区间DP：涂色/","permalink":"https://xqc-1368.github.io/2024/08/17/02%20%E5%8C%BA%E9%97%B4DP%EF%BC%9A%E6%B6%82%E8%89%B2/","excerpt":"","text":"[CQOI2007] 涂色题目描述假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\\texttt{RGBGR}$。 每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\\texttt{RRRRR}$，第二次涂成 $\\texttt{RGGGR}$，第三次涂成 $\\texttt{RGBGR}$，达到目标。 用尽量少的涂色次数达到目标。 输入格式输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。 输出格式仅一行，包含一个数，即最少的涂色次数。 样例 #1样例输入 #11AAAAA 样例输出 #111 样例 #2样例输入 #21RGBGR 样例输出 #213 提示$40\\%$ 的数据满足 $1\\le n\\le 10$。 $100\\%$ 的数据满足 $1\\le n\\le 50$。 区间dp的plus版：我愿称之为完全区间dp 把从i到j的所有情况列在对应表格中；我们发现： GBBR可以分解为（此处为常规区间dp） G+BBR GB+BR GBB+R 这3种情况（隔板法分割把区间一分为二） 当然也会出现不用讨论分隔直接完成的：比如RGBBR相对于RGBB就可以相等； 首先赋初值，对角线为初值，赋1； 然后我们可以手动填上第二个斜线上的数字，我们可以看见，因为s[2]==s[3]，所以只要在刷一个的时候范围刷大刷到另一个所在位置即可，故dp[ i ][ j ] = =dp[ i-1 ][ j ]==dp[i+1][ j ] 所以当区间 i~j 首末数字相等时，可以直接 ”刷过来“ ，即等于下面的或者左边的； 当区间 i~j 首末数字不相等时候，则用区间dp对当前空格位置代表的字符串切分，比出一个最小值 例如GBBR可以分解为（此处为常规区间dp） G+BBR dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ] GB+BR dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ] GBB+R dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ] 这3种情况（隔板法分割把区间一分为二） 因此：dp[ 1 ][ 4 ]=max{ dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ] , dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ] , dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ] }; 由此我们得到对于任意一个dp[ i ][ j ]的状态转移方程 dp[ i ][ j ]= case1: dp[ i-1 ][ j ] or dp[i+1][ j ] ( if s[ i ]==s[ j ] ) case 2: maxE(k from i to j-1){dp[ i ][ k ]+dp[ k+1 ][ j ]} ( if s[ i ]!=s[ j ] ) 由此我们就可以很愉快的敲代码了 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define maxsize 55using namespace std;int dp[maxsize][maxsize]=&#123;0&#125;;int main() &#123; string s; memset(dp,0x3f,sizeof(dp)); cin&gt;&gt;s; for(int i=0;i&lt;s.size();i++) dp[i][i]=1; for(int p=0;p&lt;s.size()-1;p++)//注意见下 for(int i=0,j=p+1;j&lt;s.size();i++,j++) &#123; if(s[i]==s[j])dp[i][j]=dp[i+1][j]; else &#123; dp[i][j]=dp[i][i]+dp[i+1][j]; for(int k=i;k&lt;j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]); &#125; &#125; cout&lt;&lt;dp[0][s.size()-1]&lt;&lt;endl; return 0; &#125; 这里的p是指对第2~n个主对角线方向的斜线的遍历（第一个斜线即主对角线已经遍历过了）","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚","slug":"01 背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚","date":"2024-08-17T06:53:17.196Z","updated":"2024-08-17T14:31:12.026Z","comments":true,"path":"2024/08/17/01 背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚/","permalink":"https://xqc-1368.github.io/2024/08/17/01%20%E8%83%8C%E5%8C%85DP%EF%BC%9AMake_Full_Use_Of%E6%A8%A1%E5%9E%8B%EF%BC%9Akkksc03%E8%80%83%E5%89%8D%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/","excerpt":"","text":"kkksc03考前临时抱佛脚题目背景kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。 题目描述这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\\ldots,A{s1}$，$B_1,B_2,\\ldots,B{s2}$，$C_1,C_2,\\ldots,C{s3}$，$D_1,D_2,\\ldots,D{s_4}$）。 kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。 由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。 输入格式本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。 第 $2$ 行，为 $A1,A_2,\\ldots,A{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。 第 $3$ 行，为 $B1,B_2,\\ldots,B{s_2}$ 共 $s_2$ 个数。 第 $4$ 行，为 $C1,C_2,\\ldots,C{s_3}$ 共 $s_3$ 个数。 第 $5$ 行，为 $D1,D_2,\\ldots,D{s_4}$ 共 $s_4$ 个数，意思均同上。 输出格式输出一行,为复习完毕最短时间。 样例 #1样例输入 #1123451 2 1 3 54 362 4 3 样例输出 #1120 提示$1\\leq s_1,s_2,s_3,s_4\\leq 20$。 $1\\leq A1,A_2,\\ldots,A{s1},B_1,B_2,\\ldots,B{s2},C_1,C_2,\\ldots,C{s3},D_1,D_2,\\ldots,D{s_4}\\leq60$。 本题为背包dp的 “ 简单 ” 变式：虽然简单变一变本蒟蒻已经不会了。 一开始的思路是贪心算法：对每一组而言先排序，然后从后向前把元素往两个空脑子里丢，哪个脑子目前内容比较少就丢哪个。 代码如下，喜提零分（听取蛙声一片） 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#include &lt;algorithm&gt;#include &lt;queue&gt;const int maxsize = 25;int n, inp;int min_time(int a[],int n)&#123; if(n==1)return a[0]; int lsum=0,rsum=0; sort(a,a+n); for(int i=n-1;i&gt;=0;i--) &#123; if(lsum&gt;rsum)rsum+=a[i]; else lsum+=a[i]; &#125; return max(lsum,rsum);&#125;int main()&#123; int sum_time=0,na,nb,nc,nd; int a[maxsize],b[maxsize],c[maxsize],d[maxsize]; cin&gt;&gt;na&gt;&gt;nb&gt;&gt;nc&gt;&gt;nd; for(int i=0;i&lt;na;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;nb;i++) cin&gt;&gt;b[i]; for (int i = 0; i &lt; nc; i++) cin &gt;&gt; c[i]; for (int i = 0; i &lt; nd; i++) cin &gt;&gt; d[i]; cout &lt;&lt; min_time(a, na) + min_time(b, nb) + min_time(c, nc) + min_time(d, nd) &lt;&lt; endl; return 0;&#125; 注意：以上代码为错误代码！！！！！！！！！ 因为可以找到一组hack数据 12//在某一行：10 10 6 6 5 3 按照贪心算法 10 6 5 10 6 3 max为21 但是实际上： 10 10 6 6 5 3 max为20 于是验证了贪心的不可行性，而这种退一步达到全局最优解的情况，就应该使用dp 这道题使用的是最基本的背包dp。我们由以上思路可以知晓，当两个脑子处理的内容大小最接近 的时候将会达到本组最优解。于是我给第一个脑子一个容量预算为sum/2（即背包容量），在运算过程中不能超过这个预算。通过将每个选择装进背包的物品的v等价于其重量w这种方法，由此得出最大化利用sum/2的背包空间所能装得下的处理总量，即dp[ sum/2 ]; 而max（sum-dp[ sum/2 ]，dp[ sum/2 ]）即为某一组耗时。 1234567891011121314int dynamic_programming(int sum,int homework[],int n)&#123; if(n==1)return homework[1]; int dp[2501]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=sum/2;j&gt;=homework[i];j--) &#123; dp[j]=max(dp[j],dp[j-homework[i]]+homework[i]); &#125; &#125; return max(sum - dp[sum / 2], dp[sum / 2]); // return sum - dp[sum / 2];&#125; 此外由于int是除以2（在正数范围内）向下取整的特性，可以数学证明sum-dp[ sum/2 ]总是大于dp[ sum/2 ]，所以注释行也还可以那样输出。 最后，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int a[5];int dynamic_programming(int sum,int homework[],int n)&#123; if(n==1)return homework[1]; int dp[2501]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=sum/2;j&gt;=homework[i];j--) &#123; dp[j]=max(dp[j],dp[j-homework[i]]+homework[i]); &#125; &#125; return max(sum - dp[sum / 2], dp[sum / 2]); // return sum - dp[sum / 2];&#125;int main()&#123; int b[21] = &#123;0&#125;,ans=0; for (int i = 1; i &lt;= 4; i++) cin &gt;&gt; a[i]; for(int i=1;i&lt;=4;i++) &#123; int sum=0; memset(b,0,sizeof(b)); for(int j=1;j&lt;=a[i];j++) &#123; cin&gt;&gt;b[j]; sum+=b[j]; &#125; ans+=dynamic_programming(sum,b,a[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包DP","slug":"算法/动态规划/背包DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包DP","slug":"背包DP","permalink":"https://xqc-1368.github.io/tags/%E8%83%8C%E5%8C%85DP/"}]},{"title":"11 期望DP：收集邮票","slug":"11 期望DP：收集邮票","date":"2024-08-17T06:53:17.192Z","updated":"2024-08-17T14:32:13.333Z","comments":true,"path":"2024/08/17/11 期望DP：收集邮票/","permalink":"https://xqc-1368.github.io/2024/08/17/11%20%E6%9C%9F%E6%9C%9BDP%EF%BC%9A%E6%94%B6%E9%9B%86%E9%82%AE%E7%A5%A8/","excerpt":"","text":"11期望DP收集邮票题目描述有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $1/n$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 次邮票需要支付 $k$ 元钱。 现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。 输入格式一行，一个数字 $N$（$N \\le 10000$）。 输出格式输出要付出多少钱，保留二位小数。 样例 #1样例输入 #113 样例输出 #1121.25 定义状态 众所周知，期望DP的定义状态一般都为已经……还需要……的期望 由于本题需要求的就是 自己得到所有种类的邮票需要花费的钱数目的期望。 那么我们就可以定义一个 ex ，它的意义是： $ex(i)$：已经收集到了 i 种邮票，还需要花费的钱数的期望。 但是题目中有一个条件 皮皮购买第k张邮票需要支付k元钱 这意味着购买价格是与购买次数有关的。 所以我们还需要定义一个状态 num ，它的意义是：$num(i)$： 已经收集到了 i种邮票，还需要购买的次数的期望。 初始化：$num(n)=0$，$ex(n)=0$ 这个应该不需要我讲吧qwq 状态转移 首先吧这个写在前面 期望公式：$E(X)= \\sum pi​⋅xi$​ ，其中 pi​ 是事件 i 发生的概率，xi​ 是权值。 发现 num 的转移是比较简单的，先考虑 num。有以下两种情况： 买到之前买到过的邮票种类，此时 $x=num(i)+1$（种类总数不变），$p=\\frac{i}{n}$​ 买到之前没有买到过的，此时 $x=num(i+1)+1$（总种类数量+1），$p=\\frac{n-i}{n}$​ 注：以上的 x 指的是次数。 根据公式，我们就可以得到关于 num 的公式： $num(i)=(num(i)+1)×\\frac{i}{n}+(num(i+1)+1)×\\frac{n-i}{n}$ 化简之后得到状态转移方程： num(i)= \\frac{num(i+1)×\\frac{n-i}{n}+1}{1−\\frac{n-i}{n}}​得到 num 后，我们再思考 ans 的转移，同样是以上的两种情况 买到之前买到过的邮票种类：此时 $x=ex(i)+num(i)+1$（种类+1，总花费=之前花费+本次花费），$p=\\frac{i}{n}$ 买到之前没有买到过的，此时$x=ex(i+1)+num(i+1)+1$（同上），$p=\\frac{n-i}{n}$ 然后我们又轻松地得到了关于 ex 的公式： $ex(i)=(ex(i)+num(i)+1)×\\frac{i}{n}​+(ex(i+1)+num(i+1)+1)×​\\frac{n-i}{n}$ 请自行化简 既然我们有了转移方程，那就开写呗 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;double num[10005]=&#123;0&#125;,ex[10005]=&#123;0&#125;;signed main()&#123; int n; cin&gt;&gt;n; num[n]=0;ex[n]=0; for(int i=n-1;i&gt;=0;i--) &#123; double p=(double)n/(n-i); num[i]=p+num[i+1]; ex[i]=p*num[i]+ex[i+1]; &#125; // for(int i=0;i&lt;=n;i++)cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; // for(int i=0;i&lt;=n;i++)cout&lt;&lt;ex[i]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; printf(&quot;%.2lf&quot;,ex[0]); //cout&lt;&lt;ex[0]&lt;&lt;&quot;\\n&quot;; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"期望DP","slug":"算法/动态规划/期望DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"期望DP","slug":"期望DP","permalink":"https://xqc-1368.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"}]},{"title":"CSS定位","slug":"09 CSS定位","date":"2024-08-17T02:28:01.411Z","updated":"2024-08-17T02:19:44.500Z","comments":true,"path":"2024/08/17/09 CSS定位/","permalink":"https://xqc-1368.github.io/2024/08/17/09%20CSS%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"定位 今日目标 能够说出 为什么要用定位 能够说出 定位的 4 种分类 能够说出 4 种定位各自的特点 能够说出 为什么常用子绝父相布局 能够写出 淘宝轮播图布局 能够说出 显示隐藏的 3 种方式以及区别 1. 定位(position) 介绍1.1 为什么使用定位 我们先来看一个效果，同时思考一下用标准流或浮动能否实现类似的效果？ 场景1： 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子. 场景2：当我们滚动窗口的时候，盒子是固定屏幕某个位置的。 结论：要实现以上效果，标准流 或 浮动都无法快速实现 所以： 1.浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 2.定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 1.2 定位组成定位：将盒子定在某一个位置，所以定位也是在摆放盒子， 按照定位的方式移动盒子 定位也是用来布局的，它有两部分组成： 定位 = 定位模式 + 边偏移 定位模式 用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 1.2.1 边偏移（方位名词）边偏移 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性。 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 1.2.2 定位模式 (position)在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 123选择器 &#123; position: 属性值; &#125; 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个： 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 1.3 定位模式介绍1.3.1. 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none，静态定位static，不要定位的时候用。 语法： 123选择器 &#123; position: static; &#125; 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 1.3.2. 相对定位(relative) - 重要 相对定位是元素在移动位置的时候，是相对于它自己原来的位置来说的（自恋型）。 语法： 123选择器 &#123; position: relative; &#125; 相对定位的特点：（务必记住） 1.它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。 2.原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。 因此，相对定位并没有脱标。它最典型的应用是给绝对定位当爹的。。。 效果图： 1.3.3. 绝对定位(absolute) - 重要1.3.3.1 绝对定位的介绍 绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的（拼爹型）。 语法： 123选择器 &#123; position: absolute; &#125; 完全脱标 —— 完全不占位置； 父元素没有定位，则以浏览器为准定位（Document 文档）。 父元素要有定位 元素将依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的特点总结：（务必记住） 1.如果没有祖先元素或者祖先元素没有定位，则以浏览器为基准定位（Document 文档）。 2.如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。 3.绝对定位不再占有原先的位置。所以绝对定位是脱离标准流的。（脱标） 1.3.3.2 定位口诀 —— 子绝父相弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。 这个“子绝父相”太重要了，是我们学习定位的口诀，是定位中最常用的一种方式这句话的意思是：子级是绝对定位的话，父级要用相对定位。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 ①子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 ②父盒子需要加定位限制子盒子在父盒子内显示。 ③父盒子布局时，需要占有位置，因此父亲只能是相对定位。 这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。 总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。 疑问：为什么在布局时，子级元素使用绝对定位时，父级元素就要用相对定位呢？ 观察下图，思考一下在布局时，左右两个方向的箭头图片以及父级盒子的定位方式。 分析： 方向箭头叠加在其他图片上方，应该使用绝对定位，因为绝对定位完全脱标，完全不占位置。 父级盒子应该使用相对定位，因为相对定位不脱标，后续盒子仍然以标准流的方式对待它。 如果父级盒子也使用绝对定位，会完全脱标，那么下方的广告盒子会上移，这显然不是我们想要的。 结论：父级要占有位置，子级要任意摆放，这就是子绝父相的由来。 1.3.4. 固定定位(fixed) - 重要 固定定位是元素固定于浏览器可视区的位置。（认死理型） 主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。 语法： 123选择器 &#123; position: fixed; &#125; 固定定位的特点：（务必记住）： 1.以浏览器的可视窗口为参照点移动元素。 跟父元素没有任何关系 不随滚动条滚动。 2.固定定位不在占有原先的位置。 固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。（认死理型） 完全脱标—— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 固定定位举例： 提示：IE 6 等低版本浏览器不支持固定定位。 小tip：固定在版心右侧 12345.fixed&#123; position:fixed; left:50%; margin-left:版面宽度的一半&#125; 1.3.5 粘性定位(sticky) - 了解 粘性定位可以被认为是相对定位和固定定位的混合。 Sticky 粘性的 语法： 1234选择器 &#123; position: sticky; top: 10px; &#125; 粘性定位的特点： 1.以浏览器的可视窗口为参照点移动元素（固定定位特点） 2.粘性定位占有原先的位置（相对定位特点） 3.必须添加 top 、left、right、bottom 其中一个才有效 跟页面滚动搭配使用。 兼容性较差，IE 不支持。 1.3.6 定位总结 定位模式 是否脱标 移动位置 是否常用 static 静态定位 否 不能使用边偏移 很少 relative 相对定位 否 (占有位置) 相对于自身位置移动 基本单独使用 absolute绝对定位 是（不占有位置） 带有定位的父级 要和定位父级元素搭配使用 fixed 固定定位 是（不占有位置） 浏览器可视区 单独使用，不需要父级 sticky 粘性定位 否 (占有位置) 浏览器可视区 当前阶段少 一定记住 相对定位、固定定位、绝对定位 两个大的特点： 1. 是否占有位置（脱标否） 2. 以谁为基准点移动位置。 学习定位重点学会子绝父相。 注意： 边偏移需要和定位模式联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 2. 综合案例：学成在线-hot 模块添加2. 1 案例截图： 2.2 案例分析 一个大的 li 中包含 一个课程图片，课程介绍文字信息，还有hot的小图标； hot图片重叠在课程图片上面—— 脱标，不占位置，需要使用绝对定位； hot图片重叠在li的右上方 —— 需要使用边偏移确定准确位置。 2.3 案例小结 子绝父相 —— 子元素使用绝对定位，父元素使用相对定位； 与浮动的对比： 绝对定位：脱标，利用边偏移指定准确位置； 浮动：脱标，不能指定准确位置，让多个块级元素在一行显示。 课堂练习：模拟老师的随堂案例完成哈根达斯案例（5 分钟）。 结构修改： 123456789101112131415&lt;!-- 修改.box-bd里面的li标签内容，添加一个hot图标 --&gt;&lt;li&gt; &lt;!-- 添加hot小图片 --&gt; &lt;em&gt; &lt;img src=&quot;images/hot.png&quot; alt=&quot;&quot;&gt; &lt;/em&gt; &lt;img src=&quot;images/pic.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt; Think PHP 5.0 博客系统实战项目演练 &lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt;&lt;/li&gt; 样式修改： 123456789101112131415161718192021222324252627.box-bd ul li &#123; /* 子绝父相 */ /* 父元素相对定位 */ position: relative; float: left; width: 228px; height: 270px; background-color: #fff; margin-right: 15px; margin-bottom: 15px;&#125;.box-bd ul li &gt; img &#123; width: 100%;&#125;.box-bd ul li h4 &#123; margin: 20px 20px 20px 25px; font-size: 14px; color: #050505; font-weight: 400;&#125;.box-bd ul li em &#123; /* 子元素绝对定位 */ position: absolute; top: 4px; right: -4px;&#125; 3. 定位(position)的应用3.1. 固定定位小技巧： 固定在版心左侧位置。小算法： 1.让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。 2.让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。 案例效果： 123456789101112131415161718192021222324&lt;style&gt; .w &#123; width: 800px; height: 1400px; background-color: pink; margin: 0 auto; &#125; .fixed &#123; position: fixed; /* 1. 走浏览器宽度的一半 */ left: 50%; /* 2. 利用margin 走版心盒子宽度的一半距离 */ margin-left: 405px; width: 50px; height: 150px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt; &lt;div class=&quot;w&quot;&gt;版心盒子 800像素&lt;/div&gt;&lt;/body&gt; 3.2. 堆叠顺序（z-index） 在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴) 语法： 123选择器 &#123; z-index: 1; &#125; z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。如下图所示： 案例演示：堆叠顺序。 4. 定位(position)的拓展4.1 绝对定位的盒子居中：注意不能用margin：0 auto 注意：加了绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中。 但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 盒子居中定位示意图 4.2 定位特殊特性绝对定位和固定定位也和浮动类似。 1.行内元素添加绝对或者固定定位，可以直接设置高度和宽度。 2.块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。 前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 4.3 脱标的盒子不会触发外边距塌陷浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的） 也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。 4.4 绝对定位（固定定位）会完全压住盒子浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片） 但是绝对定位（固定定位） 会压住下面标准流所有的内容。 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素 5. 综合案例 - 淘宝轮播图(重点)5.1 效果图 5.2 布局分析 5.3 步骤 大盒子我们类名为： tb-promo 淘宝广告 里面先放一张图片。 左右两个按钮 用链接就好了。 左箭头 prev 右箭头 next ​ 左按钮样式（border-radius：左上，右上，右下，左下）， ​ 右按钮定位，提取左右按钮共同的样式代码（并集选择器） 底侧小圆点ul 继续做。 类名为 promo-nav ​ 中间长方形椭圆 ul的定位（水平居中，离底部15px） ​ 长方形需要五个小圆点，ul无序列表，li浮动，椭圆中小圆点的样式 5.4 知识点：圆角矩形设置4个角圆角矩形可以为4个角分别设置圆度， 但是是有顺序的 1234border-top-left-radius:20px;border-top-right-radius:20px;border-bottom-right-radius:20px;border-bottom-left-radius:20px; 如果4个角，数值相同 1border-radius: 15px; 里面数值不同，我们也可以按照简写的形式，具体格式如下: 1border-radius: 左上角 右上角 右下角 左下角; 还是遵循的顺时针。 5.5 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;淘宝轮播图做法&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; &#125; .tb-promo &#123; position: relative; width: 520px; height: 280px; background-color: pink; margin: 100px auto; &#125; .tb-promo img &#123; width: 520px; height: 280px; &#125; /* 并集选择器可以集体声明相同的样式 */ .prev, .next &#123; position: absolute; /* 绝对定位的盒子垂直居中 */ top: 50%; margin-top: -15px; /* 加了绝对定位的盒子可以直接设置高度和宽度 */ width: 20px; height: 30px; background: rgba(0, 0, 0, .3); text-align: center; line-height: 30px; color: #fff; text-decoration: none; &#125; .prev &#123; left: 0; /* border-radius: 15px; */ border-top-right-radius: 15px; border-bottom-right-radius: 15px; &#125; .next &#123; /* 如果一个盒子既有left属性也有right属性，则默认会执行 left属性 同理 top bottom 会执行 top */ right: 0; /* border-radius: 15px; */ border-top-left-radius: 15px; border-bottom-left-radius: 15px; &#125; .promo-nav &#123; position: absolute; bottom: 15px; left: 50%; margin-left: -35px; width: 70px; height: 13px; /* background-color: pink; */ background: rgba(255,255,255, .3); border-radius: 7px; &#125; .promo-nav li &#123; float: left; width: 8px; height: 8px; background-color: #fff; border-radius: 50%; margin: 3px; &#125; /* 不要忘记选择器权重的问题 */ .promo-nav .selected &#123; background-color: #ff5000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tb-promo&quot;&gt; &lt;img src=&quot;images/tb.jpg&quot; alt=&quot;&quot;&gt; &lt;!-- 左侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;prev&quot;&gt; &lt; &lt;/a&gt; &lt;!-- 右侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;next&quot;&gt; &gt; &lt;/a&gt; &lt;!-- 小圆点 --&gt; &lt;ul class=&quot;promo-nav&quot;&gt; &lt;li class=&quot;selected&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. 网页布局总结通过盒子模型，清楚知道大部分html标签是一个盒子。 通过CSS浮动、定位 可以让每个盒子排列成为网页。 一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。 6.1. 标准流可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。 6.2. 浮动可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局 6.3. 定位定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 7. 元素的显示与隐藏 目的（本质） ​ 让一个元素在页面中消失或者显示出来 场景 ​ 类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 7.1. display 显示（重点） display 设置或检索对象是否及如何显示。 123display: none 隐藏对象display：block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： display 隐藏元素后，不再占有原来的位置。 后面应用及其广泛，搭配 JS 可以做很多的网页特效。实际开发场景： 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 7.2. visibility 可见性 （了解） visibility 属性用于指定一个元素应可见还是隐藏。 123visibility：visible ; 元素可视visibility：hidden; 元素隐藏 特点：visibility 隐藏元素后，继续占有原来的位置。（停职留薪） 如果隐藏元素想要原来位置， 就用 visibility：hidden 如果隐藏元素不想要原来位置， 就用 display：none (用处更多 重点） 7.3. overflow 溢出（重点） overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。 但是如果有定位的盒子， 请慎用overflow:hidden 因为它会隐藏多余的部分。 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 7.4. 显示与隐藏总结 属性 区别 用途 display 显示 （重点） 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 可见性 （了解） 隐藏对象，保留位置 使用较少 overflow 溢出（重点） 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 8 综合案例：土豆网鼠标经过显示遮罩8.1. 效果图 8.2. 案例目标1.练习元素的显示与隐藏 2.练习元素的定位 8.3. 核心原理原先半透明的黑色遮罩看不见， 鼠标经过 大盒子，就显示出来。 遮罩的盒子不占有位置， 就需要用绝对定位 和 display 配合使用。 8.4. 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;仿土豆网显示隐藏遮罩案例&lt;/title&gt; &lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .mask &#123; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面遮罩层显示出来 */ .tudou:hover .mask &#123; /* 而是显示元素 */ display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS绝对定位","slug":"CSS绝对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS相对定位","slug":"CSS相对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS定位注意事项","slug":"CSS定位注意事项","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AE%9A%E4%BD%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"CSS子绝父相","slug":"CSS子绝父相","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8/"},{"name":"CSS元素显示与隐藏","slug":"CSS元素显示与隐藏","permalink":"https://xqc-1368.github.io/tags/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"name":"CSS溢出处理","slug":"CSS溢出处理","permalink":"https://xqc-1368.github.io/tags/CSS%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/"}]},{"title":"CSS浮动布局","slug":"08 CSS 浮动布局 float","date":"2024-08-17T02:28:01.400Z","updated":"2024-08-17T02:11:10.177Z","comments":true,"path":"2024/08/17/08 CSS 浮动布局 float/","permalink":"https://xqc-1368.github.io/2024/08/17/08%20CSS%20%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80%20float/","excerpt":"","text":"一、浮动1、传统网页布局的三种方式​ CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)： 普通流（标准流） 浮动 定位 这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。 注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。 2、标准流（普通流/文档流）所谓的标准流: 就是标签按照规定好默认方式排列 块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等 以上都是标准流布局，我们前面学习的就是标准流，标准流是最基本的布局方式。 3、为什么需要浮动？​ 总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式. ​ 浮动最典型的应用：可以让多个块级元素一行内排列显示。 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。4、什么是浮动？​ float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 语法： 1选择器 &#123; float: 属性值; &#125; 5、浮动特性加了浮动之后的元素,会具有很多特性,需要我们掌握的. 1、浮动元素会脱离标准流(脱标：浮动的盒子不再保留原先的位置) 2、浮动的元素会一行内显示并且元素顶部对齐 注意： ​ 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。 3、浮动的元素会具有行内块元素的特性 如果行内元素or块元素有了浮动，则都自动转换为行内块元素 ​ 浮动元素的大小根据内容来决定 ​ 浮动的盒子中间是没有缝隙的 6、浮动元素经常和标准流父级搭配使用为了约束浮动元素位置, 我们网页布局一般采取的策略是: ​ 先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧 二、常见网页布局浮动布局注意点1、浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置 2、一个元素浮动了，理论上其余的兄弟元素也要浮动。 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流. 三、清除浮动1、为什么需要清除浮动？​ 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。 2、清除浮动本质清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度 注意： 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。 父级有了高度，就不会影响下面的标准流了 3、清除浮动样式语法： 1选择器&#123;clear:属性值;&#125; 我们实际工作中， 几乎只用 clear: both; 清除浮动的策略是: 闭合浮动. 4、清除浮动的多种方式自动设置父div的高度 4.1、额外标签法（不常用）额外标签法也称为隔墙法，是 W3C 推荐的做法。 使用方式： ​ 额外标签法会在浮动元素末尾添加一个空的标签。 1例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;，或者其他标签（如&lt;br /&gt;等）。 ​ 优点： 通俗易懂，书写方便 ​ 缺点： 添加许多无意义的标签，结构化较差 ​ 注意： 要求这个新的空标签必须是块级元素。 总结: ​ 1、清除浮动本质是? ​ 清除浮动的本质是清除浮动元素脱离标准流造成的影响 ​ 2、清除浮动策略是? ​ 闭合浮动. 只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子. ​ 3、额外标签法? ​ 隔墙法, 就是在最后一个浮动的子元素后面添 ​ 4、加一个额外标签, 添加 清除浮动样式. ​ 实际工作可能会遇到,但是不常用 4.2、父级添加 overflow 属性可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。 例如： 1overflow:hidden | auto | scroll; 优点：代码简洁 缺点：无法显示溢出的部分 注意：是给父元素添加代码 4.3、父级添加after伪元素:after 方式是额外标签法的升级版。给父元素添加： 12345678910.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; /* IE6、7 专有 */ *zoom: 1;&#125; 在父元素里面写成： 123&lt;div class=&quot;原有类 clearfix&quot;&gt; ......&lt;/div&gt; 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站： 百度、淘宝网、网易等 4.4、父级添加双伪元素给父元素添加 12345678910.clearfix:before,.clearfix:after &#123; content:&quot;&quot;; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 在父元素里面写成： 123&lt;div class=&quot;原有类 clearfix&quot;&gt; ......&lt;/div&gt; 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 总结为什么需要清除浮动？ 父级没高度。 子盒子浮动了。 影响下面布局了，我们就应该清除浮动了。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS浮动float","slug":"CSS浮动float","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B5%AE%E5%8A%A8float/"},{"name":"CSS清除浮动","slug":"CSS清除浮动","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"}]},{"title":"CSS盒子模型","slug":"07 CSS 盒子模型 BoxModel","date":"2024-08-17T02:28:01.389Z","updated":"2024-08-17T02:05:56.499Z","comments":true,"path":"2024/08/17/07 CSS 盒子模型 BoxModel/","permalink":"https://xqc-1368.github.io/2024/08/17/07%20CSS%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%20BoxModel/","excerpt":"","text":"一、盒子模型1、网页布局的本质网页布局的核心本质： 就是利用 CSS 摆盒子。 网页布局过程： 先准备好相关的网页元素，网页元素基本都是盒子 Box 。 利用 CSS 设置好盒子样式，然后摆放到相应位置。 往盒子里面装内容 2、盒子模型（Box Model）组成​ 盒子模型：把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 ​ CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 实际内容 3、边框（border）3.1、边框的使用1、border可以设置元素的边框。边框有三部分组成：边框宽度(粗细) 边框样式 边框颜色； 2、语法： 1border : border-width || border-style || border-color; 边框样式 border-style 可以设置如下值： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 3、边框的合写分写 边框简写： 1border: 1px solid red; 边框分开写法： 1border-top: 1px solid red; /* 只设定上边框， 其余同理 */ 3.2、表格的细线边框123456789101112&lt;style&gt; table&#123; width:500px; height:249px; &#125; table,td,th&#123; border:1px solid pink; border-collapse:collaspe; font-size:14px; text-align:center; &#125;&lt;/style&gt; 1、border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 2、语法： 1border-collapse:collapse; collapse 单词是合并的意思 border-collapse: collapse; 表示相邻边框合并在一起 3.3、边框会影响盒子实际大小边框会额外增加盒子的实际大小。因此我们有两种方案解决： 测量盒子大小的时候,不量边框。 如果测量的时候包含了边框,则需要 width/height 减去边框宽度 4、内边距（padding）4.1、内边距的使用方式1、padding 属性用于设置内边距，即边框与内容之间的距离。 2、语法： 合写属性： 分写属性： 4.2、内边距会影响盒子实际大小1、当我们给盒子指定 padding 值之后，发生了 2 件事情： 内容和边框有了距离，添加了内边距。 padding影响了盒子实际大小。 2、内边距对盒子大小的影响： 如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。 如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小。 3、解决方案： ​ 如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。 利用padding撑开盒子做法：导航栏字数不同时候 5、外边距（margin）5.1、外边距的使用方式123&lt;style&gt; p&#123;margin-top:30px;&#125;&lt;/style&gt; margin 属性用于设置外边距，即控制盒子和盒子之间的距离。 5.2、外边距典型应用 外边距可以让块级盒子水平居中的两个条件： 盒子必须指定了宽度（width）。 盒子左右的外边距都设置为 auto 。 常见的写法，以下三种都可以： 123margin-left: auto; margin-right: auto;margin: auto;margin: 0 auto; 注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。 5.3、外边距合并使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。 主要有两种情况: 1、相邻块元素垂直外边距的合并 ​ 当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。 解决方案： 尽量只给一个盒子添加 margin 值。 2、嵌套块元素垂直外边距的塌陷 ​ 对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方案： 可以为父元素定义上边框。 ```css.father{border:1px solid transparent; }12345- 可以为父元素定义上内边距。- ```css .father&#123; padding:1px; &#125; 可以为父元素添加 overflow:hidden。(不会使盒子变大) ```css.father{overflow:hidden; }12345678910#### 5.4、清除内外边距​ 网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。```css * &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ &#125; ​ 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了 二、盒子模型的其他样式1、圆角边框在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。 border-radius 属性用于设置元素的外边框圆角。 语法： 1border-radius:length; 参数值可以为数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius 兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用 2、盒子阴影CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 1box-shadow:10px 10px 10px -4px rgba(0,0,0,.3) 3、文字阴影在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。语法： 1text-shadow: h-shadow v-shadow blur color; 1text-shadow: 5px 5px 6px rgba(0,0,0,.3)","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS盒子模型","slug":"CSS盒子模型","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"name":"CSS边框样式","slug":"CSS边框样式","permalink":"https://xqc-1368.github.io/tags/CSS%E8%BE%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/"},{"name":"CSS内边距padding","slug":"CSS内边距padding","permalink":"https://xqc-1368.github.io/tags/CSS%E5%86%85%E8%BE%B9%E8%B7%9Dpadding/"},{"name":"CSS外边距margin","slug":"CSS外边距margin","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%96%E8%BE%B9%E8%B7%9Dmargin/"},{"name":"CSS清除内外边距","slug":"CSS清除内外边距","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E5%86%85%E5%A4%96%E8%BE%B9%E8%B7%9D/"},{"name":"CSS圆角边框","slug":"CSS圆角边框","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/"},{"name":"CSS盒子阴影","slug":"CSS盒子阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1/"}]},{"title":"CSS显示模式","slug":"06 CSS 元素的显示模式","date":"2024-08-17T02:28:01.364Z","updated":"2024-08-17T02:37:08.439Z","comments":true,"path":"2024/08/17/06 CSS 元素的显示模式/","permalink":"https://xqc-1368.github.io/2024/08/17/06%20CSS%20%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、css的显示模式1、什么是元素的显示模式定义： ​ 元素显示模式就是元素（标签）以什么方式进行显示，比如自己占一行，比如一行可以放多个。 作用： ​ 网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。 2、元素显示模式的分类2.1、块元素常见的块元素： 1&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; ​ 标签是最典型的块元素。 块级元素的特点： 比较霸道，自己独占一行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： ​ 文字类的元素内不能放块级元素 12&lt;p&gt; 标签主要用于存放文字，因此 &lt;p&gt; 里面不能放块级元素，特别是不能放&lt;div&gt; 同理， &lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 2.2、行内元素常见的行内元素： 1&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; ​ 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 12345&lt;style&gt; span&#123; background-color:hotpink; &#125;&lt;/style&gt; 注意： 链接里面不能再放链接 特殊情况链接 &lt;a&gt; 里面可以放块级元素，但是给 &lt;a&gt; 转换一下块级模式最安全 2.3、行内块元素常见的行内块标签： 1&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt; ​ 它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 行内块元素的特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。 一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点）。 123456&lt;style&gt; input&#123; width:250px; height:39px; &#125;&lt;/style&gt; 2.4、元素显示模式总结 ​ 学习元素显示模式的主要目的就是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。 3、元素显示模式的转换简单理解: ​ 一个模式的元素需要另外一种模式的特性​ 比如想要增加链接 &lt;a&gt; 的触发范围。 转换方式 转换为块元素：display:block; 转换为行内元素：display:inline; 转换为行内块：display: inline-block; 123456789101112131415161718&lt;style&gt; a&#123; height:150px; width:150px; background-color:pink; display:block; &#125; div&#123; background-color:purple; display:inline; &#125; span&#123; height:300px; width:30px; background-color:blue; display:inline-block; &#125;&lt;/style&gt; 案例，小米侧边栏 4、单行文字垂直居中的代码解决方案: ​ 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中 实现： line-height:40px; 简单理解: ​ 行高的上空隙和下空隙把文字挤到中间了， ​ 如果行高小于盒子高度,文字会偏上， ​ 如果行高大于盒子高度,则文字偏下。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS显示模式","slug":"CSS显示模式","permalink":"https://xqc-1368.github.io/tags/CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"},{"name":"CSS块元素","slug":"CSS块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS行内元素","slug":"CSS行内元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"},{"name":"CSS行内块元素","slug":"CSS行内块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0/"}]},{"title":"CSS选择器","slug":"05 CSS 选择器 Selector","date":"2024-08-17T02:28:01.343Z","updated":"2024-08-17T01:57:46.906Z","comments":true,"path":"2024/08/17/05 CSS 选择器 Selector/","permalink":"https://xqc-1368.github.io/2024/08/17/05%20CSS%20%E9%80%89%E6%8B%A9%E5%99%A8%20Selector/","excerpt":"","text":"一、选择器分类基本语法架构： CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明 CSS声明总是以分号 ; 结束，声明总以大括号 &#123;&#125; 括起来: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 标签选择器 1234p &#123; color:red; text-align:center;&#125; 类选择器 class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以一个点 . 号显示： 在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。 1.center &#123;text-align:center;&#125; 1在标签里面加上：class=&quot;nounderline gray&quot;就可以用了 你也可以指定特定的 HTML 元素使用 class。 在以下实例中, 所有的 p 元素使用 class=”center” 让该元素的文本居中: 1p.center &#123;text-align:center;&#125; id选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 以下的样式规则应用于元素属性 id=”para1”: 12345#para1&#123; text-align:center; color:red;&#125; 通配符选择器 1234*&#123; 属性1：属性值1 ; ......&#125; 二、css的复合选择器 1、什么是复合选择器？​ 在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。​ 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签）​ 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等 2、后代选择器 (重要）定义： ​ 后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 语法：(在head里面) 1234567891011121314&lt;style&gt; ol li &#123; color:pink; &#125; ol li a&#123; color:red; &#125;nav为class名 .nav li a&#123; color:yellow; &#125;&lt;/style&gt; ​ 上述语法表示选择元素 1 里面的所有元素 2 (后代元素)。 语法说明： 元素1 和 元素2 中间用空格隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可 元素1 和 元素2 可以是任意基础选择器 3、子选择器 (重要）定义： ​ 子元素选择器（子选择器）只能选择作为某元素的最近一级子元素。 ​ （简单理解就是选亲儿子元素） 语法： 12345&lt;style&gt; .nav&gt;a&#123; color:red; &#125;&lt;/style&gt; ​ 上述语法表示选择元素1 里面的所有直接后代(子元素) 元素2。 语法说明： 元素1 和 元素2 中间用 大于号 隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 必须是亲儿子，其孙子、重孙之类都不归他管. 你也可以叫他 亲儿子选择器 例子： 4、并集选择器 (重要）定义： ​ 并集选择器可以选择多组标签, 同时为他们定义相同的样式，通常用于集体声明。并集选择器是各选择器通过英文逗号（,）连接而成，任何形式的选择器都可以作为并集选择器的一部分。 语法： 1234567891011&lt;style&gt; div,p&#123; color:pink; &#125;或者 div, p, .pig li&#123; color:pink; &#125;&lt;/style&gt; ​ 上述语法表示选择元素1 和 元素2。 语法说明： 元素1 和 元素2 中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 例子： 5、伪类选择器定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法： ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 6、链接伪类选择器定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法：（请按照LVHA顺序书写，不能换序） 123456789101112131415&lt;style&gt; a:link&#123; color:#333 text-decoration:none; &#125; a:visited&#123; color:orange; &#125; a:hover&#123; color:skyblue; &#125; a:active&#123; color:green; &#125;&lt;/style&gt; ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 ​ a:link 没有点击过的(访问过的)链接​ a:visited 点击过的(访问过的)链接​ a:hover 鼠标经过的那个链接​ a:active 鼠标正在按下还没有弹起鼠标的那个链接 链接伪类选择器注意事项 ​ 为了确保生效，请按照 LVHA 的循顺序声明 :link－:visited－:hover－:active。 ​ 记忆法：love hate 或者 lv 包包 hao 。 ​ 因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 12345&lt;style&gt; a&#123; color:red; &#125;&lt;/style&gt; 链接伪类选择器实际工作开发中的写法：(重要) 7、:focus 伪类选择器定义： ​ :focus 伪类选择器用于选取获得焦点的表单元素。 ​ 焦点就是光标，一般情况 类表单元素才能获取 例子： 123456&lt;style&gt; input:focus&#123; background-color:pink; color:red; &#125;&lt;/style&gt; 复合选择器总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS复合选择器","slug":"CSS复合选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS伪元素选择器","slug":"CSS伪元素选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS链接伪类选择器","slug":"CSS链接伪类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS属性选择器","slug":"CSS属性选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS类选择器","slug":"CSS类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS标签选择器","slug":"CSS标签选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSSID选择器","slug":"CSSID选择器","permalink":"https://xqc-1368.github.io/tags/CSSID%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS通配符选择器","slug":"CSS通配符选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%9A%E9%85%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS后代选择器","slug":"CSS后代选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS子选择器","slug":"CSS子选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS并集选择器","slug":"CSS并集选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"CSS背景","slug":"04 CSS 背景 background","date":"2024-08-17T02:28:01.319Z","updated":"2024-08-17T01:54:26.951Z","comments":true,"path":"2024/08/17/04 CSS 背景 background/","permalink":"https://xqc-1368.github.io/2024/08/17/04%20CSS%20%E8%83%8C%E6%99%AF%20background/","excerpt":"","text":"一、背景基础CSS 背景属性用于定义HTML元素的背景。 CSS 属性定义背景效果: background-color background-color 属性定义了元素的背景颜色，页面的背景颜色使用在body的选择器中: 1body &#123;background-color:#b0c4de;&#125; 二、css的背景样式通过 CSS 背景属性，可以给页面元素添加背景样式。背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 1、背景颜色样式名称： ​ background-color 定义元素的背景颜色 使用方式： 1background-color:颜色值; 其他说明： ​ 元素背景颜色默认值是 transparent（透明） 1background-color:transparent; 2、背景图片样式名称： ​ background-image 定义元素的背景图片 使用方式： 1background-image:url(images/logo.png) 其他说明： ​ 实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置. (精灵图也是一种运用场景) ​ 注意：背景图片后面的地址，千万不要忘记加 URL， 同时里面的路径不要加引号。 3、背景平铺样式名称： ​ background-repeat 设置元素背景图像的平铺 1background-repeat:repeat|no-repeat|repeat-x|repeat-y 使用方式： 4、背景图片位置样式名称： ​ background-position 属性可以改变图片在背景中的位置 使用方式： ​ ​ 参数代表的意思是：x 坐标和 y 坐标。 可以使用 方位名词 或者 精确单位 其他说明： 1、参数是方位名词 ​ 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致 ​ 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 2、参数是精确单位 ​ 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标 ​ 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中 1background-poisition:20px 50px; 3、参数是混合单位 ​ 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标 wzry成长守护平台案例 虞姬皮肤全屏背景案例 5、背景图片固定样式名称： ​ background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。 使用方式： ​ 其他说明： ​ background-attachment 后期可以制作视差滚动的效果。 6、背景样式合写背景合写样式： ​ background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置; 使用方式： 7、背景色半透明CSS3 提供了背景颜色半透明的效果。 使用方式： 最后一个参数是 alpha 透明度，取值范围在 0~1之间 我们习惯把 0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明，盒子里面的内容不受影响 CSS3 新增属性，是 IE9+ 版本浏览器才支持的，但是现在实际开发,我们不太关注兼容性写法了,可以放心使用 8、背景总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS背景","slug":"CSS背景","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF/"},{"name":"CSS背景平铺","slug":"CSS背景平铺","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%B9%B3%E9%93%BA/"},{"name":"CSS背景图片位置","slug":"CSS背景图片位置","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/"}]},{"title":"CSS字体","slug":"03 CSS 字体 font","date":"2024-08-17T02:28:01.297Z","updated":"2024-08-17T01:55:51.059Z","comments":true,"path":"2024/08/17/03 CSS 字体 font/","permalink":"https://xqc-1368.github.io/2024/08/17/03%20CSS%20%E5%AD%97%E4%BD%93%20font/","excerpt":"","text":"一、CSS 字体CSS字体属性定义字体，加粗，大小，文字样式。 Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 字体系列 font-family 属性设置文本的字体系列。 font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。 注意: 如果字体系列的名称超过一个字，它必须用引号，如Font Family：”宋体”。 多个字体系列是用一个逗号分隔指明： 1p&#123;font-family:&quot;Times New Roman&quot;, Times, serif;&#125; 字体样式 主要是用于指定斜体文字的字体样式属性。 这个属性有三个值： 正常 - 正常显示文本 斜体 - 以斜体字显示的文字 倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）字体大小 123p.normal &#123;font-style:normal;&#125;p.italic &#123;font-style:italic;&#125;p.oblique &#123;font-style:oblique;&#125;/*没什么用*/ 字体大小 font-size 属性设置文本的大小。 能否管理文字的大小，在网页设计中是非常重要的。但是，你不能通过调整字体大小使段落看上去像标题，或者使标题看上去像段落。 绝对大小： 设置一个指定大小的文本 不允许用户在所有浏览器中改变文本大小 确定了输出的物理尺寸时绝对大小很有用 相对大小： 相对于周围的元素来设置大小 允许用户在浏览器中改变文字大小 如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。 设置字体大小像素(绝对大小): 123h1 &#123;font-size:40px;&#125;h2 &#123;font-size:30px;&#125;p &#123;font-size:14px;&#125; 用em来设置字体大小(相对大小): 1h1 &#123;font-size:2.5em;&#125; font-weight 属性 123p.normal &#123;font-weight:normal;&#125;p.thick &#123;font-weight:bold;&#125;p.thicker &#123;font-weight:900;&#125; 属性值 | 值 | 描述 || ————————————————————————————————— | ————————————————————————— || normal | 默认值。定义标准的字符。 || bold | 定义粗体字符。 || bolder | 定义更粗的字符。 || lighter | 定义更细的字符。 || 100 200 300 400 500 600 700 800900 | 定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold。 || inherit | 规定应该从父元素继承字体的粗细。 | font复合属性 font 简写属性在一个声明中设置所有字体属性。 可设置的属性是（按顺序）： “font-style font-variant font-weight font-size/line-height font-family“ font-size和font-family的值是必需的。如果缺少了其他值，默认值将被插入，如果有默认值的话。 123456789p.ex1&#123; font:15px arial,sans-serif;&#125;p.ex2&#123; font:italic bold 12px/30px Georgia, serif;&#125; 二、CSS 文本格式 文本颜色 颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 参阅 CSS 颜色值 查看完整的颜色值。 一个网页的背景颜色是指在主体内的选择： 123body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式 文本排列属性是用来设置文本的水平对齐方式。 文本可居中或对齐到左或右,两端对齐. 当text-align设置为”justify”，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。 123h1 &#123;text-align:center;&#125;p.date &#123;text-align:right;&#125;p.main &#123;text-align:justify;&#125; 文本修饰 text-decoration 属性用来设置或删除文本的装饰。 从设计的角度看 text-decoration属性主要是用来删除链接的下划线： 1a &#123;text-decoration:none;&#125; 也可以这样装饰文字： 123h1 &#123;text-decoration:overline;&#125;h2 &#123;text-decoration:line-through;&#125;h3 &#123;text-decoration:underline;&#125; 文本转换 文本转换属性是用来指定在一个文本中的大写和小写字母。 可用于所有字句变成大写或小写字母，或每个单词的首字母大写。 123p.uppercase &#123;text-transform:uppercase;&#125;p.lowercase &#123;text-transform:lowercase;&#125;p.capitalize &#123;text-transform:capitalize;&#125; 文本缩进 文本缩进属性是用来指定文本的第一行的缩进。 1p &#123;text-indent:50px;&#125; 三、文字阴影 在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。语法： 1text-shadow: h-shadow v-shadow blur color; 1text-shadow: 5px 5px 6px rgba(0,0,0,.3)","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS文本格式属性","slug":"CSS文本格式属性","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%B1%9E%E6%80%A7/"},{"name":"CSS文本修饰","slug":"CSS文本修饰","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/"},{"name":"CSS文本对齐","slug":"CSS文本对齐","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS字体font","slug":"CSS字体font","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93font/"}]},{"title":"CSS配套工具","slug":"02 CSS 配套实用工具emmet，PS","date":"2024-08-17T02:28:01.281Z","updated":"2024-08-17T01:45:51.423Z","comments":true,"path":"2024/08/17/02 CSS 配套实用工具emmet，PS/","permalink":"https://xqc-1368.github.io/2024/08/17/02%20CSS%20%E9%85%8D%E5%A5%97%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7emmet%EF%BC%8CPS/","excerpt":"","text":"一、emmet语法1、简介​ Emmet语法的前身是Zen coding,它使用缩写,来提高html/css的编写速度, Vscode内部已经集成该语法。 作用： ​ 快速生成HTML结构语法 ​ 快速生成CSS样式语法 2、快速生成HTML结构语法 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成&lt;div&gt;&lt;/div&gt; 如果想要生成多个相同标签 加上 就可以了 比如 div3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 如果生成的div 类名是有顺序的， 可以用 自增符号 $ 如果想要在生成的标签内部写内容可以用 { } 表示 3、快速生成CSS样式语法CSS 基本采取简写形式即可 ​ 比如 w200 按tab 可以 生成 width: 200px; ​ 比如 lh26px 按tab 可以生成 line-height: 26px; 4、快速格式化代码Vscode 快速格式化代码: shift+alt+f 也可以设置 当我们 保存页面的时候自动格式化代码: 1）文件 ———.&gt;【首选项】—————&gt;【设置】； 2）搜索emmet.include; 3）在settings.json下的【工作区设置】中添加以下语句： ​ “editor.formatOnType”: true, ​ “editor.formatOnSave”: true 二、PS 基本操作​ 因为网页美工大部分效果图都是利用 PS（Photoshop）来做的，所以以后我们大部分切图工作都是在 PS 里面完成。 ​ 部分操作： 文件→打开 ：可以打开我们要测量的图片 Ctrl+R：可以打开标尺，或者 视图→标尺 右击标尺，把里面的单位改为像素 Ctrl+ 加号(+)可以放大视图， Ctrl+ 减号(-)可以缩小视图 按住空格键，鼠标可以变成小手，拖动 PS 视图 用选区拖动 可以测量大小 Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区 三、PS 切图1、图层切图1最简单的切图方式：右击图层 → 导出 → 切片。 2、切片切图2.1、利用切片选中图片 1利用切片工具手动划出 2.2、导出选中的图片 1文件菜单 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储 。 3、PS插件切图​ Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 官网：http://www.cutterman.cn/zh/cutterman 注意：Cutterman 插件要求你的 PS 必须是完整版，不能是绿色版，所以大家需要安装完整版本。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"emmet","slug":"emmet","permalink":"https://xqc-1368.github.io/tags/emmet/"},{"name":"PS","slug":"PS","permalink":"https://xqc-1368.github.io/tags/PS/"}]},{"title":"CSS简介","slug":"01 CSS 注释，三大特性，三种样式表","date":"2024-08-17T02:27:57.504Z","updated":"2024-08-17T02:32:33.313Z","comments":true,"path":"2024/08/17/01 CSS 注释，三大特性，三种样式表/","permalink":"https://xqc-1368.github.io/2024/08/17/01%20CSS%20%E6%B3%A8%E9%87%8A%EF%BC%8C%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E4%B8%89%E7%A7%8D%E6%A0%B7%E5%BC%8F%E8%A1%A8/","excerpt":"","text":"CSS (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS 文件扩展名为 .css。 一、CSS 注释注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它。 CSS注释以 / 开始, 以 / 结束, 实例如下: 12/*这是个注释*/ /*这是另一个注释*/ 二、css三大特性1、层叠性​ 相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题 ​ 层叠性原则: 样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 2、继承性​ CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。 子元素可以继承父元素的样式： ​ （text-，font-，line-这些元素开头的可以继承，以及color属性） 继承性口诀：龙生龙，凤生凤，老鼠生的孩子会打洞 行高的继承性： 123body &#123; font:12px/1.5 Microsoft YaHei；&#125; 行高可以跟单位也可以不跟单位 如果子元素没有设置行高，则会继承父元素的行高为 1.5 此时子元素的行高是：当前子元素的文字大小 * 1.5 body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高 3、优先级当同一个元素指定多个选择器，就会有优先级的产生。 选择器相同，则执行层叠性 选择器不同，则根据选择器权重执行 选择器优先级计算表格： 优先级注意点: 权重是有4组数字组成,但是不会有进位。 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推.. 等级判断从左向右，如果某一位数值相同，则判断下一位数值。 可以简单记忆法: 通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。 a链接浏览器默认制定了一个样式：蓝色下划线 a &#123;color:blue;&#125;因此需要手动指定样式权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。 权重虽然可以叠加，但是不存在进位 div ul li ———&gt; 0,0,0,3 .nav ul li ———&gt; 0,0,1,2 a:hover ——-—&gt; 0,0,1,1 .nav a ———&gt; 0,0,1,1 案例1：继承权重为0 案例2：权重叠加 三、CSS 三种样式表当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。 如何插入样式表？ 插入样式表的方法有三种: 外部样式表(External style sheet) 内部样式表(Internal style sheet) 内联样式(Inline style) 外部样式表 当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 标签链接到样式表。 标签在（文档的）头部： 1234&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;/*href后面跟css文件路径*/&lt;/head&gt; 内部样式表 当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 1234567&lt;head&gt;&lt;style&gt;hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125;&lt;/style&gt;&lt;/head&gt; 内联样式（行内样式） 由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。 要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距： 1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS注释","slug":"CSS注释","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B3%A8%E9%87%8A/"},{"name":"CSS的插入","slug":"CSS的插入","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9A%84%E6%8F%92%E5%85%A5/"},{"name":"CSS优先级问题","slug":"CSS优先级问题","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"}]},{"title":"CSS杂项","slug":"10 CSS杂项","date":"2024-08-17T02:27:56.205Z","updated":"2024-08-17T02:27:36.920Z","comments":true,"path":"2024/08/17/10 CSS杂项/","permalink":"https://xqc-1368.github.io/2024/08/17/10%20CSS%E6%9D%82%E9%A1%B9/","excerpt":"","text":"CSS杂项 学习目标： ​ 能够使用精灵图 ​ 能够使用字体图标 ​ 能够写出 CSS 三角 ​ 能够写出常见的 CSS 用户界面样式 ​ 能够说出常见的布局技巧 1. 精灵图（重点）1.1 为什么需要精灵图一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。 为什么使用精灵图（目的）： ​ 为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。 核心原理： ​ 将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。 精灵图举例: 1.2 精灵图（sprites）的使用使用精灵图核心： 精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。 这个大图片也称为 sprites 精灵图 或者 雪碧图 移动背景图片位置， 此时可以使用 background-position 。 移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同 因为一般情况下都是往上往左移动，所以数值是负值。 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。 使用精灵图核心总结： 精灵图主要针对于小的背景图片使用。 主要借助于背景位置来实现—-background-position 。 一般情况下精灵图都是负值。（千万注意网页中的坐标： x轴右边走是正值，左边走是负值， y轴同理。） 1.3 案例：拼出自己名字1.3.1 案例效果 1.3.2 代码参考结构 1234&lt;span class=&quot;p&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;i&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;k&lt;/span&gt; 样式 12345678910111213141516171819202122232425262728span &#123; display: inline-block; background: url(images/abcd.jpg) no-repeat;&#125;.p &#123; width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px;&#125;.i &#123; width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px;&#125;.n &#123; width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px;&#125;.k &#123; width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px;&#125; 2. 字体图标2.1 字体图标的产生字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标。 精灵图是有诸多优点的，但是缺点很明显。 1.图片文件还是比较大的。 2.图片本身放大和缩小会失真。 3.一旦图片制作完毕想要更换非常复杂。 此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。 字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。 2.2 字体图标的优点轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器，请放心使用 注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。 总结： 1.如果遇到一些结构和样式比较简单的小图标，就用字体图标。 2.如果遇到一些结构和样式复杂一点的小图片，就用精灵图。 使用步骤 字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为： 1.字体图标的下载 2.字体图标的引入 （引入到我们html页面中） 3.字体图标的追加 （以后添加新的小图标） 2.3 字体图标的下载推荐下载网站： icomoon 字库 http://icomoon.io 推荐指数 ★★★★★ IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 阿里 iconfont 字库 http://www.iconfont.cn/ 推荐指数 ★★★★★ 这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 AI制作图标上传生成。 重点是，免费！ 2.4 字体图标的引入下载完毕之后，注意原先的文件不要删，后面会用。 把下载包里面的 fonts 文件夹放入页面根目录下 字体文件格式 不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。 1).TureType( .ttf )格式.ttf字体是Windows和Mac的最常见的字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+； 2).Web Open Font Format( .woff )格式woff字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+； 3).Embedded Open Type( .eot )格式.eot字体是IE专用字体，支持这种字体的浏览器有IE4+； 4).SVG( .svg )格式.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+； 2.在 CSS 样式中全局声明字体： 简单理解把这些字体文件通过css引入到我们页面中。 一定注意字体文件路径的问题 复制过来： 12345678910@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?7kkyc2&#x27;); src: url(&#x27;fonts/icomoon.eot?7kkyc2#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?7kkyc2&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?7kkyc2&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?7kkyc2#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal;&#125; html 标签内添加小图标。 给标签定义字体。 123span &#123; font-family: &quot;icomoon&quot;;&#125; 甚至可以改变颜色： 注意：务必保证 这个字体和上面@font-face里面的字体保持一致 2.5 字体图标的追加如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。 把压缩包里面的 selection.json 从新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。 2.6 字体图标加载的原理： 3. CSS 三角3.1 介绍网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标。 一张图， 你就知道 CSS 三角是怎么来的了, 做法如下： 123456789div &#123; width: 0; height: 0; border: 50px solid transparent; border-color: red green blue black;/*以下两句话为了照顾兼容性而写*/ line-height:0; font-size: 0;&#125; 我们用css 边框可以模拟三角效果 宽度高度为0 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了 为了照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0; 3.2 案例：京东三角3.2.1效果图 3.2.2 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS 三角制作&lt;/title&gt; &lt;style&gt; .box1 &#123; width: 0; height: 0; /* border: 10px solid pink; */ border-top: 10px solid pink; border-right: 10px solid red; border-bottom: 10px solid blue; border-left: 10px solid green; &#125; .box2 &#123; width: 0; height: 0; border: 50px solid transparent; border-left-color: pink; margin: 100px auto; &#125; .jd &#123; position: relative; width: 120px; height: 249px; background-color: pink; &#125; .jd span &#123; position: absolute; right: 15px; top: -10px; width: 0; height: 0; /* 为了照顾兼容性 */ line-height: 0; font-size: 0; border: 5px solid transparent; border-bottom-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;jd&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. CSS 用户界面样式什么是界面样式 所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓 防止表单域拖拽 4.1 鼠标样式 cursor123li &#123; cursor: pointer; &#125; 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 4.2 轮廓线 outline给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。 123input &#123; outline: none; &#125; 4.3 防止拖拽文本域 resize 实际开发中，我们文本域右下角是不可以拖拽的。(文本域尽量把两个textarea标签，放到一行书写，不然会出现莫名空格) 123textarea&#123; resize: none;&#125; vertical-align 属性应用 5. vertical-align 属性应用CSS 的 vertical-align 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 官方解释： 用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。（如果是块元素应该先转换为行内块元素） 语法：图文中线对齐，在图的样式中加： 1vertical-align : baseline | top | middle | bottom 5.1 图片、表单和文字对齐图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。 此时可以给图片、表单这些行内块元素的 vertical-align 属性设置为 middle 就可以让文字和图片垂直居中对齐了。 5.2 解决图片底部默认空白缝隙问题bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。 主要解决方法有两种： 1.给图片添加 vertical-align:middle | top| bottom 等。 （提倡使用的） 2.把图片转换为块级元素 display: block; 6. 溢出的文字省略号显示6.1 单行文本溢出显示省略号 单行文本溢出显示省略号—必须满足三个条件： 12345678/*1. 先强制一行内显示文本*/ white-space: nowrap; （ 默认 normal 自动换行）/*2. 超出的部分隐藏*/ overflow: hidden;/*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; 6.2 多行文本溢出显示省略号（了解） 多行文本溢出显示省略号，有较大兼容性问题，适合于webKit浏览器或移动端（移动端大部分是webkit内核） 1234567891011121314/*1. 超出的部分隐藏 */overflow: hidden;/*2. 文字用省略号替代超出的部分 */text-overflow: ellipsis;/* 3. 弹性伸缩盒子模型显示 */display: -webkit-box;/* 4. 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。 7. 常见布局技巧巧妙利用一个技术更快更好的布局： margin负值的运用 文字围绕浮动元素 行内块的巧妙运用 CSS三角强化 7.1. margin负值运用 1.让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框 2.鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index） 7.2 文字围绕浮动元素效果 布局示意图 巧妙运用浮动元素不会压住文字的特性 7.3 行内块巧妙运用 页码在页面中间显示: 把这些链接盒子转换为行内块， 之后给父级指定 text-align:center; 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中 7.4. CSS 三角强化 案例7.4.1 原理 12345678910111213141516171819202122232425&lt;style&gt; .box1 &#123; width: 0; height: 0; /* 把上边框宽度调大 */ /* border-top: 100px solid transparent; border-right: 50px solid skyblue; */ /* 左边和下边的边框宽度设置为0 */ /* border-bottom: 0 solid blue; border-left: 0 solid green; */ /* 1.只保留右边的边框有颜色 */ border-color: transparent red transparent transparent; /* 2. 样式都是solid */ border-style: solid; /* 3. 上边框宽度要大， 右边框 宽度稍小， 其余的边框该为 0 */ border-width: 100px 50px 0 0 ; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt; 7.4.2 案例效果 7.4.3 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS三角强化的巧妙运用&lt;/title&gt; &lt;style&gt; .price &#123; width: 160px; height: 24px; line-height: 24px; border: 1px solid red; margin: 0 auto; &#125; .miaosha &#123; position: relative; float: left; width: 90px; height: 100%; background-color:red; text-align: center; color: #fff; font-weight: 700; margin-right: 8px; &#125; .miaosha i &#123; position: absolute; right: 0; top: 0; width: 0; height: 0; border-color: transparent #fff transparent transparent; border-style: solid; border-width: 24px 10px 0 0; &#125; .origin &#123; font-size: 12px; color: gray; text-decoration: line-through; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;price&quot;&gt; &lt;span class=&quot;miaosha&quot;&gt; ¥1650 &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 8. CSS 初始化不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS 初始化 简单理解： CSS初始化是指重设浏览器的样式。 (也称为CSS reset） 每个网页都必须首先进行 CSS初始化。 这里我们以 京东CSS初始化代码为例。 Unicode编码字体： 把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。 比如： 黑体 \\9ED1\\4F53宋体 \\5B8B\\4F53微软雅黑 \\5FAE\\8F6F\\96C5\\9ED1","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS精灵图","slug":"CSS精灵图","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS字体图标","slug":"CSS字体图标","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"},{"name":"CSS三角绘制","slug":"CSS三角绘制","permalink":"https://xqc-1368.github.io/tags/CSS%E4%B8%89%E8%A7%92%E7%BB%98%E5%88%B6/"}]},{"title":"HTML列表","slug":"05 HTML 列表 list","date":"2024-08-16T14:35:51.896Z","updated":"2024-08-16T14:35:38.344Z","comments":true,"path":"2024/08/16/05 HTML 列表 list/","permalink":"https://xqc-1368.github.io/2024/08/16/05%20HTML%20%E5%88%97%E8%A1%A8%20list/","excerpt":"","text":"列表表格是用来显示数据的，那么列表就是用来布局的。 表格是用来显示数据的，那么列表就是用来布局的。列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。 无序：​&lt;ul&gt; 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 &lt;li&gt; 标签定义。无序列表的基本语法格式如下： 12345&lt;ul&gt;&lt;li&gt;列表项1&lt;/li&gt;&lt;li&gt;列表项2&lt;/li&gt;&lt;li&gt;列表项3&lt;/li&gt;...&lt;/ul&gt; &lt;/ul&gt; 无序列表的各个列表项之间没有顺序级别之分，是并列的。 &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。 有序：​ 有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，&lt;ol&gt; 标签用于定义有序列表，列表排序以数字来显示，并且使用 标签来定义列表项。有序列表的基本语法格式如下： 1234567&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ... &lt;/ol&gt; &lt;ol&gt;&lt;/ol&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ol&gt;&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。 自定义：自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，&lt;dl&gt; 标签用于定义描述列表（或定义列表），该标签会与 &lt;dt&gt;（定义项目/名字）和 &lt;dd&gt;（描述每一个项目/名字）一起使用。语法如下： 12345&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 列表总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML列表","slug":"HTML列表","permalink":"https://xqc-1368.github.io/tags/HTML%E5%88%97%E8%A1%A8/"}]},{"title":"HTML表格","slug":"04 HTML 表格 table","date":"2024-08-16T14:34:44.300Z","updated":"2024-08-16T14:34:30.647Z","comments":true,"path":"2024/08/16/04 HTML 表格 table/","permalink":"https://xqc-1368.github.io/2024/08/16/04%20HTML%20%E8%A1%A8%E6%A0%BC%20table/","excerpt":"","text":"表格表格的主要作用1.表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理 2.表格不是用来布局页面的,而是用来展示数据的。 3.表格的具体用法： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ... &lt;/table&gt; 1. 是用于定义表格的标签。2. 标签用于定义表格中的行，必须嵌套在 标签中。3. 用于定义表格中的单元格，必须嵌套在标签中。4.字母 td 指表格数据（table data），即数据单元格的内容。 表头单元格标签：4.表头标签的具体实现： 12345&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; ... &lt;/tr&gt; ... &lt;/table&gt; (1).一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示. 标签表示 HTML 表格的表头部分(table head 的缩写)(2)一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示. 标签表示 HTML 表格的表头部分(table head 的缩写) 5.表头单元格也是单元格，常用于表格第一行突出重要性，表头单元格里面的文字会加粗居中 表格属性：1.表格标签这部分属性我们实际开发我们不常用，后面通过 CSS 来设置. ​ ​ 思路： 先制作表格的结构. 1.第一行里面是 th 表头单元格 2.第二行开始里面是 td 普通单元格单元格里面可以放任何元素 3.文字链接图片等都可以 后书写表格属性 1.用到宽度高度边框cellpadding 和 cellspacing 2.表格浏览器中对齐 align 表格结构标签：使用场景: 因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分. 在表格标签中，分别用：标签 表格的头部区域、标签 表格的主体区域. 这样可以更好的分清表格结构。 总结: 1. &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。&lt;thead&gt; 内部必须拥有 &lt;tr&gt; 标签。 一般是位于第一行。 2. &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体，主要用于放数据本体 。 3. 以上标签都是放在`&lt;table&gt;&lt;/table&gt;` 标签中。 合并单元格：特殊情况下,可以把多个单元格合并为一个单元格1.合并单元格方式2.目标单元格3.合并单元格的步骤如下图： 合并单元格方式： 跨行合并：rowspan=”合并单元格的个数” ​ 最上侧单元格为目标单元格, 写合并代码 跨列合并：colspan=”合并单元格的个数” ​ 最左侧单元格为目标单元格, 写合并代码 比如：。删除多余的单元格。 表格总结 ​ 表格学习整体可以分为三大部分: 表格的相关标签 ​ table thead body tr th td 表格的相关属性 ​ cellspacing cellpadding width height border 合并单元格 ​ rowspan collspan","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML表格","slug":"HTML表格","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E6%A0%BC/"}]},{"title":"HTML表单","slug":"03 HTML 表单 form","date":"2024-08-16T14:32:38.946Z","updated":"2024-08-16T14:47:39.876Z","comments":true,"path":"2024/08/16/03 HTML 表单 form/","permalink":"https://xqc-1368.github.io/2024/08/16/03%20HTML%20%E8%A1%A8%E5%8D%95%20form/","excerpt":"","text":"表单表单的组成： 在 HTML 中，一个完整的表单通常由表单域、表单控件（也称为表单元素）和 提示信息3个部分构成。 表单域：表单域是一个包含表单元素的区域。在 HTML 标签中， &lt;form&gt;标签用于定义表单域，以实现用户信息的收集和传递。&lt;form&gt;会把它范围内的表单元素信息提交给服务器. 实现代码： 123&lt;form action=“url地址” method=“提交方式” name=“表单域名称&quot;&gt;各种表单元素控件&lt;/form&gt;` 表单域的常用属性： 表单控件(表单元素)&lt;input&gt; 表单元素 在英文单词中，input 是输入的意思，而在表单元素中 &lt;input&gt; 标签用于收集用户信息。在 &lt;input&gt; 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。 1&lt;input type=&quot;属性值&quot; /&gt; 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型 type 属性的属性值及其描述如下： 除 type 属性外，&lt;input&gt;标签还有其他很多属性，其常用属性如下： &lt;label&gt; 标签&lt;label&gt;标签为 input 元素定义标注（标签）。&lt;label&gt;标签用于绑定一个表单元素, 当点击&lt;label&gt; 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.语法： 12&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; 核心： 标签的 for 属性应当与相关元素的 id 属性相同。 &lt;select&gt; 表单元素使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用&lt;select&gt;标签控件定义下拉列表。 语法： 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ... &lt;/select&gt; &lt;textarea&gt; 表单元素 使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 &lt;textarea&gt; 标签。 在表单元素中，&lt;textarea&gt; 标签是用于定义多行文本输入的控件。 使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。 语法： &lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt; 文本内容 &lt;/textarea&gt; 通过 &lt;textarea&gt; 标签可以轻松地创建多行文本输入框。cols=“每行中的字符数” ，rows=“显示的行数”， 我们在实际开发中不会使用，都是用 CSS 来改变大小。 表单元素我们学习了三大组 input 输入表单元素 select 下拉表单元素 textarea 文本域表单元素.这三组表单元素都应该包含在form表单域里面,并且有 name 属性. 有三个名字非常相似的标签: 表单域 form 使用场景: 提交区域内表单元素给后台服务器 文件域 file 是input type 属性值 使用场景: 上传文件 文本域 textarea 使用场景: 可以输入多行文字, 比如留言板 网站介绍等… 我们当前阶段不需要提交表单元素,所以我们只负责表单元素的外观形态即可.","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML表单","slug":"HTML表单","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E5%8D%95/"}]},{"title":"HTML标签","slug":"02 HTML 标签 tag","date":"2024-08-16T11:40:19.107Z","updated":"2024-08-16T12:46:56.248Z","comments":true,"path":"2024/08/16/02 HTML 标签 tag/","permalink":"https://xqc-1368.github.io/2024/08/16/02%20HTML%20%E6%A0%87%E7%AD%BE%20tag/","excerpt":"","text":"一、HTML标签1.HTML语法规则：1.HTML 标签是由尖括号包围的关键词，例如 &lt;html&gt;。2.HTML 标签通常是成对出现的，例如 &lt;html&gt; 和 &lt;/html&gt; ，我们称为双标签。3.签:标签对中的第一个标签是开始标签，第二个标签是结束标签。 有些特殊的标签必须是单个标签（极少情况），例如&lt;br /&gt;，我们称为单标签。 2. 标签的关系：双标签关系可以分为两类：包含关系和并列关系包含标签 123456&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写 (1) 骨架构建快捷键 VSCode生成页面骨架结构： 输入! 按下 Tab 键。 利用插件在浏览器中预览页面：单击鼠标右键，在弹出窗口中点击“Open In Default Browser”。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;hello world&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;hello world!!!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (2) DOCTYPE &lt;!DOCTYPE html&gt; 文档类型声明标签,告诉浏览器这个页面采取html5版本来显示页面. (3) lang 语言种类用来定义当前文档显示的语言。 en定义语言为英语 zh-CN定义语言为中文简单来说,定义为en 就是英文网页, 定义为 zh-CN 就是中文网页其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文 这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的 (4) 字符集1.字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。2.在&lt;head&gt;标签内，可以通过&lt;meta&gt; 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码。3.&lt;meta charset=&quot; UTF-8&quot; /&gt;4.charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符.5.注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 &quot;UTF-8&quot;，不要写成 &quot;utf8&quot; 或 &quot;UTF8&quot;。 (5) 语义化标签学习标签是有技巧的，重点是记住每个标签的语义。简单理解就是指标签的含义，即这个标签是用来干嘛的。 根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。 [1] 标签 &lt;h1&gt; - &lt;h6&gt;HTML 提供了 6 个等级的网页标题，即&lt;h1&gt; - &lt;h6&gt;。 具体实现： 1&lt;h1&gt; 我是一级标题 &lt;/h1&gt; [2] 段落标签在 HTML 标签中，标签用于定义段落，它可以将整个网页分为若干个段落。具体实现： 1&lt;p&gt; 我是一个段落标签 &lt;/p&gt; [3] 换行标签如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br /&gt;。具体实现： 1&lt;br /&gt; [4] 文本格式化标签：在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。 语义 标签 加粗 &lt; strong &gt;&lt; /strong &gt;或者&lt; b&gt;&lt; /b &gt; 倾斜 &lt; em &gt;&lt; /em &gt;或者&lt; i &gt;&lt; /i &gt; 删除线 &lt; del &gt;&lt; /del &gt;或者&lt; s &gt;&lt; /s &gt; 下划线 &lt; ins &gt;&lt; /ins &gt;或者&lt; u &gt;&lt; /u &gt; [5] div和span标签&lt;div&gt; 和 &lt;span&gt; 是没有语义的，它们就是一个盒子，用来装内容的。具体实现： 12&lt;div&gt; 这是头部 &lt;/div&gt;&lt;span&gt; 今日价格 &lt;/span&gt; [6]图片标签在 HTML 标签中，&lt;img&gt;标签用于定义 HTML 页面中的图像。具体实现： 1&lt;img src=&quot;smiley-2.gif&quot; alt=&quot;Smiley face&quot; width=&quot;42&quot; height=&quot;42&quot;&gt; 解释： src 是标签的必须属性，它用于指定图像文件的路径和文件名。 属性 形式 功能 src URL 规定显示图像的 URL。 width pixels 规定图像的宽度 height pixels 规定图像的高度 alt text 规定图像的替代文本 图像标签的其他属性： 图像标签注意点：1.图像标签可以拥有多个属性，必须写在标签名的后面。2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。3.属性采取键值对的格式，即 key=“value” 的格式，属性 =“属性值”。 分为相对路径和绝对路径： (6)链接标签：链接的语法格式 1&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt; 文本或图像 &lt;/a&gt; 1.href：用于指定链接目标的url地址2.target:用于指定链接页面的打开方式：_self默认值 _blank新窗口打开3.#：空链接 在链接文本的 href 属性中，设置属性值为 #名字 的形式，如 &lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt; 找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如： &lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt; (7) 注释如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字具体实现： 1&lt;!-- 注释语句 --&gt; 快捷键: ctrl + / 一句话: 注释标签里面的内容是给程序猿看的, 这个代码是不执行不显示到页面中的.添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的 (8) 特殊字符在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。重点记住：空格 、大于号、 小于号 这三个， 其余的使用很少，如果需要回头查阅即可。 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;nbsp; 空格","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML注释","slug":"HTML注释","permalink":"https://xqc-1368.github.io/tags/HTML%E6%B3%A8%E9%87%8A/"},{"name":"HTML特殊字符","slug":"HTML特殊字符","permalink":"https://xqc-1368.github.io/tags/HTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"}]},{"title":"HTML语言简介","slug":"01 HTML 简介","date":"2024-08-16T11:33:16.683Z","updated":"2024-08-16T11:32:36.314Z","comments":true,"path":"2024/08/16/01 HTML 简介/","permalink":"https://xqc-1368.github.io/2024/08/16/01%20HTML%20%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、网页开发网页的相关概念1. 什么是网页： 1.网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 2.网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。 2. 网页的组成： 1.网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。 2.HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。 3. 网页的总结： 1.网页是图片、链接、文字、声音、视频等元素组成, 其实就是一个html文件(后缀名为html) 2.网页生成制作: 有前端人员书写 HTML 文件, 然后浏览器打开,就能看到了网页. 3.HTML: 超文本标记语言, 用来制作网页的一门语言. 有标签组成的. 比如 图片标签 链接标签 视频标签等… 4. 浏览器：浏览器内核（渲染引擎） 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面 目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。 5. web标准：Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。 6. 为什么需要Web标准：浏览器不同，它们显示页面或者排版就有些许差异遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 1.让 Web 的发展前景更广阔。 2.内容能被更广泛的设备访问。 3.更容易被搜寻引擎搜索。 4.降低网站流量费用。 5.使网站更易于维护。 6.提高页面浏览速度。 7. web标准的构成： 主要包括 《结构Structure》 、《表现（Presentation）》和《行为（Behavior）》三个方面。 Web 标准提出的最佳体验方案：结构、样式、行为相分离。简单理解：结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中 1.结构类似身体 2.表现类似外观装饰 3.行为类似行为动作 4.相比较而言, 三者中结构最重要. 二、查阅文档：经常查阅文档是一个非常好的学习习惯。推荐的网址：百度: http://www.baidu.comW3C : http://www.w3school.com.cn/MDN: https://developer.mozilla.org/zh-CN/","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"web标准","slug":"web标准","permalink":"https://xqc-1368.github.io/tags/web%E6%A0%87%E5%87%86/"}]},{"title":"浏览器生成信息","slug":"01 浏览器生成信息","date":"2024-08-16T03:21:02.986Z","updated":"2024-08-16T09:31:49.788Z","comments":true,"path":"2024/08/16/01 浏览器生成信息/","permalink":"https://xqc-1368.github.io/2024/08/16/01%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E4%BF%A1%E6%81%AF/","excerpt":"","text":"关键词：浏览器，Web服务器，网址（URL），HTTP，HTML，协议，URI，请求消息，解析器，Socket库，DNS服务器，域名 浏览器的具体工作步骤是： 解析URL（注意这个“解析”跟解析器没有关系） 生成HTTP请求消息 向DNS服务器查询域名对应的ip地址 委托操作系统内部的协议栈将消息发送给Web服务器，按照指定的顺序来调用Socket库中的程序组件。 一、输入URL，浏览器解析网址1、统一资源定位器 URL 浏览器：具备多种客户端功能的综合性客户端软件 FTP：文件传输协议 域名：像www.glasscom.com这样用句点（.）分隔的名称 URL：统一资源定位器 功能：不同的头，可以用以判断使用哪种功能。访问Web服务器的时候，用“http”，访问FTP服务器的时候用“ftp:“ 格式：协议（http:，ftp:，file:，mailto:，）//服务器名称+数据源路径 Web服务器和FTP服务器： 用http协议访问Web服务器：http://用户名(可省略):密码(可省略)@Web服务器域名:端口号(可省略)/文件的路径名 1http://user:password@www.glasscom.com:80/dir/file.html 用FTP协议下载和上传文件：ftp://用户名(可省略):密码(可省略)@FTP服务器域名:端口号(可省略)/文件的路径名 1ftp://user:password@ftp.glasscom.com:21/dir/file/html 服务器读取客户端本地文件：file://计算机名(可省略)/文件路径名 1file://localhost/c:/path/file1.zip 发送邮件的URL：邮件地址 1mailto:tone@glasscom.com 省略文件名情况： 比如http://www.lab.glasscom.com/dir/预先在dir文件夹下设置省略时访问的默认文件名，一般是index.html或者default.html，遇到这种情况直接访问默认页面 2、浏览器解析HTTP协议的URL HTTP协议 功能：定义了客户端和服务器之间的交互 请求信息包括：”对什么“（URI，统一资源标识符）+“进行怎样的操作”（访问方法，包括GET方法，POST方法等） URI：访问的各种目标，可以是一个网页数据文件名（html文件），也可以是一个CGI程序（Web服务器调用其他的程序） GET方法：URI指定的是文件返回文件；URI指定的是CGI程序，返回输出结果 POST方法：向服务器发送数据，此时URI一般指向一个应用程序的文件名 HEAD方法：用于获取文件最后更新时间 注：超链接主要是GET方法，表单有POST也有GET 返回消息是状态码 二、生成HTTP请求消息HTTP消息 请求消息 请求行（方法 URI HTTP版本）+消息头（请求附加信息）+消息体（POST方法消息体内有表单数据） 响应消息 状态行（HTTP 状态码 响应短语）＋消息头+消息体（从文件中读取的数据orCGI程序的输出数据） 状态码和响应短语表示内容一致，用途不同，状态码是一个数字，用来像程序告知执行结果；响应短语是文字，向人们告知执行结果。 每条请求消息只能写一个URI，所以最多只能获取一个文件。当网页包含图片时，会在网页相应位置嵌入图片标签，屏幕上会预留显示图片的空间，然后再次访问Web服务器请求图片。 所以，一个网页包含3张图片，一共要向Web服务器发送4条请求 三、向DNS服务器发起 查询 Web服务器的IP地址 请求1、IP地址需求：在委托操作系统发送消息时，需要提供通信对象的IP地址。所以需要根据域名查询IP地址。（如果Web服务器采用了虚拟主机功能，可能无法通过IP地址访问） 局域网是基于TCP/IP结构设计的，小的子网通过路由器组成一个大的网络 IP地址（一共32bit） 定义：网络号+主机号（xx栋+xx室） 子网掩码：与IP地址等长，左半边全是1，右半边全是0，用以区分网络号和主机号 例如：10.11.12.13/255.255.255.0表示网络号是10.11.12，主机号是13 若为10.11.12.13/24，则表示子网掩码前24位为1 特殊情况：主机号比特全为0，表示代表整个子网。主机号比特全为1，表示对整个子网每个主机进行广播 2、Socket库提供查询功能，解析器向DNS服务器发起查询 Socket库：可以让其他应用程序调用操作系统网络功能的库。 解析器（DNS解析器，DNS客户端）：是一段程序，包含在Socket库中，通过DNS查询IP地址的操作是 域名解析 解析器工作过程：一行代码内存地址=gethostbyname(&#39;域名&#39;) 解析器工作的内部原理： 1.当网络应用程序（浏览器）调用解析器时，程序的控制流程就会转移（原程序暂停，被调用的程序运行）到解析器内 2.解析器会生成发送给DNS服务器的查询消息，这个过程与生成要发送给Web服务器的HTTP请求类似。 3.之后委托给操作系统内部的协议栈来执行发送功能，协议栈执行发送消息操作网卡将消息发送给DNS服务器。 4.之后按照上述相反的过程层层返回 注意：与发送其他消息不同的是，我们的终端预先已知DNS服务器的IP地址，不需要再去查询 四、DNS查询到 Web服务器地址 的过程 DNS服务器的功能： 接收来自客户端的查询消息，然后根据消息内容返回IP地址。 解析器（DNS终端）向DNS服务器发送的查询消息包括： 域名（服务器名称，邮件服务器名称（即邮件地址中@之后的部分，不是邮件服务器的域名）） Class（始终为IN） 记录类型（A对应记录得到的是IP地址，MX对应记录得到的是邮件服务器） 注：当记录类型为MX时，DNS服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级。DNS服务器再次在自己内部用邮件服务器的域名搜索，可以找到邮件服务器的IP地址。 域名的层次结构 域名：越靠右表示层级越高 比如www.lab.glasscom.com表示：com集团，glasscom部，lab科，的www。 子域：下级域 建树：下级域的DNS服务器IP地址要注册到上级域的DNS服务器上 根域：其实域名应该是www.lab.glasscom.com.最后有一个点，表示注册在根域之下，不过根域一般省略。但是根域DNS服务器注册在互联网所有DNS服务器上。 工作原理：客户端访问最近的一台DNS服务器，该服务器经过以下反复找寻环节后可以响应解析器的查询消息。（注意：反复找寻的操作是第一个DNS服务器干的活） 实际的访问过程： 上级域和下级域共享一个DNS服务器，常有跳过一级查询 DNS服务器有缓存功能，若已缓存则直接返回，缓存有有效期 五、委托协议栈发送消息收发数据：TCP协议、UDP协议。 TCP协议收发数据过程（由协议栈执行）： （1）创建套接字（创建套接字阶段） （2）将管道连接到服务器端的套接字上（连接阶段） （3）收发数据（通信阶段） （4）断开管道并删除套接字（断开阶段） 套接字：数据通信管道两端的数据出入口 创建套接字： 管道在连接是由客户端发起的，在断开是由服务器or客户端任意一方发起 调用socket：创建套接字，返回描述符，放到指定内存中。 描述符：用来识别不同的套接字的标识符 连接阶段： 调用connect组件，需要： 描述符 IP地址 端口号：当同时指定IP地址和端口号时，就可以识别出某台具体计算机上的套接字 注：在创建套接字时，协议栈会为这个套接字分配一个端口号；在执行连接操作时，会将这个随便分配的端口号通知服务器。 描述符和端口号的区别 描述符：用来在一台计算机内部识别套接字的机制 端口号：让通信的另一方能够识别出套接字的机制。预先约定：Web是80号端口，电子邮件是25端口。 通信阶段 调用write，需要： 描述符 发送的数据 调用read，需要： 指定接收到的内存地址：接收缓冲区（位于应用程序的内存空间） 断开操作 HTTP要求Web服务器先断开，HTTP1.1（能在一次连接中收发多个请求和响应）要求浏览器先断开","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xqc-1368.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Web服务器","slug":"Web服务器","permalink":"https://xqc-1368.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"DNS服务器","slug":"DNS服务器","permalink":"https://xqc-1368.github.io/tags/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://xqc-1368.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"URL","slug":"URL","permalink":"https://xqc-1368.github.io/tags/URL/"},{"name":"URI","slug":"URI","permalink":"https://xqc-1368.github.io/tags/URI/"},{"name":"请求消息","slug":"请求消息","permalink":"https://xqc-1368.github.io/tags/%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/"},{"name":"域名","slug":"域名","permalink":"https://xqc-1368.github.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"Socket库","slug":"Socket库","permalink":"https://xqc-1368.github.io/tags/Socket%E5%BA%93/"},{"name":"解析器","slug":"解析器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A3%E6%9E%90%E5%99%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-08-16T02:59:19.785Z","updated":"2024-08-16T02:59:19.904Z","comments":true,"path":"2024/08/16/hello-world/","permalink":"https://xqc-1368.github.io/2024/08/16/hello-world/","excerpt":"","text":"本博客所有文章除特别声明外，均采用Hexo)制作。 这是题名为HelloWorld的主页。文件信息来源于documentation。如果遇到问题，也许可以在troubleshooting上找到答案。 快速开始创建新帖系统会自动在 scaffolds 文件夹中搜寻名为 My New Post 的文件，根据其中的内容生成新的.md 文章文件。 1$ hexo new &quot;My New Post&quot; 更多信息: Writing 启动服务器启动本地服务器，用于预览主题 1$ hexo server 或者 1$ hexo s 更多信息: 服务器 生成静态文件在发布之前，需要先生成静态文件 生成网站静态文件到默认设置的 public 文件夹 1$ hexo generate 或者 1$ hexo g 更多信息: 启动 部署到服务器将文件部署到服务器上 1$ hexo deploy 或者 1$ hexo d 更多信息: 部署 清除文件清除缓存文件 (db.json) 和已生成的静态文件 (public) 1$ hexo clean","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/categories/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/categories/%E7%B4%A0%E6%95%B0/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"算法/数据结构/栈","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"算法/动态规划/数位DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"环形DP的四边形不等式优化","slug":"算法/动态规划/环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"},{"name":"多重背包DP的二进制优化","slug":"算法/动态规划/多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"树形DP","slug":"算法/动态规划/树形DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"},{"name":"DP的单调队列优化","slug":"算法/动态规划/DP的单调队列优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"},{"name":"状压DP","slug":"算法/动态规划/状压DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"},{"name":"区域DP","slug":"算法/动态规划/区域DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9FDP/"},{"name":"背包DP","slug":"算法/动态规划/背包DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"},{"name":"期望DP","slug":"算法/动态规划/期望DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"},{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://xqc-1368.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"生成树","slug":"生成树","permalink":"https://xqc-1368.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"kruskal算法","slug":"kruskal算法","permalink":"https://xqc-1368.github.io/tags/kruskal%E7%AE%97%E6%B3%95/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://xqc-1368.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"name":"扩展欧拉定理","slug":"扩展欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"威尔逊定理","slug":"威尔逊定理","permalink":"https://xqc-1368.github.io/tags/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"拓展欧几里得定理","slug":"拓展欧几里得定理","permalink":"https://xqc-1368.github.io/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/"},{"name":"裴蜀定理","slug":"裴蜀定理","permalink":"https://xqc-1368.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"},{"name":"最大公约数gcd","slug":"最大公约数gcd","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0gcd/"},{"name":"最小公倍数lcm","slug":"最小公倍数lcm","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm/"},{"name":"辗转相除法","slug":"辗转相除法","permalink":"https://xqc-1368.github.io/tags/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/tags/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"素数判定","slug":"素数判定","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A/"},{"name":"Miller-Rabin素性检验","slug":"Miller-Rabin素性检验","permalink":"https://xqc-1368.github.io/tags/Miller-Rabin%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/"},{"name":"Pollard-Rho","slug":"Pollard-Rho","permalink":"https://xqc-1368.github.io/tags/Pollard-Rho/"},{"name":"埃氏筛法","slug":"埃氏筛法","permalink":"https://xqc-1368.github.io/tags/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/"},{"name":"线性筛法（欧拉筛法）","slug":"线性筛法（欧拉筛法）","permalink":"https://xqc-1368.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%EF%BC%88%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%89/"},{"name":"快速乘","slug":"快速乘","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/"},{"name":"快速幂","slug":"快速幂","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"差分","slug":"差分","permalink":"https://xqc-1368.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://xqc-1368.github.io/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://xqc-1368.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://xqc-1368.github.io/tags/BFS/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"},{"name":"树上距离","slug":"树上距离","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E8%B7%9D%E7%A6%BB/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树的深度","slug":"树的深度","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"},{"name":"树形dp","slug":"树形dp","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"树的直径","slug":"树的直径","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"树的重心","slug":"树的重心","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"换根dp","slug":"换根dp","permalink":"https://xqc-1368.github.io/tags/%E6%8D%A2%E6%A0%B9dp/"},{"name":"链式二叉树","slug":"链式二叉树","permalink":"https://xqc-1368.github.io/tags/%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"遍历问题","slug":"遍历问题","permalink":"https://xqc-1368.github.io/tags/%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"},{"name":"树上差分","slug":"树上差分","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"最大流","slug":"最大流","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"并查集的路径优化压缩","slug":"并查集的路径优化压缩","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%E5%8E%8B%E7%BC%A9/"},{"name":"并查集的按秩合并优化","slug":"并查集的按秩合并优化","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/"},{"name":"种类并查集","slug":"种类并查集","permalink":"https://xqc-1368.github.io/tags/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"环形DP的四边形不等式优化","slug":"环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/tags/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"},{"name":"多重背包DP的二进制优化","slug":"多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"树形DP","slug":"树形DP","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"DP的单调队列优化","slug":"DP的单调队列优化","permalink":"https://xqc-1368.github.io/tags/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"},{"name":"状压DP","slug":"状压DP","permalink":"https://xqc-1368.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"区域DP","slug":"区域DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E5%9F%9FDP/"},{"name":"背包DP","slug":"背包DP","permalink":"https://xqc-1368.github.io/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"期望DP","slug":"期望DP","permalink":"https://xqc-1368.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"},{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS绝对定位","slug":"CSS绝对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS相对定位","slug":"CSS相对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS定位注意事项","slug":"CSS定位注意事项","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AE%9A%E4%BD%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"CSS子绝父相","slug":"CSS子绝父相","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8/"},{"name":"CSS元素显示与隐藏","slug":"CSS元素显示与隐藏","permalink":"https://xqc-1368.github.io/tags/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"name":"CSS溢出处理","slug":"CSS溢出处理","permalink":"https://xqc-1368.github.io/tags/CSS%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/"},{"name":"CSS浮动float","slug":"CSS浮动float","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B5%AE%E5%8A%A8float/"},{"name":"CSS清除浮动","slug":"CSS清除浮动","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS盒子模型","slug":"CSS盒子模型","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"name":"CSS边框样式","slug":"CSS边框样式","permalink":"https://xqc-1368.github.io/tags/CSS%E8%BE%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/"},{"name":"CSS内边距padding","slug":"CSS内边距padding","permalink":"https://xqc-1368.github.io/tags/CSS%E5%86%85%E8%BE%B9%E8%B7%9Dpadding/"},{"name":"CSS外边距margin","slug":"CSS外边距margin","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%96%E8%BE%B9%E8%B7%9Dmargin/"},{"name":"CSS清除内外边距","slug":"CSS清除内外边距","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E5%86%85%E5%A4%96%E8%BE%B9%E8%B7%9D/"},{"name":"CSS圆角边框","slug":"CSS圆角边框","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/"},{"name":"CSS盒子阴影","slug":"CSS盒子阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1/"},{"name":"CSS显示模式","slug":"CSS显示模式","permalink":"https://xqc-1368.github.io/tags/CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"},{"name":"CSS块元素","slug":"CSS块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS行内元素","slug":"CSS行内元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"},{"name":"CSS行内块元素","slug":"CSS行内块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS复合选择器","slug":"CSS复合选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS伪元素选择器","slug":"CSS伪元素选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS链接伪类选择器","slug":"CSS链接伪类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS属性选择器","slug":"CSS属性选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS类选择器","slug":"CSS类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS标签选择器","slug":"CSS标签选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSSID选择器","slug":"CSSID选择器","permalink":"https://xqc-1368.github.io/tags/CSSID%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS通配符选择器","slug":"CSS通配符选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%9A%E9%85%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS后代选择器","slug":"CSS后代选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS子选择器","slug":"CSS子选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS并集选择器","slug":"CSS并集选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS背景","slug":"CSS背景","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF/"},{"name":"CSS背景平铺","slug":"CSS背景平铺","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%B9%B3%E9%93%BA/"},{"name":"CSS背景图片位置","slug":"CSS背景图片位置","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/"},{"name":"CSS文本格式属性","slug":"CSS文本格式属性","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%B1%9E%E6%80%A7/"},{"name":"CSS文本修饰","slug":"CSS文本修饰","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/"},{"name":"CSS文本对齐","slug":"CSS文本对齐","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90/"},{"name":"CSS字体font","slug":"CSS字体font","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93font/"},{"name":"emmet","slug":"emmet","permalink":"https://xqc-1368.github.io/tags/emmet/"},{"name":"PS","slug":"PS","permalink":"https://xqc-1368.github.io/tags/PS/"},{"name":"CSS注释","slug":"CSS注释","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B3%A8%E9%87%8A/"},{"name":"CSS的插入","slug":"CSS的插入","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9A%84%E6%8F%92%E5%85%A5/"},{"name":"CSS优先级问题","slug":"CSS优先级问题","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"},{"name":"CSS精灵图","slug":"CSS精灵图","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS字体图标","slug":"CSS字体图标","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"},{"name":"CSS三角绘制","slug":"CSS三角绘制","permalink":"https://xqc-1368.github.io/tags/CSS%E4%B8%89%E8%A7%92%E7%BB%98%E5%88%B6/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML列表","slug":"HTML列表","permalink":"https://xqc-1368.github.io/tags/HTML%E5%88%97%E8%A1%A8/"},{"name":"HTML表格","slug":"HTML表格","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E6%A0%BC/"},{"name":"HTML表单","slug":"HTML表单","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E5%8D%95/"},{"name":"HTML注释","slug":"HTML注释","permalink":"https://xqc-1368.github.io/tags/HTML%E6%B3%A8%E9%87%8A/"},{"name":"HTML特殊字符","slug":"HTML特殊字符","permalink":"https://xqc-1368.github.io/tags/HTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"web标准","slug":"web标准","permalink":"https://xqc-1368.github.io/tags/web%E6%A0%87%E5%87%86/"},{"name":"Web服务器","slug":"Web服务器","permalink":"https://xqc-1368.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"DNS服务器","slug":"DNS服务器","permalink":"https://xqc-1368.github.io/tags/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://xqc-1368.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"URL","slug":"URL","permalink":"https://xqc-1368.github.io/tags/URL/"},{"name":"URI","slug":"URI","permalink":"https://xqc-1368.github.io/tags/URI/"},{"name":"请求消息","slug":"请求消息","permalink":"https://xqc-1368.github.io/tags/%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/"},{"name":"域名","slug":"域名","permalink":"https://xqc-1368.github.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"Socket库","slug":"Socket库","permalink":"https://xqc-1368.github.io/tags/Socket%E5%BA%93/"},{"name":"解析器","slug":"解析器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A3%E6%9E%90%E5%99%A8/"}]}