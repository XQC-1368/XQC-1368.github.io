{"meta":{"title":"XQC1368的emo小屋","subtitle":"嬛嬛，朕emo啦！！","description":"菜坤日常","author":"XQC1368","url":"https://XQC-1368.github.io","root":"/"},"pages":[{"title":"分类","date":"2024-08-16T08:33:55.126Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://xqc-1368.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2024-08-16T06:03:33.337Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://xqc-1368.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2024-08-15T14:02:09.921Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"https://xqc-1368.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2024-08-15T14:02:09.917Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://xqc-1368.github.io/books/index.html","excerpt":"","text":""},{"title":"仓库","date":"2024-08-16T06:00:06.900Z","updated":"2024-08-16T06:00:06.900Z","comments":false,"path":"repository/index.html","permalink":"https://xqc-1368.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-08-16T05:54:24.517Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"https://xqc-1368.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2024-08-16T03:54:10.618Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"https://xqc-1368.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"8 高级语言","slug":"8 高级语言","date":"2024-08-19T11:53:47.635Z","updated":"2024-08-19T11:52:43.496Z","comments":true,"path":"2024/08/19/8 高级语言/","permalink":"https://xqc-1368.github.io/2024/08/19/8%20%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/","excerpt":"","text":"高级语言 一、低级语言：汇编语言 与硬件关系紧密 比机器语言要简单，但微处理器不能解释汇编语言 汇编器（本身也是一个COM文件）：把汇编语言转换成机器语言，把ASM文件转换成COM文件（ASM文件：汇编语言文件 / 源代码文件） 交叉汇编：用汇编器做一个汇编器 缺点： 非常乏味，微处理器芯片级的编程，微小的细节 不可“移植” 二、高级语言 编译器：将高级语言转换成机器码 好处：易用性；可移植性 坏处：没有让处理器变强大；不能使用某些处理器的特有功能 第一个编译器——A-0 最古老的高级语言——FORTRAN 第一个商务系统所使用的程序设计语言——COBOL 支持读取记录(record)和生成报表(report) IBM PL/I融合了： ALGOL的块结构 FORTRAN的数学函数功能 COBOL处理记录和报表的能力 解释性语言：解释器采取边读边执行的方式，不会产生新的文件（原理简单，但执行慢） 编译性语言：编译器读取源文件并生成一个可执行文件 Pascal语言：继承了ALGOL的大部分结构；COBOL的记录处理功能 集成开发环境：程序的文本编辑器和编译器集成在一起，方便运行调试 C（Resource From B语言（Basic CPL语言的精简版本））：UNIX完全基于C语言重写 c语言：支持移位操作与按位布尔运算操作 指针(pointer)：数字化描述内存地址 “高级汇编语言”：C语言操作集和通用处理器的指令集接近值程度更高 所有的类ALGOL语言设计模式都是基于冯·诺依曼计算机体系的。此类语言进行改进后产生了主要应用在图形化操作系统中的面向对象程序设计语言。","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"编译原理","slug":"编译原理","permalink":"https://xqc-1368.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://xqc-1368.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"7 定点数与浮点数","slug":"7 定点数与浮点数","date":"2024-08-19T11:53:47.632Z","updated":"2024-08-19T11:52:04.465Z","comments":true,"path":"2024/08/19/7 定点数与浮点数/","permalink":"https://xqc-1368.github.io/2024/08/19/7%20%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0/","excerpt":"","text":"定点数与浮点数 一、定点格式数 钱款、账户 二、浮点格式数 极大数或极小数 科学计数法（单精度） 1位符号位s 8位指数位e 23位有效数位f（精度为24位，包含“.f”左边默认的1） (−1)s×1.f×2e−127(-1)^s\\times 1.f\\times 2^{e-127}(−1)s×1.f×2e−127 127为单精度浮点数的偏移量（从0255到-127128） 单精度(float)与双精度(double) 浮点数的加法：先移位再运算 浮点数的乘法：有效数相乘，指数部分相加 8087数字协同处理芯片=浮点运算单元（FPU）=协处理器，现在FPU已经内建在CPU内部了 当CPU读到ESC时，协处理器开始工作，协处理器会以固有的方式执行存放在ROM的指令序列","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"浮点数","slug":"浮点数","permalink":"https://xqc-1368.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"}]},{"title":"6 操作系统Operation System","slug":"6 操作系统Operation System","date":"2024-08-19T11:53:47.629Z","updated":"2024-08-19T11:51:19.970Z","comments":true,"path":"2024/08/19/6 操作系统Operation System/","permalink":"https://xqc-1368.github.io/2024/08/19/6%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOperation%20System/","excerpt":"","text":"操作系统Operation System 一、初始化代码、键盘处理程序、命令处理程序 初始化代码： 背景：所有的RAM启动时都包含随机字节 内存置为全空格 堆栈指针初始化 OUT指令实现光标复位 EI指令开启中断 HLT指令完成中断 键盘处理程序： 当按下键盘按键的时候，微处理器就会响应，从初始化代码程序的末尾的HLT语句跳转到键盘处理程序。 IN指令检测哪个按键被按下 RET指令返回 回显：把按下的键显示回原光标所在处。 命令处理程序 W命令（Write）：把若干字节写入内存 D命令（Display）：便于查看内存中的内容 R命令（Run）：运行程序，具体过程是：先把要执行程序开头地址存储到存储器HL中，再执行指令PCHL，把存储的值加载到程序计数器中，跳转到程序计数器指向的地址并运行程序。 二、操作系统 文件系统：磁盘组织成文件，是操作系统的一部分 操作系统：许多软件构成的，庞大的程序集合。 操作系统的目录 目录项：32字节（8080中） 8.3命名方式：aabbccdd.txt 目录项扩展：文件长度过长，两个目录项，第12字节一个置0一个置1，文件拼接 CM/P：早期的8位微处理器操作系统 COM文件：二进制文件，存放机器码 操作系统的引导：当ROM存在时，RAM必须给ROM让位，内存一开始的那一部分属于ROM，在这里存储一段引导程序。开机后将引导程序加载到内存并运行。 内存空间组织架构 操作系统完成引导后，RAM的最高地址区域用来存放CP/M，加载完CP/M后，内存空间组织结构如下： 0000h 系统参数 0100h 临时程序区域(TPA) 控制台命令处理程序(CCP)【CP/M三大部分】 基本磁盘操作系统(BDOS)【CP/M三大部分】 最高地址 基本输入/输出系统(BIOS)【CP/M三大部分】 控制台可识别命令 命令 内容 DIR 显示磁盘的目录信息 DIR *.txt：显示所有txt文件 ERA 删除磁盘中的文件 REN 改变文件名 TYPE 显示文本文件的内容 SAVE 保存文件 执行二进制文件：直接输入名字即可。 实用程序： 外设交换设备（PIP）：用于复制文件 文本编辑器（ED）：创建和修改文件 应用程序接口（API）： 一些子程序，以操作系统为中介来访问硬件系统 新建一个文件的工作：首先将文件地址保存到寄存器对DE中，再执行： 12MVI C, 16h 调用的子程序地址CALL 5 CALL 5 执行过程：CP/M在0005h处设置了一条JMP指令（Jump），跳转到CP/M基本磁盘操作系统（BDOS），利用CP/M提供的其他功能向磁盘中创建的空文件写入内容，最后关闭文件。BDOS在工作时还要调用CP/M基本输入输出系统（BIOS），BIOS可以对硬件进行访问 总结：OS提供应用程序接口(API)，让程序能够方便地访问计算机的硬件。API是一个与设备无关(device-independent)的接口，它屏蔽了硬件之间的差异。使得CP/M的程序跨平台成为现实 发展历史： CP/M—&gt;MS-DOS 文件系统以FAT形式，后来出现层次文件系统，根目录概念出现 将txt等叫作扩展名 将磁盘空间分成簇 新增EXE的可执行文件。 后来新增：软件中断：不需要知道子程序地址直接执行中断。 Multics----&gt;UNIX 可移植性好 时分复用技术：多个用户同时与计算机进行交互（多任务操作系统） 虚拟内存技术：暂时不需要内存放到磁盘的 ”临时文件“ 部分，需要时再调入内存 GNU项目开发的Linux","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://xqc-1368.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统","slug":"操作系统","permalink":"https://xqc-1368.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"机器语言","slug":"机器语言","permalink":"https://xqc-1368.github.io/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/"}]},{"title":"5 计算机组成原理：总线","slug":"5 计算机组成原理：总线","date":"2024-08-19T11:53:47.626Z","updated":"2024-08-19T11:50:23.072Z","comments":true,"path":"2024/08/19/5 计算机组成原理：总线/","permalink":"https://xqc-1368.github.io/2024/08/19/5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%9A%E6%80%BB%E7%BA%BF/","excerpt":"","text":"计算机组成原理：总线 一、总线简介 集成电路是挂载（mounted）在电路板上的 总线的功能： 电路板之间通过总线通信，通信信号包括： 地址信号 数据输入/输出信号 控制信号 供电作用 早期流行的总线：S-100（designed for 8080） 扩展板：是一种可以插在主板上的模块化电路板，用于增强主板的功能和性能。扩展板提供了多种接口，用于与外部模块进行通信和控制操作 8088的扩展板提供了3个直接访问存储器（DMA）:采用此方法后，其他设备可以不通过微处理器而获得总线的控制权，进而直接对内存进行读写。 ISA：工业标准体系结构 历史：微通道体系结构总线（MCA），EISA总线，外围部件互联总线（PCI） 二、存储器RAM 2102静态随机访问存储器芯片（SRAM）：三态输出（除了高电平和低电平之外，还包含真空态） 静态随机访问存储器（SRAM）与动态随机访问存储器（DRAM）的区别： 对于每一位存储空间，SRAM需要4个晶体管，DRAM只需要1个晶体管，但DRAM需要较复杂的外部电路支持。 SRAM一旦断电，所有信息就会丢失；DRAM在使用时，需要定期访问其存储器的内容，这一过程称为更新周期（refresh），这一过程每秒钟都要进行几百次。 趋势：DRAM增多 内存插槽（可以容纳几块小存储器板）：SIMM（单列直插内存模块）和DIMM（双列直插内存模块） 三、输出设备 视频显示器/监视器：连接在计算机上的电子射线管（CRT） 显卡/视频适配器：为视频显示器提供电子信号的元件 扫描技术： 扫描行：每一个水平行。 水平回归：完成每一行扫描后，回到最左边。 垂直回归：完成整个屏幕扫描后，回到左上角。 场频：每秒钟扫描的次数（单位：Hz） 各行扫描技术：整个帧分为两个场来完成，偶数扫描线扫描第一个场，奇数扫描线扫描第二个场。 水平扫描频率：水平扫描每行的速率（单位：Hz） 每个场所包含的扫描线数量=水平扫描速率÷场频每个场所包含的扫描线数量=水平扫描速率\\div 场频每个场所包含的扫描线数量=水平扫描速率÷场频 每帧所包含的扫描线数量=每个场所包含的扫描线数量×2每帧所包含的扫描线数量=每个场所包含的扫描线数量\\times 2每帧所包含的扫描线数量=每个场所包含的扫描线数量×2 2×场=1×帧2\\times场=1\\times帧2×场=1×帧 带宽： 带宽限制了视频信号从一个颜色到另一个颜色又回到前一个颜色的速率（变化两次的频率） 每个水平扫描行的像素数=2×带宽÷水平扫描速率每个水平扫描行的像素数=2\\times 带宽\\div 水平扫描速率每个水平扫描行的像素数=2×带宽÷水平扫描速率 可用像素=13每个水平扫描行的像素数可用像素=\\frac{1}{3}每个水平扫描行的像素数可用像素=31​每个水平扫描行的像素数 分辨率=水平方向可用像素×垂直方向上的可用像素分辨率=水平方向可用像素\\times 垂直方向上的可用像素分辨率=水平方向可用像素×垂直方向上的可用像素 四、字符生成器，只读存储器(read-only memory,ROM) 字符生成器：是视频适配板上的一部分，通常是指ROM。 ROM：代码转换电路，实现7位ASCII码到64位码的转换（定义了字符显示的外观） 文本适配器：支持光标（Cursor）功能的显示适配器：光标所在的行列被存储在两个8位寄存器中 图形适配器（图形显卡）： 五、磁介质存储器 录音电话 卷轴式磁带（顺序访问）：长期保存，但访问速度慢 磁盘（快速访问）：拥有磁头，可以快速访问 软盘：存储速度慢，存储量小，但可以移动，插入软盘驱动器后使用。 硬盘：存储速度快，存储量大，但永久驻留在驱动器中，硬盘固定。 硬盘驱动器标准接口（这些接口都可以用内存直接访问，即DMA访问使用总线）： 小型计算机系统接口（SCSI） 增强的小型设备（ESDI） 集成设备的电气接口（IDE） 结构：磁盘表面被划分成了许多同心圆，称为磁道；又切成了一个个扇区。 磁介质存储器的使用： 微处理器发出一个地址信号，通常是寻址RAM，而非磁介质存储器。微处理器不能直接从磁盘读取数据，需要将所需的数据从磁盘调入内存（RAM），然后才能对其访问。 磁介质存储器像一个文件柜，存储在磁盘上的数据是以文件作为实体来存放的，存储和检索文件是操作系统（OS）很重要的功能。","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"存储模块","slug":"存储模块","permalink":"https://xqc-1368.github.io/tags/%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97/"},{"name":"RAM","slug":"RAM","permalink":"https://xqc-1368.github.io/tags/RAM/"},{"name":"ROM","slug":"ROM","permalink":"https://xqc-1368.github.io/tags/ROM/"},{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://xqc-1368.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"总线","slug":"总线","permalink":"https://xqc-1368.github.io/tags/%E6%80%BB%E7%BA%BF/"},{"name":"IO模块","slug":"IO模块","permalink":"https://xqc-1368.github.io/tags/IO%E6%A8%A1%E5%9D%97/"}]},{"title":"4 微机原理：两种典型的微处理器","slug":"4 微机原理：两种典型的微处理器","date":"2024-08-19T11:53:47.622Z","updated":"2024-08-19T11:41:28.595Z","comments":true,"path":"2024/08/19/4 微机原理：两种典型的微处理器/","permalink":"https://xqc-1368.github.io/2024/08/19/4%20%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%9A%E4%B8%A4%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/","excerpt":"","text":"微机原理：两种典型的微处理器 定义：将中央处理器的所有构件封装到一块硅芯片上，即微处理器。 第一个微处理器：Intel 4004 发展历史：继电器——真空管——晶体管 处理器性能评价标准： 数据通路宽度（几位微处理器？） 最大时钟频率（主频）（相同时间完成更多操作） 可寻址存储器最大空间（空间换时间） 一、Intel公司的8080处理器 基本属性： 8位微处理器 时钟频率：2MHz 8080每条指令需要418个时钟周期，意味着每条指令的执行时间为29μs\\mu sμs 寻址空间：64KB 类型：单芯片微处理器 寄存器信息：8080内含6个寄存器，每个寄存器都是8位寄存器 分别命名为: B,C,D,E,H,LB,C,D,E,H,LB,C,D,E,H,L （A是内部的累加器的代号） 通常把两个8位寄存器 H 和 L 合起来构成一个16位 寄存器对（register pair）， 称作[HL]。 助记符 指令含义 LOD 加载 STO 保存 STA 保存到累加器 LDA 加载到累加器 STAX 保存到BC或DE寄存器 LDAX 加载到BC或DE寄存器 MOV 把一个寄存器中的内容转移&lt;br&gt;到另一个寄存器（可以是原来的寄存器、累加器） HLT 停止 例如： 12345LDA A, [aaaa]MOV A, [HL]MOV [HL], CSTAX [BC], ALDAX A, [BC] 三种寻址方法 直接寻址法：MOV B, [aaaa] （源操作数为地址信息） 间接寻址法：MOV B, [HL]（源操作数为地址所在的寄存器） 立即数寻址法：MOV B, 37h （源操作数为要操作的数据对象） 立即数操作 操作 含义 MVI 传送立即数 ADI 立即数加法 ACI 立即数进位加法 SUI 立即数减法 SBI 立即数借位减法 ANI 立即数与 XRI 立即数异或 ORI 立即数或 CPI 立即数比较 不符合规则的操作结果 MOV A, A 并不会执行有意义的操作； MOV [HL], [HL]该指令是不存在的，实际上该指令的实际意义 人为规定等价于HLT 操作码的位模式： 比如：MOV操作码由八位组成 01dddsss，ddd表示目标操作数的代码，sss表示源操作数的代码 代码 对应寄存器 000 寄存器B 001 寄存器C 010 寄存器D 011 寄存器E 100 寄存器H 101 寄存器L 110 合并寄存器HL 111 累加器A 如：MOV L, E 表示为操作码：01101011 标志位（flag） 8080的标志位包括：CF（进位标志），ZF（零标志位），SF（符号标志位），PF（奇偶标志位），AF（辅助进位标志） 程序状态字（PSW）：在8080中，专门的8位寄存器，来存放所有的标志位 LDA，STA，MOV指令不会影响标志位。ADD，SUB，ADC（进位加法），SBB（借位减法）会影响标志位状态。 但是以下两个直接影响CF 操作 含义 STC 令CF置1 CMC 令CF取反 CMP指令：和SUB指令类似，也是把两个数相减。但是他是把结果保存在标志位 如果A中既有的值小于CMP的源操作数存储器中的值，那么进位标志位CF置1；如果A中既有的值等于源操作数存储器中的值，那么零标志位ZF置1。 操作 含义 CMP 比较，可设置标志位 两种特别的8080指令： 操作 含义 CMA 累加器中的数按位取反 DAA 十进制调整累加器，使用BCD码进行十进制的算术运算（加在运算出原十六进制结果后，切换结果） 增量减量操作 INR和DCR都是单字节操作，可以影响除了CF之外所有标志位 操作 含义 INR 寄存器或存储器中的数加1 DCR 寄存器或存储器中的数减1 移位操作 操作 含义 RLC 使累加器循环左移 RRC 使累加器循环右移 RAL 带进位的累加器循环左移 RAR 带进位的累加器循环右移 执行RAL时，将原最高位移至CF 执行RAR时，将原最低位移至CF 二、Intel 8080微处理器的RAM与栈 随机访问存储器RAM：可以寻址访问的存储器 栈指针：8080微处理器设置了一个专门的16位寄存器作为栈，对这段空间寻址的寄存器叫作栈指针（SP，Stack Pointer） 栈的特性：后进先出（LIFO） 入栈出栈指令 操作 含义 PUSH 压入堆栈 POP 弹出堆栈 如果你想把寄存器中所有内容保存到栈内，可以使用如下指令： 1234PUSH PSWPUSH BCPUSH DEPUSH HL 而 POP BC 则表示从栈中弹出一个值，按照来顺序保存到BC存储器中。 栈的工作方式 假设栈指针初始时位于8000h。当有数据入栈时，栈指针-1，变成7FFFh，且在7FFFh位置存储压入的数据 栈上溢和栈下溢 栈上溢（stack overflow）：使用过多PUSH指令，覆盖掉存储器中其他内容 栈下溢（stack underflow）：使用过多POP指令，栈中数据取完了还在POP 寄存器和栈的共用操作 操作 含义 LXI 对寄存器 或 堆栈指针 加载（Load）扩展的立即数（两个字节） INX 对寄存器对和堆栈指针加1 DCX 对寄存器对和堆栈指针减1 DAD 把由任意2个寄存器组成的16位寄存器对的内容加到寄存器对HL中 LXI 指令： 1LXI BC, 527Ah 以上指令等价于： 12MVI B, 52hMVI C, 7Ah DAD 指令： 一般用于计算存储器的地址，对PSW中只有对CF有影响 栈操作指令 操作 含义 SHLD 直接保存HL中的数据 LHLD 直接加载数据到HL PCHL 将HL保存的数据加载到程序计数器 SPHL 将HL保存的数据加载到堆栈指针 XTHL 把HL中的内容和堆栈顶部2个字节进行交换 XCHG 把DE中的内容和HL中的内容进行交换 Call 和 Return指令 Call（调用）指令：执行之后，程序计数器（PC）将加载一个新地址，而原来的地址则被保存到栈当中。（这种指令记录了“从何处跳转”，即保存了跳转之前的信息） 补充：8080处理器中的转移指令 操作 含义 JMP 转移 JZ 零转移 JNZ 非零转移 JC 进位转移 JNC 无进位转移 三、Intel 8080与周围设备 内存映像 I/O：除了常规的65536个地址外，另增了256个地址专门用来访问输入/输出设备，这些地址被称为I/O端口 操作 含义 OUT 把累加器中的内容 写入到 紧跟该指令后的字节 所寻址的端口 IN 把一个字节从端口读入到累加器 12OUT PPIN PP 当外围设备需要中断微处理器当前操作时，它需要把8080的INT端口的输入信号置1。8080通过从存储器取出指令的方式，来响应该中断，同时控制信号指明有中断发生。 操作 含义 DI 禁止中断 EI 允许中断 其他操作 操作 含义 RST 重新启动，立即跳转到特定的地址 NOP 无操作 四、Motorola公司生产的6800微处理器 对比： Motorola 6800相比于Intel 8080 时钟信号较简单 没有独立I/O端口 B也是累加器，无其他8位寄存器 16位索引寄存器（类似HL寄存器） 对应操作码和助记符完全不同 无奇偶标志位，有溢出标志位 汇编语言不兼容 6800高前低后，8080低前高后（Motorola方式，Intel方式） 五、现代微处理器技术 苹果公司的Mac的PowerPC微处理器 采用RISC技术（精简指令集计算机） 特点1：指令等长，只有Load和Store能访问存储器 特点2：设置大量寄存器，避免频繁访问存储器 流水线技术 处理器在执行一条指令时同时读取下一条指令 高速缓冲存储器（Cache） 在处理器内部设置一个访问速度很快的RAM阵列，存放最近要执行的指令，Cache能避免常用小循环的反复加载","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://xqc-1368.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统","slug":"操作系统","permalink":"https://xqc-1368.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"机器语言","slug":"机器语言","permalink":"https://xqc-1368.github.io/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/"},{"name":"CPU","slug":"CPU","permalink":"https://xqc-1368.github.io/tags/CPU/"}]},{"title":"数字逻辑设计02  微处理器设计","slug":"3 数字逻辑设计02  微处理器设计","date":"2024-08-19T11:53:47.614Z","updated":"2024-08-19T11:48:25.205Z","comments":true,"path":"2024/08/19/3 数字逻辑设计02  微处理器设计/","permalink":"https://xqc-1368.github.io/2024/08/19/3%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A102%20%20%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"数字逻辑设计02 微处理器设计 一、基于ALU（算数逻辑单元）的连续加法器设计 当计数器收到时钟信号后，将0000h输入给RAM，RAM将存储在0000h位置的数据RAM输入到8位加法器的A输入端。由于有先序清零操作（清零的开关没放上去），则加法器B输入端位00h，求和得加法器输出端S为27h，所以8位锁存器输出为27h。由于RAM的W写入端并没有为高电平，所以不允许写入，8位锁存器的输出则只能走右边路径到达加法器的B输入端。由于锁存器的保持作用，则该型号能一直保持在B输入端，直至下一个A端输入到达并在加法器上要求执行求和操作。 当下个时钟信号到达后，计数器输出0001h，RAM将0001h位置的数据A2h输出到加法器的A输入端，并且执行求和操作，得到的结果C9h同样的沿右边路径回到B端口并保持。 当计数器输出0002h时，RAM将0002h位置的数据18h输出到加法器的A输入端，并且执行求和操作，得到的结果E1h同样的沿右边路径回到B端口并保持。 当计数器输出0003h时，人为将RAM的W写入端置1，RAM将0003h位置的数据改写为8位锁存器在前一种状态的输出E1h。 此时完成一次连加运算，对锁存器进行手动清零并执行下一次连加运算 二、代码RAM 与数据RAM 在分立内存中 完全同位置情况 的指令连加系统设计 由上述例子可以看出，进行连加操作的时候，首先要把一个字节从存储器传输到累加器中，这个过程称为加载（Load），再要把一个字节从存储器中加（Add）到累加器中。第三个操作是把累加器运算结果保存（Store）回数据RAM中，另外还需要让累加器停下（Halt）的操作。有可能我们后面还需要减法（Subtract）。 如果让数据RAM与代码RAM同位，那么就像下面这样： 那么数据RAM和代码RAM就可以这样设计，用同一个计数器来触发地址。 为了执行Load指令，数据RAM阵列的输出有时应该直接作为8位锁存器的输入。所以此时应该设置一个二选一选择器来实现这种功能。 具体实现如下： 加入减法操作所需的反相器后如下： 三、进位加法和借位减法 进行8位加法时，使用的是常规的Add指令。加法器的进位输入是0。当进行高位字节数相加时，要使用新的Add with Carry指令在这种情况下，要用进位锁存器（假设在上图中加上这样一个锁存器）的输出作为加法器的进位输入。 先进行低位运算，再进行高位运算。 四、扩展寻址模式，操作+地址RAM（代码RAM）与 数据RAM 在分立内存中 不同位置情况 的控制系统设计 扩展寻址模式：除了停止指令（Halt指令）之外，需要3个字节，第一个字节记录操作内容，第2,3个字节记录操作对象的地址。 下面为代码RAM 下面为本操作的数据RAM中内容 控制系统部分如下设计（其他部分同前）： 从存储器中取出指令的过程称为 取指令取指令取指令 每条指令需要的时间为三个时钟周期 上图中使用了两个RAM阵列，一个用来存放指令码，另一个用来存放操作数据 但是同样是RAM，所以操作码和操作数可以用同一个RAM控制： 五、操作+地址RAM（代码RAM）与 数据RAM 在共用内存中 不同位置情况 的控制系统设计 为了实现这一设计，必须要使用2-1选择器，分清此时需要从RAM中取出的是代码还是数据。 此时共用的RAM中的存储信息是： 六、置数法 实现 跳转指令（Jump） 解决内存不连续问题和指令码不等长问题（Halt和其他的不等长），需要跳转指令Jump 通常情况下，自动加法器以顺序方式对RAM阵列寻址，Jump指令改变了机器的寻址方式。 五、利用 Jump 指令实现乘法器 共用RAM的数据部分 预置信息： 第一次循环：相当于实现 00 00 h+00 A7 h=00 A7 h=00 A7 h * 1 将1002h-1003h的部分看作从001Ch变小到0000h的计数装置，也就是让以上部分运行001Ch次即可实现00A7h*001Ch 执行完以上指令，需要让001C减一，由于停止（Halt）操作码恰好为FFh，把任何一个数加上它，相当于把这个数减一。(FFh一数两用，表示停止或者表示-1) 执行完以上指令，需要让001C减一的同时，让代码执行位置跳转（Jump）回开头的0000h： 但是需要考虑的是，当001C减到0000h时，就停止程序。而不再跳转 所以此处我们需要考虑的是条件跳转中的 零跳转（Jump If Zero） 零跳转的机器码写法（衔接上图） 零跳转的硬件实现：零锁存器 当执行到第28次循环的时候，1004h和1005h地址保存的16位数等于A7h和1Ch的乘积。1003h地址保存的值为1，此时他和FFh相加的值为0，因此0标志位被置位。Jump If Zero指令不会在跳转到0000h地址，相反，下一条执行的指令即Halt指令 除了零跳转之外，还有其他条件跳转方式如下： 八、汇编语言基础 操作指令 目标操作数，源操作数 朴素的直接写地址的汇编语言： 标号性质的汇编语言 九、结语 能否控制重复操作或者循环操作是计算机与计算器的区别。 在处理器中，8位反相器和8位加法器构成了算数逻辑单元（ALU，Arithmetic Logic Unit） 16位计数器可以称为程序计数器（PC Program Counter）","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"加法器与减法器","slug":"加法器与减法器","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E5%87%8F%E6%B3%95%E5%99%A8/"},{"name":"RAM","slug":"RAM","permalink":"https://xqc-1368.github.io/tags/RAM/"},{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"ALU","slug":"ALU","permalink":"https://xqc-1368.github.io/tags/ALU/"},{"name":"连加器","slug":"连加器","permalink":"https://xqc-1368.github.io/tags/%E8%BF%9E%E5%8A%A0%E5%99%A8/"},{"name":"跳转JUMP","slug":"跳转JUMP","permalink":"https://xqc-1368.github.io/tags/%E8%B7%B3%E8%BD%ACJUMP/"},{"name":"扩展寻址","slug":"扩展寻址","permalink":"https://xqc-1368.github.io/tags/%E6%89%A9%E5%B1%95%E5%AF%BB%E5%9D%80/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://xqc-1368.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统","slug":"操作系统","permalink":"https://xqc-1368.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"数字逻辑设计01  RAM随机访问存储器","slug":"2 数字逻辑设计01  RAM随机访问存储器","date":"2024-08-19T11:53:47.611Z","updated":"2024-08-19T11:41:37.472Z","comments":true,"path":"2024/08/19/2 数字逻辑设计01  RAM随机访问存储器/","permalink":"https://xqc-1368.github.io/2024/08/19/2%20%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A101%20%20RAM%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8/","excerpt":"","text":"数字逻辑设计：自动操作 一、寄存器 用来暂时存放参与运算的数据和运算结果。把能够用来存储一组二进制代码的同步时序逻辑电路称为寄存器。 注意看，这本来是一个D触发器，由于命名方式的改变，他的D：数据输入端被更名为DI（即Data In），他的时钟信号端被命名为W（写操作端，Write），他原来的输出端Q被命名为DO（Data Out） 将他们以同步时序电路的方式”并联“： 可以得到一个八位寄存器（《code》中用八位锁存器代指这个概念，以下图片不作区分） 可以简化为如下所示的图： 二、随机存储器（RAM）的基本结构 又名“读/写存储器” 读写操作很自由，只需要改变地址及相关的输入，就可以从寄存器中读出或写入需要的数据 随机访问存储器的符号 随机存储器的组成：译码器＋寄存器+选择器 将两个RAM组合成RAM阵列 这个RAM阵列可以存储的二进制数依然是8个，但每个数的位宽为2位。 使用2个8×18\\times18×1的RAM搭一个16×116\\times116×1的RAM 相当于把两个3-8译码器用一个1-2译码器联结起来 下方用一个2-1选择器把两个8-1选择器联结起来 （红圈部分不太理解是什么意思） S作为选择端，本质上用于选择存储的信息，所以可以并入地址端（A_3端即为S端） 注意：16×116\\times116×1中 前一个数字=存储RAM阵列的存储容量=2地址输入端的个数前一个数字 = 存储RAM阵列的存储容量 = 2^{地址输入端的个数}前一个数字=存储RAM阵列的存储容量=2地址输入端的个数 后一个数字=每个单位由几位二进制数构成=数据输入端的个数后一个数字 = 每个单位由几位二进制数构成 = 数据输入端的个数后一个数字=每个单位由几位二进制数构成=数据输入端的个数","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"RAM","slug":"RAM","permalink":"https://xqc-1368.github.io/tags/RAM/"},{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://xqc-1368.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"1 计算机科学与技术——大纲Computer Science And Technology","slug":"1 计算机科学与技术——大纲Computer Science And Technology","date":"2024-08-19T11:53:47.607Z","updated":"2024-08-19T11:38:10.912Z","comments":true,"path":"2024/08/19/1 计算机科学与技术——大纲Computer Science And Technology/","permalink":"https://xqc-1368.github.io/2024/08/19/1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%A4%A7%E7%BA%B2Computer%20Science%20And%20Technology/","excerpt":"","text":"计算机科学与技术Computer Science And Technology 基于《code：编码 隐匿在计算机软硬件背后的语言》（《Code：The hidden Language of Computer Hardware and Software》），哈尔滨工业大学（深圳）计算机思维导论课，和MOOC哈尔滨工业大学的课程总结的计算机学习路线思维导图 注意：哈尔滨工业大学（深圳）的“计算机科学与技术”专业没有加入《微机原理》这门课","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"}]},{"title":"9 图形化革命","slug":"9 图形化革命","date":"2024-08-19T11:53:47.603Z","updated":"2024-08-19T11:53:24.503Z","comments":true,"path":"2024/08/19/9 图形化革命/","permalink":"https://xqc-1368.github.io/2024/08/19/9%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E9%9D%A9%E5%91%BD/","excerpt":"","text":"图形化革命 电传打字机———&gt;键盘＋阴极射线管(CRT)（哑终端）——》SAGE中的电子枪显示器——》光栅显示器 图形用户界面(GUI) Alto 麦金托什机(Macintosh)——Mac OS（主要以Pascal开发） （系统软件，可以用于支持API函数，实现用户界面不同组件） Windows（主要以C语言开发） 面向对象程序设计思想(OOP) 对象(object)实际上是代码和数据的组合，应用于图形操作系统 C++：C语言的扩展面向对象语言（面向对象能做的传统语言也能，只是结构不够好） 开发生产力工具：集成开发环境(IDE)、可视化教程(Visual Programming) 传递格式化文本方法：RTF 格式：PostScript 计算机图形的两个分支 矢量（图元文件）（CAD常用） 光栅（位图） 位图文件格式：Windows：bmp格式，Mac：paint格式，另外pict格式支持两种图片 位图压缩： 游程长度编码（RLE）：72×蓝色72\\times蓝色72×蓝色代表72个蓝色字符 图形交换格式（gif）：考虑像素值的模式 基于gif的LZW压缩 注意：RLE和LZW的压缩都属于无损压缩，压缩过程可逆 JEPG：部分有损的压缩 光学字符识别（OCR）：识别位图上字符，变成ASCII码 位图和图元文件都是数字化的可视信息。 音频信息——转换成比特和字节。 CD 脉冲编码调制技术(PCM)，信息保存在CD上 CD使用的采样频率为44100Hz，根据采样定理，恰好稍大于人耳能听到的的声音频率范围（20~2wHz）的两倍 模拟数字转换器(ADC)与数字模拟转换器(DAC) DVD数字多用光盘：两面均可以存储，且视频信息可以被压缩为原来的150\\frac{1}{50}501​ 声音合成：MIDI 音频压缩：MPEG技术 Java 介于编译语言与解释语言之间，编译的结果不是机器码，而是Java字节码 Java字节码可以在Java虚拟机上被解释 平台无关性：Java程序的运行不受限于机器与图形操作系统","categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"}],"tags":[{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"GUI","slug":"GUI","permalink":"https://xqc-1368.github.io/tags/GUI/"}]},{"title":"03-2 存储电路：RAM 与 ROM","slug":"03-2 存储电路：RAM 与 ROM","date":"2024-08-19T09:44:09.425Z","updated":"2024-08-19T09:42:48.002Z","comments":true,"path":"2024/08/19/03-2 存储电路：RAM 与 ROM/","permalink":"https://xqc-1368.github.io/2024/08/19/03-2%20%E5%AD%98%E5%82%A8%E7%94%B5%E8%B7%AF%EF%BC%9ARAM%20%E4%B8%8E%20ROM/","excerpt":"","text":"随机存储器（RAM）与只读存储器（ROM） 一、寄存器 用来暂时存放参与运算的数据和运算结果。把能够用来存储一组二进制代码的同步时序逻辑电路称为寄存器。 注意看，这本来是一个D触发器，由于命名方式的改变，他的DDD：数据输入端被更名为DIDIDI（即Data In），他的时钟信号端被命名为W（写操作端，Write），他原来的输出端Q被命名为DO（Data Out） 将他们以同步时序电路的方式”并联“： 可以得到一个八位寄存器（《code》中用八位锁存器代指这个概念，以下图片不作区分） 可以简化为如下所示的图： 实际应用的寄存器如图所示：包括74LS75和74HC175 二、随机存储器（RAM）的基本结构 又名“读/写存储器” 读写操作很自由，只需要改变地址及相关的输入，就可以从寄存器中读出或写入需要的数据 随机访问存储器的符号 随机存储器的组成：译码器＋寄存器+选择器 将两个RAM组合成RAM阵列 这个RAM阵列可以存储的二进制数依然是8个，但每个数的位宽为2位。 使用2个8×18\\times18×1的RAM搭一个16×116\\times116×1的RAM 相当于把两个3-8译码器用一个1-2译码器联结起来 下方用一个2-1选择器把两个8-1选择器联结起来 （红圈部分不太理解是什么意思） S作为选择端，本质上用于选择存储的信息，所以可以并入地址端（A3A_3A3​端即为SSS端） 注意：16×116\\times116×1中 前一个数字 = 存储RAM阵列的存储容量 = 2地址输入端的个数2^{地址输入端的个数}2地址输入端的个数 后一个数字 = 每个单位由几位二进制数构成 = 数据输入端的个数 三、静态随机存储器（SRAM） 相比于上面的结构的改进：合并了选择器和译码器的功能，调整为不管是写入还是读出，都由译码器确定需要操作的元素的地址 SRAM的静态存储单元：六管CMOS静态存储单元 看着非常复杂，其实上，它本质就是靠着锁存器自锁功能来存储数据的， T1T_1T1​~T4T_4T4​组成SR锁存器，用于记忆1位二进制代码，其中T1T_1T1​，T2T_2T2​和T3T_3T3​，T4T_4T4​分别接成了反相器G1G_1G1​和G2G_2G2​ 注意看这个Q，他是存储这一位信息的地方（也就是原来的一位锁存器的输出） 当CS=0时候表示电路可以启动了，此时： 当R/W′R/W&#x27;R/W′端口输入1时，代表读取模式，数据沿蓝色线从 QQQ 到 I/OI/OI/O； 当R/W′R/W&#x27;R/W′端口输入0时，代表写入模式，数据沿绿色线从 I/OI/OI/O 到 QQQ； 当然，实现以上数据传递，需要 XiX_iXi​ 和 YiY_iYi​ 线都接上高电平。这需要这一位被选择。 在下图中，行列地址译码器可以确定存储矩阵上哪个元素的 XiX_iXi​ 和 YiY_iYi​ 都导通，那么该元素才有可能被读取。 四、动态随机存储器（DRAM） 特点：大容量，高集成度，需要刷新。 五、只读存储器（ROM） 只读存储器的基本结构 地址译码器由二极管与门构成，存储矩阵由或门构成。输出缓冲器则用于提高存储器的带负载能力，并实现对输出状态的三态控制。 其中W0W_0W0​$W_3$是字线，$d_0$d3d_3d3​是位线（数据线），而A1A_1A1​和A0A_0A0​则被称为地址线 与此同时，要通过给定的 EN′EN&#x27;EN′ 信号决定对输出的三态控制。 技巧：字线与位线的交叉点接有 MOS 管 / 二极管时相当于存1，没有接 MOS 管 / 二极管 时相当于存0 鉴于 MOS管中也有PN结，可以用来代替原来图中的PN结。对存储部分，可以有如下改造： 六、其他类型分ROM与闪存 掩模只读存储器（Mask ROM） 数据固化，不可以修改 可编程只读存储器（PROM） 一次性：一经写入，不可修改 PROM结构示意图： 一开始存储阵列里面全是1，写入时在D_0~D_7 以下三种：UVEPROMUVEPROMUVEPROM、E2PROME^2PROME2PROM 以及闪存，都属于EPROM（可擦除可编程只读存储器） 紫外线擦除的只读存储器（UVEPROM）与电信号擦除的可编程只读存储器(E2PROME^2PROME2PROM) 略 快闪存储器（闪存，Flash Memory） 闪存的存储单元是：一只浮栅MOS管除了控制栅 GeG_eGe​ 之外，在控制栅和衬底之间增加了一个浮置栅 GfG_fGf​ 工作原理： 在读出状态下 若浮置栅 GfG_fGf​ 上充有负电荷， 当字线给出高电平时浮栅MOS管截止，位线上输出高电平； 当字线给出低电平时浮栅MOS管导通，位线上输出低电平。 若浮置栅 $G_f $上没有负电荷， 当字线给出高电平时浮栅MOS管导通，位线上输出低电平； 当字线给出低电平时浮栅MOS管截止，位线上输出高电平。 在写入状态下 若浮置栅GfG_fGf​ 的充电是利用雪崩注入的方法实现的：GeG_eGe​加正脉冲，DDD加高电压，SSS加0电平，D−SD-SD−S直接雪崩击穿，高速电子到达浮置栅GfG_fGf​ 在擦除状态下 GeG_eGe​置0，SSS加正脉冲，产生导电隧道，Ge−GfG_e-G_fGe​−Gf​之间电容小于Gf−SG_f-SGf​−S之间电容，脉冲电压加到隧道，浮置栅GfG_fGf​上电子被导走。 特点：擦除快，写入慢 七、存储器容量的扩展 位扩展方式：直接联结 例如：用8片 1024×11024\\times11024×1 的 RAM 接成一个 1024×81024 \\times 81024×8 的RAM 对于ROM，除了上面没有 R/W′R/W&#x27;R/W′ 端之外，其余与RAM相同 字扩展方式：使用译码器加地址端口数量 例如：用4片256×8256\\times 8256×8 的RAM接成一个1024×81024\\times 81024×8 的RAM 增加两位地址代码A8A_8A8​和A9A _9A9​ 译码器输出与各个RAM的CS端相连 则有： 上述接法也适用于ROM","categories":[{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"存储模块","slug":"存储模块","permalink":"https://xqc-1368.github.io/tags/%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97/"},{"name":"RAM","slug":"RAM","permalink":"https://xqc-1368.github.io/tags/RAM/"},{"name":"ROM","slug":"ROM","permalink":"https://xqc-1368.github.io/tags/ROM/"}]},{"title":"03-1 存储电路：各种各样的触发器","slug":"03-1 存储电路：各种各样的触发器","date":"2024-08-19T09:44:09.420Z","updated":"2024-08-19T09:24:52.807Z","comments":true,"path":"2024/08/19/03-1 存储电路：各种各样的触发器/","permalink":"https://xqc-1368.github.io/2024/08/19/03-1%20%E5%AD%98%E5%82%A8%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"数字电子技术基础——半导体存储电路：触发器 一、触发器按照逻辑功能分类 触发器按照逻辑功能分类： SR触发，JK触发，T触发，D触发 1.SR触发： 功能 S为置位端（set），R为复位端（reset） 当S=1时，输出Q=1 当R=1时，输出Q=0 S,R不同时为1。S,R同时为0，保持上一个状态。 特性方程 {Q∗=S+R′QSR=0\\left\\{ \\begin{aligned} Q^{*} &amp; = S+R&#x27;Q \\\\ SR &amp;= 0 \\\\ \\end{aligned} \\right. {Q∗SR​=S+R′Q=0​ 状态转换图 2.JK触发器 功能 J为置位端，K为复位端 当J=1J=1J=1时，输出Q=1 当K=1K=1K=1时，输出Q=0 J,K之间不要求同时不为1。J,K同时为0，保持上一个状态。 J,K同时为1，时钟信号到达后 Q∗Q^*Q∗ 相比于 QQQ 发生翻转 特征方程 Q∗=JQ′+K′QQ^{*} = JQ&#x27;+K&#x27;Q Q∗=JQ′+K′Q 状态转换图 3.T触发器 功能：翻转 T为翻转信号输入端 当T=1时，输出信号在0-1之间翻转 当T=0时，输出信号保持 特征方程 Q∗=TQ′+T′QQ^{*} = TQ&#x27;+T&#x27;Q Q∗=TQ′+T′Q 状态转换图 4.D触发器 功能：指挥 为翻转信号输入端 当D=1时，Q=1或保持1 当D=0时，Q=0或保持0 特征方程 Q∗=DQ^{*} = D Q∗=D 状态转换图 二、触发器按照触发方式分类 1. 电平触发的触发器 介入功能 CLK=0时，不接受输入，保持原来状态 CLK=1时，接受输入，相应变化 2. 边沿触发的触发器 下降沿触发： 上升沿触发： 介入功能 CP信号为对应沿时，接受输入 CP信号不为对应沿时，不接受输入，保持原来状态 3. 脉冲触发器 下降沿脉冲触发 上升沿脉冲触发就是在C1外面接上一个 “。^。。” 介入功能 CP信号为对应沿沿前时，接受输入直至沿到达 CP信号为对应沿沿后时，不接受输入，保持原来状态直至相反沿到达开始接受输入 JK脉冲触发器在接受输入过程中输出信号只能翻转一次，而SR触发器可以根据脉冲区间S,R输入信号的改变多次翻转","categories":[{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"存储模块","slug":"存储模块","permalink":"https://xqc-1368.github.io/tags/%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97/"},{"name":"触发器","slug":"触发器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"}]},{"title":"02-3 数值比较器","slug":"02-3 数值比较器","date":"2024-08-19T09:44:09.411Z","updated":"2024-08-19T09:19:54.787Z","comments":true,"path":"2024/08/19/02-3 数值比较器/","permalink":"https://xqc-1368.github.io/2024/08/19/02-3%20%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83%E5%99%A8/","excerpt":"","text":"数值比较器 一、一位数值比较器 A=1，B=0时有A&gt;B： Y(A&gt;B)=AB′Y_{(A&gt;B)}=AB&#x27;Y(A&gt;B)​=AB′ A=0，B=1时有A&lt;B： Y(A&gt;B)=AB′Y_{(A&gt;B)}=AB&#x27;Y(A&gt;B)​=AB′ A=B=0或A=B=1时 即A⨀B=1A\\bigodot B=1A⨀B=1时有A=B： Y(A=B)=A⨀BY_{(A=B)}=A\\bigodot BY(A=B)​=A⨀B 如下图所示为其中一种实现方法： 二、多位数值比较器 Y(A&gt;B)=A3B3′+(A3⨀B3)A2B2′+(A3⨀B3)(A2⨀B2)A1B1′+(A3⨀B3)(A2⨀B2)(A1⨀B1)A0B0′+(A3⨀B3)(A2⨀B2)(A1⨀B1)(A0⨀B0)I(A&gt;B)Y_{(A&gt;B)}=A_3B&#x27;_3+(A_3\\bigodot B_3)A_2B&#x27;_2+(A_3\\bigodot B_3)(A_2\\bigodot B_2)A_1B&#x27;_1\\\\+(A_3\\bigodot B_3)(A_2\\bigodot B_2)(A_1\\bigodot B_1)A_0B&#x27;_0+(A_3\\bigodot B_3)(A_2\\bigodot B_2)(A_1\\bigodot B_1)(A_0\\bigodot B_0)I_{(A&gt;B)}Y(A&gt;B)​=A3​B3′​+(A3​⨀B3​)A2​B2′​+(A3​⨀B3​)(A2​⨀B2​)A1​B1′​+(A3​⨀B3​)(A2​⨀B2​)(A1​⨀B1​)A0​B0′​+(A3​⨀B3​)(A2​⨀B2​)(A1​⨀B1​)(A0​⨀B0​)I(A&gt;B)​ 简单的中国话理解：A&gt;B只能是最高位A3&gt;B3A_3&gt;B_3A3​&gt;B3​；或者最高位相等，第二位A2&gt;B2A_2&gt;B_2A2​&gt;B2​；或者最高位和第二位都相等，第三位A1&gt;B1A_1&gt;B_1A1​&gt;B1​；或者前面三位都相等，最后一位A0&gt;B0A_0&gt;B_0A0​&gt;B0​；或者这些位全部相等，来自低位的进位信号为I(A&gt;B)I_{(A&gt;B)}I(A&gt;B)​ 同理可以得到Y(A&lt;B)Y_{(A&lt;B)}Y(A&lt;B)​。 当然，也可以使用代入定理，因为上述已经有Y(A&gt;B)Y_{(A&gt;B)}Y(A&gt;B)​，而且显然Y(A=B)Y_{(A=B)}Y(A=B)​相对好算 （Y(A=B)=(A3⨀B3)(A2⨀B2)(A1⨀B1)(A0⨀B0)I(A=B)Y_{(A=B)}=(A_3\\bigodot B_3)(A_2\\bigodot B_2)(A_1\\bigodot B_1)(A_0\\bigodot B_0)I_{(A=B)}Y(A=B)​=(A3​⨀B3​)(A2​⨀B2​)(A1​⨀B1​)(A0​⨀B0​)I(A=B)​） 那么也就很好得出Y(A&lt;B)=(Y(A=B)+Y(A&gt;B))′Y_{(A&lt;B)}=(Y_{(A=B)}+Y_{(A&gt;B)})&#x27;Y(A&lt;B)​=(Y(A=B)​+Y(A&gt;B)​)′ 以上实现：4位数值比较器74HC85","categories":[{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"数值比较器","slug":"数值比较器","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83%E5%99%A8/"}]},{"title":"02-2 加法器与减法器","slug":"02-2 加法器与减法器","date":"2024-08-19T09:44:09.405Z","updated":"2024-08-19T09:18:32.630Z","comments":true,"path":"2024/08/19/02-2 加法器与减法器/","permalink":"https://xqc-1368.github.io/2024/08/19/02-2%20%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E5%87%8F%E6%B3%95%E5%99%A8/","excerpt":"","text":"加法器与减法器 一、实现异或门的一种好方法： 使用最少继电器实现（只用了6个继电器） 使用单种逻辑门实现（用了8个继电器） 二、一位加法器 半加器 半加器（半加就是只求本位的和，暂不管低位送来的进位数）的逻辑状态表 A B CO (进位信号) S (本位和) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 逻辑表达式： f(x)={S=A′B+AB′（异或）CO=ABf(x)=\\left\\{ \\begin{aligned} &amp;S=A&#x27;B+AB&#x27;（异或）\\\\ &amp;CO=AB \\end{aligned} \\right. f(x)={​S=A′B+AB′（异或）CO=AB​ 实现如下：（需要8个继电器） 全加器（Full Adder） 将对应位的加数和来自低位进位的3个数相加 使用半加器实现全加器（需要18个继电器：8×2+2=188\\times2+2=188×2+2=18） 值得注意的是，两个半加器的输出不可能全为1，所以将两个进位信号相或，即可得到输出。 二、多位加法器 串行进行的多位加法器 缺点：运算速度慢（下图展示的是4位串行进位加法器） 超前进位加法器（74HC283） 下图为一全加器真值表： CI A B S CO 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 先计算 COiCO_iCOi​： 可见：(CO)i=AiBi+(Ai+Bi)(CI)i(CO)_i=A_iB_i+(A_i+B_i)(CI)_i(CO)i​=Ai​Bi​+(Ai​+Bi​)(CI)i​ 定义： 进位生成函数 Gi=AiBiG_i=A_iB_iGi​=Ai​Bi​ 进位传送函数Pi=(Ai+Bi)P_i=(A_i+B_i)Pi​=(Ai​+Bi​) 则上述式子可以化简为 (CO)i=Gi+PiCIi(CO)_i=G_i+P_iCI_i(CO)i​=Gi​+Pi​CIi​ 由于CIi=COi−1CI_i=CO_{i-1}CIi​=COi−1​ 迭代可得： (CO)i=Gi+PiGi−1+PiPi−1Gi−2+...+PiPi−1...P1G0+PiPi−1...P0(CI0)(CO)_i=G_i+P_iG_{i-1}+P_iP_{i-1}G_{i-2}+...+P_iP_{i-1}...P_1G_0+P_iP_{i-1}...P_0(CI_0)(CO)i​=Gi​+Pi​Gi−1​+Pi​Pi−1​Gi−2​+...+Pi​Pi−1​...P1​G0​+Pi​Pi−1​...P0​(CI0​) 实际上在搭建过程中是将原始式子中所有的部分反向后完成，即有： (CO)i′=Gi′+Pi′Gi−1′+Pi′Pi−1′Gi−2′+...+Pi′Pi−1′...P1′G0′+Pi′Pi−1′...P0′(CI0)′(CO)&#x27;_i=G&#x27;_i+P&#x27;_iG&#x27;_{i-1}+P&#x27;_iP&#x27;_{i-1}G&#x27;_{i-2}+...+P&#x27;_iP&#x27;_{i-1}...P&#x27;_1G&#x27;_0+P&#x27;_iP&#x27;_{i-1}...P&#x27;_0(CI_0)&#x27;(CO)i′​=Gi′​+Pi′​Gi−1′​+Pi′​Pi−1′​Gi−2′​+...+Pi′​Pi−1′​...P1′​G0′​+Pi′​Pi−1′​...P0′​(CI0​)′ 即：(CO)i=(Gi′+Pi′Gi−1′+Pi′Pi−1′Gi−2′+...+Pi′Pi−1′...P1′G0′+Pi′Pi−1′...P0′(CI0)′)′(CO)_i=(G&#x27;_i+P&#x27;_iG&#x27;_{i-1}+P&#x27;_iP&#x27;_{i-1}G&#x27;_{i-2}+...+P&#x27;_iP&#x27;_{i-1}...P&#x27;_1G&#x27;_0+P&#x27;_iP&#x27;_{i-1}...P&#x27;_0(CI_0)&#x27;)&#x27;(CO)i​=(Gi′​+Pi′​Gi−1′​+Pi′​Pi−1′​Gi−2′​+...+Pi′​Pi−1′​...P1′​G0′​+Pi′​Pi−1′​...P0′​(CI0​)′)′ 而从全加器的真值表也可以得出 SiS_iSi​ 的逻辑表达式: Si=(AiBi′+Ai′Bi)(CI)i′+(AiBi+Ai′Bi′)(CI)iS_i=(A_iB&#x27;_i+A&#x27;_iB_i)(CI)&#x27;_i+(A_iB_i+A&#x27;_iB&#x27;_i)(CI)_iSi​=(Ai​Bi′​+Ai′​Bi​)(CI)i′​+(Ai​Bi​+Ai′​Bi′​)(CI)i​ 也就是：Si=Ai⊕Bi⊕(CI)iS_i=A_i\\oplus B_i \\oplus (CI)_iSi​=Ai​⊕Bi​⊕(CI)i​ 三、减法器 1. 十进制数对9的补数（反码）与对10的补数（补码） 减法运算变为加法运算：求对9 的补数 如果计算：253-176 相当于计算： 253 + (999-176)+1-1000 循环排序的实现法：对所有数取10的补数 10的补数=9的补数＋1 -500 -499 … -1 0 1 … 498 499 500 500 501 … 999 000 001 … 498 499 500 2. 二进制数对1的补数（二进制反码）和对2的补数（二进制补码） （1）异或门搭建的求补器 由于异或门的工作方式： XOR 0 1 0 0 1 1 1 0 当取反信号为0时，不取反，执行左边一列；当取反信号为1时， 取反，执行右边一列。 集成之后如下图： 二进制减法器的实现如下： 当SUB信号输入0时，表相加。当SUB信号输入1时，表相减。 先看SUB=0的情况： 求补器不工作，输出与输入相同。即正常地把两个数相加。CI输入也是0。 而且输出的CO信号与SUB信号作异或运算，即当SUB=0，有输出信号Y=CO 若Y=1，则表示运算上溢（表示加法中得到的值大于八位二进制能表示的最大数字255）。 再看SUB=1的情况： 求补器工作，输出与输出反向。输入的B7B_7B7​$B_0$是取反之后的结果。这时`CI`的输入为1，加上后表示$B_7$B0B_0B0​取反结果＋1 A7A_7A7​~A0A_0A0​表示的数为正数，补码为其本身。加法器相当于把两者的补码相加。 得到的和输出的是相减之后的结果（这怎么理解，见下） 比如253-176=77得到的是正数，没有下溢。 253 用二进制表示为1111 1101（也是它的补码） 176用二进制表示为1011 0000 -176的八位二进制补码为0101 0000 求和得到：1 0100 1101 （可见如果结果为正，是一定能溢出一位的，因为溢出是来源于我加上去的那个256，连0加上256 ，都能溢出一位。而假如结果没有溢出，只能说明结果本来就是负数） 这样算相当于253+（256-176）-256（-256的操作依靠取后8位实现） 又比方说176-253=-77，得到的是负数 176的二进制：1011 0000 -253的补码：0000 0011 求和后：1011 0011 （注意：这是179的二进制，求得-79的二进制需要在对这个数取反加一） 由上面这段文字可知，结果的CO位体现着结果的正负性。当CO为1的时候，表示输出的是正数；当CO为0的时候，表示输出的是负数。 当CO等于0的时候，我们只知道他是负的，不知道具体是多少，后续还要再对该数字做取反加一的后续操作，才能得到-77中的“77”这个信息。 当我们已经得到了176+（256-253）后： 后续的取反加一实际上是在做这个：256-（176+（256-253）） 写在最后的注意事项： 无符号八位二进制数表示范围为：0~255 有符号八位二进制数表示范围为：-128~127","categories":[{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"加法器与减法器","slug":"加法器与减法器","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E5%87%8F%E6%B3%95%E5%99%A8/"}]},{"title":"02-1 编码器、译码器与数据选择器","slug":"02-1 编码器、译码器与数据选择器","date":"2024-08-19T09:44:09.400Z","updated":"2024-08-19T08:59:39.204Z","comments":true,"path":"2024/08/19/02-1 编码器、译码器与数据选择器/","permalink":"https://xqc-1368.github.io/2024/08/19/02-1%20%E7%BC%96%E7%A0%81%E5%99%A8%E3%80%81%E8%AF%91%E7%A0%81%E5%99%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"02-1 编码器与译码器 一、编码器 功能：将输入的每一个高、低电平信号编成一个对应的二进制代码。 1、普通编码器 在普通编码器中，任何时刻只允许输入一个编码信号 2、优先编码器 允许同时输入两个以上的编码信号，但编码器早已将所有信号的优先级排了顺序，同时出现多个信号时，仅对其中优先权最高的一个进行编码。 （1）下图为：8线-3线优先编码器74HC148 功能介绍： 1‘ 启动端S‘ ：当输入低电平时候才能启动；输入高电平电路不工作，所有输出端置为1. 2’ 启动端S’ 置0时，电路工作： 选通输出端YS′Y&#x27;_SYS′​为0，扩展端YEX′Y&#x27;_{EX}YEX′​为1时意味着：检测到电路虽然被启动，但是没有输入。 选通输出端YS′Y&#x27;_SYS′​为1，扩展端YEX′Y&#x27;_{EX}YEX′​为0时意味着：检测到电路启动，且有输入，此时Y2′Y&#x27;_2Y2′​~Y1′Y&#x27;_1Y1′​ 为有效输出，可以读取。 功能表格如下：注意看，下面所有的内容(包括输入输出)都是“非”之后的结果。I7I_7I7​优先级最高 （2）下图为：二 - 十进制优先编码器74HC147 其功能较为简单，如下： 二、译码器 使用与非门搭建的3线-8线译码器74HC138 功能表如下： 启动信号需求：S1S_1S1​置1，S2S_2S2​和S3S_3S3​置0（有一个是0即可，当然，一般是让两个都是0） 对应的，也有二 - 十进制译码器74HC42 三、数据选择器 经典的二选一数据选择器 二选一数据选择器的逻辑表达式： $Y=SEL \\cdot A+SEL’ \\cdot B $ 双4选1数据选择器的74HC153 逻辑式： Y1=[D10(A1′A0′)+D11(A1′A0′)+D12(A1′A0′)+D13(A1′A0′)]⋅S1Y_1=[D_{10}(A&#x27;_1A&#x27;_0)+D_{11}(A&#x27;_1A&#x27;_0)+D_{12}(A&#x27;_1A&#x27;_0)+D_{13}(A&#x27;_1A&#x27;_0)]\\cdot S_1Y1​=[D10​(A1′​A0′​)+D11​(A1′​A0′​)+D12​(A1′​A0′​)+D13​(A1′​A0′​)]⋅S1​ Y2=[D20(A1′A0′)+D21(A1′A0′)+D22(A1′A0′)+D23(A1′A0′)]⋅S2Y_2=[D_{20}(A&#x27;_1A&#x27;_0)+D_{21}(A&#x27;_1A&#x27;_0)+D_{22}(A&#x27;_1A&#x27;_0)+D_{23}(A&#x27;_1A&#x27;_0)]\\cdot S_2Y2​=[D20​(A1′​A0′​)+D21​(A1′​A0′​)+D22​(A1′​A0′​)+D23​(A1′​A0′​)]⋅S2​","categories":[{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"译码器","slug":"译码器","permalink":"https://xqc-1368.github.io/tags/%E8%AF%91%E7%A0%81%E5%99%A8/"},{"name":"编码器","slug":"编码器","permalink":"https://xqc-1368.github.io/tags/%E7%BC%96%E7%A0%81%E5%99%A8/"},{"name":"数据选择器","slug":"数据选择器","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"01 数制与码制","slug":"01 数制与码制","date":"2024-08-19T09:44:09.394Z","updated":"2024-08-19T08:56:44.609Z","comments":true,"path":"2024/08/19/01 数制与码制/","permalink":"https://xqc-1368.github.io/2024/08/19/01%20%E6%95%B0%E5%88%B6%E4%B8%8E%E7%A0%81%E5%88%B6/","excerpt":"","text":"数字电子技术基础——数制与码制 一、二进制及其转换 二进制，是在数学和数字电路中以2为基数的记数系统，是以2为基数代表系统的二进位制。这一系统中，通常用两个不同的符号0和1来表示 。 1.整数的 X进制-二进制 转换： 十转二： X转十： 难点1：带有小数的二进制数转十进制： (101.11)2=1×22+0×21+1×20+1×2−1+1×2−2=(5.75)10(101.11)_2=1\\times2^2+0\\times2^1+1\\times2^0+1\\times2^{-1}+1\\times2^{-2}=(5.75)_{10}(101.11)2​=1×22+0×21+1×20+1×2−1+1×2−2=(5.75)10​ 难点2：带有小数的十进制数转二进制： 分别计算整数和小数部分： 整数部分按照上述方法计算 小数部分：将原数字乘2，取其整数部分；小数部分乘2，取其整数部分；如此循环直到小数部分不存在为止。最后将每一轮所取得的整数部分顺序排列 2. 十六、八进制与二进制的转化 二进制四位一组对应十六进制一位，二进制三位一组对应八进制一位，不足补齐前导0 二、二进制的朴素的乘除运算 二进制乘法：正常乘就行 二进制除法：“减”-“右移”-“减”-“右移”-“减”-“右移”-“减”-“右移”-“减”循环 三、利用补码实现二进制数加减法 原码：带符号的二进制数 反码：原码除了符号位之外取反得到，记为(N)INV(N)_{INV}(N)INV​ 补码：补码=模数+真值（超出模数则舍弃一个模数）。 用补码相加代替减法运算使得避开比较环节，记为(N)COMP(N)_{COMP}(N)COMP​ 例子：5是-7对模12的原码 难点4：原码和补码间的转换方式 原码转换为补码（将实际数值转换为补码以便在计算机中表示）： 如果原码表示的是一个正数，补码=原码。 如果原码表示的是一个负数，补码=原码除符号位取反＋1 补码转换为原码（从补码得到实际数值）： 如果补码的最高位（符号位）是0，那么它表示的是一个正数，原码就是补码本身。 如果补码的最高位是1，那么它表示的是一个负数，原码=补码除符号位取反＋1 难点5：进位溢出到符号位的处理方式：添加位数 例：用补码方式计算-13+10 13和10都可以用4位二进制数表示，加上一位符号位，考虑结果超过16可能性（后面算-13-10的时候会有，用5位试试看就知道会出问题），此处采用六位二进制数字表示 其中-13的原码为1-01101，10的原码为0-01010 由此可以得到二者的补码： 其中 -13的补码为1-10011，10的原码为0-01010（注意10是正数，补码等于本身） 补码相加：（在相加过程中符号位参与运算，出现符号进位的情况后面再说） −131−10011 100−01010−−−−−−−−−−−− −31−11101-13\\quad1-10011\\\\ \\ \\ \\ 10\\quad0-01010\\\\ ------------\\\\ \\ \\ -3\\quad1-11101 −131−10011 100−01010−−−−−−−−−−−− −31−11101 注意此处得到的是-3的补码，要翻译回原码，由于第一项为符号位，为1，则对后面的取反＋1，得到1-00011，即为-3的原码。 −13 1−10011−10 1−10110−−−−−−−−−−−−−23(1) 1−11101-13\\quad\\quad\\ \\ 1-10011\\\\ -10\\quad\\quad\\ \\ 1-10110\\\\ ------------\\\\ -23\\quad(1)\\ \\ 1-11101 −13 1−10011−10 1−10110−−−−−−−−−−−−−23(1) 1−11101 注意！！！：二进制补码相加的时候，和的符号位等于两数符号位与来自最高位的进位相加的结果，而舍弃产生的进位。 以下为这句话的解释： 在二进制相加中，如果两个位相加的结果超过了当前位的表示范围，就会产生进位。对于补码相加，进位被舍弃，不参与最终结果的计算。这是因为补码的表示范围是固定的，超过该范围的进位部分将被忽略，以保持结果的正确性。 所以如果已经能够确定结果的范围，算出来的就一定是正确的了。只是其内部在取模，回环往复达到结果而已。 拓展：正溢出，负溢出与变形补码 变形补码就是多一个符号位，原来的0变00，11变11。 对加法而言，正负相加显然是不会溢出的。 那么对于正正相加，符号位为00、00，发生溢出时是上溢，应该会有进位到符号位上，会变成01。 而对于负负相加，符号位为11、11，此时两个数为2∗2(n+1)+x2*2^(n+1)+x2∗2(n+1)+x, 2∗2(n+1)+y2*2^(n+1)+y2∗2(n+1)+y, 因为x和y都是负数，两个相加结果会小于4∗2(n+1)4*2^(n+1)4∗2(n+1)，不溢出的时候高两位表示的应该是3∗2(n+1)3*2^(n+1)3∗2(n+1)，所以是11，而溢出的时候，x+y&lt;−2∗（n+1）x+y&lt;-2*（n+1）x+y&lt;−2∗（n+1），高两位表示的应该是2∗2(n+1)2*2^(n+1)2∗2(n+1)，对应10。 所以&quot;00&quot;、 “01”分别表示正数、正溢出（上溢），“11”、“10”表示负数、负溢出（下溢）。 四、码制 （一）等长编码 8421码 难点6：8421码（BCD码） 用四位二进制数对位表示十进制数，没有权值，是等长编码 例如：38 3： 0011 8： 1000 所以38：（00111000）8421BCD码（0011 1000）_{8421BCD码}（00111000）8421BCD码​ 格雷码 最大特点：相邻代码只有一位改变状态。 应用：路由器 （二）变长编码 哈夫曼编码 基于各个字母出现的频率进行不同长度的编码，出现频率小，编码长，表示不常用。适用于字典。","categories":[{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"数制与码制","slug":"数制与码制","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E5%88%B6%E4%B8%8E%E7%A0%81%E5%88%B6/"}]},{"title":"04-1 时序逻辑电路的分析和设计通式","slug":"04-1 时序逻辑电路的分析和设计通式","date":"2024-08-19T09:44:09.380Z","updated":"2024-08-19T09:43:45.584Z","comments":true,"path":"2024/08/19/04-1 时序逻辑电路的分析和设计通式/","permalink":"https://xqc-1368.github.io/2024/08/19/04-1%20%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1%E9%80%9A%E5%BC%8F/","excerpt":"","text":"数字电子技术基础：05 时序逻辑电路 一、同步时序逻辑电路的分析方法 电路图—&gt;三大方程—&gt;状态转换表—&gt;状态转换图 二、异步时序逻辑电路的分析方法 电路图—&gt;三大方程—&gt;状态转换表—&gt;状态转换图 三、同步时序逻辑电路的设计方法 状态转换图—&gt;合并化简法—&gt;规定状态，画出“次态”输出卡诺图—&gt;卡诺图的分解—&gt;处理自启动问题—&gt;列出三大方程—&gt;画出电路图","categories":[{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"时序逻辑电路","slug":"时序逻辑电路","permalink":"https://xqc-1368.github.io/tags/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/"}]},{"title":"07函数","slug":"07函数","date":"2024-08-19T04:23:45.921Z","updated":"2024-08-19T03:31:56.292Z","comments":true,"path":"2024/08/19/07函数/","permalink":"https://xqc-1368.github.io/2024/08/19/07%E5%87%BD%E6%95%B0/","excerpt":"","text":"基础笔记：07函数 1.函数定义、函数调用、函数原型 （1）定义：函数（Function）是C中模块化编程的最小单位； 一个C程序由一个或多个源程序文件组成 一个源程序文件由一个或多个函数组成 （2）函数的地位关系 函数是平等的 main()稍微特殊一点，C程序的执行从main函数开始。调用其他函数后流程回到main函数，在main函数中结束整个程序的运行 （3）函数的分类 标准库函数 ANSI/ISOC定义的标准库函数 符合标准的C语言编译器必须提供这些函数 函数的行为也要符合ANSI/ISOC定义 第三方库函数 其他厂商自行开发的C语言函数库 不在标准范围内，能扩充C语言的功能（图形、数据库等） 自定义函数 用户自己定义的函数 包装后，也可成为函数库，供别人使用 （4）程序设计中函数的功能 不局限于计算，还有判断推理 （5）函数定义方法 C/C++main函数返回值以及return 0的作用 main函数的返回值 main函数的返回值用于说明程序的退出状态。如果返回0，则代表程序正常退出。返回其它数字的含义则由系统决定。通常，返回非零代表程序异常退出。 素养阅读 2.函数的参数传递与返回值 （1）函数的参数传递和返回值 调用者通过函数名调用函数 有返回值时，可放到一个赋值表达式语句中 还可放到一个函数调用语句中，作为另一个函数的参数 （2）函数调用 函数定义时的参数，形式参数（Parameter），简称形参 函数调用时的参数，实际参数（Argument），简称实参 过程：每次执行函数调用时 现场保护并为函数的内部变量（包括形参）分配内存 把实参值复制给形参，单向传值（实参–&gt;形参） 实参与形参数目一致，类型匹配（否则类型自动转换） 现场保护 执行函数内语句 当执行到return语句或}时，从函数退出 从函数退出时 根据函数调用栈中保存的返回地址，返回到当次函数调用的地方 程序控制权交给调用者，返回值作为函数调用表达式的值 收回分配给函数内所有变量（包括形参）的内存 （3）函数原型 调用函数前先声明返回值类型、函数名和形参类型 有助于编译器对函数参数类型的匹配检查 区别： （4）函数封装（Encapsulation） 外界对函数的影响仅限于入口参数 函数对外界的影响仅限于一个返回值和数组、指针形参 如何增强程序的健壮性，使函数具有遇到不正确使用或非法数据输入时避免出错的能力？答：在函数的入口处，检查输入参数的合法性，同时，主程序增加对函数返回值的检验 （5）函数复用：就是用好几次 （6）断言（assert） 考虑使用断言的几种情况 检查程序中的各种假设的正确性 证实或测试某种不可能发生的状况确实不会发生 仅用于调试程序，不能作为程序的功能 Debug版有效 Release版失效 Debug和Release的区别 Debug：调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息 Release：发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件 Debug 版本： /MDd /MLd 或 /MTd 使用 Debug runtime library(调试版本的运行时刻函数库) /Od 关闭优化开关 /D “_DEBUG” 相当于 #define _DEBUG,打开编译调试代码开关(主要针对assert函数) /ZI 创建 Edit and continue(编辑继续)数据库，这样在调试过程中如果修改了源代码不需重新编译 /GZ 可以帮助捕获内存错误 /Gm 打开最小化重链接开关，减少链接时间 Release 版本： /MD /ML 或 /MT 使用发布版本的运行时刻函数库 /O1 或 /O2 优化开关，使程序最小或最快 /D “NDEBUG” 关闭条件编译调试代码开关(即不编译assert函数) /GF 合并重复的字符串，并将字符串常量放到只读内存，防止被修改 3.递归函数 （1）函数的嵌套调用 C语言规定函数不能嵌套定义 函数是相互平行的，该限制可以使编译器简单化 但可以嵌套调用 在调用一个函数的过程中又调用另一个函数 函数直接或间接调用自己，称为递归调用（RecursiveCall），这样的函数，称为递归函数（Recursive Function） （2）递归函数 字典是递归定义的典型实例 递归过程 函数调用栈 (5)递归方法编写程序的优点 符合人的思维习惯，逼近数学公式的表示 从编程角度来看，简洁、直观、精炼，易编、易懂、逻辑清楚，结构清晰、可读性好 （6）递归方法编写程序的缺点 增加了函数调用开销，每次调用都需参数传递、现场保护等，为函数使用的参数、局部变量等额外分配存储空间 耗费更多的时间和栈空间，时空效率低 重复计算多 4.变量的作用域与存储类型 变量的作用域 （Scope）:指在源程序中定义变量的位置及其能被读写访问的 范围，分为： 局部变量（Local Variable）:在语句块内（函数、复合语句）定义的变量 有效范围仅为该语句块（函数，复合语句） 仅能由语句块内的语句访问，退出语句块时释放内存，不再有效 全局变量（Global Variable )：在所有函数之外定义的变量 有效范围是从定义变量的位置开始，到本程序结束 假如变量同名… 并列语句块内各自定义（不同作用域）的变量同名互不干扰 形参和实参的作用域不同，互不干扰（改变形参对实参不影响） 局部变量与全局变量同名：局部变量屏蔽全局变量 只要作用域不同，新的声明屏蔽旧的声明 编译器如何区分不同作用域的同名变量？ 一个变量名能代表两个不同的值，仅当它能代表两个不同的内存地址 编译器通过将同名变量映射到不同的内存地址来实现作用域的划分局部变量和全局变量被分配的内存区域不同，因而内存地址也不同 形参和实参的作用域、内存地址不同，所以形参值的改变不会影响实参 可划分为四大内存分区：堆、栈、静态存储区和代码区。 堆区： 由程序猿手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请，堆的总大小为机器的虚拟内存的大小。 说明：new操作符本质上是使用了malloc进行内存的申请，new和malloc的区别如下： （1）malloc是C语言中的函数，而new是C++中的操作符。 （2）malloc申请之后返回的类型是void*，而new返回的指针带有类型。 （3）malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数。 栈区： 由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。整个程序的栈区的大小可以在编译器中由用户自行设定，VS中默认的栈区大小为1M，可通过VS手动更改栈的大小。64bits的Linux默认栈大小为10MB，可通过ulimit -s临时修改。 静态存储区： 静态存储区内的变量在程序编译阶段已经分配好内存空间并初始化。这块内存在程序的整个运行期间都存在，它主要存放静态变量、全局变量和常量。 注意： （1）这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。 （2）静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。 （3）字符串常量存储在静态存储区的常量区，字符串常量的名称即为它本身，属于常变量。 （4）数据区的具体划分，有利于我们对于变量类型的理解。不同类型的变量存放的区域不同。后面将以实例代码说明这四种数据区中具体对应的变量。 代码区： 存放程序体的二进制代码。比如我们写的函数，都是在代码区的。 示例代码： 12345678910111213int a = 0;//静态全局变量区char *p1; //编译器默认初始化为NULLvoid main()&#123; int b; //栈 char s[] = &quot;abc&quot;;//栈 char *p2 = &quot;123456&quot;;//123456在字符串常量区，p2在栈上 static int c =0; //c在静态变量区，0为文字常量，在代码区 const int d=0; //栈 static const int d;//静态常量区 p1 = (char *)malloc(10);//分配得来得10字节在堆区。 strcpy(p1, &quot;123456&quot;); //123456放在字符变量想串常量区，编译器可能会将它与p2所指向的&quot;123456&quot;优化成一个地方&#125; 以上所有代码，编译成二进制后存放于代码区，文字常量存放于代码区，是不可寻址的。 变量的存储类型 存储类型 数据类型 变量名; C存储类型关键字：auto（自动变量）、static（静态变量）(包括：静态局部变量，静态外部变量)、extern（外部变量）（编译器并不对其分配内存，只是表明“我知道了”）、register（寄存器变量） 全局变量（跟下面几类不是并列关系） 先看看定义：定义在函数外面的变量，就叫全局变量。 包括：普通全局变量 静态全局变量 跨文件引用全局变量(extern) 关于自动变量的解释 又叫动态局部变量（缺省类型），存在栈内。进入语句块时自动申请内存，退出时自动释放内存，离开函数，值就消失 关于外部变量的解释 全局变量在整个程序中起作用，如果程序包含多个程序文件模块，可以通过外部声明，使得全局变量的作用范围扩展到其他模块，也可以通过定义静态全局变量，使其作用范围仅限制在这个模块 全局变量只能被定义一次，如果其他模块要使用该全局变量，需要通过外部变量的声明。 外部变量声明格式： extern 变量名表； 只起说明作用，不分配存储单元，对应存储单元在全局变量定义时分配。 main.c 12345678910#include &lt;stdio.h&gt;int count ;extern void write_extern();int main()&#123; count = 5; write_extern();&#125; support.c 12345678#include &lt;stdio.h&gt;extern int count;void write_extern(void)&#123; printf(&quot;count is %d\\n&quot;, count);&#125; 关于静态局部变量的解释 静态局部变量在静态存储区内分配存储单元，在程序整个运行期间都不释放。而普通局部变量属于动态存储类别，存储在动态存储区空间，函数调用结束后即释放； 静态局部变量只初始化一次，以后每次调用函数时保留上次函数调用结束时的值。而自动变量每调用一次函数重新执行一次赋值语句； 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(对数值型变量)或空字符(对字符型变量)。而对自动变量来说，如果不赋初值，则它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的值是不确定的。 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域仍为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它的。 关于静态全局变量的解释 当程序只有一个文件模块，其与一般全局变量作用相同； 当程序有多个模块时，C语言静态全局变量的作用范围局限于该模块。 1）全局变量是不显式用static修饰的全局变量，但全局变量默认是动态的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。 2）全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。 静态全局变量有以下特点： 1.该变量在全局数据区分配内存； 2.未经初始化的静态全局变量会被程序自动初始化为0 3.静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 4.静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。 局部变量初始化时机问题： 首先，静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。 在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。 而在C中，初始化时在执行相关代码时才会进行初始化，~~*主要是由于C引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。*~~ **所以在C中是可以使用变量对静态局部变量进行初始化的。** 后面再来谈谈另一个问题，假如我们在一个循环中，定义了一个静态局部变量并进行初始化，循环过程中，编译器怎么知道当前的静态局部变量已经初始化过了呢？ 这个问题C和C++的处理方式也是不一样的。 C中编译器会直接跳过这一个语句，因为在编译的时候已经对静态局部变量进行过分配空间并初始化，所以代码执行过程中根本不需要再次执行。 而在C++中，编译器会在编译器分配内存后，在全局区域（当前静态局部变量的地址）附近同样分配一块空间，进行记录变量是否已经进行过初始化。之所以说附近是根据编译器不同，处理方式不同导致的。 关于寄存器变量的解释 在程序运行时，根据需要到内存中相应的存储单元中调用，如果一个变量在程序中频繁使用，例如循环变量，那么，系统就必须多次访问内存中的该单元，影响程序的执行效率。 因此，C语言\\C++语言还定义了一种变量，不是保存在内存上，而是直接存储在CPU中的寄存器中，这种变量称为寄存器变量。 1register int i=100; C编译程序会自动地将寄存器变量变为自动变量 对于VC编译器会自动优化，即使没有声明寄存器变量，VC也会自动优化。 对于GCC编译器就不会自动优化。 由于受硬件寄存器长度的限制，所以寄存器变量只能是char、int或指针型。 寄存器说明符只能用于说明函数中的变量和函数中的形参，因此不允许将外部变量或静态变量说明为&quot;register&quot; register变量使用的是硬件CPU中的寄存器，寄存器变量无地址，所以不能使用取地址运算符&quot;&amp;&quot;求寄存器变量的地址。 5.模块化程序设计方法：自顶向下","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"函数","slug":"函数","permalink":"https://xqc-1368.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"07 多态","slug":"07 多态","date":"2024-08-19T04:23:45.918Z","updated":"2024-08-19T04:25:39.449Z","comments":true,"path":"2024/08/19/07 多态/","permalink":"https://xqc-1368.github.io/2024/08/19/07%20%E5%A4%9A%E6%80%81/","excerpt":"","text":"06 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 1.虚函数和多态 在类的定义中，前面有 virtual 关键字的成员函数就是虚函数。 virtual 关键字只用在类定义里的函数声明中，写函数体时不用。 12345class base&#123; virtual int get();&#125;;int base::get()&#123;&#125; 2. 多态的两种表现形式 表现形式一：派生类的指针可以赋给基类指针。 通过基类指针调用基类和派生类中的同名虚函数时: （1）若该指针指向一个基类的对象，那么被调用是基类的虚函数； （2）若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制就叫做“多态”。 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;class CBase&#123; public: virtual void SomeVirtualFunction() &#123;cout&lt;&lt;&quot;base&quot;&lt;&lt;endl;&#125;&#125;;class CDerived : public CBase&#123; public: virtual void SomeVirtualFunction() &#123;cout&lt;&lt;&quot;derived&quot;&lt;&lt;endl;&#125;&#125;;int main()&#123; CDerived ODerived; CBase *p = &amp;ODerived; p-&gt;SomeVirtualFunction(); // 调用哪个虚函数取决于p指向哪种类型的对象 return 0;&#125; 以上的基类指针p指向派生类对象，所以调用的是派生类的成员函数 输出结果如下： 1derived 表现形式二：派生类的对象可以赋给基类引用 通过基类引用调用基类和派生类中的同名虚函数时: （1）若该引用引用的是一个基类的对象，那么被调用是基类的虚函数； （2）若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚数。 这种机制也叫做“多态”。 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;class CBase&#123; public: virtual void SomeVirtualFunction() &#123;cout&lt;&lt;&quot;base&quot;&lt;&lt;endl;&#125;&#125;;class CDerived : public CBase&#123; public: virtual void SomeVirtualFunction() &#123;cout&lt;&lt;&quot;derived&quot;&lt;&lt;endl;&#125;&#125;;int main()&#123; CDerived ODerived; CBase &amp;r = ODerived; r.SomeVirtualFunction(); // 调用哪个虚函数取决于r引用哪种类型的对象 return 0;&#125; 输出结果： 1derived 3. 构造函数和析构函数中调用虚函数 在构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数 派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数 4. 多态实现的关键 — 虚函数表 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的 多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。 5.虚析构函数 背景：通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数，但是，删除一个派生类的对象时，应该先调用派生类的析构函数，然后调用基类的析构函数。 解决办法：把基类的析构函数声明为virtual，派生类的析构函数可以virtual不进行声明。通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数 结论：一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成虚函数。或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。 注意：不允许以虚函数作为构造函数 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;class son&#123;public: virtual ~son() &#123; cout &lt;&lt; &quot;bye from son&quot; &lt;&lt; endl; &#125;;&#125;;class grandson : public son&#123;public: ~grandson() &#123; cout &lt;&lt; &quot;bye from grandson&quot; &lt;&lt; endl; &#125;;&#125;;int main()&#123; son *pson; pson = new grandson(); delete pson; return 0;&#125; 输出结果： 12bye from grandsonbye from son 执行grandson::~grandson()，引起执行son::~son()！！！ 6. 纯虚函数和抽象类 纯虚函数： 没有函数体的虚函数 1virtual void Print( ) = 0 ; //纯虚函数 抽象类：包含纯虚函数的类叫抽象类 抽象类只能作为基类来派生新类使用，不能创建抽象类的对象 抽象类的指针和引用可以指向由抽象类派生出来的类的对象 123A a; // 错，A 是抽象类，不能创建对象A *pa; // ok,可以定义抽象类的指针和引用pa = new A; // 错误, A 是抽象类，不能创建对象 在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。（翻译成人话就是：类里面但凡有一个纯虚函数，就只能算抽象类）","categories":[{"name":"OOP面向对象","slug":"OOP面向对象","permalink":"https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"OOP","slug":"OOP","permalink":"https://xqc-1368.github.io/tags/OOP/"},{"name":"多态","slug":"多态","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E6%80%81/"},{"name":"虚函数","slug":"虚函数","permalink":"https://xqc-1368.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"}]},{"title":"06 继承与派生","slug":"06 继承与派生","date":"2024-08-19T04:23:45.912Z","updated":"2024-08-19T03:21:23.476Z","comments":true,"path":"2024/08/19/06 继承与派生/","permalink":"https://xqc-1368.github.io/2024/08/19/06%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","excerpt":"","text":"继承与派生 1.定义 继承： 在定义一个新的类B时，如果该类与某个已有的类A相似(指的是B拥有A的全部特点)，那么就可以把A作为一个基类，而把B作为基类的一个派生类(也称子类)。 派生： 派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。 派生类一经定义后，可以独立使用，不依赖于基类。 派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public 在派生类的各个成员函数中，不能访问 基类中的private成员。 派生类写法： 1234class 派生类名：public 基类名&#123;&#125;; 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;// 基类 Shapeclass Shape &#123; public: void setWidth(int w) &#123;width = w;&#125; void setHeight(int h) &#123;height = h;&#125; protected: int width; int height;&#125;;// 基类 PaintCostclass PaintCost &#123; public: int getCost(int area) &#123;return area * 70;&#125;&#125;;// 派生类class Rectangle: public Shape, public PaintCost&#123; public: int getArea() &#123; return (width * height); &#125;&#125;;int main(void)&#123; Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; // 输出总花费 cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl; return 0;&#125; 2. 派生类对象的内存空间 派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。 3.类的两种关系——继承关系与复合关系 继承：“是”关系。 基类 A，B是基类A的派生类。 逻辑上要求：“一个B对象也是一个A对象”。 复合：“有”关系。（可能算下表中的组合关系？吧） 类C中“有”成员变量k，k是类D的对象，则C和D是复合关系 一般逻辑上要求：“D对象是C对象的固有属性或组成部分” 1234567891011class CPoint&#123; double x, y; friend class CCircle; //便于Ccirle类操作其圆心&#125;;class CCircle&#123; double r; CPoint center;&#125;; 复合关系的另一种写法：（可能算下表中的关联关系吧？） 例题：为“狗”类设一个“业主”类的对象指针；为“业主”类设一个“狗”类的对象指针数组。 12345678910class CMaster; //CMaster必须提前声明，不能先 //写CMaster类后写Cdog类class CDog&#123; CMaster *pm;&#125;;class CMaster&#123; CDog *dogs[10];&#125;; 3. 派生类覆盖基类成员 派生类可以定义一个和基类成员同名的成员，这叫覆盖。在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用域符号::。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class base&#123; public: int j;int i; void func()&#123;cout&lt;&lt;&quot;fuck&quot;&lt;&lt;endl;&#125;;&#125;;class derived : public base&#123; public: int i; void access(); void func()&#123;cout&lt;&lt;&quot;fucku&quot;&lt;&lt;endl;&#125;;&#125;;void derived::access()&#123; j = 5; //引用的是基类的j（只有一个j） i = 5; //引用的是派生类的 i base::i = 5; //引用的是基类的 i func(); //派生类的 base::func(); //基类的&#125;int main()&#123; derived obj; obj.i = 1; obj.base::i = 1; obj.access(); cout&lt;&lt;obj.j&lt;&lt;endl;//obj.j改成obj.base::j输出一样的结果 return 0;&#125; 输出结果： 123fuckufuck5 注：若在基类中加入int k;并且在access方法中加入k=3;则报错，因为派生类的成员函数无权访问基类的私有变量。 4. 类的保护成员 基类的private成员：可以被下列函数访问 基类的成员函数 基类的友元函数 基类的public成员：可以被下列函数访问 基类的成员函数 基类的友元函数 派生类的成员函数 派生类的友元函数 其他的函数 基类的protected成员：可以被下列函数访问 基类的成员函数 基类的友元函数 派生类的成员函数可以访问当前对象和其它对象的基类的保护成员 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Father&#123; private: int nPrivate; //私有成员 public: int nPublic; //公有成员 protected: int nProtected; // 保护成员&#125;;class Son : public Father&#123; void AccessFather() &#123; nPublic = 1; // ok; nPrivate = 1; // wrong nProtected = 1; // OK，访问从基类继承的protected成员 Son f; f.nProtected = 1; // ok &#125;&#125;;int main()&#123; Father f; Son s; f.nPublic = 1; // Ok s.nPublic = 1; // Ok f.nProtected = 1; // error f.nPrivate = 1; // error s.nProtected = 1; // error s.nPrivate = 1; // error return 0;&#125; 5. 派生类的构造函数 例如，我们写了以下 “昆虫”类 ： 123456789101112131415161718class Bug&#123; private: int nLegs; int nColor; public: int nType; Bug(int legs, int color); void PrintBug()&#123;&#125;;&#125;;class FlyBug : public Bug // FlyBug是Bug的派生类&#123; int nWings; public: FlyBug(int legs, int color, int wings);&#125;; 继承关系派生类的构造函数的写法： 对于类FlyBug而言，只能使用 初始化列表构造： 12345678910111213141516171819//Bug的构造函数没有关系，跟之前一样的Bug::Bug(int legs, int color)&#123; nLegs = legs; nColor = color;&#125;//错误的FlyBug构造函数FlyBug::FlyBug(int legs, int color, int wings)&#123; nLegs = legs; // 不能访问 nColor = color; // 不能访问 nType = 1; // ok nWings = wings;&#125;//正确的FlyBug构造函数：FlyBug::FlyBug(int legs, int color, int wings) : Bug(legs, color)&#123; nWings = wings;&#125; 使用时，即初始化对象时写法：FlyBug fb ( 2,3,4); 注意： 在创建派生类的对象时，需要调用基类的构造函数：初始化派生类对象中从基类继承的成员。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。 调用基类构造函数的两种方式 显式方式：在派生类的构造函数中，为基类的构造函数提供参数. derived::derived(arg_derived-list):base(arg_base-list) 隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的无参构造函数 派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。 考虑以下程序： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class Base&#123; public: int n; Base(int i) : n(i) &#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; constructed&quot; &lt;&lt; endl;&#125; ~Base() &#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; destructed&quot; &lt;&lt; endl;&#125;&#125;;class Derived : public Base&#123; public: Derived(int i) : Base(i) &#123;cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl;&#125; ~Derived() &#123;cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123; Derived Obj(3); return 0;&#125; 输出结果： 1234Base 3 constructedDerived constructedDerived destructedBase 3 destructed 6. 包含成员对象的派生类的构造函数写法 即：第一类复合关系的派生函数的构造函数的写法（关键在最后一行啊前面是铺垫） 也是使用初始化列表： 12345678910111213141516171819202122232425class Bug&#123; private: int nLegs; int nColor; public: int nType; Bug(int legs, int color); void PrintBug()&#123;&#125;;&#125;;class Skill&#123; public: Skill(int n) &#123;&#125;&#125;;class FlyBug : public Bug&#123; int nWings; Skill sk1, sk2; public: FlyBug(int legs, int color, int wings);&#125;;FlyBug::FlyBug(int legs, int color, int wings) : Bug(legs, color), sk1(5), sk2(color), nWings(wings)&#123;&#125; 7.封闭派生类对象的构造函数和析构函数的执行顺序 在创建派生类的对象时: 先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员； 再执行成员对象类的构造函数，用以初始化派生类对象中成员对象。 最后执行派生类自己的构造函数 在派生类对象消亡时： 先执行派生类自己的析构函数 再依次执行各成员对象类的析构函数 最后执行基类的析构函数 析构函数的调用顺序与构造函数的调用顺序相反。 8.public继承的赋值兼容规则 以public方式继承时，考虑以下程序段： 123456class base&#123;&#125;;class derived : public base&#123;&#125;;base b;derived d; 1） 派生类的对象可以赋值给基类对象 b = d; 2） 派生类对象可以初始化基类引用 base &amp; br = d; 3） 派生类对象的地址可以赋值给基类指针 base * pb = &amp; d; 如果派生方式是 private或protected，则上述三条不可行。 protected继承和private继承： 123456class base&#123;&#125;;class derived : protected base&#123;&#125;;base b;derived d; protected继承时，基类的public成员和protected成员成为派生类的protected成员。 private继承时，基类的public成员成为派生类的private成员，基类的protected成员成为派生类的不可访问成员。 protected和private继承不是“是”的关系。 9. 基类与派生类的指针强制转换 公有派生的情况下,派生类对象的指针可以直接赋值给基类指针： Base * ptrBase = &amp;objDerived; 因为基类指针指向基类对象的首地址，也就是指向派生类对象，而派生类的所有变量地址中前几个是基类变量所拥有的地址，但是因为指针是指向基类的指针，所有只能访问的内存是基类的那几个变量。 ptrBase指向的是一个Derived类的对象； *ptrBase可以看作一个Base类的对象，访问它的public成员直接通过ptrBase即可，但不能通过ptrBase访问objDerived对象中属于Derived类而不属于Base类的成员 即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有，而派生类中有的成员。 但是，通过强制指针类型转换，可以把ptrBase转换成Derived类的指针： 12Base * ptrBase = &amp;objDerived;Derived *ptrDerived = (Derived * ) ptrBase; 程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会出错。 10.直接基类和间接基类 在声明派生类时，只需要列出它的直接基类 派生类的成员包括： 派生类自己定义的成员 直接基类中的所有成员 所有间接基类的全部成员 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Base&#123; public: int n; Base(int i) : n(i) &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; constructed&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base &quot; &lt;&lt; n &lt;&lt; &quot; destructed&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123; public: Derived(int i) : Base(i) &#123; cout &lt;&lt; &quot;Derived constructed&quot; &lt;&lt; endl; &#125; ~Derived() &#123; cout &lt;&lt; &quot;Derived destructed&quot; &lt;&lt; endl; &#125;&#125;;class MoreDerived : public Derived&#123; public: MoreDerived() : Derived(4) &#123; cout &lt;&lt; &quot;More Derived constructed&quot; &lt;&lt; endl; &#125; ~MoreDerived() &#123; cout &lt;&lt; &quot;More Derived destructed&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; MoreDerived Obj; return 0;&#125; 输出结果： 123456Base 4 constructedDerived constructedMore Derived constructedMore Derived destructedDerived destructedBase 4 destructed 11. 多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： 1234class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123;&lt;派生类类体&gt;&#125;; 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;// 基类 Shapeclass Shape &#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;// 基类 PaintCostclass PaintCost &#123; public: int getCost(int area) &#123; return area * 70; &#125;&#125;;// 派生类class Rectangle: public Shape, public PaintCost//多继承&#123; public: int getArea() &#123; return (width * height); &#125;&#125;;int main(void)&#123; Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; // 输出总花费 cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl; return 0;&#125; 输出结果： 12Total area: 35Total paint cost: $2450 附录：Python面向对象程序设计菜鸟教程链接Python 面向对象 | 菜鸟教程 (runoob.com)","categories":[{"name":"OOP面向对象","slug":"OOP面向对象","permalink":"https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"OOP","slug":"OOP","permalink":"https://xqc-1368.github.io/tags/OOP/"},{"name":"继承与复合关系","slug":"继承与复合关系","permalink":"https://xqc-1368.github.io/tags/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/"},{"name":"派生类","slug":"派生类","permalink":"https://xqc-1368.github.io/tags/%E6%B4%BE%E7%94%9F%E7%B1%BB/"}]},{"title":"05 流运算符和一元运算符的重载","slug":"05 流运算符和一元运算符的重载","date":"2024-08-19T04:23:45.905Z","updated":"2024-08-19T02:55:44.208Z","comments":true,"path":"2024/08/19/05 流运算符和一元运算符的重载/","permalink":"https://xqc-1368.github.io/2024/08/19/05%20%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/","excerpt":"","text":"1. 流插入运算符和流提取运算符的重载 cout 是在 iostream 中定义的，ostream 类的对象。 “&lt;&lt;” 能用在cout 上是因为，在iostream 里对 “&lt;&lt;” 进行了重载。 例题：假定c是Complex复数类的对象，现在希望写“cout &lt;&lt; c;”，就能以“a+bi”的形式输出c的值，写“cin&gt;&gt;c;”，就能从键盘接受“a+bi”形式的输入，并且使得c.real = a,c.imag = b。 解答： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;using namespace std;class Complex&#123; double real, imag;public: Complex(double r = 0, double i = 0) : real(r), imag(i)&#123;&#125;; friend ostream &amp;operator&lt;&lt;(ostream &amp;cout,const Complex &amp;c); friend istream &amp;operator&gt;&gt;(istream &amp;cin, Complex &amp;c);&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Complex &amp;c)&#123; cout &lt;&lt; c.real &lt;&lt; &quot;+&quot; &lt;&lt; c.imag &lt;&lt; &quot;i&quot;; //以&quot;a+bi&quot;的形式输出 return cout;&#125;istream &amp;operator&gt;&gt;(istream &amp;cin, Complex &amp;c)&#123; string s; cin &gt;&gt; s; //将&quot;a+bi&quot;作为字符串读入, “a+bi” 中间不能有空格 int pos = s.find(&quot;+&quot;, 0); //printf(&quot;%s\\n&quot;,s.c_str()); string sTmp = s.substr(0, pos); //分离出代表实部的字符串 c.real = stof(sTmp); // atof库函数能将const char*指针指向的内容转换成 float sTmp = s.substr(pos + 1, s.length() - 2); //分离出代表虚部的字符串 c.imag = stof(sTmp); return cin;&#125;int main()&#123; Complex c,n; cin &gt;&gt; c &gt;&gt; n; cout &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; n; return 0;&#125; 输入： 122+3i4+5i 输出结果： 12+3i,4+5i 2. 自增、自减运算符的重载和类型转换运算符 自增运算符++、自减运算符–有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，C++规定： 前置运算符作为一元运算符重载 重载为成员函数： T &amp; operator++(); T &amp; operator--(); 重载为全局函数： T1 &amp; operator++(T2); T1 &amp; operator—(T2); 后置运算符作为二元运算符重载，多写一个没用的参数： 重载为成员函数： T operator++(int); T operator--(int); 重载为全局函数： T1 operator++(T2,int ); T1 operator—( T2,int); 但是在没有后置运算符重载而有前置重载的情况下，在vs中，obj++ 也调用前置重载，而dev则令 obj ++ 编译出错 类型转换运算符： operator int ( ) &#123; return n; &#125; 这里，int 作为一个类型强制转换运算符被重载, 此后 12Demo s;(int) s ;//等效于 s.int(); 注意：类型强制转换运算符被重载时不能写返回值类型，实际上其返回值类型就是该类型强制转换运算符代表的类型 实际案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class CDemo&#123;private: int n;public: CDemo(int i = 0) : n(i) &#123;&#125; CDemo &amp;operator++(); //用于前置形式 CDemo operator++(int); //用于后置形式 operator int() &#123; return n; &#125; friend CDemo &amp;operator--(CDemo &amp;); friend CDemo operator--(CDemo &amp;, int);&#125;;CDemo &amp;CDemo::operator++()&#123; //前置 ++ n++; return *this;&#125; // ++s即为: s.operator++();CDemo CDemo::operator++(int k)&#123; //后置 ++ CDemo tmp(*this); //记录修改前的对象 n++; return tmp; //返回修改前的对象&#125; // s++即为: s.operator++(0);CDemo &amp;operator--(CDemo &amp;d)&#123; //前置-- d.n--; return d;&#125; //--s即为: operator--(s);CDemo operator--(CDemo &amp;d, int)&#123; //后置-- CDemo tmp(d); d.n--; return tmp;&#125; // s--即为: operator--(s, 0); int main()&#123; CDemo d(5);//因为写了类型转换运算符，所以以下所有输出检测到输出对象的时候能瞬间把对象转换成int，//于是就按照int类型输出 cout &lt;&lt; (d++) &lt;&lt; &quot;,&quot;; //等价于 d.operator++(0); cout &lt;&lt; d &lt;&lt; &quot;,&quot;; cout &lt;&lt; (++d) &lt;&lt; &quot;,&quot;; //等价于 d.operator++(); cout &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; (d--) &lt;&lt; &quot;,&quot;; //等价于 operator--(d,0); cout &lt;&lt; d &lt;&lt; &quot;,&quot;; cout &lt;&lt; (--d) &lt;&lt; &quot;,&quot;; //等价于 operator--(d); cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; 运算符重载的注意事项 C++不允许定义新的运算符 ； 重载后运算符的含义应该符合日常习惯； 运算符重载不改变运算符的优先级； 以下运算符不能被重载：“.”、“.*”、“::”、“?:”、sizeof； 重载运算符()、[]、-&gt;或者赋值运算符=时，运算符重载函数必须声明为类的成员函数。","categories":[{"name":"OOP面向对象","slug":"OOP面向对象","permalink":"https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"OOP","slug":"OOP","permalink":"https://xqc-1368.github.io/tags/OOP/"},{"name":"运算符重载","slug":"运算符重载","permalink":"https://xqc-1368.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"name":"流运算符","slug":"流运算符","permalink":"https://xqc-1368.github.io/tags/%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"04双向广度优先搜索：八数码难题","slug":"04双向广度优先搜索：八数码难题","date":"2024-08-19T04:23:45.901Z","updated":"2024-08-19T03:20:26.602Z","comments":true,"path":"2024/08/19/04双向广度优先搜索：八数码难题/","permalink":"https://xqc-1368.github.io/2024/08/19/04%E5%8F%8C%E5%90%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%9A%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/","excerpt":"","text":"双向广度优先搜索：八数码难题 八数码难题 题目描述 在 3×33\\times 33×3 的棋盘上，摆有八个棋子，每个棋子上标有 111 至 888 的某一数字。棋盘中留有一个空格，空格用 000 来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为 123804765123804765123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。 输入格式 输入初始状态，一行九个数字，空格用 000 表示。 输出格式 只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数。保证测试数据中无特殊无法到达目标状态数据。 样例 #1 样例输入 #1 1283104765 样例输出 #1 14 提示 样例解释 图中标有 000 的是空格。绿色格子是空格所在位置，橙色格子是下一步可以移动到空格的位置。如图所示，用四步可以达到目标状态。 并且可以证明，不存在更优的策略。 双向广度优先搜索： 我们常常会面临这样一类搜索问题：起点是给出的，终点也是已知的，需要确定能否从起点到达终点，如果可以，需要多少步。 如果我们用常规的搜索方法，从起点开始往下搜，那得到的解答树可能非常庞大，这样漫无目的的搜索就像大海捞针。 要从庞大的解答树中找到一根“针”，即终点，用蓝色表示 让我们切换一下思路，既然终点是已知的，我们何必让它闲着呢？我们完全可以分别从起点和终点出发，看它们能否相遇： 从起点和终点分别展开搜索，解答树瞬间缩小了很多 如果原本的解答树规模是 ，使用双向搜索后，规模立刻缩小到了约 ，当 较大时优化非常可观。 双向搜索主要有两种，双向BFS和双向迭代加深。 双向BFS 与普通的BFS不同，双向BFS维护两个而不是一个队列，然后轮流拓展两个队列。同时，用数组（如果状态可以被表示为较小的整数）或哈希表记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种标记同时标记时，搜索结束。 主要代码部分思想 1234567891011121314151617181920queue&lt;T&gt; Q[3]; // T要替换为用来表示状态的类型，可能为int，string还有bitset等bool found = false;Q[1].push(st); // st为起始状态Q[2].push(ed); // ed为终止状态for (int d = 0; d &lt; D + 2; ++d) // 这个我也不知道为什么这么写，//应该是设计一个最大深度&#123; int dir = (d &amp; 1) + 1, sz = Q[dir].size(); // 记录一下当前的搜索方向，1为正向，2为反向 for (int i = 0; i &lt; sz; ++i) &#123; auto x = Q[dir].front(); Q[dir].pop(); if (H[x] + dir == 3) // H是数组或哈希表，若H[x]+dir==3说明两个方向都搜到过这个点 found = true; H[x] = dir; // 这里需要把当前状态能够转移到的新状态压入队列 &#125; if (found) // ...&#125; 本题代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longint dx[4]=&#123;1,-1,0,0&#125;;int dy[4]=&#123;0,0,1,-1&#125;;unordered_map&lt;string,int&gt; H;//建立一个哈希表H用于记录当前状态是否被搜索过queue&lt;string&gt; q[3];//建立一个q[1],q[2]分别用于表示从前广搜和从后广搜的经历过的状态string justswap(string temp,int pos,int topos)&#123;//本函数用于交换字符串temp中pos位置和topos位置的值，返回一个字符串 if(topos&lt;pos)//如果顺序不对，换一下，保证pos&lt;topos &#123; int temp=topos; topos=pos; pos=temp; &#125; //切片，返回即可 string ret1=temp.substr(0,pos); string ret2=temp.substr(pos+1,topos-pos-1); string ret3=temp.substr(topos+1,temp.size()-topos); return ret1+temp[topos]+ret2+temp[pos]+ret3;&#125;signed main(void)&#123; string st; string ed = &quot;123804765&quot;; cin&gt;&gt;st; q[1].push(st);//1表示正向搜索 q[2].push(ed);//2表示反向搜索 int co=0; while(!q[1].empty() || !q[2].empty())//这个终止条件没什么用在这里 &#123; int direct=co%2+1;//co用于计数 int qs=q[direct].size();//要提前取出队列大小，不然一边向队列里 //添加元素，一边删元素，会出现混乱 for(int i=0;i&lt;qs;i++) &#123;//对direct方向的队列元素进行拓展 string temp=q[direct].front(); q[direct].pop(); if(H.count(temp))//如果temp状态已经被走过了 &#123;//如果没有被走过进不了下面这个if，则不处理，直接考察q[direct]的下一个元素 if(H[temp]+direct==3)//如果temp已经被另一个方向走过了 &#123; cout&lt;&lt;co-1&lt;&lt;endl;//输出步数，注意是co-1；//因为交汇的状态算了两次 exit(0); &#125; &#125; else //如果没有走过 &#123; H.insert(&#123;temp,direct&#125;);//插入键值对 int pos=temp.find(&#x27;0&#x27;);//找到0的位置 for(int i=0;i&lt;=3;i++)//在temp基础上往四个方向拓展 &#123; if((pos%3)+dx[i]&lt;0 || (pos%3)+dx[i]&gt;2 || pos+dy[i]*3&lt;0 || pos+dy[i]*3&gt;=9)continue; //处理越界情况 string t=justswap(temp,pos,pos+dx[i]+dy[i]*3); //往四个方向拓展 q[direct].push(t); //压入队列 &#125; &#125; &#125; co++; &#125; return 0;&#125; 一般形式（节选自oiwiki）(用一个队列写的方式，但是不适用于本题) 1234567891011121314将开始结点和目标结点加入队列 q标记开始结点为 1标记目标结点为 2while (队列 q 不为空)&#123; 从 q.front() 扩展出新的 s 个结点 如果 新扩展出的结点已经被其他数字标记过 那么 表示搜索的两端碰撞 那么 循环结束 如果 新的 s 个结点是从开始结点扩展来的 那么 将这个 s 个结点标记为 1 并且入队 q 如果 新的 s 个结点是从目标结点扩展来的 那么 将这个 s 个结点标记为 2 并且入队 q&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"算法/搜索","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xqc-1368.github.io/tags/BFS/"},{"name":"双向BFS","slug":"双向BFS","permalink":"https://xqc-1368.github.io/tags/%E5%8F%8C%E5%90%91BFS/"}]},{"title":"04 一般运算符与赋值符的重载","slug":"04 一般运算符与赋值符的重载","date":"2024-08-19T04:23:45.898Z","updated":"2024-08-19T03:18:38.044Z","comments":true,"path":"2024/08/19/04 一般运算符与赋值符的重载/","permalink":"https://xqc-1368.github.io/2024/08/19/04%20%E4%B8%80%E8%88%AC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%B5%8B%E5%80%BC%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD/","excerpt":"","text":"04运算符重载——运算符与赋值符 1. 基本概念 运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之 能作用于对象。 运算符重载的实质是函数重载 因此，既可以重载为普通函数，又可以重载为成员函数 解读时：把含运算符的表达式转换成对运算符函数的调用，把运算符的操作数转换成运算符函数的参数。运算符被多次重载时，根据实参的类型决定调用哪个运算符函数。 2. 运算符重载的形式 1234返回值类型 operator 运算符 ( 形参表 )&#123; ......&#125; 重载为成员函数时，参数个数为运算符目数减一（减掉的那个是作用的对象中前面一个）。 重载为普通函数时，参数个数为运算符目数。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class Complex&#123;public: double real, imag; Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) &#123;&#125; Complex operator-(const Complex &amp;c);&#125;;Complex operator+(const Complex &amp;a, const Complex &amp;b)&#123; return Complex(a.real + b.real, a.imag + b.imag); //返回一个临时对象&#125;Complex Complex::operator-(const Complex &amp;c)&#123; return Complex(real - c.real, imag - c.imag); //返回一个临时对象&#125;int main()&#123; Complex a(4, 4), b(1, 1), c; c = a + b; //等价于c=operator+(a,b); cout &lt;&lt; c.real &lt;&lt; &quot;,&quot; &lt;&lt; c.imag &lt;&lt; endl; cout &lt;&lt; (a - b).real &lt;&lt; &quot;,&quot; &lt;&lt; (a - b).imag &lt;&lt; endl; // a-b等价于a.operator-(b) return 0;&#125; 程序输出： 125,53,3 注意： c = a + b; 等价于c=operator+(a,b); a-b 等价于a.operator-(b) 3. 赋值运算符的重载 有时候希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个 char * 类型的字符串赋值给一个字符串对象,此时就需要重载赋值运算符“=”。 赋值运算符“=”只能重载为成员函数 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class String&#123; private: char *str; public: String() : str(new char[1]) &#123; str[0] = 0; &#125; const char *c_str() &#123; return str; &#125;; String &amp;operator=(const char *s); ~String() &#123; delete[] str; &#125;&#125;;String &amp;String::operator=(const char *s)&#123; //重载“=”以使得 obj = “hello”能够成立 delete[] str; str = new char[strlen(s) + 1]; strcpy(str, s); return *this;&#125;int main()&#123; String s; s = &quot;Good Luck,&quot;; //等价于 s.operator=(&quot;Good Luck,&quot;); cout &lt;&lt; s.c_str() &lt;&lt; endl; // String s2 = &quot;hello!&quot;; //这条语句要是不注释掉就会出错,因为这句话需要用到复制构造函数 s = &quot;Shenzhou 8!&quot;; //等价于 s.operator=(&quot;Shenzhou 8!&quot;); cout &lt;&lt; s.c_str() &lt;&lt; endl; return 0;&#125; 输出结果： 12Good Luck,Shenzhou 8! tips： C++中有参构造函数，拷贝构造函数和赋值运算符重载的区别和实现 1.拷贝构造函数（复制构造函数） 强调：这里b对象是不存在的，是用a 对象来构造和初始化b的！！ 123A a;A b(a);//或：A b=a; 都是拷贝构造函数来创建对象b 2.有参构造函数 当创建一个类的对象时，它被调用来对类的数据成员进行初始化和分配内存 1A a(2); 3.赋值运算符重载 当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。 当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作 123A a;A b;b=a; 强调：这里a,b对象是已经存在的，是用a 对象来赋值给b的！！ 赋值运算的重载声明如下： 1 A&amp; operator = (const A&amp; other) 通常大家会对拷贝构造函数和赋值函数混淆，这儿仔细比较两者的区别： 1）拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。 2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象 3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。（这些要点会在下面的String实现代码中体现） 4.浅拷贝、深拷贝 如不定义自己的赋值运算符，那么S1=S2实际上导致 S1.str和 S2.str指向同一地方。 问题： 如果S1对象消亡，析构函数将释放 S1.str指向的空间，则S2消亡时还要释放一次，不妥。 另外，如果执行 S1 = “other”；会导致S2.str指向的地方被delete 另外，考虑下面语句： 123String s;s = &quot;Hello&quot;;s = s; 如果不判定字符串是否完全相同，则导致等号左右两侧同时被析构，导致赋值出错 解决方案： 123456789String &amp;operator=(const String &amp;s)&#123; if (this == &amp;s) return *this; delete[] str; str = new char[strlen(s.str) + 1]; strcpy(str, s.str); return *this;&#125; 注意到，operator = 返回值类型为String&amp;类型，那么这里能不能使用void或String呢？ 考虑以下情况：a = b = c; 连等语句的撰写 当函数返回值为引用的时候才能放在等号左边，为了保留原风格的特性，于是使用引用。 则此时： a = b = c;等价于a.operator=(b.operator=(c)); (a=b)=c;等价于(a.operator=(b)).operator=(c); 引申：为了避免浅拷贝，于是我们写复制构造函数 12345String(String &amp;s)&#123; str = new char[strlen(s.str) + 1]; strcpy(str, s.str);&#125; 5.运算符重载为友元函数 需要知道的是：一般情况下，将运算符重载为类的成员函数，是较好的选择。 但有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。 考虑下面程序： 1234567891011class Complex&#123; double real, imag; public: Complex(double r, double i) : real(r), imag(i)&#123;&#125;; Complex operator+(double r);&#125;;Complex Complex::operator+(double r)&#123; //能解释 c+5 return Complex(real + r, imag);&#125; 经过上述重载后： 12Complex c ;c = c + 5; //有定义，相当于 c = c.operator +(5); 但是： c = 5 + c; //编译出错 所以，为了使得上述的表达式能成立，需要将 + 重载为普通函数 1234Complex operator+(double r, const Complex &amp;c)&#123; //能解释 5+c return Complex(c.real + r, c.imag);&#125; 但是普通函数又不能访问私有成员，所以，需要将运算符 + 重载为友元。 12345678class Complex&#123; double real, imag; public: Complex(double r, double i) : real(r), imag(i)&#123;&#125;; Complex operator+(double r); friend Complex operator+(double r, const Complex &amp;c);&#125;; 项目练习：动态数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;//写一个动态内存数组//析构函数//构造函数//复制构造函数class CArray&#123; int len; int *p; public: CArray(int s=0);//有参构造函数 ~CArray();//析构函数 CArray(CArray &amp;a);//复制构造函数 void push_back(int ele);//push_back函数 int length(); // length函数 CArray &amp;operator=(const CArray &amp;a);//=重载 int &amp;operator[](int i);//[]重载 void display() &#123; for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;;CArray::CArray(CArray &amp;a)&#123; if(!a.p) &#123; p=NULL; len=0; return; &#125; len=a.len; p=new int[len]; memcpy(p,a.p,sizeof(int)*len);&#125;CArray :: CArray(int s)&#123; len=s; if(len==0)p=NULL; else p=new int [len];&#125;CArray ::~CArray()&#123; if(p)delete[]p;&#125;void CArray::push_back(int ele)&#123; if(p) &#123; int *tp = new int[len+ 1]; //重新分配空间 memcpy(tp, p, sizeof(int) * len); //拷贝原数组内容 delete[] p; p = tp; &#125; else &#123; p=new int[1]; &#125; p[len]=ele; ++len;&#125;int CArray::length()&#123; return len;&#125;int &amp;CArray::operator[](int i)&#123; return p[i];&#125;CArray &amp;CArray::operator=(const CArray &amp;a)&#123; if(p==a.p) &#123; return *this; &#125; if(a.p==NULL) &#123; len = 0; if(p)delete []p; p=NULL; return *this; &#125; if(a.len&gt;len) &#123; if(p) delete[] p; p = new int[a.len]; &#125; len=a.len; memcpy(p,a.p,sizeof(int)*a.len); return *this;&#125;int main(void)&#123; //要编写可变长整型数组类，使之能如下使用： CArray a; //开始里的数组是空的 for (int i = 0; i &lt; 5; ++i) &#123; a.push_back(i);//push_back函数 &#125; a.display(); CArray a2, a3; a2 = a;//赋值符号重载 a2.display(); a2 = a3; // a2是空的 a3.display(); a[3] = 100;//[]重载 CArray a4(a); a4.display(); return 0;&#125; 输出结果： 12340 1 2 3 4 0 1 2 3 40 1 2 100 4","categories":[{"name":"OOP面向对象","slug":"OOP面向对象","permalink":"https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"OOP","slug":"OOP","permalink":"https://xqc-1368.github.io/tags/OOP/"},{"name":"运算符重载","slug":"运算符重载","permalink":"https://xqc-1368.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"}]},{"title":"02Bucket思想：A-B 数对","slug":"02Bucket思想：A-B 数对","date":"2024-08-19T04:23:45.894Z","updated":"2024-08-19T02:47:32.552Z","comments":true,"path":"2024/08/19/02Bucket思想：A-B 数对/","permalink":"https://xqc-1368.github.io/2024/08/19/02Bucket%E6%80%9D%E6%83%B3%EF%BC%9AA-B%20%E6%95%B0%E5%AF%B9/","excerpt":"","text":"好题记录2023.9-1 题目： A-B 数对 题目背景 出题是一件痛苦的事情！ 相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！ 题目描述 给出一串正整数数列以及一个正整数 CCC，要求计算出所有满足 A−B=CA - B = CA−B=C 的数对的个数（不同位置的数字一样的数对算不同的数对）。 输入格式 输入共两行。 第一行，两个正整数 N,CN,CN,C。 第二行，NNN 个正整数，作为要求处理的那串数。 输出格式 一行，表示该串正整数中包含的满足 A−B=CA - B = CA−B=C 的数对的个数。 样例 #1 样例输入 #1 124 11 1 2 3 样例输出 #1 13 提示 对于 75%75\\%75% 的数据，1≤N≤20001 \\leq N \\leq 20001≤N≤2000。 对于 100%100\\%100% 的数据，1≤N≤2×1051 \\leq N \\leq 2 \\times 10^51≤N≤2×105，0≤ai&lt;2300 \\leq a_i &lt;2^{30}0≤ai​&lt;230，1≤C&lt;2301 \\leq C &lt; 2^{30}1≤C&lt;230。 2017/4/29 新添数据两组 思路 O(n2)思路 楼下的题解讲的很清楚，就是将A−B=C变成A=B+C，朴素的算法是一个二重循环，当然我们知道这肯定会超时的。 O(nlogn)思路（笔者采用这个思路） 利用二分，一遍循环枚举找B，中间二分找C，时间复杂度O(nlogn)，可以通过本题 也可以利用stl中自带的红黑树map达到AC的效果 O(n)思路 优化一点的算法呢则是用桶去保存每个数，这样我们就只需要枚举B，然后判断一下C存不存在就行了，这样的时间复杂度是O(n)，当然此算法空间复杂度很高会MLE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;int binary_search_low(long long a[],long long key,long long low,long long high)&#123; long long i=low,mid; long long j=high,flag=-1; while(i&lt;=j) &#123; mid=(i+j)/2; if(a[mid]&gt;=key) &#123; j=mid-1; &#125; else &#123; i=mid+1; &#125; &#125; if(a[i]==key) &#123; flag=i; &#125; return flag;&#125;int binary_search_high(long long a[],long long key,long long low,long long high)&#123; long long i=low,mid; long long j=high,flag=-1; while(i&lt;=j) &#123; mid=(i+j)/2; if(a[mid]&gt;key) &#123; j=mid-1; &#125; else &#123; i=mid+1; &#125; &#125; if(a[j]==key) &#123; flag=j; &#125; return flag;&#125;int main(void)&#123; long long i,j,n,c,mid,flag1,ans=0,flag2; cin&gt;&gt;n&gt;&gt;c; long long a[n],key; for (int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for (int i=0;i&lt;n;i++) &#123; flag1=binary_search_high(a,a[i]+c,i+1,n-1); flag2=binary_search_low(a,a[i]+c,i+1,n-1); if(flag1!=-1 &amp;&amp; flag2!=-1) &#123; ans+=(flag1-flag2+1); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 当然sort部分可以编写快速排序，但是不给过，有两个测试点超时 以下内容看不懂 正题 好吧，前面讲了这么多都是为了告诉你各算法的优缺点，自然在目前来看，HASH解法是最优秀的（除了打表），那么具体怎样实现呢？ 实现 前面讲O(n)算法的时候，讲过用桶去做，这样的代价是用空间换时间，需要的空间代价是极高的，而HASH就是避免了这一点。 其实我们可以发现，桶数组中是有很多桶是没有用到的，也就是浪费了空间，比如有4个数 2 4 7 10001 用桶你就必须得开一个10001的数组，而用HASH只需要开一个长度为4的数组，它们的位置分别为 2%4=2 4%4=0 7%4=3 10001%4=1 在HASH表中表示为 0 1 2 3 4 10001 2 7 明白了吗？其实就是%一个数而已，若%的过程中，这个位置已经有数了，那么就放在它的后面就行了，以此类推。","categories":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}]},{"title":"02 类和对象：构造函数和析构函数","slug":"02 类和对象：构造函数和析构函数","date":"2024-08-19T04:23:45.887Z","updated":"2024-08-19T03:18:09.279Z","comments":true,"path":"2024/08/19/02 类和对象：构造函数和析构函数/","permalink":"https://xqc-1368.github.io/2024/08/19/02%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/","excerpt":"","text":"类 &amp; 对象 面向对象的程序设计： 面向对象的程序=类+类+…+类面向对象的程序 = 类 + 类 + …+ 类面向对象的程序=类+类+…+类 设计程序的过程，就是设计类的过程。 对象的内存分配：对象所占用的内存空间的大小，等于所有成员变量的大小之和。 求法：sizeof(类名) 对象之间的运算： 对象之间可以用 “=”进行赋值，但是不能用 “==”，“!=”，“&gt;”,“&lt;”“&gt;=”“&lt;=”进行比较，除非这些运算符经过了“重载”。 1.类的定义 类中的数据称为成员变量，函数称为成员函数。 类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。 定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 以下实例我们使用关键字 class 定义 Box 数据类型，包含了三个成员变量 length、breadth 和 height： 1234567class Box&#123; public: double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;; 关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected，这个我们稍后会进行讲解。 2.定义对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象： 12Box Box1; // 声明 Box1，类型为 BoxBox Box2; // 声明 Box2，类型为 Box 对象 Box1 和 Box2 都有它们各自的数据成员。 下面程序定义了一个roommate类，记录了几个人的睡觉时间和起床时间： 123456789101112131415class roommate&#123; public: int name,getup,sleep; int average_sleeptime(void); void Init(int _name,int _getup,int _sleep) &#123; name=_name;getup=_getup;sleep=_sleep; &#125;&#125;;int roommate ::average_sleeptime(void)&#123; if(sleep&lt;24 &amp;&amp; sleep&gt;12)return getup+24-sleep; else return getup-sleep;&#125; 3.访问数据成员 用法1：对象名.成员名 123CRectangle r1,r2;r1.w = 5;r2.Init(5,4); 用法2：指针-&gt;成员名 12345CRectangle r1,r2;CRectangle * p1 = &amp; r1;CRectangle * p2 = &amp; r2;p1-&gt;w = 5;p2-&gt;Init(5,4); //Init作用在p2指向的对象上 用法3：引用名.成员名 1234CRectangle r2;CRectangle &amp; rr = r2;rr.w = 5;rr.Init(5,4); //rr的值变了，r2的值也变 类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。 4.类成员的可访问范围 在类的定义中，用下列访问范围关键字来说明类成员可被访问的范围： private: 私有成员，只能在成员函数内访问 public : 公有成员，可以在任何地方访问 protected: 保护成员 注：三种关键字出现的次数和先后次序都没有限制 如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。 12345678910class Man &#123; int nAge; //私有成员 char szName[20]; // 私有成员 public: void SetName(char * szName) &#123; strcpy( Man::szName,szName); &#125; &#125;; 在类的成员函数内部，能够访问： 当前对象的全部属性、函数； 同类其它对象的全部属性、函数。 注：用struct定义类和用&quot;class&quot;的唯一区别，就是未说明是公有还是私有的成员，就是公有 5.成员函数的重载和参数缺省 成员函数也可以重载 成员函数可以带缺省参数。 1234567891011121314151617181920class Location &#123; private : int x, y; public: void init( int x=0 , int y = 0 ); void valueX( int val ) &#123; x = val ;&#125; int valueX() &#123; return x; &#125;&#125;;void Location::init( int X, int Y)&#123; x = X ; y = Y;&#125;int main() &#123; Location A,B; A.init(5); A.valueX(5); cout &lt;&lt; A.valueX(); return 0;&#125; 6.构造函数 定义：成员函数的一种： 名字与类名相同，可以有参数，不能有返回值(void也不行) 作用是对对象进行初始化，如给成员变量赋初值。 如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数。默认构造函数无参数，不做任何操作 如果定义了构造函数，则编译器不生成默认的无参数的构造函数。对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数 一个类可以有多个构造函数 系统自动生成的无参构造函数： 1234567891011class Complex &#123; private : double real, imag; public: void Set( double r, double i);//相当于系统自动在这里写了一个：（无参构造函数）// Complex();&#125;; //编译器自动生成默认构造函数Complex c1; //默认构造函数被调用Complex * pc = new Complex; //默认构造函数被调用 手写的带参构造函数： 12345678910111213141516class Complex &#123; private : double real, imag; public: Complex( double r, double i = 0);//提前定义，并写好缺省值&#125;; Complex::Complex( double r, double i) &#123; real = r; imag = i;&#125;Complex c1; // error, 缺少构造函数的参数Complex * pc = new Complex; // error, 没有参数Complex c1(2); // OKComplex c1(2,4), c2(3,5);Complex * pc = new Complex(3,4); 带参构造函数的重载： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class Complex&#123; public: double real, imag; void Set(double r, double i); Complex(double r, double i); Complex(double r); Complex(Complex c1, Complex c2);&#125;;Complex::Complex(double r, double i)&#123; real = r; imag = i;&#125;Complex::Complex(double r)&#123; real = r; imag = 0;&#125;Complex::Complex(Complex c1, Complex c2)&#123; real = c1.real + c2.real; imag = c1.imag + c2.imag;&#125;// c1 = &#123;3, 0&#125;, c2 = &#123;1, 0&#125;, c3 = &#123;4, 0&#125;;int main()&#123; Complex c1(3), c2(1, 0), c3(c1, c2); cout&lt;&lt;c1.real&lt;&lt;endl; return 0;&#125; 注：构造函数最好是public的，private构造函数不能直接用来初始化对象 12345678class CSample&#123; private: CSample() &#123;&#125;&#125;;int main()&#123;CSample Obj; //err. 唯一构造函数是privatereturn 0;&#125; 7.构造函数在数组中的使用 构造一个对象，就调用一次构造函数： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;class CSample&#123; int x; public: CSample()//（1）无参构造函数 &#123; cout &lt;&lt; &quot;Constructor 1 Called&quot; &lt;&lt; endl; &#125; CSample(int n)//（2）带参构造函数 &#123; x = n; cout &lt;&lt; &quot;Constructor 2 Called&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; CSample array1[2]; //构造两个无参对象，都使用（1） cout &lt;&lt; &quot;step1&quot; &lt;&lt; endl; CSample array2[2] = &#123;4, 5&#125;; //构造两个有参对象，都使用（2） cout &lt;&lt; &quot;step2&quot; &lt;&lt; endl; CSample array3[2] = &#123;3&#125;; //构造1个有参对象和1个无参对象，先使用（1），再使用（2） cout &lt;&lt; &quot;step3&quot; &lt;&lt; endl; CSample *array4 =new CSample[2]; //构造两个无参对象，都使用（1） delete[] array4; return 0;&#125; 以上程序输出： 1234567891011Constructor 1 CalledConstructor 1 Calledstep1Constructor 2 CalledConstructor 2 Calledstep2Constructor 2 CalledConstructor 1 Calledstep3Constructor 1 CalledConstructor 1 Called 单对象多参数的构造： 1234567891011121314class Test&#123; public: Test(int n) &#123;&#125; //(1) Test(int n, int m) &#123;&#125; //(2) Test() &#123;&#125; //(3)&#125;;// 三个元素分别用(1),(2),(3)初始化Test array1[3] = &#123; 1, Test(1,2) &#125;;//等价于：Test array1[3] = &#123;Test(1), Test(1, 2),Test()&#125;;//没有申请内存的不能算数Test * pArray[3] = &#123; new Test(4), new Test(1,2) &#125;;//两个元素（注意：是两个元素，不是三个）分别用(1),(2) 初始化 拓展：使用初始化列表来初始化字段 使用初始化列表来初始化字段： 1234Line::Line( double len): length(len)&#123; cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;&#125; 上面的语法等同于如下语法： 12345Line::Line( double len)&#123; length = len; cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;&#125; 假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示： 1234C::C( double a, double b, double c): X(a), Y(b), Z(c)&#123; ....&#125; 8.复制构造函数（copy constructor） 只有一个参数,即对同类对象的引用。 形如 X::X( X&amp; )或X::X(const X &amp;), 二者选一 后者能以常量对象作为参数 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能 注意： 不允许有形如 X::X( X ) or X ( X ) 的构造函数。 123class CSample &#123; CSample( CSample c ) &#123;&#125; //错，不允许这样的构造函数&#125;; 9.复制构造函数起作用的三种情况 1)当用一个对象去初始化同类的另一个对象时。 12Complex c2(c1);Complex c2 = c1; //初始化语句，非赋值语句 2)如果某函数有一个参数是类 A 的对象，那么该函数被调用时，类A的复制构造函数将被调用。 1234567891011121314class A &#123; public: A() &#123; &#125;; A( A &amp; a) &#123; cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt;endl; &#125;&#125;;void Func(A a1)&#123; &#125;int main()&#123; A a2; Func(a2); return 0;&#125; 12程序输出结果为: Copy constructor called 3)如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用: 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class A&#123;public: int v; A(int n) &#123; v = n; &#125;; A(const A &amp;a) &#123; v = a.v; cout &lt;&lt; &quot;Copy constructor called&quot; &lt;&lt; endl; &#125;&#125;;A Func()&#123; A b(4); return b;&#125;int main()&#123; cout &lt;&lt; Func().v &lt;&lt; endl; return 0;&#125; 这段程序理论上应该输出： 12Copy constructor called4 但实际上只输出了： 14 这是因为： C++ 函数返回值为对象时调用复制构造函数的问题 知识点： C++中调用复制构造函数的三种情况： 1.通过一个对象构造另一个对象 2.调用参数为对象的函数 3.调用返回值为对象的函数 – 上述知识点在各种书籍、博客都无不同，属于C++的标准 – 但是实际测试的时候，当调用返回值为对象的函数时，并未按预想地调用复制构造函数。 – 在查阅了很多博客资料后，原因如下： 当调用返回值为对象的函数时，系统消耗调用复制构造函数、调用构造函数，调用析构函数的代价，为了减少消耗，编译器使用了一项名为返回值优化的技术，使得调用函数时不需要调用复制构造函数 具体过程： 1234567891011121314151617181920class Person&#123; string name; int age; Person(string name,int age)&#123; this-&gt;name = age; this-&gt;age = age; &#125; //复制构造函数 Person(const Person&amp; p)&#123; cout&lt;&lt;&quot;调用复制构造函数&quot;; &#125;&#125;；//返回一个Person对象Person create(string name,int age)&#123; return new Person(name,age);&#125; int main()&#123; Person p = create(&quot;张三&quot;,20);&#125; 优化前：调用create函数时，先根据传入的参数生成一个临时对象 t1（栈中），然后拷贝生成临时对象 t2（栈外），函数执行完毕，返回 t2的地址，t1被回收；p根据返回的 t2 地址构造对象 优化后：调用create函数时，编译器偷偷地增加了一个参数，传入了p的地址，直接在函数内部构造了p对象 10.转换构造函数（Intconstructor） 定义转换构造函数的目的是实现类型的自动转换。 只有一个参数，而且不是复制构造函数的构造函数，一般就可以看作是转换构造函数。 当需要的时候，编译系统会自动调用转换构造函数，建立一个无名的临时对象(或临时变量)。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class Complex&#123;public: double real, imag; explicit Complex(int i)//显式类型转换构造函数 &#123; cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl; real = i; imag = 0; &#125; Complex(double r, double i) &#123; real = r; imag = i; &#125;&#125;;int main()&#123; Complex c1(7, 8); Complex c2 = Complex(12); c1 = 9; // error, 9不能被自动转换成一个临时Complex对象 c1 = Complex(9); // ok cout&lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl; return 0;&#125; 隐式类型转换构造函数： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Complex&#123;public: double real, imag; Complex(int i)//区别1 &#123; cout &lt;&lt; &quot;IntConstructor called&quot; &lt;&lt; endl; real = i; imag = 0; &#125; Complex(double r, double i) &#123; real = r; imag = i; &#125;&#125;;int main()&#123; Complex c1(7, 8); Complex c2 = 12;//区别2 c1 = 9; // 9被自动转换成一个临时Complex对象 cout &lt;&lt; c1.real &lt;&lt; &quot;,&quot; &lt;&lt; c1.imag &lt;&lt; endl; return 0;&#125; 11.析构函数（destructors） 名字与类名相同，在前面加 ~ ， 没有参数和返回值，一个类最多只能有一个析构函数。 析构函数对象消亡时即自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间等。 如果定义类时没写析构函数，则编译器生成缺省析构函数。缺省析构函数什么也不做。 如果定义了析构函数，则编译器不生成缺省析构函数。 析构函数实例： 12345678910111213141516class String&#123; private: char *p; public: String() &#123; p = new char[10]; &#125; ~String();&#125;;String ::~String()&#123; delete[] p;&#125; 析构函数被调用的几种情况： 1.对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。 12345678910111213#include &lt;iostream&gt;using namespace std;class Ctest&#123; public: ~Ctest() &#123; cout &lt;&lt; &quot;destructor called&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Ctest array[2]; cout &lt;&lt; &quot;End Main&quot; &lt;&lt; endl; return 0;&#125; 2.delete 运算导致析构函数调用。 12345678int main()&#123; Ctest *pTest; pTest = new Ctest;//构造函数调用 delete pTest;//析构函数调用 pTest = new Ctest[3]; //构造函数调用3次 delete[] pTest; //析构函数调用3次&#125; 若new一个对象数组，那么用delete释放时应该写 []。否则只delete一个对象(调用一次析构函数) 3.析构函数在对象作为函数返回值返回后被调用 1234567891011121314151617#include &lt;iostream&gt;using namespace std;class CMyclass&#123; public: ~CMyclass() &#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125;&#125;;CMyclass obj;CMyclass fun(CMyclass sobj)&#123; //参数对象消亡也会导致析构函数被调用 return sobj; //函数调用返回时生成临时对象返回&#125;int main()&#123; obj = fun(obj); //函数调用的返回值（临时对象）被 return 0; //用过后，该临时对象析构函数被调用&#125; 输出： 123destructordestructordestructor","categories":[{"name":"OOP面向对象","slug":"OOP面向对象","permalink":"https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"OOP","slug":"OOP","permalink":"https://xqc-1368.github.io/tags/OOP/"},{"name":"类和对象","slug":"类和对象","permalink":"https://xqc-1368.github.io/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"name":"构造函数和析构函数","slug":"构造函数和析构函数","permalink":"https://xqc-1368.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"}]},{"title":"01删除标记思想：队列安排","slug":"01删除标记思想：队列安排","date":"2024-08-19T04:23:45.883Z","updated":"2024-08-19T02:45:45.115Z","comments":true,"path":"2024/08/19/01删除标记思想：队列安排/","permalink":"https://xqc-1368.github.io/2024/08/19/01%E5%88%A0%E9%99%A4%E6%A0%87%E8%AE%B0%E6%80%9D%E6%83%B3%EF%BC%9A%E9%98%9F%E5%88%97%E5%AE%89%E6%8E%92/","excerpt":"","text":"队列安排 题目描述 一个学校里老师要将班上 NNN 个同学排成一列，同学被编号为 1∼N1\\sim N1∼N，他采取如下的方法： 先将 111 号同学安排进队列，这时队列中只有他一个人； 2∼N2\\sim N2∼N 号同学依次入列，编号为 iii 的同学入列方式为：老师指定编号为 iii 的同学站在编号为 1∼(i−1)1\\sim(i-1)1∼(i−1) 中某位同学（即之前已经入列的同学）的左边或右边； 从队列中去掉 MMM 个同学，其他同学位置顺序不变。 在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。 输入格式 第一行一个整数 NNN，表示了有 NNN 个同学。 第 2∼N2\\sim N2∼N 行，第 iii 行包含两个整数 k,pk,pk,p，其中 kkk 为小于 iii 的正整数，ppp 为 000 或者 111。若 ppp 为 000，则表示将 iii 号同学插入到 kkk 号同学的左边，ppp 为 111 则表示插入到右边。 第 N+1N+1N+1 行为一个整数 MMM，表示去掉的同学数目。 接下来 MMM 行，每行一个正整数 xxx，表示将 xxx 号同学从队列中移去，如果 xxx 号同学已经不在队列中则忽略这一条指令。 输出格式 一行，包含最多 NNN 个空格隔开的整数，表示了队列从左到右所有同学的编号。 样例 #1 样例输入 #1 123456741 02 11 0233 样例输出 #1 12 4 1 提示 【样例解释】 将同学 222 插入至同学 111 左边，此时队列为： 2 1 将同学 333 插入至同学 222 右边，此时队列为： 2 3 1 将同学 444 插入至同学 111 左边，此时队列为： 2 3 4 1 将同学 333 从队列中移出，此时队列为： 2 4 1 同学 333 已经不在队列中，忽略最后一条指令 最终队列： 2 4 1 【数据范围】 对于 20%20\\%20% 的数据，1≤N≤101\\leq N\\leq 101≤N≤10。 对于 40%40\\%40% 的数据，1≤N≤10001\\leq N\\leq 10001≤N≤1000。 对于 100%100\\%100% 的数据，1&lt;M≤N≤1051&lt;M\\leq N\\leq 10^51&lt;M≤N≤105。 Vector做法：在删除（O（n）不够方便）部分运用桶的思想，删除时“标记删除” 注：以下的queue仅仅为动态数组的名字，并不是队列，和队列没半毛钱关系 添加部分代码 123456789101112131415161718192021222324252627int n,k,p,end,x,m,k0=0,k1=0,flag=0;vector&lt;int&gt;::iterator iter;cin&gt;&gt;n;vector&lt;int&gt; queue(1,1);int del[100005] =&#123;0&#125;;for (int i=2;i&lt;=n;i++)&#123; cin&gt;&gt;k&gt;&gt;p; for(iter=queue.begin();iter!=queue.end();iter++) &#123; if(*iter==k)break;//iter为迭代器，用于遍历queue，寻找k号同学 k0++;//这个循环相当于find函数 &#125; if(p==0) &#123; queue.insert(queue.begin()+k0,i); k0=0; &#125; else if(p==1) &#123; queue.insert(queue.begin()+k0+1,i); k0=0; &#125;&#125; 重头戏：删除部分代码，看网友大佬如何用桶思想实现标记删除（在桶中标记所有现有的元素，然后用桶标记要删除的元素，实则在queue中并没有将该元素删除，而是在输出时候检测桶中这个元素是否已经被删除了，考虑是否输出，时间复杂度骤降，但只适用于每个元素只出现一次的情况，好处是与此同时可以实现删除时候的去重） 123456789101112131415161718192021cin&gt;&gt;m;for (int i=1;i&lt;=n;i++)&#123; del[i]=1;//由上一段代码可知，del是一个全为0的桶，此处赋值所有已存在在queue中的内容&#125;for (int i=0;i&lt;m;i++)&#123; cin&gt;&gt;x; del[x]=0;//用标记法“删除”元素x&#125;for (iter=queue.begin();iter!=queue.end();iter++)&#123; if(del[*iter]==1)//标记删除的元素不输出 &#123; cout&lt;&lt;*iter&lt;&lt;&quot; &quot;; &#125;&#125;cout&lt;&lt;endl;return 0; 需要的头文件： 12#include&lt;iostream&gt;#include&lt;vector&gt; 注意：本做法在www.luogu.com中仅开启吸氧O2才能通过，因此没有这么完美 List做法：在查找方面用索引的做法，记录每号同学的位置 索引查找仅限于用于链表，因为只有链表插入时是不改变其他同学的地址信息的，也就是说pos[?]的位置不用再一一修订。 以下片段为插入部分 12345678910111213141516171819202122const int maxN = 1e5 + 10;Iter pos[maxN];list&lt;int&gt; queList;bool erased[maxN];int N;queList.push_front(1);pos[1] = queList.begin(); for (int i = 2; i &lt;= N; i++) &#123; int k, p; scanf(&quot;%d%d&quot;, &amp;k, &amp;p); if (p == 0) &#123; pos[i] = queList.insert(pos[k], i); //left &#125; else &#123; auto nextIter = next(pos[k]); pos[i] = queList.insert(nextIter, i); //right &#125; &#125; pos[n]为索引数组，其内容为n的位置 在删除方面，直接使用内置函数即可，因为erase在list之中的复杂度较低，直接用没什么问题。 123456789101112int M; scanf(&quot;%d&quot;, &amp;M); for (int x, i = 1; i &lt;= M; i++) &#123; scanf(&quot;%d&quot;, &amp;x); if (!erased[x]) &#123; queList.erase(pos[x]); &#125; erased[x] = true; &#125;&#125;","categories":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}]},{"title":"01 面向对象程序设计基础","slug":"01 面向对象程序设计基础","date":"2024-08-19T04:23:45.879Z","updated":"2024-08-19T02:52:24.791Z","comments":true,"path":"2024/08/19/01 面向对象程序设计基础/","permalink":"https://xqc-1368.github.io/2024/08/19/01%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"第一章 从C到C++ 1.1引用 1概念： 某个变量的引用，等价于这个变量，相当于这个变量的一个别名 写法：类型名&amp;引用名= 某变量名 1234int a=2;int &amp;b=a;cout&lt;&lt;b&lt;&lt;endl;//b引用了a，b的类型是 int&amp;return 0; 上述程序输出为2 注：改变引用变量的值，原变量也会改变，因为引用变量仅仅是一个别名 12345int a=2;int &amp;b=a;b=8;//修改引用变量的值cout&lt;&lt;a&lt;&lt;endl;//原变量的值也被修改return 0; 上述程序输出为8 2 引用的要求： 定义引用时，一定要将其初始化成引用某个变量 初始化后，他就一直引用该变量，不会再引用其他变量 引用只能引用变量，不能引用常量和表达式。 12345int a=2,c=9;int &amp;b=a;b=c;//仅仅表示把c的值赋给b，即把c的值赋给a，b并没有引用cout&lt;&lt;a&lt;&lt;endl;return 0; 3 引用作为函数参数 可以在函数内部修改参数的值 相当于指针，但是不用像指针一样麻烦地每次都写* 用于交换a，c的程序如下： 12345678910111213void swap(int &amp;a,int &amp;b)&#123; a^=b; b^=a; a^=b;&#125;signed main()&#123; int a=2,c=9; swap(a,c); cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl; return 0;&#125; 上述程序输出为9 2 4 引用作为函数的返回值 12345678910int&amp; setvalue()&#123; return n;&#125;signed main()&#123; setvalue()=40; cout&lt;&lt;n&lt;&lt;endl; return 0;&#125; 上述程序输出为40 5 常引用 概念： const int&amp; r=nr的类型为const int &amp; 不能通过常引用去修改其引用的内容（但内容本身可以修改） 12345int n=100;const int &amp;r=n;n=0;//OKr=9;//编译错误return 0; 注：const int&amp;与int &amp;是 不同类型 1.2 内联函数和重载函数 1 内联函数 作用：减少函数调用的开销 编译器处理对内联函数的调用语句时，是将整个函数的代码 插入 到调用语句处，而不会产生调用函数的语句。 在函数定义前面加inline关键字，即可定义内联函数 12345678910inline int MAX(int a,int b)&#123; return a&gt;b?a:b;&#125;signed main()&#123; int a=9,b=8; cout&lt;&lt;MAX(a,b)&lt;&lt;endl; return 0;&#125; 2 函数重载 一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。 123456789101112131415161718192021222324252627282930int MAX(int a,int b)//(1)&#123; return a&gt;b?a:b;&#125;double MAX(double a,double b)//(2)&#123; return a&gt;b?a:b;&#125;int MAX(int a,int b,int c)//(3)&#123; int d=a&gt;b?a:b; return d&gt;c?d:c;&#125;signed main()&#123; int a=9,b=8,c=12;//2 int//3 int cout&lt;&lt;MAX(a,b)&lt;&lt;endl; cout&lt;&lt;MAX(a,b,c)&lt;&lt;endl;//2 double 调用（2） double r=3.4,g=2.5; cout&lt;&lt;MAX(r,g)&lt;&lt;endl;//generate two-meaning error 二义性错误 double t=9.9; cout&lt;&lt;MAX(t,b)&lt;&lt;endl;//generate two-meaning error 二义性错误 cout&lt;&lt;MAX(3,2.4)&lt;&lt;endl; return 0;&#125; 函数重载使得函数命名变得简单。编译器根据调用语句的中的实参的个数和类型判断应 该调用哪个函数。 3 函数的缺省值 定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。 1234567891011121314int func(int a,int b=2,int c=3)&#123; return a+b+c;&#125;signed main()&#123; int a=9,b=8,c=12; cout&lt;&lt;func(a)&lt;&lt;endl;//等价于func(9,2,3)输出14 cout&lt;&lt;func(a,b)&lt;&lt;endl;//等价于func(9,8,3)输出20 cout&lt;&lt;func(a,b,c)&lt;&lt;endl;//等价于func(9,8,12)输出29 cout &lt;&lt; func(a, , c) &lt;&lt; endl; //不行,只能最右边的连续若干个参数缺省 return 0;&#125; 1.3 const关键字 不可通过常量指针修改其指向的内容 123456789signed main()&#123; int a=8,b; const int *p=&amp;a; a=5;//correct *p=0;//error：表达式必须是可修改的左值 p = &amp;b; // correct 常量指针的指向可以变化 return 0;&#125; 不能把常量指针赋值给非常量指针，反过来可以：因为const int *类型的初始化的时候默认指向的值不可修改 123456789signed main()&#123; int a=8,b=9,*p2=&amp;b; const int *p=&amp;a; p=p2; p2 = p; // 不能将 const int*类型的值分配到 int 类型的实体 p2=(int*)p;//correct return 0;&#125; 函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容 12345void MyPrintf( const char * p )&#123; strcpy( p,&quot;this&quot;); //编译出错 printf(&quot;%s&quot;,p); //ok&#125; 1.4 动态内存分配 1 分配一个变量 P = new T; T是任意类型名，P是类型为T * 的指针。 动态分配出一片大小为 sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。比如： 123456789signed main()&#123; int *p; p = new int; *p = 0; cout &lt;&lt; *p &lt;&lt; endl; delete p; return 0;&#125; 2 分配一个数组 P = new T[N]; T :任意类型名 P :类型为T * 的指针 N :要分配的数组元素的个数，可以是整型表达式 动态分配出一片大小为 sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给P。 123456789signed main()&#123; int *p; p=new int[20]; p[5]=0; cout&lt;&lt;p[5]&lt;&lt;endl; delete []p; return 0;&#125; 3 delete运算符释放动态分配的内存 用“new”动态分配的内存空间，一定要用“delete”运算符进行释放 句法：delete 指针；//该指针必须指向new出来的空间 1234int * p = new int;* p = 5;delete p;delete p; //导致异常，一片空间不能被delete多次 用“delete”释放动态分配的数组，要加“[]” 句法：delete [ ] 指针；//该指针必须指向new出来的数组 123int * p = new int[20];p[0] = 1;delete [] p;","categories":[{"name":"OOP面向对象","slug":"OOP面向对象","permalink":"https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"OOP","slug":"OOP","permalink":"https://xqc-1368.github.io/tags/OOP/"},{"name":"引用","slug":"引用","permalink":"https://xqc-1368.github.io/tags/%E5%BC%95%E7%94%A8/"},{"name":"内联函数","slug":"内联函数","permalink":"https://xqc-1368.github.io/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"name":"重载函数","slug":"重载函数","permalink":"https://xqc-1368.github.io/tags/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"name":"动态内存分配","slug":"动态内存分配","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"}]},{"title":"字符串操作函数汇总","slug":"字符串操作函数汇总","date":"2024-08-19T04:23:45.874Z","updated":"2024-08-19T03:39:04.732Z","comments":true,"path":"2024/08/19/字符串操作函数汇总/","permalink":"https://xqc-1368.github.io/2024/08/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/","excerpt":"","text":"C++ 字符串 C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 C 风格字符串 C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 \\0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 RUNOOB 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 RUNOOB 的字符数多一个。 1char site[7] = &#123;&#x27;R&#x27;, &#x27;U&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;O&#x27;, &#x27;B&#x27;, &#x27;\\0&#x27;&#125;; 依据数组初始化规则，您可以把上面的语句写成以下语句： 1char site[] = &quot;RUNOOB&quot;; 以下是 C/C++ 中定义的字符串的内存表示： 其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 \\0 放在字符串的末尾。让我们尝试输出上面的字符串： 实例 123456789#include &lt;iostream&gt; using namespace std; int main () &#123; char site[7] = &#123;&#x27;R&#x27;, &#x27;U&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;O&#x27;, &#x27;B&#x27;, &#x27;\\0&#x27;&#125;; cout &lt;&lt; &quot;菜鸟教程: &quot;; cout &lt;&lt; site &lt;&lt; endl; return 0; &#125; 当上面的代码被编译和执行时，它会产生下列结果： 菜鸟教程: RUNOOB C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 &amp; 目的 1 strcpy(s1, s2);复制字符串 s2 到字符串 s1。 2 strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如:string str1 = “runoob”;string str2 = “google”;string str = str1 + str2; 3 strlen(s1);返回字符串 s1 的长度。 4 strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 5 strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 下面的实例使用了上述的一些函数： 实例 1234567891011121314151617181920#include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main () &#123; char str1[13] = &quot;runoob&quot;; char str2[13] = &quot;google&quot;; char str3[13]; int len ; //复制 str1 到 str3 strcpy( str3, str1); cout &lt;&lt; &quot;strcpy( str3, str1) : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 strcat( str1, str2); cout &lt;&lt; &quot;strcat( str1, str2): &quot; &lt;&lt; str1 &lt;&lt; endl; // 连接后，str1 的总长度 len = strlen(str1); cout &lt;&lt; &quot;strlen(str1) : &quot; &lt;&lt; len &lt;&lt; endl; return 0; &#125; 当上面的代码被编译和执行时，它会产生下列结果： 123strcpy( str3, str1) : runoobstrcat( str1, str2): runoobgooglestrlen(str1) : 12 C++ 中的 String 类 C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例： 现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。 实例 12345678910111213141516171819#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main () &#123; string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; &quot;str3.size() : &quot; &lt;&lt; len &lt;&lt; endl; return 0; &#125; 当上面的代码被编译和执行时，它会产生下列结果： 123str3 : runoobstr1 + str2 : runoobgooglestr3.size() : 12 其他一些实用函数 in c in c++","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C++ STL","slug":"C-STL","permalink":"https://xqc-1368.github.io/categories/C-STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"字符串","slug":"字符串","permalink":"https://xqc-1368.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"STL","slug":"STL","permalink":"https://xqc-1368.github.io/tags/STL/"}]},{"title":"指针与二维数组","slug":"指针与二维数组","date":"2024-08-19T04:23:45.869Z","updated":"2024-08-19T03:08:18.529Z","comments":true,"path":"2024/08/19/指针与二维数组/","permalink":"https://xqc-1368.github.io/2024/08/19/%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","excerpt":"","text":"指针与二维数组 数组法及其变式 123456789//数组法1a==a+0==&amp;a[0]; *a==*(a+0)==a[0];a+1==&amp;a[1]; *(a+1)==a[1];//数组法2a[0]+1==&amp;a[0][1]; *(a[0]+1)==a[0][1];//数组法3*(a+1)+2==&amp;a[1][2]; *(*(a+1)+2)==a[1][2];//数组法4(*(a+1))[2]==a[1][2]; 列指针法 123456789101112//列指针的定义方法int *p; //初始化方法//初始化：指向第一个元素：（以下三个方法等价）p=a[0] ; p=*a ; p=&amp;a[0][0];//初始化：指向任意一个元素：p=a[i][j];p=a[2][1]; //列指针的使用方法：（a为m行n列的一个二维数组）*(p+i*n+j)==a[i][j]; p+i*n+j==&amp;a[i][j];p[i*n+j]==a[i][j]; 语法 样例 说明 指向任意元素 指针变量=&amp;数组名[下标1][下标2] p=&amp;a[1][2] p指向的元素为7 指向首个元素 指针变量=&amp;数组名[0][0]指针变量=*二维数组名 p=&amp;a[0][0]或p=*a p指向首个元素，即数值1所在位置 p p+1 p+2 p+3 p+4 p+5 p+6 p+7 p+8 p+9 p+10 p+11 表示方法 说明 指针类型 a[0] 是一维数组名称，首地址第0个元素地址(a[0]+0) 列指针 a[0]+1 第0行，第1个元素 列指针 a[0]+2 第0行，第2个元素 列指针 a[0]+3 第0行，第3个元素 列指针 行指针法 1234567891011//行指针的定义int (*p)[4];//行指针的初始化(a为某数组)(二者任选其一即可)p=a; p=&amp;a[0];//行指针应用公式p[i][j]==a[i][j];*(*(p+i)+j)==a[i][j]; *(p+i)+j==&amp;a[i][j];*(p[i]+j)==a[i][j]; p[i]+j==&amp;a[i][j];(*(p+i))[j]==a[i][j]; 二维数组的名字默认是行指针 表示方法 说明 指针类型 a或a+0 指向第0行 行指针 a+1 指向第1行 行指针 a+2 指向第2行 行指针 行指针和列指针的联系 行指针：指的是一整行，不指向具体元素。 列指针：指的是二维数组中某一行的某个具体元素。 可以将列指针认为是行指针的具体元素，行指针是列指针的地址。 两者间的具体转化： *行指针—&gt;列指针 &amp;列指针—&gt;行指针 行指针 转换成：列指针 a或a+0 *a或a[0] a+1 *(a+1)或a[1] 列指针解引用 内容等价表示 含义 *a[0] *(*a) a[0][0] *a[1] *( *(a+1)) a[1][0] 某一行的列指针 转换成：某一行的行指针 a[0] &amp;a[0]或&amp;a或&amp;(a+0) a[1] &amp;a[1]或&amp;(a+1) 行指针和列指针转换试验结果： 1234567891011121314151617181920212223242526//列指针的定义方法int *p; //初始化方法//初始化：指向第一个元素：（以下三个方法等价）p=a[0] ; p=*a ; p=&amp;a[0][0];//初始化：指向任意一个元素：p=a[i][j];p=a[2][1]; //目前p是列指针是吧 根据：&amp;列指针==行指针 发现只有用[]的方法表示的时候才可以实现(&amp;p)[i][j]==a[i][j];//试验可行*(*(&amp;p+i)+j)==a[i][j]; *(&amp;p+i)+j==&amp;a[i][j];//试验不可行*(&amp;p[i]+j)==a[i][j]; &amp;p[i]+j==&amp;a[i][j];//试验可行(*(&amp;p+i))[j]==a[i][j];//试验不可行//行指针的定义int (*p)[4];//行指针的初始化(a为某数组)(二者任选其一即可)p=a; p=&amp;a[0];//目前p是行指针吧 根据：*行指针==列指针 发现均可以实现*(*p+i*n+j)==a[i][j]; *p+i*n+j==&amp;a[i][j];//试验可行(*p)[i*n+j]==a[i][j]; //试验可行","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数组","slug":"数组","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"指针","slug":"指针","permalink":"https://xqc-1368.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"指向函数的指针的理解问题","slug":"指向函数的指针的理解问题","date":"2024-08-19T04:23:45.866Z","updated":"2024-08-19T03:37:28.684Z","comments":true,"path":"2024/08/19/指向函数的指针的理解问题/","permalink":"https://xqc-1368.github.io/2024/08/19/%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E9%97%AE%E9%A2%98/","excerpt":"","text":"指向函数的指针的理解问题 原题如下： calculate形参中函数指针部分：应该理解为第三个参数为一个指向a function which return double and need one double 该指针叫hanshu 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;double for_y1(double x)&#123; return 1+x*x;&#125;double for_y2(double x)&#123; return x/(1+x*x);&#125;double calculate(double a,double b,double (*hanshu)(double))&#123; double n=10000;//n为等分数 double h=(b-a)/n; double sum=((*hanshu)(a)+(*hanshu)(b))/2; for(int i=1;i&lt;n;i++) &#123; sum+=(*hanshu)(a+i*h);//(*hanshu)表示取hanshu指针指向的函数 &#125; return sum*h;&#125;int main(void)&#123; double a,b; scanf(&quot;%lf %lf&quot;,&amp;a,&amp;b); printf(&quot;%lf %lf&quot;, calculate(a, b, for_y1), calculate(a, b, for_y2)); return 0;&#125;","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"指针","permalink":"https://xqc-1368.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"问答形式标记法","slug":"问答形式标记法","date":"2024-08-19T04:23:45.856Z","updated":"2024-08-19T03:07:23.635Z","comments":true,"path":"2024/08/19/问答形式标记法/","permalink":"https://xqc-1368.github.io/2024/08/19/%E9%97%AE%E7%AD%94%E5%BD%A2%E5%BC%8F%E6%A0%87%E8%AE%B0%E6%B3%95/","excerpt":"","text":"问答形式标记法 如 01迷宫 题目描述 有一个仅由数字 000 与 111 组成的 n×nn \\times nn×n 格迷宫。若你位于一格 000 上，那么你可以移动到相邻 444 格中的某一格 111 上，同样若你位于一格 111 上，那么你可以移动到相邻 444 格中的某一格 000 上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入格式 第一行为两个正整数 n,mn,mn,m。 下面 nnn 行，每行 nnn 个字符，字符只可能是 000 或者 111，字符之间没有空格。 接下来 mmm 行，每行两个用空格分隔的正整数 i,ji,ji,j，对应了迷宫中第 iii 行第 jjj 列的一个格子，询问从这一格开始能移动到多少格。 输出格式 mmm 行，对于每个询问输出相应答案。 样例 #1 样例输入 #1 123452 201101 12 2 样例输出 #1 1244 提示 对于样例，所有格子互相可达。 对于 20%20\\%20% 的数据，n≤10n \\leq 10n≤10； 对于 40%40\\%40% 的数据，n≤50n \\leq 50n≤50； 对于 50%50\\%50% 的数据，m≤5m \\leq 5m≤5； 对于 60%60\\%60% 的数据，n,m≤100n,m \\leq 100n,m≤100； 对于 100%100\\%100% 的数据，1≤n≤10001\\le n \\leq 10001≤n≤1000，1≤m≤1000001\\le m \\leq 1000001≤m≤100000。 思路是因为可以把迷宫想象成若干区块构成，相同区块之间可以互通，不同区块之间不能互通。 那么找到某一个区块，用bfs的手段就可以在二维数组map中找到所有可以与他相连可以互通的区块，于是就将这些区块的数量总和标在另一个数组visited中。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#define int long longusing namespace std;int map[1005][1005]=&#123;0&#125;;int visited[1005][1005]=&#123;0&#125;;int dx[4]=&#123;1,0,-1,0&#125;;int dy[4]=&#123;0,1,0,-1&#125;;int sum; int n,m;typedef struct&#123; int x; int y;&#125;pos;queue&lt;pos&gt;q;queue&lt;pos&gt; save;void cont(int x,int y)&#123; sum=1; pos temp; temp.x=x; temp.y=y; visited[x][y]=-1; q.push(temp); while(!q.empty()) &#123; int tx=q.front().x; int ty=q.front().y; for(int i=0;i&lt;4;i++) &#123; if(tx+dx[i]&gt;=0 &amp;&amp; tx+dx[i]&lt;n &amp;&amp; ty+dy[i]&gt;=0 &amp;&amp; ty+dy[i]&lt;n &amp;&amp; visited[tx+dx[i]][ty+dy[i]]==0 &amp;&amp;map[tx+dx[i]][ty+dy[i]]==1-map[tx][ty]) &#123; visited[tx+dx[i]][ty+dy[i]]=-1; sum++; pos temp; temp.x=tx+dx[i]; temp.y=ty+dy[i]; q.push(temp); &#125; &#125; save.push(q.front()); //cout&lt;&lt;tx&lt;&lt;&quot; &quot;&lt;&lt;ty&lt;&lt;endl; q.pop(); &#125; int tt=save.size();//把本次fs遍历过的点存到save中 for(int i=0;i&lt;tt;i++) &#123; visited[save.front().x][save.front().y]=sum; save.pop(); &#125;&#125;signed main()&#123; char t; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;t; map[i][j]=(long long)t-48; &#125; &#125; int sx,sy; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(visited[i][j]==0) &#123; cont(i,j); &#125; &#125; &#125; //for(int i=0;i&lt;n;i++) //&#123; // for(int j=0;j&lt;n;j++) // &#123; // cout&lt;&lt;visited[i][j]&lt;&lt;&quot; &quot;; // &#125; // cout&lt;&lt;endl; //&#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;sx&gt;&gt;sy; cout&lt;&lt;visited[sx-1][sy-1]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}]},{"title":"前缀和背景下的二分答案 ：平均数","slug":"前缀和背景下的二分答案 ：平均数","date":"2024-08-19T04:23:45.851Z","updated":"2024-08-19T03:07:03.820Z","comments":true,"path":"2024/08/19/前缀和背景下的二分答案 ：平均数/","permalink":"https://xqc-1368.github.io/2024/08/19/%E5%89%8D%E7%BC%80%E5%92%8C%E8%83%8C%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%20%EF%BC%9A%E5%B9%B3%E5%9D%87%E6%95%B0/","excerpt":"","text":"平均数 题目描述 给一个长度为 nnn 的数列，我们需要找出该数列的一个子串，使得子串平均数最大化，并且子串长度 ≥m\\ge m≥m。 输入格式 第一行两个整数 nnn 和 mmm。 接下来 nnn 行，每行一个整数 aia_iai​，表示序列第 iii 个数字。 输出格式 一个整数，表示最大平均数的 100010001000 倍，如果末尾有小数，直接舍去，不要用四舍五入求整。 样例 #1 样例输入 #1 123456789101110 664210385941 样例输出 #1 16500 提示 数据规模与约定 对于 60%60\\%60% 的数据，保证 m≤n≤104m\\le n\\le 10^4m≤n≤104； 对于 100%100\\%100% 的数据，保证 1≤m≤n≤1051 \\leq m\\le n\\le 10^51≤m≤n≤105，0≤ai≤20000\\le a_i\\le20000≤ai​≤2000。 思路：1.先找一个基准数字x；这个基准数的找寻可以使用二分。 2.求出数组中每个数字相对于这个基准数字的偏移量数组。 例如：4 -1 -2 8 -1 的数组，假设我某一轮二分答案的mid为4； 则我找到的偏移量数组为：0 -5 -6 4 -5； 3.接下来，求这个偏移量数组的前缀和数组，便于后续的求和处理； 例如：上述数组的前缀和数组为：0 -5 -11 -7 -12 i 从第m位开始遍历到n（数组最后），开始求以 i 为结尾的子串的最大字串和。最大子段和可以转化为前缀和相减的形式。 设sum[i]为序列A的前i项的和 。设s[i]是序列A以A[i]结尾且长度不小于F的最大连续子段和, 那么显然有: s[i] = sum[i] - min{sum[j]}(0&lt;=j&lt;=i-L) 使用minn这个变量记录1~m位置的最小值（因为我们总希望前缀和a[ i ]减去一个尽量小的数字）。但这个过程可以不用再添加一个循环，因为我只需要在一开始，i-m还是0的时候就记录从0号位置，后续随着i 往后移动，每增加一个位置就也相当于放开了i-m号位置，这时判断i-m号位置的元素是不是比前面0i-m-1这个号码范围内的元素的最小值更小即可求出0i-m范围内的最小值。 附上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#define INF 2147483647#include &lt;iostream&gt;using namespace std;const long long MAXN = 100010;double a[MAXN], sum[MAXN];long long n, m;int check(double x)&#123; double presum_of_dis[MAXN] = &#123;0&#125;; for (long long i = 1; i &lt;= n; i++)//构造前缀和数组 &#123;//presum_of_dis为距离基准值x的距离数组的前缀和 presum_of_dis[i] = presum_of_dis[i - 1]+(a[i]-x); &#125; double minn=INF,maxn=-INF; for(long long i=m;i&lt;=n;i++) &#123; if(minn&gt;presum_of_dis[i-m])minn=presum_of_dis[i-m]; if(presum_of_dis[i]-minn&gt;maxn)maxn=presum_of_dis[i]-minn; &#125; if(maxn&gt;=0)return 1; else return 0;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (long long i = 1; i &lt;= n; ++i) scanf(&quot;%lf&quot;, &amp;a[i]); double i= 0, j = 2000,ans; while (i-j &lt;=0.0000000000001 ) &#123; double mid = (i + j) /2; if (check(mid)) &#123; ans=mid; i = mid +0.0000001; &#125; else j = mid -0.0000001; &#125; cout&lt;&lt;(int)(i*1000)&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"算法/二分","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"前缀和","slug":"前缀和","permalink":"https://xqc-1368.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"二分","slug":"二分","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"GIT操作的注释","slug":"关于git的操作的注释","date":"2024-08-19T04:23:45.842Z","updated":"2024-08-19T03:06:05.646Z","comments":true,"path":"2024/08/19/关于git的操作的注释/","permalink":"https://xqc-1368.github.io/2024/08/19/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E9%87%8A/","excerpt":"","text":"关于git的操作的注释 1 git问题error: remote origin already exists. git问题error: remote origin already exists._git error: remote origin already exists.-CSDN博客 2 上传本地代码到github网站 添加远程库 - 廖雪峰的官方网站 (liaoxuefeng.com) 但是其中的ssh协议的传输已经不能使用, 应该使用http协议","categories":[{"name":"git","slug":"git","permalink":"https://xqc-1368.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://xqc-1368.github.io/tags/git/"}]},{"title":"二分答案基础：书的复制","slug":"二分答案基础：书的复制","date":"2024-08-19T04:23:45.834Z","updated":"2024-08-19T03:37:31.201Z","comments":true,"path":"2024/08/19/二分答案基础：书的复制/","permalink":"https://xqc-1368.github.io/2024/08/19/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%B9%A6%E7%9A%84%E5%A4%8D%E5%88%B6/","excerpt":"","text":"书的复制 题目背景 大多数人的错误原因：尽可能让前面的人少抄写，如果前几个人可以不写则不写，对应的人输出 0 0 。 不过，已经修改数据，保证每个人都有活可干。 题目描述 现在要把 mmm 本有顺序的书分给 kkk 个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。 现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。 输入格式 第一行两个整数 m,km,km,k。 第二行 mmm 个整数，第 iii 个整数表示第 iii 本书的页数。 输出格式 共 kkk 行，每行两个整数，第 iii 行表示第 iii 个人抄写的书的起始编号和终止编号。 kkk 行的起始编号应该从小到大排列，如果有多解，则尽可能让前面的人少抄写。 样例 #1 样例输入 #1 129 31 2 3 4 5 6 7 8 9 样例输出 #1 1231 56 78 9 提示 1≤k≤m≤5001\\le k \\le m \\le 5001≤k≤m≤500。 无论使用二分答案还是动态规划，最后都要使用贪心，“则尽可能让前面的人少抄写。” 二分答案做法（较简便）（识别使用二分答案的依据是：最大值的最小值） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;#include &lt;vector&gt;#define maxsize 505int a[maxsize]=&#123;0&#125;;int m, k, sum = 0;bool check(int x)&#123; int need=1,temp=x; for(int i=m-1;i&gt;=0;i--) &#123; if(temp&gt;=a[i])temp-=a[i]; else &#123; temp=x-a[i]; need++; &#125; &#125; if(need&gt;k)return false; else return true;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; sum+=a[i]; &#125; int i=sum/k,j=sum,mid,ans; while(i&lt;=j) &#123; mid=(i+j)/2; if(check(mid)) &#123; ans=mid; j=mid-1; &#125; else i=mid+1; &#125; int temp=ans; vector&lt;int&gt; t; t.push_back(m); for (int i = m - 1; i &gt;= 0; i--) &#123; if (temp &gt;= a[i]) temp -= a[i]; else &#123; temp = ans - a[i]; t.push_back(i+2); t.push_back(i+1); &#125; &#125; t.push_back(1); for(int i=t.size()-1;i&gt;=0;i-=2) &#123; cout&lt;&lt;t[i]&lt;&lt;&quot; &quot;&lt;&lt;t[i-1]&lt;&lt;endl; &#125; return 0;&#125; dp的话这是区间dp 注意：leap是累计数组，通过数组之间元素相减在可以直接得出区间元素和。 动态数组的行列定义： i~人数k：当前拥有的人手 jm当前讨论的范围为0j 前两层循环遍历每一个格子； 状态转移方程 f [ i ] [ j ] = minE(t from 1 to j-1)( max{dp[i-1][t],leap[j]-leap[t] } ) 上面的minE表示枚举取最小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;#include &lt;vector&gt;#define maxsize 505int main()&#123; int m,k,a[maxsize]=&#123;0&#125;,leap[maxsize]=&#123;0&#125;,dp[maxsize][maxsize]=&#123;0&#125;; cin&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;a[i]; if (i == 1) leap[i] =a[i]; else leap[i] = leap[i-1]+a[i]; &#125; for(int i=1;i&lt;=m;i++) &#123; dp[1][i]=leap[i]; &#125; for(int i=2;i&lt;=k;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; dp[i][j] = max(dp[i - 1][1], leap[j] - leap[0]); for(int t=1;t&lt;j;t++) &#123; if(max(dp[i-1][t],leap[j]-leap[t])&lt;dp[i][j]) dp[i][j] = max(dp[i - 1][t], leap[j] - leap[t]); &#125; &#125; &#125; int indeedmin=dp[k][m],i=m; vector&lt;int&gt; v; v.push_back(m); while (i&gt;0) &#123; if(indeedmin-a[i]&gt;=0) indeedmin-=a[i]; else &#123; indeedmin=dp[k][m]-a[i]; v.push_back(i+1); v.push_back(i); &#125; i--; &#125; v.push_back(1); for(int i=v.size()-1;i&gt;=0;i-=2) cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;&lt;&lt;v[i-1]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"算法/二分","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"二分","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"The conclusion of  process of debug","slug":"The conclusion of  process of debug","date":"2024-08-19T04:23:45.823Z","updated":"2024-08-19T03:42:01.487Z","comments":true,"path":"2024/08/19/The conclusion of  process of debug/","permalink":"https://xqc-1368.github.io/2024/08/19/The%20conclusion%20of%20%20process%20of%20debug/","excerpt":"","text":"The conclusion of process of debug 1.迷宫问题中如果迷宫长这样 请把a[i][j]使用字符输入 不然一次会读入一整行","categories":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"}]},{"title":"STL","slug":"STL","date":"2024-08-19T04:23:45.808Z","updated":"2024-08-19T04:23:26.841Z","comments":true,"path":"2024/08/19/STL/","permalink":"https://xqc-1368.github.io/2024/08/19/STL/","excerpt":"","text":"一、基本概念 STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C中，但在被引入C之前该技术就已经存在了很长的一段时间。 STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文 件： 1&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt; 使用STL的好处 1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。 2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。 例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址； STL的sort()函数可以用来操作vector,list等容器。 3）程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。 4）STL具有高可重用性，高性能，高移植性，跨平台的优点。 高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。 高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种) 高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。 跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。 二、容器 1 容器的分类 （1）序列式容器（Sequence containers） 每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。 vector、deque、list、stack、queue （2）关联式容器（Associated containers） 元素位置取决于特定的排序准则，和插入顺序无关 set、multiset、map、multimap 2 vector 容器 （1） vector容器简介 vector是将元素置于一个动态数组中加以管理的容器。 vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。 vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时 （2）vector对象的默认构造 vector采用模板类实现，vector对象的默认构造形式 12345678910vector&lt;T&gt; vecT; vector&lt;int&gt; vecInt; //一个存放int的vector容器。vector&lt;float&gt; vecFloat; //一个存放float的vector容器。vector&lt;string&gt; vecString; //一个存放string的vector容器。... //尖括号内还可以设置指针类型或自定义类型。class CA&#123;&#125;;vector&lt;CA*&gt; vecpCA; //用于存放CA对象的指针的vector容器。vector&lt;CA&gt; vecCA; //用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的， //所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。 （3）vector对象的带参数构造 理论知识 vector(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。 vector(n,elem); //构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); //拷贝构造函数 1234567int iArray[] = &#123;0,1,2,3,4&#125;;vector&lt;int&gt; vecIntA(iArray, iArray+5);// //用构造函数初始化容器vecIntB vector&lt;int&gt; vecIntB(vecIntA.begin() , vecIntA.end()); vector&lt;int&gt; vecIntB(vecIntA.begin() , vecIntA.begin()+3); vector&lt;int&gt; vecIntC(3,9); //此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。vector&lt;int&gt; vecIntD(vecIntA); （4）vector的赋值 理论知识 vector.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。 vector.assign(n,elem); //将n个elem拷贝赋值给本身。 vector&amp; operator=(const vector &amp;vec); //重载等号操作符 vector.swap(vec); // 将vec与本身的元素互换。 123456789vector&lt;int&gt; vecIntA, vecIntB, vecIntC, vecIntD;int iArray[] = &#123;0,1,2,3,4&#125;;vecIntA.assign(iArray,iArray+5);//用其它容器的迭代器作参数。vecIntB.assign(vecIntA.begin(), vecIntA.end()); vecIntC.assign(3,9);vector&lt;int&gt; vecIntD;vecIntD = vecIntA;vecIntA.swap(vecIntD); （5）vector的大小 理论知识 vector.size(); //返回容器中元素的个数 vector.empty(); //判断容器是否为空 vector.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 vector.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 例如 vecInt是vector 声明的容器，现已包含1,2,3元素。 int iSize = vecInt.size(); //iSize == 3; bool bEmpty = vecInt.empty(); // bEmpty == false; 执行vecInt.resize(5); //此时里面包含1,2,3,0,0元素。 再执行vecInt.resize(8,3); //此时里面包含1,2,3,0,0,3,3,3元素。 再执行vecInt.resize(2); //此时里面包含1,2元素。 （6）vector末尾的添加移除操作 vector vecInt; vecInt.push_back(1); //在容器尾部加入一个元素 vecInt.push_back(3); vecInt.push_back(5); vecInt.push_back(7); vecInt.push_back(9); vecInt.pop_back(); vecInt.pop_back(); （7）vector的数据存取 理论知识： vec.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。 vec[idx]; //返回索引idx所指的数据，越界时，运行直接报错 123456789vector&lt;int&gt; vecInt; //假设包含1 ,3 ,5 ,7 ,9vecInt.at(2) == vecInt[2] ; //5vecInt.at(2) = 8; 或 vecInt[2] = 8;vecInt 就包含 1, 3, 8, 7, 9值int iF = vector.front(); //iF==1int iB = vector.back(); //iB==9vector.front() = 11; //vecInt包含&#123;11,3,8,7,9&#125;vector.back() = 19; //vecInt包含&#123;11,3,8,7,19&#125; （8）vector的插入 理论知识 vector.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 vector.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 vector.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值 简单案例 12345678910111213141516vector&lt;int&gt; vecA;vector&lt;int&gt; vecB;vecA.push_back(1);vecA.push_back(3);vecA.push_back(5);vecA.push_back(7);vecA.push_back(9);vecB.push_back(2);vecB.push_back(4);vecB.push_back(6);vecB.push_back(8);vecA.insert(vecA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125; pos必须是地址值 vecA.insert(vecA.begin()+1,2,33); //&#123;11,33,33,1,3,5,7,9&#125;vecA.insert(vecA.begin() , vecB.begin() , vecB.end()); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; 9、vector的删除 理论知识 vector.clear(); //移除容器的所有数据 vec.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 vec.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 简单案例: 12345删除区间内的元素vecInt是用vector&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。vecInt.erase(vecInt.begin(),vecInt.begin()+3);//删除vecInt的所有元素vecInt.clear(); //容器为空 10、迭代器 1）迭代器的基本概念 什么是迭代器： 迭代器是一种检查容器内元素并且遍历容器内元素的数据类型。 迭代器的作用： 迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。 为什么需要迭代器： STL提供了多种容器，每种容器的实现原理各不相同，如果没有迭代器我们需要记住每一种容器中对象的访问方法，很显然这样会变得非常麻烦。 STL提供的许多容器中都实现了一个迭代器用于对容器中对象的访问，虽然每个容器中的迭代器的实现方式不一样，但是对于用户来说操作方法是一致的，也就说通过迭代器统一了对所有容器的访问方式。例如：访问当前元素的下一个元素我们可以通过迭代器自增进行访问。 迭代器是为了提高编程效率而开发的。 迭代器的本质： 迭代器是容器类中专门实现的一个访问容器中数据的内嵌类（类中类） 为了统一每个容器中对于迭代器的操作，在容器类中会使用typedef将迭代器类进行别名定义，别名为：iterator 迭代器类对容器中元素的访问方式：指针 迭代器类的具体实现：为了隐藏每个容器中迭代器的具体实现，也为了统一用户对于每个容器中迭代器的访问方式，用户可以把迭代器当成一个指针对容器中的元素进行访问。但是因为迭代器不是指针，因此在迭代器类中我们需要对 * 、-&gt;、前置++/–、后置++/–等操作符进行重载。 123456T &amp;operator*() const &#123;&#125;node&lt;T&gt;*operator-&gt;() const &#123;&#125;list_iterator &amp;operator++() &#123;&#125;list_iterator operator++(int) &#123;&#125;bool operator==(const list_iterator &amp;t) const &#123;&#125;bool operator!=(const list_iterator &amp;t) const &#123;&#125; 2）vector容器的迭代器 每种容器类型都定义了自己的迭代器类型，如vector： 1vector&lt;int&gt;::iterator iter; //变量名为iter。 3）vector容器迭代器类中的成员函数 vector容器的迭代器属于“随机访问迭代器”：迭代器一次可以移动多个位置 4）begin和end操作 每种容器都定义了一队命名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的元素指向第一个元素。 1vector&lt;int&gt;::iterator iter=v.begin(); //若v不为空，iter指向v[0]。 由end返回的迭代器指向最后一个元素的下一个, 若v为空，begin和end返回的相同。 ++iter;//使迭代器自增指向下一个元素 ==和!=操作符来比较两个迭代器，若两个迭代器指向同一个元素，则它们相等，否则不想等。 迭代器使用举例： 12for(vector&lt;int&gt;::iterator iter=v.begin();iter!=v.end();iter++) *iter=0; //将vector中的元素全部赋值为0； 5）迭代器的算术操作 iter+n; //迭代器iter加上n，指在当前迭代器所在的位置i（如在vector第一个元素位置）之前加上n个元素后的位置。 iter-n; //迭代器iter减去n，指在当前迭代器的所在位置之后减n个元素的位置 5）迭代器失效 插入元素导致迭代器失效 我们先看这么一段代码： 12345678910111213int main()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);//v有三个元素 1，2，3,4 vector&lt;int&gt;::iterator it1 = v.begin() + 3; v.insert(it1, 8);//插入一个8 cout &lt;&lt; *it1 &lt;&lt; endl;//输出it位置的元素 return 0;&#125; 运行上面这段代码，我们会发现输出的结果并不是8，甚至有可能会导致程序崩溃。这是为什么呢？ 因为在insert时，vector可能需要进行扩容，而扩容的本质是new一块新的空间，再将数据迁移过去。而我们知道，迭代器的内部是通过指针访问容器中的元素的，而插入后，若vector扩容，则原有的数据被释放，指向原有数据的迭代器就成了野指针，所以迭代器失效了。 而解决的办法很简单，insert函数提供了返回值，这个返回值是指向插入之后的val的迭代器。我们只需要保存返回的迭代器，并使用这个新的迭代器即可。 1234567891011121314int main()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);//v有三个元素 1，2，3,4 vector&lt;int&gt;::iterator it1 = v.begin() + 3; it1 = v.insert(it1, 8);//插入一个8 cout &lt;&lt; *it1 &lt;&lt; endl;//输出it位置的元素 return 0;&#125; 删除元素导致迭代器失效 我们先看这们一段代码： 123456vector&lt;int&gt; cont =&#123;1,2,3,3,3,4,5,5,5,6&#125;;for (iter = cont.begin(); iter != cont.end();iter++)&#123; if (*iter == 3) cont.erase(iter);&#125; 对于序列式容器(如vector,deque)，序列式容器就是数组式容器，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。所以不能使用erase(iter++)的方式，还好erase方法可以返回下一个有效的iterator。 解决办法： 12345678vector&lt;int&gt; cont =&#123;1,2,3,3,3,4,5,5,5,6&#125;;for (iter = cont.begin(); iter != cont.end();)&#123; if (*iter == 3) iter = cont.erase(iter); else iter++; &#125; 10.2.3 deque容器 deque简介： deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。 deque在接口上和vector非常相似，在许多操作的地方可以直接替换。 deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法， deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。 deque与vector在操作上几乎一样，deque多两个函数： deque.push_front(elem); //在容器头部插入一个数据 deque.pop_front(); //删除容器第一个数据 10.2.4 list容器 1、list简介 list是一个双向链表容器，可高效地进行插入删除元素。 list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err) 2、list对象的默认构造 list采用模板类实现,对象的默认构造形式：list lst 如： 123list&lt;int&gt; lstInt; //定义一个存放int的list容器。list&lt;float&gt; lstFloat; //定义一个存放float的list容器。list&lt;string&gt; lstString; //定义一个存放string的list容器。 3、list头尾的添加移除操作 list.push_back(elem); //在容器尾部加入一个元素 list.pop_back(); //删除容器中最后一个元素 list.push_front(elem); //在容器开头插入一个元素 list.pop_front(); //从容器开头移除第一个元素 123456789101112list&lt;int&gt; lstInt;lstInt.push_back(1);lstInt.push_back(3);lstInt.push_back(5);lstInt.push_back(7);lstInt.push_back(9);lstInt.pop_front();lstInt.pop_front();lstInt.push_front(11);lstInt.push_front(13);lstInt.pop_back();lstInt.pop_back(); 4、list的数据存取 list.front(); //返回第一个元素。 list.back(); //返回最后一个元素。 1234567891011list&lt;int&gt; lstInt;lstInt.push_back(1);lstInt.push_back(3);lstInt.push_back(5);lstInt.push_back(7);lstInt.push_back(9); int iFront = lstInt.front(); //1int iBack = lstInt.back(); //9lstInt.front() = 11; //11lstInt.back() = 19; //19 5、list与迭代器 list 容器的迭代器是“双向迭代器”：双向迭代器从两个方向读写容器。除了提供前向迭代器的全部操作之外，双向迭代器还提供前置和后置的自减运算 list.begin(); //返回容器中第一个元素的迭代器。 list.end(); //返回容器中最后一个元素之后的迭代器。 list.rbegin(); //返回容器中倒数第一个元素的迭代器。 list.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 123456789101112131415161718list&lt;int&gt; lstInt;lstInt.push_back(1);lstInt.push_back(3);lstInt.push_back(5);lstInt.push_back(7);lstInt.push_back(9); for (list&lt;int&gt;::iterator it=lstInt.begin(); it!=lstInt.end(); ++it)&#123; cout &lt;&lt; *it; cout &lt;&lt; &quot; &quot;;&#125; for (list&lt;int&gt;::reverse_iterator rit=lstInt.rbegin(); rit!=lstInt.rend(); ++rit)&#123; cout &lt;&lt; *rit; cout &lt;&lt; &quot; &quot;;&#125; 6、list对象的带参数构造 list(n,elem); //构造函数将n个elem拷贝给本身。 list(beg,end); //构造函数将[beg,end]区间中的元素拷贝给本身 list(const list &amp;lst); //拷贝构造函数。 12345678910list&lt;int&gt; lstIntA;lstIntA.push_back(1);lstIntA.push_back(3);lstIntA.push_back(5);lstIntA.push_back(7);lstIntA.push_back(9); list&lt;int&gt; lstIntB(lstIntA.begin(),lstIntA.end()); //1 3 5 7 9list&lt;int&gt; lstIntC(5,8); //8 8 8 8 8list&lt;int&gt; lstIntD(lstIntA); //1 3 5 7 9 7、list的赋值 list.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。 list.assign(n,elem); //将n个elem拷贝赋值给本身。 list&amp; operator=(const list &amp;lst); //重载等号操作符 list.swap(lst); // 将lst与本身的元素互换。 1234567891011list&lt;int&gt; lstIntA,lstIntB,lstIntC,lstIntD;lstIntA.push_back(1);lstIntA.push_back(3);lstIntA.push_back(5);lstIntA.push_back(7);lstIntA.push_back(9); lstIntB.assign(lstIntA.begin(),lstIntA.end()); //1 3 5 7 9lstIntC.assign(5,8); //8 8 8 8 8lstIntD = lstIntA; //1 3 5 7 9lstIntC.swap(lstIntD); //互换 8、list的大小 list.size(); //返回容器中元素的个数 list.empty(); //判断容器是否为空 list.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 list.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 123456789101112list&lt;int&gt; lstIntA;lstIntA.push_back(1);lstIntA.push_back(3);lstIntA.push_back(5); if (!lstIntA.empty())&#123; int iSize = lstIntA.size(); //3 lstIntA.resize(5); //1 3 5 0 0 lstIntA.resize(7,1); //1 3 5 0 0 1 1 lstIntA.resize(2); //1 3&#125; 9、list的插入 list.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 list.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 list.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 1234567891011121314151617list&lt;int&gt; lstA;list&lt;int&gt; lstB; lstA.push_back(1);lstA.push_back(3);lstA.push_back(5);lstA.push_back(7);lstA.push_back(9); lstB.push_back(2);lstB.push_back(4);lstB.push_back(6);lstB.push_back(8); lstA.insert(lstA.begin(), 11); //&#123;11, 1, 3, 5, 7, 9&#125;lstA.insert(++lstA.begin(),2,33); //&#123;11,33,33,1,3,5,7,9&#125;lstA.insert(lstA.begin() , lstB.begin() , lstB.end() ); //&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125; 10、list的删除 list.clear(); //移除容器的所有数据 list.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 list.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 lst.remove(elem); //删除容器中所有与elem值匹配的元素。 12345678910111213list&lt;int&gt;::iterator itBegin=lstInt.begin();++itBegin;list&lt;int&gt;::iterator itEnd=lstInt.begin();++itEnd;++itEnd;++itEnd;lstInt.erase(itBegin,itEnd);//此时容器lstInt包含按顺序的1,6,9三个元素。lstA.push_back(3);lstA.push_back(3);lstA.remove(3); //将list中所有的3删除lstA.clear();//容器为空 11、list的反序排列 lst.reverse(); //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。 12345678list&lt;int&gt; lstA;lstA.push_back(1);lstA.push_back(3);lstA.push_back(5);lstA.push_back(7);lstA.push_back(9); lstA.reverse(); //9 7 5 3 1 12、list迭代器失效 删除结点导致迭代器失效 1234567for(list&lt;int&gt;::iterator it=lstInt.being(); it!=lstInt.end(); ) //小括号里不需写 ++it&#123; if(*it == 3) &#123; lstInt.erase(it); //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。 &#125;&#125; 附加部分：C++ STL prev()和next()函数 1 advance() 函数移动的是源迭代器 2 prev()函数 3 next()函数 1 advance() 函数移动的是源迭代器 但值得一提的是，advance() 函数移动的是源迭代器，举个例子： 1234567891011121314#include &lt;iostream&gt; // std::cout#include &lt;iterator&gt; // std::advance#include &lt;vector&gt;using namespace std;//创建一个 vector 容器vector&lt;int&gt; myvector&#123; 1,2,3,4 &#125;;//it为随机访问迭代器，其指向 myvector 容器中第一个元素vector&lt;int&gt;::iterator it = myvector.begin();//输出 it 迭代器指向的数据cout &lt;&lt; &quot;移动前的 *it = &quot; &lt;&lt; *it &lt;&lt; endl;//借助 advance() 函数将 it 迭代器前进 2 个位置advance(it, 2);cout &lt;&lt; &quot;移动后的 *it = &quot; &lt;&lt; *it &lt;&lt; endl; 通过程序的运行结果不难看出，advance() 函数没有任何返回值，其移动的是 it 迭代器本身。 这就产生一个问题，若我们不想移动 it 迭代器本身，而仅仅是想在 it 迭代器的基础上，得到一个移动指定位置的新迭代器，显然 advance() 函数是不合适的，这时就可以使用 2 prev()函数 prev 原意为“上一个”，但 prev() 的功能远比它的本意大得多，该函数可用来获取一个距离指定迭代器 n 个元素的迭代器。 prev() 函数的语法格式如下： template BidirectionalIterator prev (BidirectionalIterator it, typename iterator_traits::difference_type n = 1); 其中，it 为源迭代器，其类型只能为双向迭代器或者随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 1。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。 注意，当 n 为正数时，其返回的迭代器将位于 it 左侧；反之，当 n 为负数时，其返回的迭代器位于 it 右侧。 12345678910111213141516#include &lt;iostream&gt; // cout#include &lt;iterator&gt; // next#include &lt;list&gt; // listusing namespace std;//创建并初始化一个 list 容器list&lt;int&gt; mylist&#123; 1,2,3,4,5 &#125;;list&lt;int&gt;::iterator it = mylist.end();//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 左侧auto newit = prev(it, 2);cout &lt;&lt; &quot;prev(it, 2) = &quot; &lt;&lt; *newit &lt;&lt; endl;//n为负数，newit 位于 it 右侧it = mylist.begin();newit = prev(it, -2);cout &lt;&lt; &quot;prev(it, -2) = &quot; &lt;&lt; *newit; 可以看到，当 it 指向 mylist 容器最后一个元素之后的位置时，通过 prev(it, 2) 可以获得一个新迭代器 newit，其指向的是距离 it 左侧 2 个元素的位置（其存储的是元素 4）；当 it 指向 mylist 容器中首个元素时，通过 prev(it, -2) 可以获得一个指向距离 it 右侧 2 个位置处的新迭代器。 3 next()函数 和 prev 相反，next 原意为“下一个”，但其功能和 prev() 函数类似，即用来获取一个距离指定迭代器 n 个元素的迭代器。 next() 函数的语法格式如下： template ForwardIterator next (ForwardIterator it, typename iterator_traits::difference_type n = 1); 其中 it 为源迭代器，其类似可以为前向迭代器、双向迭代器以及随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 1。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。 需要注意的是，当 it 为前向迭代器时，n 只能为正数，该函数最终得到的新迭代器位于 it 右侧；当 it 为双向迭代器或者随机访问迭代器时，若 n 为正数，则得到的新迭代器位于 it 右侧，反之位于 it 左侧。 12345678910111213141516#include &lt;iostream&gt; // std::cout#include &lt;iterator&gt; // std::next#include &lt;list&gt; // std::listusing namespace std;//创建并初始化一个 list 容器list&lt;int&gt; mylist&#123; 1,2,3,4,5 &#125;;list&lt;int&gt;::iterator it = mylist.begin();//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 右侧auto newit = next(it, 2);cout &lt;&lt; &quot;next(it, 2) = &quot; &lt;&lt; *newit &lt;&lt; endl;//n为负数，newit 位于 it 左侧it = mylist.end();newit = next(it, -2);cout &lt;&lt; &quot;next(it, -2) = &quot; &lt;&lt; *newit; 可以看到，和 prev() 函数恰好相反，当 n 值为 2 时，next(it, 2) 函数获得的新迭代器位于 it 迭代器的右侧，距离 2 个元素；反之，当 n 值为 -2 时，新迭代器位于 it 迭代器的左侧，距离 2 个元素。 注意，和 prev() 函数一样，next() 函数自身也不会检查新迭代器指向的有效性，需要我们自己来保证。 10.2.5 stack容器 1、Stack简介 stack是堆栈容器，是一种“先进后出”的容器。 stack是简单地装饰deque容器而成为另外的一种容器。 2、stack对象的默认构造 stack采用模板类实现， stack对象的默认构造形式：stack s; 12345stack &lt;int&gt; stkInt; //一个存放int的stack容器。stack &lt;float&gt; stkFloat; //一个存放float的stack容器。stack &lt;string&gt; stkString; //一个存放string的stack容器。... //尖括号内还可以设置指针类型或自定义类型。 3、stack的push()与pop()方法 123456789stack.push(elem); //往栈头添加元素stack.pop(); //从栈头移除第一个元素stack&lt;int&gt; stkInt; stkInt.push(1);stkInt.push(3);stkInt.pop(); stkInt.push(5);stkInt.push(7); stkInt.push(9);stkInt.pop(); stkInt.pop(); //此时stkInt存放的元素是1,5 4、 stack对象的拷贝构造与赋值 stack(const stack &amp;stk); //拷贝构造函数 stack&amp; operator=(const stack &amp;stk); //重载等号操作符 12345678910stack&lt;int&gt; stkIntA;stkIntA.push(1);stkIntA.push(3);stkIntA.push(5);stkIntA.push(7);stkIntA.push(9);stack&lt;int&gt; stkIntB(stkIntA); //拷贝构造stack&lt;int&gt; stkIntC;stkIntC = stkIntA; //赋值 5、 stack的数据存取 12345678910stack.top(); //返回最后一个压入栈元素stack&lt;int&gt; stkIntA;stkIntA.push(1);stkIntA.push(3);stkIntA.push(5);stkIntA.push(7);stkIntA.push(9);int iTop = stkIntA.top(); //9stkIntA.top() = 19; //19 6、stack的大小 stack.empty(); //判断堆栈是否为空 stack.size(); //返回堆栈的大小 1234567891011stack&lt;int&gt; stkIntA;stkIntA.push(1);stkIntA.push(3);stkIntA.push(5);stkIntA.push(7);stkIntA.push(9);if (!stkIntA.empty())&#123; int iSize = stkIntA.size(); //5&#125; 10.2.6 queue 容器 1、Queue简介 queue是队列容器，是一种“先进先出”的容器。 2、queue对象的默认构造 queue采用模板类实现，queue对象的默认构造形式：queue q; 如： 12345queue&lt;int&gt; queInt; //一个存放int的queue容器。queue&lt;float&gt; queFloat; //一个存放float的queue容器。queue&lt;string&gt; queString; //一个存放string的queue容器。... //尖括号内还可以设置指针类型或自定义类型。 3、queue的push()与pop()方法 queue.push(elem); //往队尾添加元素 queue.pop(); //从队头移除第一个元素 123456queue&lt;int&gt; queInt;queInt.push(1);queInt.push(3);queInt.push(5);queInt.push(7);queInt.push(9);queInt.pop();queInt.pop();此时queInt存放的元素是5,7,9 4、queue对象的拷贝构造与赋值 queue(const queue &amp;que); //拷贝构造函数 queue&amp; operator=(const queue &amp;que); //重载等号操作符 12345678910queue&lt;int&gt; queIntA;queIntA.push(1);queIntA.push(3);queIntA.push(5);queIntA.push(7);queIntA.push(9); queue&lt;int&gt; queIntB(queIntA); //拷贝构造queue&lt;int&gt; queIntC;queIntC = queIntA; //赋值 5、queue的数据存取 queue.back(); //返回最后一个元素 queue.front(); //返回第一个元素 123456789101112queue&lt;int&gt; queIntA;queIntA.push(1);queIntA.push(3);queIntA.push(5);queIntA.push(7);queIntA.push(9); int iFront = queIntA.front(); //1int iBack = queIntA.back(); //9 queIntA.front() = 11; //11queIntA.back() = 19; //19 6、queue的大小 queue.empty(); //判断队列是否为空 queue.size(); //返回队列的大小 1234567891011queue&lt;int&gt; queIntA; queIntA.push(1); queIntA.push(3); queIntA.push(5);queIntA.push(7);queIntA.push(9); if (!queIntA.empty())&#123; int iSize = queIntA.size(); //5&#125; 10.2.7 Set和multiset容器 1、set/multiset的简介 set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。 set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。 multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。 不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。 #include &lt;set&gt; 123456789102、set/multiset对象的默认构造```cppset&lt;int&gt; setInt; //一个存放int的set容器。set&lt;float&gt; setFloat; //一个存放float的set容器。set&lt;string&gt; setString; //一个存放string的set容器。multiset&lt;int&gt; mulsetInt; //一个存放int的multi set容器。multi set&lt;float&gt; multisetFloat; //一个存放float的multi set容器。multi set&lt;string&gt; multisetString; //一个存放string的multi set容器。 3、set对象的拷贝构造与赋值 set(const set &amp;st); //拷贝构造函数 set&amp; operator=(const set &amp;st); //重载等号操作符 set.swap(st); //交换两个集合容器 12345678910111213set&lt;int&gt; setIntA;setIntA.insert(3);setIntA.insert(1);setIntA.insert(7);setIntA.insert(5);setIntA.insert(9); set&lt;int&gt; setIntB(setIntA); //1 3 5 7 9set&lt;int&gt; setIntC;setIntC = setIntA; //1 3 5 7 9 setIntC.insert(6);setIntC.swap(setIntA); //交换 4、set的大小 set.size(); //返回容器中元素的数目 set.empty();//判断容器是否为空 1234567891011set&lt;int&gt; setIntA;setIntA.insert(3);setIntA.insert(1);setIntA.insert(7);setIntA.insert(5);setIntA.insert(9); if (!setIntA.empty())&#123; int iSize = setIntA.size(); //5&#125; 5、set的插入与迭代器 set.insert(elem); //在容器中插入元素。 set.begin(); //返回容器中第一个数据的迭代器。 set.end(); //返回容器中最后一个数据之后的迭代器。 set.rbegin(); //返回容器中倒数第一个元素的迭代器。 set.rend(); //返回容器中倒数最后一个元素的后面的迭代器。 1234567891011set&lt;int&gt; setInt;setInt.insert(3); setInt.insert(1);setInt.insert(5);setInt.insert(2);for(set&lt;int&gt;::iterator it=setInt.begin(); it!=setInt.end(); ++it)&#123; int iItem = *it; cout &lt;&lt; iItem; //或直接使用cout &lt;&lt; *it&#125;//这样子便顺序输出 1 2 3 5。 5、set的删除 set.clear(); //清除所有元素 set.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 set.erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 set.erase(elem); //删除容器中值为elem的元素。 12345678910111213141516171819删除区间内的元素setInt是用set&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9,11元素。set&lt;int&gt;::iterator itBegin=setInt.begin();++itBegin;set&lt;int&gt;::iterator itEnd=setInt.begin();++itEnd;++itEnd;++itEnd;setInt.erase(itBegin,itEnd);//此时容器setInt包含按顺序的1,6,9,11四个元素。 删除容器中第一个元素setInt.erase(setInt.begin()); //6,9,11 删除容器中值为9的元素set.erase(9); 删除setInt的所有元素setInt.clear(); //容器为空 6、set集合的元素排序 要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。 下面将讲解什么是functor，functor的用法。 123456set&lt;int,greater&lt;int&gt;&gt; setIntB; setIntB.insert(3);setIntB.insert(1);setIntB.insert(5);setIntB.insert(2);此时容器setIntB就包含了按顺序的5,3,2,1元素 函数对象functor的用法 尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。 functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。 greater&lt;&gt;与less&lt;&gt;就是函数对象。 下面举出greater的简易实现原理: 1234567class greater&#123; bool operator() (const int&amp; iLeft, const int&amp; iRight) &#123; return (iLeft&gt;iRight); //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight); &#125;&#125; 容器就是调用函数对象的operator()方法去比较两个值的大小。 思考：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。 1234567891011121314151617181920212223242526272829303132//学生类class CStudent&#123; public: CStudent(int iID, string strName) &#123; m_iID = iID; m_strName = strName; &#125; int m_iID; //学号 string m_strName; //姓名&#125;//本类不写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。//函数对象class StuFunctor&#123; bool operator() (const CStudent &amp;stu1, const CStudent &amp;stu2) &#123; return (stu1.m_iID&lt;stu2.m_iID); &#125;&#125; //main函数int main()&#123; set&lt;CStudent, StuFunctor&gt; setStu; setStu.insert(CStudent(3,&quot;小张&quot;)); setStu.insert(CStudent(1,&quot;小李&quot;)); setStu.insert(CStudent(5,&quot;小王&quot;)); setStu.insert(CStudent(2,&quot;小刘&quot;)); //此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” &#125; 7、set的查找 set.find(elem); //查找elem元素，返回指向elem元素的迭代器。 set.count(elem); //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。 set.lower_bound(elem); //返回第一个 &gt;=elem元素的迭代器。 set.upper_bound(elem); // 返回第一个&gt;elem元素的迭代器。 123456789101112131415set&lt;int&gt; setInt;setInt.insert(3);setInt.insert(1);setInt.insert(7);setInt.insert(5);setInt.insert(9); set&lt;int&gt;::iterator itA = setInt.find(5);int iA = *itA; //iA == 5int iCount = setInt.count(5); //iCount == 1 set&lt;int&gt;::iterator itB = setInt.lower_bound(5);set&lt;int&gt;::iterator itC = setInt.upper_bound(5);int iB = *itB; //iB == 5int iC = *itC; //iC == 7 set.equal_range(elem); //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 函数返回两个迭代器，而这两个迭代器被封装在pair中。 pair&lt; set&lt;int&gt;::iterator, set&lt;int&gt;::iterator &gt; pairIt = setInt.equal_range(5); //pair是什么？ &lt;!--code￼48--&gt; 10.2.8 map和multimap容器 1、map/multimap的简介 map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。 map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。 map可以直接存取key所对应的value，支持[]操作符，如map[key]=value(将key键所对应的值修改为value) multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。 2、map/multimap对象的默认构造 1234567//map/multimap采用模板类实现，对象的默认构造形式：map&lt;T1,T2&gt; mapTT;multimap&lt;T1,T2&gt; multimapTT; //如：map&lt;int, char&gt; mapA;map&lt;string,float&gt; mapB;//其中T1,T2还可以用各种指针类型或自定义类型 3、map的插入与迭代器 1map.insert(...); //往容器插入元素，返回pair 在map中插入元素的三种方式： 假设 map mapStu; 一、通过pair的方式插入对象 1mapStu.insert(pair(3,&quot;小张&quot;) ); 二、通过value_type的方式插入对象 1mapStu.insert( map&lt;int,string&gt;::value_type(1,&quot;小李&quot;) ); 三、通过数组的方式插入值 123mapStu[3] = “小刘&quot;;mapStu[5] = “小王&quot;； 前两种方法，采用的是insert()方法，该方法返回值为pair 第三种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为“小刘”的键值对插入到map中。若发现已存在3这个键，则修改这个键对应的value为“小刘”。 如果键存在则修改，如果不存在则插入 string strName = mapStu[2]; //取操作或插入操作 只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。 12345678910111213map&lt;int, string&gt; mapA;pair&lt;map&lt;int,string&gt;::iterator, bool&gt; pairResult = mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;)); //插入方式一 int iFirstFirst = (pairResult.first)-&gt;first; //iFirst == 3;string strFirstSecond = (pairResult.first)-&gt;second; //strFirstSecond为&quot;小张&quot;bool bSecond = pairResult.second; //bSecond == true;mapA.insert(map&lt;int,string&gt;::value_type(1,&quot;小李&quot;)); //插入方式二mapA[3] = &quot;小刘&quot;; //修改valuemapA[5] = &quot;小王&quot;; //插入方式三 string str1 = mapA[2]; //执行插入 string() 操作，返回的str1的字符串内容为空。string str2 = mapA[3]; //取得value，str2为&quot;小刘&quot; 使用迭代器遍历： 123456for (map&lt;int,string&gt;::iterator it=mapA.begin(); it!=mapA.end(); ++it)&#123; pair&lt;int, string&gt; pr = *it; int iKey = pr.first; string strValue = pr.second;&#125; 4、map容器或者键所对应的值 方法一：使用[] 方法二：使用find()函数：成功返回对应的迭代器，失败返回end()的返回值 1map&lt;int, string&gt;::iterator it = mapS.find(3); 方法三：使用at()函数，如果键值对不存在会抛出“out_of_range 异常” 5、map对象的拷贝构造与赋值 map(const map &amp;mp); //拷贝构造函数 map&amp; operator=(const map &amp;mp); //重载等号操作符 map.swap(mp); //交换两个集合容器 123456789101112map&lt;int, string&gt; mapA;mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); map&lt;int ,string&gt; mapB(mapA); //拷贝构造map&lt;int, string&gt; mapC;mapC = mapA; //赋值 mapC[3] = &quot;老张&quot;;mapC.swap(mapA); //交换 6、map的大小 map.size(); //返回容器中元素的数目 map.empty();//判断容器是否为空 12345678910map&lt;int, string&gt; mapA;mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); if (mapA.empty())&#123; int iSize = mapA.size(); //iSize == 4&#125; 7、map的删除 map.clear(); //删除所有元素 map.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 map.erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 map.erase(keyElem); //删除容器中key为keyElem的对组。 12345map&lt;int, string&gt; mapA;mapA.insert(pair&lt;int,string&gt;(3,&quot;小张&quot;));mapA.insert(pair&lt;int,string&gt;(1,&quot;小杨&quot;));mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); 删除区间内的元素： 12345678map&lt;int,string&gt;::iterator itBegin=mapA.begin();++ itBegin;++ itBegin;map&lt;int,string&gt;::iterator itEnd=mapA.end();mapA.erase(itBegin,itEnd); //此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。 mapA.insert(pair&lt;int,string&gt;(7,&quot;小赵&quot;));mapA.insert(pair&lt;int,string&gt;(5,&quot;小王&quot;)); 删除容器中指定 的元素： 1mapA.erase(5); 删除容器中指定位置的元素： 1mapA.erase(mapA.begin()); 8、map的查找 map.find(key); 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end(); map.count(keyElem); //返回容器中key为keyElem的对组个数。 map.lower_bound(elem); //返回第一个&gt;=elem元素的迭代器。 map.upper_bound(elem); // 返回第一个&gt;elem元素的迭代器。 map.equal_range(elem); //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 123456789101112map&lt;int,string&gt;::iterator it=mapStu.find(3);if(it == mapStu.end())&#123;//没找到&#125;else&#123; //找到了 pair&lt;int, string&gt; pairStu = *it; int iID = pairStu.first; //或 int iID = it-&gt;first; string strName = pairStu.second; //或 string strName = it-&gt;second;&#125; 10.2.9 总结 特点对比： 底层实现： 10.3 算法 10.3.1 排序算法 10.3.1.1 sort() 排序函数 sort() 函数是基于快速排序实现的 sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数： 容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 vector、deque 这 2个容器提供支持 如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持&lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符 sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须拷贝构造函数和赋值运算符的重载。 sort() 排序是不稳定的 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::sort#include &lt;vector&gt; // std::vectorusing namespace std;//以普通函数的方式实现自定义排序规则bool mycomp(int i, int j) &#123; return (i &lt; j);&#125;//以函数对象的方式实现自定义排序规则class mycomp2 &#123;public: bool operator() (int i, int j) &#123; return (i &lt; j); &#125;&#125;;int main() &#123; int a[] = &#123; 32, 71, 12, 45, 26, 80, 53, 33 &#125;; vector&lt;int&gt; myvector(a, a+8); //调用第一种语法格式，对 32、71、12、45 进行排序 sort(myvector.begin(), myvector.begin() + 4); //(12 32 45 71) 26 80 53 33 //调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序 sort(myvector.begin(), myvector.begin() + 4, greater&lt;int&gt;()); //(71 45 32 12) 26 80 53 33 //调用第二种语法格式，通过自定义比较规则进行排序 sort(myvector.begin(), myvector.end(), mycomp2());//12 26 32 33 45 53 71 80 //输出 myvector 容器中的元素 for (vector&lt;int&gt;::iterator it = myvector.begin(); it != myvector.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 10.3.1.2 stable_sort()排序算法 stable_sort() 函数是基于归并排序实现的 stable_sort() 是稳定的排序算法 stable_sort()函数与sort()函数的使用方法相同。 10.3.1.3 partial_sort()排序函数 1、引入 假设这样一种情境，有一个存有 100 万个元素的容器，但我们只想从中提取出值最小的 10 个元素，该如何实现呢？ 通过前面的学习，可能会想到使用 sort() 或者 stable_sort() 排序函数，即通过对容器中存储的 100 万个元素进行排序，就可以成功筛选出最小的 10 个元素。但仅仅为了提取 10 个元素，却要先对 100 万个元素进行排序，可想而知这种实现方式的效率是非常低的。 对于解决类似的问题，C++ STL 标准库提供了更高效的解决方案，使用 partial_sort()。 partial sort 可直译为“部分排序”，该函数可以从指定区域中提取出部分数据，并对它们进行排序。 2、语法格式 123456789101112131415//按照默认的升序排序规则，对 [first, last) 范围的数据进行筛选并排序void partial_sort (RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);//按照 comp 排序规则，对 [first, last) 范围的数据进行筛选并排序void partial_sort (RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);/*其中，first、middle 和 last 都是随机访问迭代器，comp 参数用于自定义排序规则。partial_sort() 函数会以交换元素存储位置的方式实现部分排序的。具体来说，partial_sort() 会将 [first, last) 范围内最小（或最大）的 middle-first 个元素移动到 [first, middle) 区域中，并对这部分元素做升序（或降序）排序。*/ 需要注意的是，partial_sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 partial_sort() 函数： partial_sort() 函数只适用于 array、vector、deque 这 3 个容器。 当选用默认的升序排序规则时，容器中存储的元素类型必须支持 &lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符； partial_sort() 函数在实现过程中，需要交换某些元素的存储位置。因此，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::partial_sort#include &lt;vector&gt; // std::vectorusing namespace std;//以普通函数的方式自定义排序规则bool mycomp1(int i, int j) &#123; return (i &gt; j);&#125;//以函数对象的方式自定义排序规则class mycomp2 &#123;public: bool operator() (int i, int j) &#123; return (i &gt; j); &#125;&#125;;int main() &#123; vector&lt;int&gt; myvector&#123; 3,2,5,4,1,6,9,7&#125;; //以默认的升序排序作为排序规则，将 myvector 中最小的 4 个元素移动到开头位置并排好序 partial_sort(myvector.begin(), myvector.begin() + 4, myvector.end()); cout &lt;&lt; &quot;第一次排序:\\n&quot;; for (vector&lt;int&gt;::iterator it = myvector.begin(); it != myvector.end(); ++it) cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;; cout &lt;&lt; &quot;\\n第二次排序:\\n&quot;; // 以指定的 mycomp2 作为排序规则，将 myvector 中最大的 4 个元素移动到开头位置并排好序 partial_sort(myvector.begin(), myvector.begin() + 4, myvector.end(), mycomp2()); for (vector&lt;int&gt;::iterator it = myvector.begin(); it != myvector.end(); ++it) cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;; return 0;&#125; 程序执行结果为： 10.3.1.4 merge()函数 功能：将两个已经排好序的序列合并为一个有序的序列 默认排序规则： 12345678910111213//以默认的升序排序作为排序规则OutputIterator merge (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);//以自定义的 comp 规则作为排序规则OutputIterator merge (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);/** firs1t为第一个容器的首迭代器，last1为第一个容器的末迭代器；* first2为第二个容器的首迭代器，last2为容器的末迭代器；* result为存放结果的容器，comapre为比较函数（可略写，默认为合并为一个升序序列）。*/ 注意：使用的时候result，如果用的vector，必须先使用resize扩容 10.3.1.5 revrese()函数 函数参数:reverse(first，last) 功能：反转容器 注意： string和vector和deque只能使用模板库算法里的反转函数 list可以使用算法里的和list类的reverse stack和queue没有迭代器，自然不能使用算法里的reverse,其类也没有提供反转的成员函数 set和map的元素是按照键值排序的，不能修改键值，不可反转. 10.3.2 查找算法 10.3.2.1 adjacent_find() 功能：在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。 123456789vector&lt;int&gt; vecInt;vecInt.push_back(1);vecInt.push_back(2);vecInt.push_back(2);vecInt.push_back(4);vecInt.push_back(5);vecInt.push_back(5);vector&lt;int&gt;::iterator it = adjacent_find(vecInt.begin(), vecInt.end()); //*it == 2 10.3.2.2 binary_search() 功能：二分查找法，在有序序列中查找value,找到则返回true。 12345678set&lt;int&gt; setInt;setInt.insert(3);setInt.insert(1);setInt.insert(7);setInt.insert(5);setInt.insert(9);bool bFind = binary_search(setInt.begin(),setInt.end(),5); 10.3.2.3 count() 功能：利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。 12345678vector&lt;int&gt; vecInt;vecInt.push_back(1);vecInt.push_back(2);vecInt.push_back(2);vecInt.push_back(4);vecInt.push_back(2);vecInt.push_back(5);int iCount = count(vecInt.begin(),vecInt.end(),2); //iCount==3 10.3.2.4 find() 功能：find() 函数用于在指定范围内查找和目标元素值相等的第一个元素。 函数的语法格式： 1InputIterator find (InputIterator first, InputIterator last, const T&amp; val); 其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。 正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。 该函数会返回一个输入迭代器，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。 find() 函数的底层实现，其实就是用运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持运算符。 1234567891011121314151617181920212223#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::find#include &lt;vector&gt; // std::vectorusing namespace std;int main() &#123; //find() 函数作用于普通数组 char stl[] =&quot;http://c.biancheng.net/stl/&quot;; //调用 find() 查找第一个字符 &#x27;c&#x27; char * p = find(stl, stl + strlen(stl), &#x27;c&#x27;); //判断是否查找成功 if (p != stl + strlen(stl)) &#123; cout &lt;&lt; p &lt;&lt; endl; &#125; //find() 函数作用于容器 vector&lt;int&gt; myvector&#123; 10,20,30,40,50 &#125;; vector&lt;int&gt;::iterator it; it = find(myvector.begin(), myvector.end(), 30); if (it != myvector.end()) cout &lt;&lt; &quot;查找成功：&quot; &lt;&lt; *it; else cout &lt;&lt; &quot;查找失败&quot;; return 0;&#125; 10.3.2.5 find_if() 功能：和 find() 函数相同，find_if() 函数也用于在指定区域内执行查找操作。不同的是，前者需要明确指定要查找的元素的值，而后者则允许自定义查找规则。 12345678910111213141516171819#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::find_if#include &lt;vector&gt; // std::vectorusing namespace std;//以函数对象的形式定义一个 find_if() 函数的查找规则class mycomp2 &#123;public: bool operator()(const int&amp; i) &#123; return ((i % 2) == 1); &#125;&#125;;int main() &#123; vector&lt;int&gt; myvector&#123; 4,2,3,1,5 &#125;; //调用 find_if() 函数 vector&lt;int&gt;::iterator it = find_if(myvector.begin(), myvector.end(), mycomp2()); cout &lt;&lt; &quot;*it = &quot; &lt;&lt; *it; return 0;&#125; 10.3.2.5 search() 功能：search()函数用于在序列 A 中查找序列 B 第一次出现的位置。 例如，以如下两个序列为例： 可以看到，序列 B 在序列 A 中出现了 2 次，借助 search() 函数，我们可以找到序列 A 中第 1 个 {1,2,3}。 search() 函数提供有以下 2 种语法格式： 1234567//查找 [first1, last1) 范围内第一个 [first2, last2) 子序列ForwardIterator search (ForwardIterator first1, ForwardIterator last1, ForwardIterator first2, ForwardIterator last2);//查找 [first1, last1) 范围内，和 [first2, last2) 序列满足 pred 规则的第一个子序列ForwardIterator search (ForwardIterator first1, ForwardIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred); 其中，各个参数的含义分别为： first1、last1：都为正向迭代器，其组合 [first1, last1) 用于指定查找范围（也就是上面例子中的序列 A）； first2、last2：都为正向迭代器，其组合 [first2, last2) 用于指定要查找的序列（也就是上面例子中的序列 B）； pred：用于自定义查找规则。该规则实际上是一个包含 2 个参数且返回值类型为 bool 的函数（第一个参数接收 [first1, last1) 范围内的元素，第二个参数接收 [first2, last2) 范围内的元素）。函数定义的形式可以是普通函数，也可以是函数对象。 search() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和 last1 迭代器相同。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::search#include &lt;vector&gt; // std::vectorusing namespace std;//以普通函数的形式定义一个匹配规则bool mycomp1(int i, int j) &#123; return (i%j == 0);&#125;//以函数对象的形式定义一个匹配规则class mycomp2 &#123;public: bool operator()(const int&amp; i, const int&amp; j) &#123; return (i%j == 0); &#125;&#125;;int main() &#123; vector&lt;int&gt; myvector&#123; 1,2,3,4,8,12,18,1,2,3 &#125;; int myarr[] = &#123; 1,2,3 &#125;; //调用第一种语法格式 vector&lt;int&gt;::iterator it = search(myvector.begin(), myvector.end(), myarr, myarr + 3); if (it != myvector.end()) &#123; cout &lt;&lt; &quot;第一个&#123;1,2,3&#125;的起始位置为：&quot; &lt;&lt; it - myvector.begin() &lt;&lt; &quot;,*it = &quot; &lt;&lt; *it &lt;&lt; endl; &#125; int myarr2[] = &#123; 2,4,6 &#125;; //调用第二种语法格式 it = search(myvector.begin(), myvector.end(), myarr2, myarr2 + 3, mycomp2()); if (it != myvector.end()) &#123; cout &lt;&lt; &quot;第一个&#123;2,3,4&#125;的起始位置为：&quot; &lt;&lt; it - myvector.begin() &lt;&lt; &quot;,*it = &quot; &lt;&lt; *it; &#125; return 0;&#125; 程序执行结果为：","categories":[{"name":"C++ STL","slug":"C-STL","permalink":"https://xqc-1368.github.io/categories/C-STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"字符串","slug":"字符串","permalink":"https://xqc-1368.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"STL","slug":"STL","permalink":"https://xqc-1368.github.io/tags/STL/"}]},{"title":"MARKTEXT使用指南","slug":"MARKTEXT使用指南","date":"2024-08-19T04:23:45.795Z","updated":"2024-08-19T04:23:25.632Z","comments":true,"path":"2024/08/19/MARKTEXT使用指南/","permalink":"https://xqc-1368.github.io/2024/08/19/MARKTEXT%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"MARKTEXT使用指南 1.建立新文件 ctrl+j 调出侧边框 然后我们可以看到最左侧有三个符号，分别是便签纸 ，放大镜，字母H 然后我们来看一下第一个符号有什么作用，当我们按下 ctrl+t 的时候，我们会发现，左侧工作区多了一个Untitled(未命名),当我们每按下一次 ctrl+t 的时候，系统会自动生成一个新的未命名页面 为什么要有这一步呢，我举个简单的例子，比如我们同时在学习计算机网络和操作系统两门课，如果我们不想把这两门课自己记录的笔记搞混，最好的办法就是准备两个笔记本，这里一个页面就相当于一个笔记本 然后第二个放大镜图标是查找功能，这里我们先放一下，接下来回和其他功能放到一块讲 2.写作 首先我们点击那个左边三个图标中的H图标，切换到标题模式 首先我们来学习一下标题的使用 首先我们可以打一个#号，输入完之后我们会惊喜的发现左侧也出现了这个#号 我们此时再去按一下空格，会进入标题输入模式，就像下面这样，你可能会好奇#号去哪了，让我们仔细观察，刚才输入#号的地方多了一个H1图标，这样就表示我们进入了标题输入模式 下面让我们看看输入一些东西会发生什么吧 到这一步你可能还会疑惑这有什么用，先别着急，答案马上揭晓，限免我们继续类比思考，H1是一个#号，那H2是不是就是两个#,恭喜你，猜对了！ 下面让我们按一下回车换行，回到正常的文字输入模式，上一行是标题模式，只要你在上一行写，他都会出现在左侧，这不是我们的目的 首先我们输入两个# 然后还是老规矩按一下空格，然后我们就能看到H2了，然后继续在上面写 我们可以看到，我们已经把标题写好了，以后只要往标题里面写对应内容就好了，同时左边的生成的标题文字是可以点击的，点击哪个标题，系统就会跳到对应标题处，这样就可以很轻松的知道自己笔记写到哪了 学会上面的基本操作之后，我再演示一下如何生成同级标题，如果你想和食谱同级就输一个#，如果想和红烧排骨同级就输入两个#,演示如下 下面来讲如何插入代码块，这里假如我们要在红烧排骨里面写代码，我们就先在红烧排骨后面点一下，然后多按几下换行，为插入代码预留足够的空间，按下ctrl+shift+k,我们会看到这样的场景 然后我们输入要用的语言，比如这里我们用javascript,当我们只输入到了java的时候就跳出补全了 这时候我们啥也不要干，只按上下键进行选择就好了，选好后按回车确认，然后在框里写的代码就有高亮语法了 如果要跳出代码块按 ctrl+shift+n 就欧克了 还有一个功能是插入列表，快捷键是 ctrl+shift+t 定义好行和列点击ok就可以了 还有一个是插入图片，这个我们平常一般都是插入截图，截好之后，找好地方，右键然后paste,或者ctrl+v就可以 学会插图在听网课时可以帮我们节约非常多的时间 最后再教大家一个功能就是查找 比如这是我之前做的python笔记，因为时间有点久了，所以找不到一些笔记在哪了 这时候我们可以按下 ctrl+f 输入关键词查找 在里面输入关键字 3.保存与关闭 假如我们写好了一篇文章，我们按下 ctrl+s 系统会让我们选择保存地址，我们一定要牢记自己保存到哪了，这样以后才能继续在刚才的笔记上做修改和增加 好了，下面让我们再次打开它吧，首先打开编辑器，选open fil 找到保存的地址，找到对应文件双击就OK了 最后我要提醒一点，Marktext没有返回上一步的功能，所以你最好写一段保存一段，不然写了半天，不小心误删了，可是很痛苦的，如果写一段保存一段，还能再最后退出的时候选择不保存留住大部分内容 好了，祝你在Marktext的世界玩的愉快 ————————————————","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://xqc-1368.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://xqc-1368.github.io/tags/Markdown/"}]},{"title":"CMake学习笔记2","slug":"CMake学习笔记2","date":"2024-08-19T04:23:45.786Z","updated":"2024-08-19T03:11:53.273Z","comments":true,"path":"2024/08/19/CMake学习笔记2/","permalink":"https://xqc-1368.github.io/2024/08/19/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","excerpt":"","text":"CMake学习笔记2 2.7 日志 在CMake中可以用用户显示一条消息，该命令的名字为message： 1message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] &quot;message to display&quot; ...) (无)：重要消息 STATUS ：非重要消息 WARNING：CMake 警告, 会继续执行 AUTHOR_WARNING：CMake 警告 (dev), 会继续执行 SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤 FATAL_ERROR：CMake 错误, 终止所有处理过程 CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。 CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。 123456# 输出一般日志信息message(STATUS &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)# 输出警告信息message(WARNING &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)# 输出错误信息message(FATAL_ERROR &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;) 2.8 变量操作 2.8.1 追加 有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过file命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用set命令也可以使用list命令。 使用set拼接 如果使用set进行字符串拼接，对应的命令格式如下： 1set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...) 关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。 12345678cmake_minimum_required(VERSION 3.0)project(TEST)set(TEMP &quot;hello,world&quot;)file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)# 追加(拼接)set(SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;) 使用list拼接 如果使用list进行字符串拼接，对应的命令格式如下： 1list(APPEND &lt;list&gt; [&lt;element&gt; ...]) list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。 12345678cmake_minimum_required(VERSION 3.0)project(TEST)set(TEMP &quot;hello,world&quot;)file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)# 追加(拼接)list(APPEND SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;) 在CMake中，使用set命令可以创建一个list。一个在list内部是一个由分号;分割的一组字符串。例如，set(var a b c d e)命令将会创建一个list:a;b;c;d;e，但是最终打印变量值的时候得到的是abcde。 1234set(tmp1 a;b;c;d;e)set(tmp2 a b c d e)message($&#123;tmp1&#125;)message($&#123;tmp2&#125;) 输出的结果： 12abcdeabcde 2.8.2 字符串移除 我们在通过file搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如： 123456789$ tree.├── add.cpp├── div.cpp├── main.cpp├── mult.cpp└── sub.cpp0 directories, 5 files 在当前这么目录有五个源文件，其中main.cpp是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要add.cpp、div.cpp、mult.cpp、sub.cpp这四个源文件就可以了。此时，就需要将main.cpp从搜索到的数据中剔除出去，想要实现这个功能，也可以使用list 1list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...]) 通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了REMOVE_ITEM。 12345678910cmake_minimum_required(VERSION 3.0)project(TEST)set(TEMP &quot;hello,world&quot;)file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/*.cpp)# 移除前日志message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)# 移除 main.cpplist(REMOVE_ITEM SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/main.cpp)# 移除后日志message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;) 可以看到，在第8行把将要移除的文件的名字指定给list就可以了。但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。 关于list命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。 获取 list 的长度。 1list(LENGTH &lt;list&gt; &lt;output variable&gt;) 读取列表中指定索引的的元素，可以指定多个索引 1list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;) 将列表中的元素用连接符（字符串）连接起来组成一个字符串 1list (JOIN &lt;list&gt; &lt;glue&gt; &lt;output variable&gt;) 查找列表是否存在指定的元素，若果未找到，返回-1 1list(FIND &lt;list&gt; &lt;value&gt; &lt;output variable&gt;) 将元素追加到列表中 1list (APPEND &lt;list&gt; [&lt;element&gt; ...]) 在list中指定的位置插入若干元素 1list(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...]) 将元素插入到列表的0索引位置 1list (PREPEND &lt;list&gt; [&lt;element&gt; ...]) 将列表中最后元素移除 1list (POP_BACK &lt;list&gt; [&lt;out-var&gt;...]) 将列表中第一个元素移除 1list (POP_FRONT &lt;list&gt; [&lt;out-var&gt;...]) 将指定的元素从列表中移除 1list (REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...]) 将指定索引的元素从列表中移除 1list (REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...]) 移除列表中的重复元素 1list (REMOVE_DUPLICATES &lt;list&gt;) 列表翻转 1list(REVERSE &lt;list&gt;) 列表排序 1list (SORT &lt;list&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;]) 2.9 宏定义 在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示： 123456789101112131415#include &lt;stdio.h&gt;#define NUMBER 3int main()&#123; int a = 10;#ifdef DEBUG printf(&quot;我是一个程序猿, 我不会爬树...\\n&quot;);#endif for(int i=0; i&lt;NUMBER; ++i) &#123; printf(&quot;hello, GCC!!!\\n&quot;); &#125; return 0;&#125; 在程序的第七行对DEBUG宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出（上述代码中并没有定义这个宏）。 为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在gcc/g++命令中去指定，如下： 1$ gcc test.c -DDEBUG -o app 在gcc/g++命令中通过参数 -D指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为DEBUG。 在CMake中我们也可以做类似的事情，对应的命令叫做add_definitions: 1add_definitions(-D宏名称) 针对于上面的源文件编写一个CMakeLists.txt，内容如下： 12345cmake_minimum_required(VERSION 3.0)project(TEST)# 自定义 DEBUG 宏add_definitions(-DDEBUG)add_executable(app ./test.c) 通过这种方式，上述代码中的第八行日志就能够被输出出来了。 3.预定义宏 下面的列表中为大家整理了一些CMake中常用的宏： 宏 功能 PROJECT_SOURCE_DIR 使用cmake命令后紧跟的目录，一般是工程的根目录 PROJECT_BINARY_DIR 执行cmake命令的目录 CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径 CMAKE_CURRENT_BINARY_DIR target 编译目录 EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置 LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置 PROJECT_NAME 返回通过PROJECT指令定义的项目名称 CMAKE_BINARY_DIR 项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径 CMake 保姆级教程（下） 1. 嵌套的CMake 如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。 先来看一下下面的这个的目录结构： 12345678910111213141516171819202122232425$ tree├── build├── calc│ ├── add.cpp│ ├── CMakeLists.txt│ ├── div.cpp│ ├── mult.cpp│ └── sub.cpp├── CMakeLists.txt├── include│ ├── calc.h│ └── sort.h├── sort│ ├── CMakeLists.txt│ ├── insert.cpp│ └── select.cpp├── test1│ ├── calc.cpp│ └── CMakeLists.txt└── test2 ├── CMakeLists.txt └── sort.cpp6 directories, 15 files include 目录：头文件目录 calc 目录：目录中的四个源文件对应的加、减、乘、除算法 对应的头文件是include中的calc.h sort 目录 ：目录中的两个源文件对应的是插入排序和选择排序算法 对应的头文件是include中的sort.h test1 目录：测试目录，对加、减、乘、除算法进行测试 test2 目录：测试目录，对排序算法进行测试 可以看到各个源文件目录所需要的CMakeLists.txt文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。 1.1 准备工作 1.1.1 节点关系 众所周知，Linux的目录是树状结构，所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。因此，我们需要了解一些关于 CMakeLists.txt 文件变量作用域的一些信息： 根节点CMakeLists.txt中的变量全局有效 父节点CMakeLists.txt中的变量可以在子节点中使用 子节点CMakeLists.txt中的变量只能在当前节点中使用 1.1.2 添加子目录 接下来我们还需要知道在 CMake 中父子节点之间的关系是如何建立的，这里需要用到一个 CMake命令： 1add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])","categories":[{"name":"CMake","slug":"CMake","permalink":"https://xqc-1368.github.io/categories/CMake/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"CMake","slug":"CMake","permalink":"https://xqc-1368.github.io/tags/CMake/"}]},{"title":"CMake学习笔记1","slug":"CMake学习笔记1","date":"2024-08-19T04:23:45.782Z","updated":"2024-08-19T03:40:30.200Z","comments":true,"path":"2024/08/19/CMake学习笔记1/","permalink":"https://xqc-1368.github.io/2024/08/19/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"CMake学习笔记 来源： 文件资料 CMake 保姆级教程（上） | 爱编程的大丙 (subingwen.cn) 视频教学 【CMake 保姆级教程【C/C++】】 （一）第一次开发顺序： 1.要写的main程序写好，分程序写好，头文件库写好 2.建立CMakeLists.txt文件，在里面写内容 3.在终端上建立build文件夹，cd到里面，使用MinGW编译器把cmake文件转为makefile工程文件（Windows下），即在终端写入以下内容： 1cmake -G &quot;MinGW makefiles&quot; ../ 在Linux上： 1cmake .. 即可，生成的是makefile文件夹 4.将makefile文件做成可执行程序：在终端中输入 make 即可 （二）二次修改后的问题 问题1：编译失败 检查有无语法错误 ctrl+shift+p选择工具包，使用cmake -G “MinGW makefiles” …/指令 关闭保存cmakelists.txt时候才会生成自动生成build文件夹 问题2：修改之后重新编译 关闭并保存文件，看是否报错，错了可能语法有问题，没错自动编译 （三）下面是正文： 1.CMake概述 CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。 而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，自动生成本地化的Makefile和工程文件，最后用户只需make编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译流程如下图： 蓝色虚线表示使用makefile构建项目的过程 红色实线表示使用cmake构建项目的过程 介绍完CMake的作用之后，再来总结一下它的优点： 跨平台 能够管理大型项目 简化编译构建过程和编译过程 可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能 2.CMake的使用 CMake支持大写、小写、混合大小写的命令。如果在编写CMakeLists.txt文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。 2.1 注释 2.1.1 注释行 CMake 使用 # 进行行注释，可以放在任何位置。 12# 这是一个 CMakeLists.txt 文件cmake_minimum_required(VERSION 3.0.0) 2.1.2 注释块 CMake 使用 #[[ ]] 形式进行块注释。(哦这个展示他失败了) 1234#[[ 这是一个 CMakeLists.txt 文件。 这是一个 CMakeLists.txt 文件 这是一个 CMakeLists.txt 文件]]cmake_minimum_required(VERSION 3.0.0) 实际上是可以的： 2.1 只有源文件 2.1.1 共处一室 1.准备工作，为了方便测试，在我本地电脑准备了这么几个测试文件 add.cpp 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;int add(int a, int b)&#123; return a+b;&#125; sub.cpp 12345678#include &lt;stdio.h&gt;#include &quot;head.h&quot;// 你好int subtract(int a, int b)&#123; return a-b;&#125; mult.cpp 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;int multiply(int a, int b)&#123; return a*b;&#125; div.cpp 1234567#include &lt;stdio.h&gt;#include &quot;head.h&quot;double divide(int a, int b)&#123; return (double)a/b;&#125; head.h 1234567891011#ifndef _HEAD_H#define _HEAD_H// 加法int add(int a, int b);// 减法int subtract(int a, int b);// 乘法int multiply(int a, int b);// 除法double divide(int a, int b);#endif main.cpp 1234567891011121314#include &lt;stdio.h&gt;#include &quot;head.h&quot;int main()&#123; int a = 20; int b = 12; printf(&quot;a = %d, b = %d\\n&quot;, a, b); printf(&quot;a + b = %d\\n&quot;, add(a, b)); printf(&quot;a - b = %d\\n&quot;, subtract(a, b)); printf(&quot;a * b = %d\\n&quot;, multiply(a, b)); printf(&quot;a / b = %f\\n&quot;, divide(a, b)); return 0;&#125; 2.上述文件的目录结构如下： 12345678$ tree.├── add.c├── div.c├── head.h├── main.c├── mult.c└── sub.c 3.添加 CMakeLists.txt 文件 在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下： 123cmake_minimum_required(VESION 3.0)project(CALC)add_executable(app add.c div.c main.c mult.c sub.c) 接下来依次介绍一下在 CMakeLists.txt 文件中添加的三个命令: cmake_minimum_required：指定使用的 cmake 的最低版本 可选，非必须，如果不加可能会有警告 project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。 1234567# PROJECT 指令的语法是：project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])project(&lt;PROJECT-NAME&gt; [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]] [DESCRIPTION &lt;project-description-string&gt;] [HOMEPAGE_URL &lt;url-string&gt;] [LANGUAGES &lt;language-name&gt;...]) add_executable：定义工程会生成一个可执行程序 1add_executable(可执行程序名 源文件名称) 这里的可执行程序名和project中的项目名没有任何关系 源文件名可以是一个也可以是多个，如有多个可用空格或 ; 间隔 1234# 样式1add_executable(app add.c div.c main.c mult.c sub.c)# 样式2add_executable(app add.c;div.c;main.c;mult.c;sub.c) 4.执行CMake 命令 万事俱备只欠东风，将 CMakeLists.txt 文件编辑好之后，就可以执行 cmake命令了。 (win关闭保存cmakelists.txt 文件后会自动执行cmake) 2.1.2 VIP 包房 通过上面的例子可以看出，如果在CMakeLists.txt文件所在目录执行了cmake命令之后就会生成一些目录和文件（包括 makefile 文件），如果再基于makefile文件执行make命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为build: 1234$ mkdir build$ cd build$ cmake -G &quot;MinGW makefiles&quot; ../$ make 现在cmake命令是在build目录中执行的，但是CMakeLists.txt文件是build目录的上一级目录中，所以cmake 命令后指定的路径为..，即当前目录的上一级目录。 当命令执行完毕之后，在build目录中会生成一个makefile文件 12345678$ tree build -L 1build├── CMakeCache.txt├── CMakeFiles├── cmake_install.cmake└── Makefile1 directory, 3 files 这样就可以在build目录中执行make命令编译项目，生成的相关文件自然也就被存储到build目录中了。这样通过cmake和make生成的所有文件就全部和项目源文件隔离开了，各回各家，各找各妈。 2.2 私人订制 2.2.1 定义变量 在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set。 123# SET 指令的语法是：# [] 中的参数为可选项, 如不需要可以不写SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) VAR：变量名 VALUE：变量值 123456# 方式1: 各个源文件之间使用空格间隔# set(SRC_LIST add.c div.c main.c mult.c sub.c)# 方式2: 各个源文件之间使用分号 ; 间隔set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)add_executable(app $&#123;SRC_LIST&#125;) 2.2.2 指定使用的C标准 在编写C程序的时候，可能会用到C11、C14、C17、C20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准： 1$ g++ *.cpp -std=c++11 -o app 上面的例子中通过参数-std=c11指定出要使用c11标准编译程序，C标准对应有一宏叫做DCMAKE_CXX_STANDARD。在CMake中想要指定C标准有两种方式： 1.在 CMakeLists.txt 中通过 set 命令指定 123456#增加-std=c++11set(CMAKE_CXXSTANDARD 11)#增加-std=c++14set(CMAKE_CXX_STANDARD 14)#增加-std=c++17set(CMAKE_CXX_STANDARD 17) 123456789- 2.在执行 cmake 命令的时候指定出这个宏的值```shell#增加-std=c++11cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11#增加-std=c++14cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14#增加-std=c++17cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17 在上面例子中 CMake 后的路径需要根据实际情况酌情修改。 2.2.3 指定输出的路径 在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令进行设置: 12set(HOME /home/robin/Linux/Sort)set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin) 第一行：定义一个变量用于存储一个绝对路径 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建 由于可执行程序是基于 cmake 命令生成的makefile文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 ./xxx/xxx，那么这个路径中的 ./ 对应的是 makefile 文件所在的那个目录。 2.3 搜索文件 如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。 2.3.1 方式1 在 CMake 中使用aux_source_directory 命令可以查找某个路径下的所有源文件，命令格式为： 1aux_source_directory(&lt; dir &gt; &lt; variable &gt;) dir：要搜索的目录 variable：将从dir目录下搜索到的源文件列表存储到该变量中 123456cmake_minimum_required(VERSION 3.0)project(CALC)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)# 搜索 src 目录下的源文件aux_source_directory($&#123;CMAKE_SOURCE_DIR&#125;/src SRC_LIST)add_executable(app $&#123;SRC_LIST&#125;) 2.3.2 方式2 如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是file（当然，除了搜索以外通过 file 还可以做其他事情）。 1file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型) GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。 GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。 搜索当前目录的src目录下所有的源文件，并存储到变量中 12file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)file(GLOB MAIN_HEAD $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/*.h) CMAKE_CURRENT_SOURCE_DIR 或 CMAKE_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。 关于要搜索的文件路径和类型可加双引号，也可不加: 1file(GLOB MAIN_HEAD &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;) 2.4 包含头文件 在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是include_directories: 1include_directories(headpath) 举例说明，有源文件若干，其目录结构如下： 1234567891011121314$ tree.├── build├── CMakeLists.txt├── include│ └── head.h└── src ├── add.cpp ├── div.cpp ├── main.cpp ├── mult.cpp └── sub.cpp3 directories, 7 files CMakeLists.txt文件内容如下: 123456789101112cmake_minimum_required(VERSION 3.0)project(CALC)set(CMAKECXX_STANDARD 11)set(HOME /home/robin/Linux/calc)set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)#或写成$&#123;PROJECT_BINARY_DIR&#125;/bin，其中PROJECT_BINARY_DIR为build目录的地址include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)#或写成include_directories($&#123;CMAKE_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)add_executable(app $&#123;SRC_LIST&#125;) 其中，第六行指定就是头文件的路径，PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。 2.5 制作动态库或静态库 有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在 cmake 中生成这两类库文件的方法。 2.5.1 制作静态库 在 cmake 中，如果要制作静态库，需要使用的命令如下： 1add_library(库名称 STATIC 源文件1 [源文件2] ...) 在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。 在Windows中虽然库名和Linux格式不同（lib+库名字+.lib然而事实上不是这样），但也只需指定出名字即可。 下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用： 1234567891011.├── build├── CMakeLists.txt├── include # 头文件目录│ └── head.h├── main.cpp # 用于测试的源文件└── src # 源文件目录 ├── add.cpp ├── div.cpp ├── mult.cpp └── sub.cpp 根据上面的目录结构，可以这样编写CMakeLists.txt文件: 12345cmake_minimum_required(VERSION 3.0)project(CALC)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)add_library(calc STATIC $&#123;SRC_LIST&#125;) 这样最终就会生成对应的静态库文件libcalc.a。 2.5.2 制作动态库 在cmake中，如果要制作动态库，需要使用的命令如下： 1add_library(库名称 SHARED 源文件1 [源文件2] ...) 在Linux中，动态库名字分为三部分：lib+库名字+.so，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。 在Windows中虽然库名和Linux格式不同 (.dll文件) ，但也只需指定出名字即可。 根据上面的目录结构，可以这样编写CMakeLists.txt文件: 12345cmake_minimum_required(VERSION 3.0)project(CALC)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)add_library(calc SHARED $&#123;SRC_LIST&#125;) 这样最终就会生成对应的动态库文件libcalc.so。 2.5.3 指定输出的路径 方式1 - 适用于动态库 对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录： 1234567cmake_minimum_required(VERSION 3.0)project(CALC)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)# 设置动态库生成路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)add_library(calc SHARED $&#123;SRC_LIST&#125;) 方式2 - 都适用 由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用EXECUTABLE_OUTPUT_PATH宏了，而应该使用LIBRARY_OUTPUT_PATH，这个宏对应静态库文件和动态库文件都适用。 12345678910cmake_minimum_required(VERSION 3.0)project(CALC)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)# 设置动态库/静态库生成路径set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)# 生成动态库#add_library(calc SHARED $&#123;SRC_LIST&#125;)# 生成静态库add_library(calc STATIC $&#123;SRC_LIST&#125;) 2.6 包含库文件 在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。 2.6.1 链接静态库 123456src├── add.cpp├── div.cpp├── main.cpp├── mult.cpp└── sub.cpp 现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。 测试目录结构如下： 123456789101112$ tree .├── build├── CMakeLists.txt├── include│ └── head.h├── lib│ └── libcalc.a # 制作出的静态库的名字└── src └── main.cpp4 directories, 4 files 在cmake中，链接静态库的命令如下： 1link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...]) 参数1：指定出要链接的静态库的名字 可以是全名 libxxx.a 也可以是掐头（lib）去尾（.a）之后的名字 xxx 参数2-N：要链接的其它静态库的名字 如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来： 1link_directories(&lt;lib path&gt;) 这样，修改之后的CMakeLists.txt文件内容如下: 1234567891011cmake_minimum_required(VERSION 3.0)project(CALC)# 搜索指定目录下源文件file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)# 包含头文件路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)# 包含静态库路径link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)# 链接静态库link_libraries(calc)add_executable(app $&#123;SRC_LIST&#125;) 添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了 2.6.2 链接动态库 在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的，在此不再过多赘述，如有疑惑请参考Linux静态库与动态库 在cmake中链接动态库的命令如下: 1234target_link_libraries( &lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...) target：指定要加载动态库的文件的名字 该文件可能是一个源文件 该文件可能是一个动态库文件 该文件可能是一个可执行文件 PRIVATE|PUBLIC|INTERFACE：动态库的访问权限，默认为PUBLIC 如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。 动态库的链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。 12target_link_libraries(A B C)target_link_libraries(D A) PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。 PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库 INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。 链接系统动态库 动态库的链接和静态库是完全不同的： 静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。 动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存 因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后： 1234567cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)# 添加并指定最终生成的可执行程序名add_executable(app $&#123;SRC_LIST&#125;)# 指定可执行程序要链接的动态库名字target_link_libraries(app pthread) 链接第三方动态库 现在，自己生成了一个动态库，对应的目录结构如下： 1234567891011$ tree .├── build├── CMakeLists.txt├── include│ └── head.h # 动态库对应的头文件├── lib│ └── libcalc.so # 自己制作的动态库文件└── main.cpp # 测试用的源文件3 directories, 4 files 假设在测试文件main.cpp中既使用了自己制作的动态库libcalc.so又使用了系统提供的线程库，此时CMakeLists.txt文件可以这样写：（注意以下代码是有小错误的再往下看） 123456cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)add_executable(app $&#123;SRC_LIST&#125;)target_link_libraries(app pthread calc) 在第六行中，pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息： 12$ ./app./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 这是因为可执行程序启动之后，去加载calc这个动态库，但是不知道这个动态库被放到了什么位置，所以就加载失败了，在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令： 1link_directories(path) 所以修改之后的CMakeLists.txt文件应该是这样的： 1234567891011cmake_minimum_required(VERSION 3.0)project(TEST)file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)# 指定源文件或者动态库对应的头文件路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)# 指定要链接的动态库的路径link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)# 添加并生成一个可执行程序add_executable(app $&#123;SRC_LIST&#125;)# 指定要链接的动态库target_link_libraries(app pthread calc) 通过link_directories指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。 温馨提示：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。","categories":[{"name":"CMake","slug":"CMake","permalink":"https://xqc-1368.github.io/categories/CMake/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"CMake","slug":"CMake","permalink":"https://xqc-1368.github.io/tags/CMake/"}]},{"title":"13文件操作","slug":"13文件操作","date":"2024-08-19T04:23:45.776Z","updated":"2024-08-19T03:04:40.292Z","comments":true,"path":"2024/08/19/13文件操作/","permalink":"https://xqc-1368.github.io/2024/08/19/13%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"文件操作 1.打开，创建与关闭 123FILE *fp;fp = fopen(&quot;words.txt&quot;, &quot;w&quot;)//以只写方式打开fclose(fp);//关闭 2.读写方式 （1）字符方式读写 1‘ 字符方式读入 1234567891011FILE *fp2;while ((fp2 = fopen(&quot;words.txt&quot;, &quot;r&quot;) )== NULL)&#123; printf(&quot;error!!!\\n&quot;); exit(0);&#125;while ((ch = getc(fp2)) != EOF)&#123; putchar(ch);&#125;fclose(fp2); 也可以使用判断是否到达结尾的函数 feof 12345678910111213FILE *fp2;while ((fp2 = fopen(&quot;words.txt&quot;, &quot;r&quot;) )== NULL)&#123; printf(&quot;error!!!\\n&quot;); exit(0);&#125;ch = fgetc(fp2);//fp指向ch所在位置，获取当前的chwhile (!feof(fp2))//若fp指向EOF，则函数返回0&#123; putchar(ch); ch = fgetc(fp2);// fp指向ch所在位置，获取当前的ch&#125;fclose(fp2); 2’ 字符方式写入 12345678910111213 FILE *fp;char ch;while ((fp = fopen(&quot;words.txt&quot;, &quot;w&quot;)) == NULL)&#123; printf(&quot;error!!!\\n&quot;); exit(0);&#125;printf(&quot;Now,you can input your words:\\n&quot;);while ((ch = getchar()) != &#x27;\\n&#x27;)&#123; fputc(ch, fp);&#125;fclose(fp); （2）字符串方式读写 1‘ 字符串读入 1234567891011 FILE *fp2;char ch2[N];while((fp2=fopen(&quot;words.txt&quot;,&quot;r&quot;))==NULL)&#123; printf(&quot;error\\n&quot;); exit(0);&#125;printf(&quot;display:\\n&quot;);fgets(ch2,100,fp2);puts(ch2);fclose(fp2); 2’ 字符串写入 1234567891011 FILE *fp;char ch[N];while((fp=fopen(&quot;words.txt&quot;,&quot;w&quot;))==NULL)&#123; printf(&quot;error!!!\\n&quot;); exit(0);&#125;printf(&quot;now,put your words:\\n&quot;);gets(ch);fputs(ch,fp);fclose(fp); 细节问题gets和scanf里的%s有什么区别，前者能读换行符后者不能。 （3）格式化读写 怎么读就怎么写，怎么写就怎么读：格式化读写 1‘ 格式化写入 123456789101112131415161718 FILE *fp;int a[N][N];while((fp=fopen(&quot;words.txt&quot;,&quot;w&quot;))==NULL)&#123; printf(&quot;error!!!\\n&quot;); exit(0);&#125;printf(&quot;now,put your words:\\n&quot;);for(int i=0;i&lt;4;i++)&#123; cout&lt;&lt;&quot;请输入语文 数学 信息技术 通用技术成绩：&quot;&lt;&lt;endl; cin&gt;&gt;a[i][0]&gt;&gt;a[i][1]&gt;&gt;a[i][2]&gt;&gt;a[i][3];&#125;for(int i=0;i&lt;4;i++)&#123; fprintf(fp,&quot;%2d\\t%2d\\t%2d\\t%2d\\n&quot;,a[i][0],a[i][1],a[i][2],a[i][3]);&#125;fclose(fp); 2’ 格式化读入 1234567891011121314 FILE *fp2;int a2[N][N];while((fp2=fopen(&quot;words.txt&quot;,&quot;r&quot;))==NULL)&#123; printf(&quot;error\\n&quot;); exit(0);&#125;printf(&quot;display:\\n&quot;);for(int i=0;i&lt;4;i++)&#123; fscanf(fp2, &quot;%2d\\t%2d\\t%2d\\t%2d\\n&quot;, &amp;a2[i][0], &amp;a2[i][1], &amp;a2[i][2], &amp;a2[i][3]); cout &lt;&lt; a2[i][0] &lt;&lt; &quot; &quot; &lt;&lt; a2[i][1] &lt;&lt; &quot; &quot; &lt;&lt; a2[i][2] &lt;&lt; &quot; &quot; &lt;&lt; a2[i][3] &lt;&lt;endl;&#125;fclose(fp2); （4）数据块读写（二进制读写） 提前声明 1234567#define N 100typedef struct &#123; int chinese; int math; int xxjs; int tyjs;&#125;student; 1‘ 二进制写入 123456789101112131415 FILE *fp;student stus[N];while((fp=fopen(&quot;words.txt&quot;,&quot;wb&quot;))==NULL)&#123; printf(&quot;error!!!\\n&quot;); exit(0);&#125;printf(&quot;now,put your words:\\n&quot;);for(int i=0;i&lt;4;i++)&#123; cout&lt;&lt;&quot;请输入语文 数学 信息技术 通用技术成绩：&quot;&lt;&lt;endl; cin&gt;&gt;stus[i].chinese&gt;&gt;stus[i].math&gt;&gt;stus[i].xxjs&gt;&gt;stus[i].tyjs;&#125;fwrite(stus,sizeof(student),N,fp);fclose(fp); 2’ 二进制读入 1234567891011121314 FILE *fp2;student stu2[N];while((fp2=fopen(&quot;words.txt&quot;,&quot;rb&quot;))==NULL)&#123; printf(&quot;error\\n&quot;); exit(0);&#125;printf(&quot;display:\\n&quot;);fread(stu2,sizeof(student),N,fp2);for(int i=0;i&lt;4;i++)&#123; cout &lt;&lt; stu2[i].chinese &lt;&lt; &quot; &quot; &lt;&lt; stu2[i].math &lt;&lt; &quot; &quot; &lt;&lt; stu2[i].xxjs &lt;&lt; &quot; &quot; &lt;&lt; stu2[i].tyjs &lt;&lt;endl;&#125;fclose(fp2); （5）文件随机读写（文件指针） 1‘ rewind函数 —— 让文件指针重新回到起始位置 123456long pos = ftell(pf);printf(&quot;重置之前文件指针的位置: %d\\n&quot;, pos);rewind(pf);pos = ftell(pf);printf(&quot;重置之后文件指针的位置: %d\\os);n&quot;, pos); 2’ ftell 函数 —— 告知当前文件指针相对于起始位 long pos = ftell(pf); printf(&quot;%d\\n&quot;, pos); 3‘ fseek 函数 —— 移动文件指针的位置 fseek(fp, -1, SEEK_CUR); // 将文件指针相对于当前位置向左移动一个单位 第一个参数stream：文件指针（FILE 类型）* 第二个参数offset：相对于起始位置的偏移量。（long类型） offset &lt; 0，从起始位置起，向左移动 | offset | 个单位 offset &gt; 0，从起始位置起，向右移动 | offset | 个单位 第三个参数：起始位置。可选值有三个 可选值 解析 SEEK_CUR 当前文件指针指向的位置 SEEK_END 文件末尾 SEEK_SET 文件起始位置 返回值：成功返回0，失败返回一个非零值。","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"C语言 文件操作","slug":"C语言-文件操作","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"11动态数组","slug":"11动态数组","date":"2024-08-19T04:23:45.761Z","updated":"2024-08-19T03:04:12.592Z","comments":true,"path":"2024/08/19/11动态数组/","permalink":"https://xqc-1368.github.io/2024/08/19/11%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/","excerpt":"","text":"11动态数组 从堆（heap）上分配 在程序运行期间，用动态内存分配函数来申请的内存都是从堆上分配的，动态内存的生存期由程序员自己来决定 分配内存的两大主要方式 void* malloc(unsigned int size); 向系统申请大小为size的内存块 把首地址返回，若申请不成功则返回NULL 例如: 123int *pi = NULL;Pi = (int *)malloc(sizeof(int)); void* calloc(unsigned int num,unsigned int size); 向系统申请num个size大小的内存块 把首地址返回，若申请不成功则返回NULL 例如: 123float *pf = NULL;pf =(float *)calloc(10,sizeof(float)); 需要头文件： #include &lt;stdlib.h&gt; #include &lt;alloc.h&gt; 注：void* 类型的指针可以指向任意类型的变量，通常强转(Type*)为其他类型 清除内存分配：void free(void* p); 释放由malloc()和calloc()申请的内存块 p是指向此块内存的指针 free时系统标记此块内存为未占用，可被重新分配 改变分配内存的存储空间方式： void* realloc(void* p , unsigned int size); 改变原来分配的存储空间的大小 p是指向此块内存的指针，size是新内存块的大小 函数返回新分配存储空间首地址，与原来分配的首地址不一定相同 一维动态数组的创建 创建一个长度为n的动态数组并输入 123456789101112p=(int*)malloc(n*sizeof(int));//p=(int *)calloc(n,sizeof(int));if(p==NULL)//确保指针使用前是非空指针&#123; printf(&quot;No enough memory!\\n&quot;); exit(1);&#125;for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;p[i]);&#125;free(p);//释放向系统申请的存储空间 二维动态数组的创建 创建一个长度为n的动态数组并输入 1234567891011121314151617p=(int *)malloc(n*m*sizeof(int));//p=(int*)calloc(n*m,sizeof(int));//得到的p为int* 类型，所以为列指针if(p==NULL)//确保指针使用前是非空指针&#123; printf(&quot;No enough memory!\\n&quot;); exit(1);&#125;for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++) &#123; scanf(&quot;%d&quot;,&amp;p[i*n+j]); &#125;&#125;free(p);//释放向系统申请的存储空间","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"动态数组","slug":"动态数组","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"}]},{"title":"10字符串","slug":"10字符串","date":"2024-08-19T04:23:45.756Z","updated":"2024-08-19T03:36:27.044Z","comments":true,"path":"2024/08/19/10字符串/","permalink":"https://xqc-1368.github.io/2024/08/19/10%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"10字符串 1.字符串常量 一串以’\\0’结尾的字符在C语言中被看作字符串 用双引号括起的一串字符是字符串常量，C语言自动为其添加’\\0’结束符 2.字符数组和字符指针 字符串的存储 C语言没有提供专门的字符串数据类型 使用字符数组和字符指针来处理字符串 字符数组：每个元素都是字符类型的数组 数组的最后一个元素必须是’\\0’才表示字符串 字符数组的初始化 用字符常量的初始化列表对数组初始化 char str[6] = &#123;'C','h','i','n','a','\\0'&#125;; 用字符串常量直接对数组初始化 char str[6] = &#123;&quot;China&quot;&#125;; char str[6] = &quot;China&quot;; char str[ ] = &quot;China&quot;; 字符指针 还可以用字符指针来指向一个字符，如果让字符指针指向一个字符串常量 char *pStr =&quot;Hello China&quot;; 字符是否可以修改问题：关键看字符指针指向的字符串被存储在哪个区域 case 1：pStr是一个指向常量存储区中的字符串的指针变量 char *pStr =&quot;Hello China&quot;; char *pStr; pStr= &quot;Hello China&quot;; 字符串保存在只读的常量存储区 可修改pStr的值（指向），但不可以对它所指向的存储单元进行写操作 case 2：数组名str作为指针 char str[]=&quot;Hello China&quot;; 函数内定义，保存在动态存储区 函数外定义，或定义为静态数组，字符串保存在静态存储区 数组名str的值不可修改，是地址常量 数组中存储的字符可以被修改 case 3：pStr是一个指向不在常量存储区中的字符串的指针变量 char str[]=&quot;Hello China&quot;; char *pStr; pStr = str; 或 pStr = &amp;str[0]; pStr的值（指向）可以被修改，它所指向的字符串也可以被修改 3.字符串处理函数 按字符逐个访问or输入/输出 按字符串整体输入/输出： 不能输入带空格的字符串： 1.用%d输入数字或%s输入字符串时，忽略空格、回车或制表符等空白字符，读到这些字符时，系统认为读入结束，因此不能输入带空格的字符串 2.scanf()不读走回车，回车仍留在缓冲区中，回车需要加一个getchar()，被getchar()读走 scanf(&quot;%s&quot;,str); printf(&quot;%s&quot;,str); 可以输入带空格的字符串 读入特性： 1.可输入带空格的字符串，因为空格和制表符都是字符串的一部分 2.空格和制表符都是字符串的一部分，以回车作为字符串的终止符，同时将回车从缓冲区读走，但不作为字符串的一部分 gets(str); puts(str); 对于缓冲区的解释： 键盘输入都被保存在输入缓冲区中，直到用户输入回车，输入函数才去读缓冲区中的数据 缓冲区溢出攻击 世界上第一个缓冲区溢出攻击：Internet蠕虫，曾造成全球多台网络服务器瘫痪 原因：gets()、scanf()、strcpy()等不限制字符串长度，不对数组越界进行检查和限制，导致有用的堆栈数据被覆盖，给黑客攻击以可乘之机 防范方法：fgets(input, sizeof(input), stdin);限制输入字符串的长度，更灵活 n族字符串函数 scanf的优化： 对于下面这段代码：假如格式不匹配，输入了非数字字符？ 1234do&#123; printf(&quot;Input n:&quot;); ret = scanf(&quot;%d&quot;, &amp;n);&#125;while (ret != 1); scanf()按指定格式读取缓冲区中的数据，如果读取失败，则缓冲区中的非数字字符不会被读走，一直处于判断、读取、退出，判断、读取、退出，……（死机） 判断scanf()返回成功读取的数据的个数，可以避免死机问题，但还需清空缓冲区 12345678do&#123; printf(&quot;input n&quot;); ret=scanf(&quot;%d&quot;,&amp;n); if(ret!=1) &#123; while(getchar()!=&#x27;\\n&#x27;);//清空缓冲区 &#125;&#125;while(ret!=1); 输出时的引号写法：\\“ 字符串处理函数 需要包含头文件#include &lt;string.h&gt; string length函数：strlen(字符串); 计算方法：不包括\\0的实际字符的个数 char str[10] = &#123;&quot;China&quot;&#125;; printf(&quot;%d&quot;,strlen(str)); &lt;!--code￼2--&gt; string copy函数：strcpy(目的字符串, 源字符串); (字符串不能用=整体复制) 注意复制的方向，str2必须足够大 string combination函数：strcat(目的字符串, 源字符串); str2必须足够大！ string comparison函数：strcmp(字符串1, 字符串2); （字符串不能用&gt;,&lt;,==比较大小） if (strcmp(str2, str1) == 0) 计算方法 当出现第一对不相等的字符时，就由这两个字符决定所在字符串的大小，返回其ASCII码比较的结果值 4.向函数传递字符串 向函数传递字符串时：既可用字符数组作函数参数，也可用字符指针作函数参数；传字符串的首地址，而非字符串中的全部字符 5.从函数返回字符串指针 返回字符串首地址","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"字符串","slug":"字符串","permalink":"https://xqc-1368.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"09指针","slug":"09指针","date":"2024-08-19T04:23:45.752Z","updated":"2024-08-19T03:33:36.228Z","comments":true,"path":"2024/08/19/09指针/","permalink":"https://xqc-1368.github.io/2024/08/19/09%E6%8C%87%E9%92%88/","excerpt":"","text":"09指针 1.指针的概念和变量的地址 变量的内存地址 内存中的每个字节都有唯一的编号（地址）地址按字节编号，其字长一般与主机相同32位机使用32位地址，最多支持2^32字节内存(4G) 地址是一个无符号整数，从0开始，依次递增。在表达和交流时，通常把地址写成十六进制数，如0x0037b000 直接寻址：按变量的地址直接访问：&amp;a 间接寻址：通过存放变量地址的其他变量访问该变量 指针（Pointer）类型 指针变量——具有指针类型的变量 变量的指针←→变量的地址 保存32位地址值的指针变量占4个字节的内存，这4个字节中保存了一个地址 从这个地址开始多少个字节内的数据是有效的呢？用什么数据类型去理解这些数据呢？ 指针的基类型就是回答这个问题的 12int *pa,*pb;//定义了可以指向整型数据的指针变量pa和pbchar *pc;//定义了可以指向字符型数据的指针变量pc 告诉编译器，pa是一个指针变量，占4字节内存，需要用一个int型变量的地址给它赋值，但pa并未具体指向某个int型变量 2.指针变量的定义和初始化 指针变量使用之前必须初始化（指针变量只能指向同一基类型的变量） 如果你不知把它指向哪里，那就指向NULL 1int *pa=NULL; 空指针：值为NULL的指针，即无效指针 既然0（NULL）用来表示空指针，那么空指针就是指向地址为0的单元的指针吗？ 答案：不一定 每个C编译器都被允许用不同的方式来表示空指针，并非所有编译器都使用0地址。某些编译器为空指针使用不存在的内存地址，硬件会检查出这种试图通过空指针访问内存的方式 初始化指针变量pa=&amp;a或int *pa=&amp;a; 后者等价于： 123int a;int *pa=NULL;pa=&amp;a; 3.取地址和间接寻址运算符 引用指针指向的变量的值，称为指针的解引用(Pointer Dereference) 4.指针变量作函数参数 普通变量作函数参数—按值调用，实参的值不随形参值的改变而改变 形参（parameter）← 实参变量的值 Fun(arg); 指针做函数参数—按地址调用，为了在被调函数中修改其无法直接访问的实参的值 指针形参(pointer parameter) ← 实参变量的地址 Fun(&amp;arg); 5.函数指针 函数指针(Function Pointer)：指向函数的指针变量 数据类型 (*指针变量名)(形参列表);int (*f)(int a, int b); 函数指针f指向的函数原型为：int 函数名(int a, int b); 原理：编译器将不带()的函数名解释为该函数的入口地址，函数指针变量存储的是函数在内存中的入口地址，令f = Fun，就是让f指向函数fun() 123456789101112131415161718192021222324252627282930void Fun(int x, int y, int (*f)(int, int));int Max(int x, int y);int Min(int x, int y);int Add(int x, int y);int main()&#123; int a, b; scanf(&quot;%d,%d&quot;, &amp;a, &amp;b); Fun(a, b, Max); Fun(a, b, Min); Fun(a, b, Add); return 0;&#125;void Fun(int x, int y, int (*f)(int, int))&#123; int result; result = (*f)(x, y) ; printf(&quot;%d\\n&quot;, result);&#125;int Max(int x, int y)&#123; printf(&quot;max=&quot;); return x&gt;y? x : y;&#125;int Min(int x, int y)&#123; printf(&quot;min=&quot;); return x&lt;y? x : y;&#125;int Add(int x, int y)&#123; printf(&quot;sum=&quot;); return x+y;&#125; 6.指针与一维数组间的关系 int a[5]; int *p = a; 数组名是数组的首地址 int *p = &amp;a[0]; &amp;a[0]是整型元素的地址 p是整型指针 a[0]的类型和p的基类型相同 数组元素的等价引用形式：a[i] ↔ *(a+i) 7.指针与二维数组间的关系 数组法及其变式 123456789//数组法1a==a+0==&amp;a[0]; *a==*(a+0)==a[0];a+1==&amp;a[1]; *(a+1)==a[1];//数组法2a[0]+1==&amp;a[0][1]; *(a[0]+1)==a[0][1];//数组法3*(a+1)+2==&amp;a[1][2]; *(*(a+1)+2)==a[1][2];//数组法4(*(a+1))[2]==a[1][2]; 列指针法 123456789101112//列指针的定义方法int *p; //初始化方法//初始化：指向第一个元素：（以下三个方法等价）p=a[0] ; p=*a ; p=&amp;a[0][0];//初始化：指向任意一个元素：p=a[i][j];p=a[2][1]; //列指针的使用方法：（a为m行n列的一个二维数组）*(p+i*n+j)==a[i][j]; p+i*n+j==&amp;a[i][j];p[i*n+j]==a[i][j]; 语法 样例 说明 指向任意元素 指针变量=&amp;数组名[下标1][下标2] p=&amp;a[1][2] p指向的元素为7 指向首个元素 指针变量=&amp;数组名[0][0]指针变量=*二维数组名 p=&amp;a[0][0]或p=*a p指向首个元素，即数值1所在位置 p p+1 p+2 p+3 p+4 p+5 p+6 p+7 p+8 p+9 p+10 p+11 表示方法 说明 指针类型 a[0] 是一维数组名称，首地址第0个元素地址(a[0]+0) 列指针 a[0]+1 第0行，第1个元素 列指针 a[0]+2 第0行，第2个元素 列指针 a[0]+3 第0行，第3个元素 列指针 行指针法int (*p)[3]; //行指针，基类型是int[3] 1234567891011//行指针的定义int (*p)[4];//行指针的初始化(a为某数组)(二者任选其一即可)p=a; p=&amp;a[0];//行指针应用公式p[i][j]==a[i][j];*(*(p+i)+j)==a[i][j]; *(p+i)+j==&amp;a[i][j];*(p[i]+j)==a[i][j]; p[i]+j==&amp;a[i][j];(*(p+i))[j]==a[i][j]; 二维数组的名字默认是行指针 表示方法 说明 指针类型 a或a+0 指向第0行 行指针 a+1 指向第1行 行指针 a+2 指向第2行 行指针 行指针和列指针的联系 行指针：指的是一整行，不指向具体元素 列指针：指的是二维数组中某一行的某个具体元素。 可以将列指针认为是行指针的具体元素，行指针是列指针的地址。 两者间的具体转化： *行指针—&gt;列指针 &amp;列指针—&gt;行指针 行指针 转换成：列指针 a或a+0 *a或a[0] a+1 *(a+1)或a[1] 列指针解引用 内容等价表示 含义 *a[0] *(*a) a[0][0] *a[1] *( *(a+1)) a[1][0] 某一行的列指针 转换成：某一行的行指针 a[0] &amp;a[0]或&amp;a或&amp;(a+0) a[1] &amp;a[1]或&amp;(a+1) 行指针和列指针转换试验结果(uninportant) 1234567891011121314151617181920212223242526//列指针的定义方法int *p; //初始化方法//初始化：指向第一个元素：（以下三个方法等价）p=a[0] ; p=*a ; p=&amp;a[0][0];//初始化：指向任意一个元素：p=a[i][j];p=a[2][1]; //目前p是列指针是吧 根据：&amp;列指针==行指针 发现只有用[]的方法表示的时候才可以实现(&amp;p)[i][j]==a[i][j];//试验可行*(*(&amp;p+i)+j)==a[i][j]; *(&amp;p+i)+j==&amp;a[i][j];//试验不可行*(&amp;p[i]+j)==a[i][j]; &amp;p[i]+j==&amp;a[i][j];//试验可行(*(&amp;p+i))[j]==a[i][j];//试验不可行//行指针的定义int (*p)[4];//行指针的初始化(a为某数组)(二者任选其一即可)p=a; p=&amp;a[0];//目前p是行指针吧 根据：*行指针==列指针 发现均可以实现*(*p+i*n+j)==a[i][j]; *p+i*n+j==&amp;a[i][j];//试验可行(*p)[i*n+j]==a[i][j]; //试验可行 8.指针数组及其应用 形参声明为二维数组的行指针，列数须为常量 形参声明为二维数组的列指针，列数可为变量","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"指针","permalink":"https://xqc-1368.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"08数组","slug":"08数组","date":"2024-08-19T04:23:45.743Z","updated":"2024-08-19T04:33:00.047Z","comments":true,"path":"2024/08/19/08数组/","permalink":"https://xqc-1368.github.io/2024/08/19/08%E6%95%B0%E7%BB%84/","excerpt":"","text":"08数组 1.对数组名特殊含义的理解 数组名表示数组的首地址,不代表整个数组元素值! 2.数组的定义和初始化 （1）定义 一个有10个int型元素的一维数组 – 系统分配连续的10个int型存储空间给此数组  为什么数组下标从0开始？ – 使编译器简化，且运算速度少量提高 （2）内存分配 数组大小必须是值为正的常量（C99标 准），不能为变量，一旦定义，不能改变 大小。大小最好用宏定义，以适应未来的变化 12#define N 10int a[N]; 根据数组的数据类型，为每一元素安排相应字节数的存储单元 根据数组的存储类型，将其安排在内存的动态、静态存储区或寄存器区 （3）一维数组的引用 数组名[下标]：引用时下标允许是int型变量或表达式 允许快速随机访问 允许使用a[i]这样的形式访问每个元素 可以像使用普通变量一样使用 （4）未初始化的数组元素值是什么？ 静态数组和全局数组自动初始化为0值 否则，是随机数 （5）进阶 更高效的数组初始化方法（只能为0） memset(a, 0, sizeof(a)); 用sizeof(a)来获得数组a所占的内存字节数 • 更高效的数组赋值方法 memcpy(b, a, sizeof(a)); • 需要包含相应的头文件： #include &lt;string.h&gt; （6）访问数组元素时，下标越界是大忌！ （7）二维数组的定义和初始化 一维数组： int a[5];  用一个下标确定各元素在数组中的顺序  可用排列成一行的元素来表示 二维数组：int b[2][3]; 用两个下标确定各元素在数组中的顺序 用排列成i行，j列的元素来表示 逻辑结构，非物理结构 内存中线性保存 存储特性： 存放顺序：按行存放，线性存储 先顺序存放第0行，再存放第1行 已知每行列数才能正确读出数组元素 所以初始化时，第二维长度不能省略 案例：int a[][3]={{1,2,3},{4,5},{6},{0}}; n维数组：int c[3][2][4];  用n个下标来确定各元素在数组中的顺序 （8）非法访问可能合理 a[0][3]和a[1][0]指的是同一元素，不检查下标越界，a[0][3]的写法也合法，但隐患严重 3.向函数传递一维数组 数组作函数参数——按地址调用 传递数组的首地址， 实参与形参数组占同一段内存单元 普通变量作函数参数——按值调用 传递变量值的副本， 实参与形参变量占不同的内存单元 4.向函数传递二维数组 在声明函数的二维数组形参时，不能省略数组第二维的长度（列数） 元素地址：首地址+偏移量 比较：保存n个学生一门课程的成绩 用一维数组 int Average(int score[], int n); 通常不指定数组的长度，用另一个形参来指定数组的大小保存n个学生的m门课程的成绩 用二维数组 void Average(int score[][COURSE_N], float aver[], int n); 可省略数组第一维的长度，不能省略第二维的长度 数组aver可保存每个学生的平均分，或每门课程的平均分 5.排序、查找、求最值等算法 交换法/选择排序/冒泡排序/插入排序 冒泡排序： 12345678910111213141516171819#include&lt;stdio.h&gt;int main(void)&#123; int a[9]=&#123;3,5,6,2,1,4,7,9,8&#125;,temp; int n=9; for(int i=0;i&lt;n-1;i++)&#123; for (int j=n-i-1;j&gt;0;j--) &#123; if(a[j]&lt;a[j-1])&#123; temp=a[j-1]; a[j-1]=a[j]; a[j]=temp; &#125; &#125; &#125; for (int i=0;i&lt;n;i++)&#123; printf(&quot;%d&quot;,a[i]); &#125; return 0;&#125; 选择排序： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int main(void)&#123; int a[9]=&#123;3,5,6,2,1,4,7,9,8&#125;,temp,j,change; int n=9; for(int i=0;i&lt;n;i++) &#123; temp=i; for (int j=i+1;j&lt;n;j++) &#123; if(a[temp]&gt;a[j])&#123; temp=j;//记录下标！！！！ &#125; &#125; if(temp != i) &#123; change=a[i]; a[i]=a[temp]; a[temp]=change; &#125; &#125; for (int i =0;i&lt;n;i++)&#123; printf(&quot;%d&quot;,a[i]); &#125; return 0;&#125; 插入排序： 123456789101112131415161718#include&lt;stdio.h&gt;int main(void)&#123; int a[9]=&#123;3,5,6,2,1,4,7,9,8&#125;,temp,j; int n=9; for(int i=1;i&lt;n;i++)&#123; j=i-1; temp=a[i]; while (j&gt;=0 &amp;&amp; a[j]&gt;temp)&#123; a[j+1]=a[j]; j--; &#125; a[j+1]=temp;//注意这里拿的是a[j+1] &#125; for (int i=0;i&lt;n;i++)&#123; printf(&quot;%d&quot;,a[i]); &#125; return 0;&#125; 顺序查找/二分查找 二分查找： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main(void)&#123; int a[9] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;, left = 0, right = 8; int key = 8, mid; while (left &lt;= right) &#123; mid = (left + right) / 2; //若left+right大于int的最大值，可以long long， 也可以left+(high-left)/2 if (a[mid] == key) &#123; printf(&quot;find it! it is on%d&quot;, mid); break; &#125; else if (a[mid] &gt; key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return 0;&#125; 注意：mid = (high + low) / 2; 如果数组很大，low和high之和大于有符号整数的极限值（在limits.h中定义）就会发生数值溢出，使mid成为一个负数 防止溢出的解决方案 修改计算中间值的方法，用减法代替加法  mid = low + (high - low) / 2; 6.筛法求质数 直接上代码，不解释：复杂度O(n^2) 1234567int i, j, a[N+1];for (i=2; i&lt;=N; i++) a[i] = i;for (i=2; i&lt;=sqrt(N); i++) for (j=i+1; j&lt;=N; j++) if (a[i]!=0 &amp;&amp; a[j]!=0 &amp;&amp; a[j]%a[i]==0) a[j] = 0;","categories":[{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数组","slug":"数组","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2024-08-18T12:16:49.145Z","updated":"2024-08-18T12:16:00.672Z","comments":true,"path":"2024/08/18/最小生成树/","permalink":"https://xqc-1368.github.io/2024/08/18/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"最小生成树 1. Kruskal算法 Kruskal算法的思想比Prim好理解一些。 先把边按照权值进行排序， 用贪心的思想优先选取权值较小的边，并依次连接， 若出现环则跳过此边（用并查集来判断是否存在环）继续搜，直到已经使用的边的数量比总点数少一即可。 证明：刚刚有提到：如果某个连通图属于最小生成树，那么所有从外部连接到该连通图的边中的一条最短的边必然属于最小生成树。所以不难发现，当最小生成树被拆分成彼此独立的若干个连通分量的时候，所有能够连接任意两个连通分量的边中的一条最短边必然属于最小生成树 123456789101112131415161718192021void kruskal()&#123; sort(edge_set,edge_set+m,cmp); for(int i=0;i&lt;m;i++) &#123; fax=find(edge_set[i].a); fay=find(edge_set[i].b); if(fax!=fay) &#123; ans += edge_set[i].weight; fa[fax] = fay; cnt++; &#125; if (cnt==n-1) &#123; flag=1; break; &#125; &#125;&#125; 例题： 【模板】最小生成树 题目描述 如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。 输入格式 第一行包含两个整数 N,MN,MN,M，表示该图共有 NNN 个结点和 MMM 条无向边。 接下来 MMM 行每行包含三个整数 Xi,Yi,ZiX_i,Y_i,Z_iXi​,Yi​,Zi​，表示有一条长度为 ZiZ_iZi​ 的无向边连接结点 Xi,YiX_i,Y_iXi​,Yi​。 输出格式 如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。 样例 #1 样例输入 #1 1234564 51 2 21 3 21 4 32 3 43 4 3 样例输出 #1 17 提示 数据规模： 对于 20%20\\%20% 的数据，N≤5N\\le 5N≤5，M≤20M\\le 20M≤20。 对于 40%40\\%40% 的数据，N≤50N\\le 50N≤50，M≤2500M\\le 2500M≤2500。 对于 70%70\\%70% 的数据，N≤500N\\le 500N≤500，M≤104M\\le 10^4M≤104。 对于 100%100\\%100% 的数据：1≤N≤50001\\le N\\le 50001≤N≤5000，1≤M≤2×1051\\le M\\le 2\\times 10^51≤M≤2×105，1≤Zi≤1041\\le Z_i \\le 10^41≤Zi​≤104。 样例解释： 所以最小生成树的总边权为 2+2+3=72+2+3=72+2+3=7。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct &#123; int a; int b; int weight;&#125;edge;edge edge_set[200001];int fa[5005];int n, m, u, v, w,cnt=0,fax,fay,ans=0,flag=0;bool cmp(edge p,edge q)&#123; return p.weight&lt;q.weight;&#125;int find(int x)&#123; if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];&#125;void kruskal()&#123; sort(edge_set,edge_set+m,cmp); for(int i=0;i&lt;m;i++) &#123; fax=find(edge_set[i].a); fay=find(edge_set[i].b); if(fax!=fay) &#123; ans += edge_set[i].weight; fa[fax] = fay; cnt++; &#125; if (cnt==n-1) &#123; flag=1; break; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; edge temp; temp.a=u; temp.b=v; temp.weight=w; edge_set[i]=temp; &#125; for(int i=1;i&lt;=n;i++) &#123; fa[i]=i; &#125; kruskal(); if(flag==0)cout&lt;&lt;&quot;orz&quot;&lt;&lt;endl; else printf(&quot;%d&quot;,ans);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"生成树","slug":"生成树","permalink":"https://xqc-1368.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"kruskal算法","slug":"kruskal算法","permalink":"https://xqc-1368.github.io/tags/kruskal%E7%AE%97%E6%B3%95/"}]},{"title":"同余：欧拉定理及扩展定理，费马小定理","slug":"04-1同余：欧拉定理及其扩展，费马小定理","date":"2024-08-18T12:07:25.644Z","updated":"2024-08-19T02:14:37.462Z","comments":true,"path":"2024/08/18/04-1同余：欧拉定理及其扩展，费马小定理/","permalink":"https://xqc-1368.github.io/2024/08/18/04-1%E5%90%8C%E4%BD%99%EF%BC%9A%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95%EF%BC%8C%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","excerpt":"","text":"在一些计数的问题中，常常要求对结果取模，但是在计算非常庞大的次幂的时候，无法直接取模，可以先把底数对 p 取模，指数对$ \\varphi(p)$ 取模，再计算次幂，有效地降低时间复杂度。 第二章 同余 0x20 同余 0x21 整数的取余运算 0x21.1 整数的取余运算（模运算） 定义：带余除法，设 a , b 是整数，且 b &gt; 0，使得 a=bq+r，且 0≤r&lt;b ，称 q 为商， r 为余数。 显然带余除法中的商和余数都是唯一的，在下文中将商记为 a / b ，将余数记为 a % b ，/ 与 % 的运算优先级与乘除法相同。 定义以下运算： 取模运算：a % p (或a mod p)，表示 a 除以 p 的余数。 模 p 加法：(a+b)%p ，其结果是a + b 算术和除以p的余数，也就是说，( a + b ) = k p + r ，则( a + b ) % p = r 。 模 p 减法：( a − b ) % p，其结果是a − b算术差除以p的余数。 模 p 乘法：( a ∗ b ) % p，其结果是a ∗ b 算术乘法除以p的余数。 模运算有如下简单性质： a%b=a−b×⌊ab⌋a \\% b = a-b\\times \\lfloor\\frac{a}{b}\\rfloora%b=a−b×⌊ba​⌋，即若 a % b = c ，则 a = b x + c ，x=⌊ab⌋x= \\lfloor\\frac{a}{b}\\rfloorx=⌊ba​⌋。 n % p 得到结果的正负由被除数 n 决定,与 p 无关。 结合率： ((a+b)%p+c)%p=(a+(b+c)%p)%p((a+b) \\% p + c) \\% p = (a + (b+c) \\% p) \\% p((a+b)%p+c)%p=(a+(b+c)%p)%p ((a×b)%p×c)%p=(a×(b×c)%p)%p((a\\times b) \\% p\\times c)\\% p = (a\\times (b\\times c) \\% p) \\% p((a×b)%p×c)%p=(a×(b×c)%p)%p 交换率： (a+b)%p=(b+a)%p(a + b) \\% p = (b+a) \\% p(a+b)%p=(b+a)%p (a×b)%p=(b×a)%p(a\\times b) \\% p = (b\\times a) \\% p(a×b)%p=(b×a)%p 分配率： ((a+b)%p×c)%p=((a×c)%p+(b×c)%p)%p((a +b)\\% p\\times c) \\% p = ((a \\times c) \\% p + (b\\times c) \\% p) \\% p((a+b)%p×c)%p=((a×c)%p+(b×c)%p)%p 若a%p=x,a%q=x,gcd⁡(p,q)=1a\\%p=x,a\\%q=x,\\gcd(p,q)=1a%p=x,a%q=x,gcd(p,q)=1，则a%(p×q)=xa\\%(p×q)=xa%(p×q)=x 更多关于模运算性质以及同余详见本文 0x22同余。 0x21.2 整数模意义下的加减乘乘方运算 (a+b)%c=(a%c+b%c)%c(a+b) \\%c=(a\\%c+b\\%c)\\%c(a+b)%c=(a%c+b%c)%c (a−b)%c=(a%c−b%c+c)%c(a-b)\\%c=(a\\%c-b\\%c+c)\\%c(a−b)%c=(a%c−b%c+c)%c (a×b)%c=(a%c)×(b%c)%c(a \\times b)\\%c=(a\\%c)\\times (b\\%c)\\%c(a×b)%c=(a%c)×(b%c)%c (ab)%p=((a%p)b)%p(a^b) \\% p = ((a \\% p)^b) \\% p(ab)%p=((a%p)b)%p 计算减法的时候，通常需要加上模数 c，防止出现负数。 O(nlogn)O(nlogn)O(nlogn) 的 大数快速幂算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int mod;char s[20000001];int qqpow(int a, int b)&#123; int ret=1; while(b) &#123; if(b&amp;1)ret=(ret*a)%mod; a=(a*a)%mod; b&gt;&gt;=1; &#125; return ret;&#125; int qpow(int a, char *b, int len)&#123; int ret=1; while(len&gt;0) &#123; if(b[len-1]!=&#x27;0&#x27;) ret=(ret*qqpow(a,b[len-1]-&#x27;0&#x27;))%mod; a=(qqpow(a,10))%mod; len--; &#125; return ret;&#125;int read(char s[])&#123; int len=0; char ch; while((ch=getchar())!=&#x27;\\n&#x27;) &#123; s[len++]=ch; &#125; return len;&#125;signed main()&#123; int a; scanf(&quot;%lld %lld&quot;,&amp;a,&amp;mod); getchar(); int len; len=read(s); cout&lt;&lt;qpow(a,s,len); return 0;&#125; 对应题目改编自洛谷 【模板】扩展欧拉定理 题目背景 出题人也想写有趣的题面，可惜并没有能力。 题目描述 给你三个正整数，a,m,ba,m,ba,m,b，你需要求：ab mod ma^b \\bmod mabmodm 输入格式 一行三个整数，a,m,ba,m,ba,m,b 输出格式 一个整数表示答案 样例 #1 样例输入 #1 12 7 4 样例输出 #1 12 样例 #2 样例输入 #2 1998244353 12345 98765472103312450233333333333 样例输出 #2 15333 提示 注意输入格式，a,m,ba,m,ba,m,b 依次代表的是底数、模数和次数 【样例 111 解释】 24 mod 7=22^4 \\bmod 7 = 224mod7=2 【数据范围】 对于 100%100\\%100% 的数据，1≤a≤1091\\le a \\le 10^91≤a≤109，1≤b≤20000000，1≤m≤1081\\le b \\le 20000000，1\\le m \\le 10^81≤b≤20000000，1≤m≤108。 改了什么捏，当然是把b的数据范围改了。嘻嘻 那就可以过了 然而原题的数据范围是1≤b≤10200000001≤b≤10^{20000000}1≤b≤1020000000 0x22 同余 若正整数 a 和 b 除以 m 的余数相等，则称 a ，b 模 m 同余，记作a≡b (mod m)a\\equiv b\\ (\\text{mod}\\ m)a≡b (mod m)。 即 a % m = b % m 0x21.1 同余的性质 同余的基本性质： 性质21.1.1 ： (自反性)：a≡a(modm)a≡a(mod m)a≡a(modm) 性质21.1.2 ： (对称性)：若a≡b(mod m)，则b≡a(mod m)若 a≡b(\\mod\\ m)，则 b≡a(\\mod\\ m)若a≡b(mod m)，则b≡a(mod m) 性质21.1.3 ： (传递性)：若a≡b(mod m),b≡c(mod m)，则a≡c(modm)若 a≡b(\\mod\\ m),b≡c(\\mod\\ m)，则 a≡c(mod m)若a≡b(mod m),b≡c(mod m)，则a≡c(modm) 性质21.1.4 ： (同加性)：若a≡b(modm)，则a±c≡b±c(modm)若 a≡b(mod m)，则 a±c≡b±c(mod m)若a≡b(modm)，则a±c≡b±c(modm) 性质21.1.5 ： (同乘性)： 若a≡b(mod m)，则a×c≡b×c(mod m)若 a≡b(\\mod \\ m)，则 a×c≡b×c(\\mod\\ m)若a≡b(mod m)，则a×c≡b×c(mod m)，若a≡b(mod m),c≡d(mod m)，则a×c≡b×d(mod m)若 a≡b(\\mod\\ m),c≡d(\\mod\\ m)，则 a×c≡b×d(\\mod\\ m)若a≡b(mod m),c≡d(mod m)，则a×c≡b×d(mod m) 性质21.1.6 ： (同幂性)：ac≡bc(mod m)a^c≡b^c(\\mod\\ m)ac≡bc(mod m) 性质21.1.7 ： (不满足同除性)：若 a≡b(modm)a≡b(mod m)a≡b(modm)不满足a÷c≡b÷c(modm)a÷c≡b÷c(mod m)a÷c≡b÷c(modm) 性质21.1.8 ： (满足同除性)： 若a≡b(modm)a≡b(mod m)a≡b(modm)，c∣a，c∣bc ∣ a ， c ∣ bc∣a，c∣b , 则 $\\cfrac{a}{c}≡\\cfrac{b}{c}\\ \\pmod {\\cfrac{m}{\\gcd(m,c)} } $ 或者可以换一种表述方式： 若 ca≡cb(mod m)ca≡cb (\\mod m)ca≡cb(modm)则 a≡b(modmgcd⁡(m,c))a≡b \\pmod {\\frac{m}{\\gcd(m,c)} }a≡b(modgcd(m,c)m​) 例如：gcd⁡(c,m)=1⟹a≡b(modm)\\gcd(c,m)=1\\Longrightarrow a\\equiv b\\pmod mgcd(c,m)=1⟹a≡b(modm) 该性质会在取遍剩余系会用到。 推论21.1.9 ：若$ a≡b(modm) ， m’\\ |\\ m，则， 则，则a≡b \\pmod {m’}$ 推论21.1.10 ： a≡b(modmi)(i=1..k)a≡b \\pmod {m_i} (i=1..k)a≡b(modmi​)(i=1..k)等价于 a≡b(modM)=lcm(m1,m2,..mk)a≡b \\pmod M =\\mathrm{lcm}(m1,m2,..mk)a≡b(modM)=lcm(m1,m2,..mk) 推论21.1.12 ：a≡b(modm)a≡b(modm)a≡b(modm) 且 c≡d(modm)c≡d(modm)c≡d(modm) ⟹a+c≡b+d(modm)\\Longrightarrow a+c\\equiv b+d\\pmod m⟹a+c≡b+d(modm) 推论21.1.13 ：$a≡b(modm) $且 c≡d(modm)⟹a−c≡b−d(modm)c≡d(modm) \\Longrightarrow a-c\\equiv b-d\\pmod mc≡d(modm)⟹a−c≡b−d(modm) 0x21.2 费马小定理 若 p 是质数，则对于任意的整数 a 都有ap≡a(modp)a^p≡a \\pmod pap≡a(modp)。若 $gcd(a,p)=1 $，即 a 不是 p 的倍数，则有 ap−1≡1(modp)a^{p−1}≡1\\pmod pap−1≡1(modp) 费马小定理降幂：ak≡akmod (p−1) (mod p)a^k\\equiv a^{k\\mod(p-1)}\\;(\\mod \\;p)ak≡akmod(p−1)(modp) 费马大定理： m &gt; 2 时， xm+ym=zmx^m + y^m = z^mxm+ym=zm无正整数解 当m = 2 ，对于式子 a2+b2=c2a^2+b^2=c^2a2+b2=c2 （n 为任意正整数）： 当 a 为奇数时：a=2n+1,c=n2+(n+1)2,b=c−1a=2n+1,c=n^2+(n+1)^2,b=c-1a=2n+1,c=n2+(n+1)2,b=c−1 当 a 为偶数时：a=2n+2,c=1+(n−1)2,b=c−2a=2n+2,c=1+(n-1)^2,b=c-2a=2n+2,c=1+(n−1)2,b=c−2 0x21.3 欧拉定理 欧拉定理 定理21.3.1 ： 若正整数 a , n 互质，则 $a^{\\varphi(n)}≡1(\\mod\\ n) 其中其中其中 \\varphi(n)$是欧拉函数。 推论21.3.2： ∃x∈N∗,ax≡1(mod m) ⟺ gcd⁡(a,m)=1\\exists x\\in N^{*},a^x\\equiv 1(\\mod m) \\iff \\gcd(a,m)=1∃x∈N∗,ax≡1(modm)⟺gcd(a,m)=1 欧拉降幂（拓展欧拉定理） 若 a 与 m 互质： ab≡abmod φ(m)(modm)a^b\\equiv a^{b\\mod\\varphi(m)}\\pmod mab≡abmodφ(m)(modm) 若不保证 a 与 m 互质：b&gt;φ(m)时：ab≡abmod φ(m)+φ(m) (modm)b&gt; \\varphi(m) 时：a^b\\equiv a^{b\\mod \\varphi(m)+\\varphi(m)}\\;\\pmod mb&gt;φ(m)时：ab≡abmodφ(m)+φ(m)(modm) 在一些计数的问题中，常常要求对结果取模，但是在计算非常庞大的次幂的时候，无法直接取模，可以先把底数对 p 取模，指数对 φ(p)\\varphi(p)φ(p)取模，再计算次幂，有效地降低时间复杂度。 欧拉函数的性质 0x14 互质与欧拉函数 0x14.1 欧拉函数 定义: ∀a,b∈N 若$ gcd ⁡ ( a , b ) = 1 ,$则称 a , b 互质。 对于三个数或更多的数，把gcd ⁡ ( a , b , c ) = 1称之为 a , b , c 互质。 把 gcd⁡(a,b)=gcd⁡(a,c)=gcd⁡(b,c)=1gcd ⁡ ( a , b ) = gcd ⁡ ( a , c ) = gcd ⁡ ( b , c ) = 1gcd⁡(a,b)=gcd⁡(a,c)=gcd⁡(b,c)=1称之为 a , b , c 两两互质。显然 a , b , c 两两互质是优于 a , b , c 互质的。 性质14.1.1：int 范围内的数 n 中， 1∼n1\\sim n1∼n中与 n 互质的个数最多只有1600（max⁡{φ(1∼2147483647)})1600（\\quad max ⁡ \\{ φ ( 1 ∼ 2147483647 ) \\}\\quad )1600（max⁡{φ(1∼2147483647)}) 欧拉函数 定义：1 ⋯ N中与 N 互质的数的个数，被称为欧拉函数，记作 φ(N)\\varphi(N)φ(N)，phi。 如果 n 是一个素数，那么 φ(n)=n−1φ(n)=n−1φ(n)=n−1 （所有小于 n 的都互素） 如果 n 是素数的 k 次幂，即n=pkn = p^kn=pk，那么 φ(pk)=pk−pk−1φ(p^k) = p^k - p^{k-1}φ(pk)=pk−pk−1（除了 p的倍数以外，与 1 ∼ n 中的任意数都互素） 我们可以的到下列结论： 由算数基本定理（唯一分解定理）得 N=p1k1×p2k2×p3k3×⋯ pmkmN= p_{1}^{k_{1}} \\times p_{2}^{k_{2}} \\times p_{3}^{k_{3}} \\times \\cdots \\ p_{m}^{k_{m}} N=p1k1​​×p2k2​​×p3k3​​×⋯ pmkm​​ 则有： φ(N)=N×∏p∣N(1−1p)\\varphi(N)=N \\times \\prod_{p\\mid N}(1-\\frac{1}{p}) φ(N)=N×p∣N∏​(1−p1​) 其中，如果 p是素数,则φ(p)=p×(1−1p)=p−1φ( p) =p\\times (1- \\frac{1}{p}) = p-1φ(p)=p×(1−p1​)=p−1 我们可以利用这个性质在分解质因数的同时 $ O(\\sqrt n)$使用公式求解欧拉函数 123456789101112inline int euler_one(int n)&#123; int ans = n; for(int i = 2; i * i &lt;= n; ++ i)&#123; if(n % i == 0)&#123; ans = ans / i * (i - 1); while(n % i == 0)n /= i; &#125; &#125; if(n &gt; 1)ans = ans / n * (n - 1); return ans;&#125; 由此我们得到了上面那道题的真实数据范围条件（1≤b≤1020000000）（1≤b≤10^{20000000}）（1≤b≤1020000000）下的abmod ma^b\\mod mabmodm的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int mod;string s;int qmul(int x,int y,int mod)&#123; int z=(long double)x/mod*y; int res=(unsigned long long)x*y-(unsigned long long)z*mod; return (res+mod)%mod;&#125;int qpow(int a,int b,int mod)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=qmul(ans,a,mod); a=qmul(a,a,mod); b&gt;&gt;=1; &#125; return ans;&#125;int varphi(int n)//求varphi(n)&#123; if(n==1)return 1; int ans=n; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; ans=ans/i*(i-1); while(n%i==0)n/=i; &#125; &#125; if(n&gt;1)//n 此时为 超过 输入时的n开根号 的唯一一个质数//比如n=21，n经过前面了这里变成7 ans=ans/n*(n-1); return ans;&#125;void EEt(int a,string b,int mod)&#123; int b_mod=0; int tmod=varphi(mod);//! //cout&lt;&lt;tmod&lt;&lt;endl; for(int i=0;i&lt;b.length();i++) &#123; b_mod=b_mod*10+b[i]-&#x27;0&#x27;; if(b_mod&gt;=tmod) &#123; b_mod%=tmod; &#125; &#125; //cout&lt;&lt;b_mod&lt;&lt;endl; int bb=0; //cout&lt;&lt;&quot;tmod&quot;&lt;&lt;tmod&lt;&lt;endl; if(b.length()&lt;=10)bb=stol(b,nullptr,10); //cout&lt;&lt;bb&lt;&lt;&quot;bb&quot;&lt;&lt;endl; if(bb!=0 &amp;&amp; bb&lt;=tmod)&#123;printf(&quot;%lld&quot;,qpow(a,bb,mod));&#125; else &#123; b_mod = b_mod + tmod; printf(&quot;%lld&quot;, qpow(a, b_mod, mod)); return; &#125;&#125; signed main()&#123; int a; scanf(&quot;%lld %lld&quot;,&amp;a,&amp;mod); getchar(); cin&gt;&gt;s; EEt(a,s,mod); return 0;&#125; 0x51.1 线性筛法求欧拉函数 我们注意到在线性筛中，每一个合数都是被最小的质因子筛掉，筛法求素数的同时也得到了每个数的最小质因子，这是线性筛求欧拉函数的关键。 1.考虑n=pjk,φ(n)n=p^k_j,\\varphi(n)n=pjk​,φ(n) 显然有φ(pjk)=pjk−pjk−1=pjk−1×(pj−1)\\varphi(p^k_j)=p^k_j-p^{k-1}_j=p_j^{k-1}\\times(p_j-1)φ(pjk​)=pjk​−pjk−1​=pjk−1​×(pj​−1) 2.考虑n=i×pjn=i\\times p_jn=i×pj​当pj∣ip_j\\mid ipj​∣i 即iii含有因子pjp_jpj​,由于i=npji=\\frac{n}{p_j}i=pj​n​，由唯一分解定理： φ(n)=n×∏i=1spi−1pi=p1×i×∏i=1spi−1pi=p1×φ(i)\\begin{aligned} \\varphi(n) &amp; =n\\times \\prod_{i=1}^{s}\\frac{p_i-1}{p_i} \\\\[2ex] &amp; =p_1\\times i\\times \\prod_{i=1}^{s}\\frac{p_i-1}{p_i} \\\\[2ex] &amp; =p_1\\times \\varphi(i) \\end{aligned} φ(n)​=n×i=1∏s​pi​pi​−1​=p1​×i×i=1∏s​pi​pi​−1​=p1​×φ(i)​ 3.考虑 n=i×pjn=i\\times p_jn=i×pj​，φ(n)\\varphi(n)φ(n)，当 iii 不整除pjp_jpj​ 即 iii 与 pjp_jpj​ 互质，积性函数显然有性质： φ(n)=φ(i)×φ(pj)=φ(i)×(pj−1)\\varphi(n)=\\varphi(i)\\times \\varphi(p_j)=\\varphi(i)\\times(p_j-1) φ(n)=φ(i)×φ(pj​)=φ(i)×(pj​−1) 由于我们仅在在线性筛的框架上增加了一些细节，所以时间复杂度依然是O(n)的。 威尔逊定理：解决带有“！”的问题 0x21.4 威尔逊定理 威尔逊定理 定理21.4.1： 当 p 为质数时有： (p−1)!≡p−1≡−1(mod p)(p-1)!\\equiv p-1\\equiv -1(\\mod\\;p)(p−1)!≡p−1≡−1(modp)， (p−2)!≡1(modp)(p-2)!\\equiv 1\\pmod p(p−2)!≡1(modp) 其中 定理21.4.1 实际上就等价于：若 p 是质数，则 (p−1)!+1 能够被 p 整除。 n 为素数时： (n−1)!mod n=1(n-1)!\\mod n=1(n−1)!modn=1 n 为合数时：除 n = 4 以外，(n−1)!mod n=0(n-1)!\\mod n=0(n−1)!modn=0 威尔逊定理的逆命题 定理21.4.2： 若一个数 p，满足条件(p−1)!+1(p−1)!+1(p−1)!+1可以被 p 整除，那么 p 是素数。 即：p 可整除 (p-1)!+1 是 p 为质数的充要条件。 例题：杭州电子科技大学HDU例题：杭州电子科技大学HDU例题：杭州电子科技大学HDU Problem B. Fansblog（HDU 6608 19多校） 给定一个质数P(109≤P≤1014)P(10^9≤P≤10^{14})P(109≤P≤1014)， Q 是 最大的那个小于 P 的质数，求 Q ! %PQ\\ !\\ \\%PQ ! %P Solution 根据威尔逊定理 (P−1)!≡P−1≡−1(mod P)(P-1)!\\equiv P-1\\equiv -1(\\mod P)(P−1)!≡P−1≡−1(modP)，所以显然可以构造答案 Q ! 我们知道P&gt;Q，则有(P−1)!≡1×2×⋅⋅⋅⋅⋅⋅×Q×(Q+1)×⋅⋅⋅⋅⋅⋅×(P−1)≡P−1(mod P)(P-1)!\\equiv1\\times 2\\times······\\times Q \\times (Q+1)\\times······\\times (P-1)\\equiv P-1(\\mod P)(P−1)!≡1×2×⋅⋅⋅⋅⋅⋅×Q×(Q+1)×⋅⋅⋅⋅⋅⋅×(P−1)≡P−1(modP) 则有：Q!≡P−1(Q+1)×⋅⋅⋅⋅⋅⋅×(P−1)≡1(Q+1)×⋅⋅⋅⋅⋅⋅×(P−2)(mod P)Q!\\equiv\\cfrac{P-1}{(Q+1)\\times······\\times (P-1)}\\equiv\\cfrac{1}{(Q+1)\\times······\\times (P-2)}(\\mod P)Q!≡(Q+1)×⋅⋅⋅⋅⋅⋅×(P−1)P−1​≡(Q+1)×⋅⋅⋅⋅⋅⋅×(P−2)1​(modP) 即求(Q+1)×⋅⋅⋅⋅⋅⋅×(P−2)(Q+1)\\times······\\times (P-2)(Q+1)×⋅⋅⋅⋅⋅⋅×(P−2)的逆元，当然目前还不会求","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://xqc-1368.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"name":"扩展欧拉定理","slug":"扩展欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"威尔逊定理","slug":"威尔逊定理","permalink":"https://xqc-1368.github.io/tags/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"}]},{"title":"同余：拓展欧几里得定理","slug":"04.2 同余：拓展欧几里得","date":"2024-08-18T12:07:25.641Z","updated":"2024-08-18T12:07:12.096Z","comments":true,"path":"2024/08/18/04.2 同余：拓展欧几里得/","permalink":"https://xqc-1368.github.io/2024/08/18/04.2%20%E5%90%8C%E4%BD%99%EF%BC%9A%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"","text":"0x22 拓展欧几里德 0x22.1 裴蜀（Bézout）定理(用于求解“不定方程”的相关问题) 内容：设 a , b是不全为零的整数 ，对于任意整数 x , y ，满足 gcd⁡(a,b)∣(ax+by)gcd ⁡ ( a , b)| (ax+by)gcd⁡(a,b)∣(ax+by) ，且存在整数x，y使得： ax+by=gcd⁡(a,b)a x + b y = gcd ⁡ ( a , b )ax+by=gcd⁡(a,b) 推论1：(感觉不像推论) gcd⁡(a,b)∣c⟺∃x,y∈Z,ax+by=c\\gcd(a,b)\\mid c⟺∃x,y∈Z,ax+by=cgcd(a,b)∣c⟺∃x,y∈Z,ax+by=c 方程$ ax+by=d(d=gcd(a,b)) $即为丢番图方程。 逆定理推论 设 a,b 是不全为零的整数，若d&gt;0是a,b 的公因数，且存在整数 x,y , 使得ax+by=d，则 d=gcd(a,b)。 特殊地，设a,b 是不全为零的整数，若存在整数 x,y , 使得ax+by=1，则 a,b互质 推论2：∀a,b,z∈N∗,gcd⁡(a,b)=1∃x,y∈N,ax+by=ab−a−b+z\\forall a,b,z\\in\\mathbb{N^{*}},\\gcd(a,b)=1\\\\\\exists x,y\\in\\mathbb{N^{}} ,ax+by=ab−a−b+z∀a,b,z∈N∗,gcd(a,b)=1∃x,y∈N,ax+by=ab−a−b+z 即两互质的数 a , b，表示不出的最大的数为ab−a−b。 推论2 进一步的结论： 对自然数 a、b和整数n，a 与 !b 互素，考察不定方程：ax+by=n. 其中 x 和 y 为自然数。如果方程有解，称 n 可以被 a、b 表示。 记C= ab−a−b。由 a 与 b 互素，C 必然为奇数。则有结论： 对任意的整数 n，n与C-n中有且仅有一个可以被表示。 即：可表示的数与不可表示的数在区间 [0,C]表示；负数不可被表示，大于 C 的数可被表示。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"拓展欧几里得定理","slug":"拓展欧几里得定理","permalink":"https://xqc-1368.github.io/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/"},{"name":"裴蜀定理","slug":"裴蜀定理","permalink":"https://xqc-1368.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"}]},{"title":"整除：最大公约数和最小公倍数","slug":"03-2 整除：最大公约数与最小公倍数","date":"2024-08-18T12:07:25.636Z","updated":"2024-08-18T12:01:36.840Z","comments":true,"path":"2024/08/18/03-2 整除：最大公约数与最小公倍数/","permalink":"https://xqc-1368.github.io/2024/08/18/03-2%20%E6%95%B4%E9%99%A4%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/","excerpt":"","text":"0x13 最大公因数与最小公倍数 0x13.1 约数 约数，又称因数。整数a aa除以整数 b ( b ≠ 0 ) 除得的商正好是整数而没有余数，我们就说a 能被b整除，或b 能整除a 。a 称为b 的倍数，b称为a 的约数。 唯一分解定理，任何一个大于 1 11 的数都可以被分解成有限个质数乘积的形式 N=∏i=1mpiCiN = \\prod_{i=1}^{m}p_i^{C_i} N=i=1∏m​piCi​​ 其中$ p_1 &lt; p_2 &lt; ··· &lt; p_m为质数，为质数，为质数，C_i$为正整数 N 的正约数个数为： (c1+1)×(c2+1)×⋯(cm+1)=∏i=1m(ci+1)(c1+1)\\times (c_2+1)\\times \\cdots (c_m+1)=\\prod_{i=1}^{m}(c_i+1)(c1+1)×(c2​+1)×⋯(cm​+1)=∏i=1m​(ci​+1) NMN^MNM的正约数个数为： $ (M\\times {c_1}+1)\\times (M\\times {c_2}+1)\\times \\cdots (M\\times {c_m}+1)=\\prod_{i=1}^{m}(M\\times {c_i}+1)$ N 的所有正约数和为： $ (1+p_1+p_1^2+\\cdots +p_1{c_1})\\times\\cdots\\times(1+p_m+p_m2+\\cdots +p_m{c_m})=\\prod_{i=1}{m}(\\sum_{j=0}{c_i}(p_i)j)$ 随机数据下，约数个数的期望是O(ln⁡ n)O(\\ln\\ n)O(ln n) 试除法 - 求 n的正约数集合 显然约数总是成对出现（除了完全平方数，只有一个$ \\sqrt{n}$ ），所以只需要枚举到n\\sqrt{n}n​ 即可。 1234567for(int i=1;i*i&lt;=n;i++) if(n%i==0) &#123; diver.emplace_back(i); if(n/i!=i) diver.emplace_back(n/i); &#125; a useful conclusion: 推论：一个整数 n 的约数个数上界为 2n2\\sqrt{n}2n​ 倍数法 - 求 1 ∼ n 1\\sim n1∼n 中每个数的正约数集合 按照埃氏筛的形式枚举倍数，时间复杂度为O(n+n2+n3+⋯+nn)≈n×log⁡n=O(nlog⁡n)O(n+\\cfrac n 2+\\cfrac n 3+\\cdots+\\cfrac n n)≈n\\times \\log n=O(n\\log n)O(n+2n​+3n​+⋯+nn​)≈n×logn=O(nlogn) 时间复杂度为O(nlog⁡n)O(n\\log n)O(nlogn) 可以求出求 1∼n1\\sim n1∼n中每个数的正约数集合，但并不能求出具体某个数的因子是谁，常用于一些于因子有关的计算，如计算 ∑i=1n∑d∣nd\\sum_{i=1}^{n}\\sum_{d \\mid n}d∑i=1n​∑d∣n​d 或是$ \\sum_{i=1}^{n}\\sum_{d \\mid n}f(d) $ ，可以使用倍数法在O(nlog⁡n)O(n\\log n)O(nlogn)的复杂度下计算。 1234567891011int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++ i)&#123; for(int j = 1 ;j * i &lt;= n; ++ j)&#123; factor[i * j].push_back(j); &#125; &#125; return 0;&#125; 推论：1∼n1\\sim n1∼n中每个数的约数的总和大概为nlog⁡nn \\log nnlogn。 0x13.2 最大公约数 两个数 a 和 b 的最大公约数$ \\tt (Greatest Common Divisor) $是指同时整除 a和 b 的最大因数，记为 gcd⁡(a,b)\\gcd(a, b)gcd(a,b)。 一个约定俗成的定理：任何非零整数和零的最大公约数为它本身。 有如下基本性质： 性质13.2.1：$ \\gcd(a,b)=\\gcd(b,a)$ 性质13.2.2： gcd⁡(a,b)=gcd⁡(a−b,b)(a≥b)\\gcd(a,b)=\\gcd(a-b,b)\\quad(a ≥b)gcd(a,b)=gcd(a−b,b)(a≥b) 性质13.2.3：gcd⁡(a,b)=gcd⁡(a mod b,b)\\gcd(a,b)=\\gcd(a\\bmod b,b)gcd(a,b)=gcd(amodb,b) 性质13.2.4：gcd⁡(a,b,c)=gcd⁡(gcd⁡(a,b),c)\\gcd(a,b,c)=\\gcd(\\gcd(a,b),c)gcd(a,b,c)=gcd(gcd(a,b),c) 性质13.2.5：gcd⁡(ka,kb)=k gcd⁡(a,b)\\gcd(ka,kb)=k\\ \\gcd(a,b)gcd(ka,kb)=k gcd(a,b) 性质13.2.6：gcd⁡(k,ab)=1 ⟺ gcd⁡(k,a)=1 &amp;&amp; gcd⁡(k,b)=1\\gcd(k,ab)=1 \\iff \\gcd(k,a)=1\\ \\&amp;\\&amp;\\ \\gcd(k,b)=1gcd(k,ab)=1⟺gcd(k,a)=1 &amp;&amp; gcd(k,b)=1 特别地，如果 a , b 的gcd⁡(a,b)=1\\gcd(a,b)=1gcd(a,b)=1，则称这两个数互质（互素）。 辗转相除法（又称欧几里德算法） 理论基础： $ \\forall a,b\\in\\N,b\\neq 0,\\gcd(a,b)=\\gcd(b,a\\ \\mathrm{mod}\\ b)$ 时间复杂度 $ O(\\log n)$ 最坏情况：斐波那契数列相邻的两项，因为斐波那契数列相邻的两项一定互质。欧几里德算法由于存在大量的取模运算，对于大整数耗时较大。 Code int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125; &lt;!--code￼2--&gt; 提前用位运算交换，很方便 0x13.3 最小公倍数 两个数 a和 b的最小公倍数 (LeatestCommonMultiple)\\tt (Leatest Common Multiple)(LeatestCommonMultiple)是指同时被 a 和 b 整除的最小倍数，记为 lcm(a,b)\\text{lcm}(a, b)lcm(a,b)。特殊的，当a 和 b 互素时， lcm(a,b)=ab\\text{lcm}(a, b) = ablcm(a,b)=ab。 性质13.3.1：∀a,b∈N,gcd⁡(a,b)×lcm(a,b)=a×b\\forall a, b \\in N,\\gcd(a, b) \\times \\text{lcm}(a, b) = a \\times b∀a,b∈N,gcd(a,b)×lcm(a,b)=a×b 可以使用 gcd ⁡ , lcm 的定义证明 性质13.3.1 ，证明略。 123int lcm(int a,int b)&#123; return a / gcd(a,b) * b;//先除后乘，以免溢出64位整数&#125; 重要性质：gcd 与 lcm 的指数最值表示法 由唯一分解定理得，若 n=p1α1×p2α2×p3α3×⋯×pkαkn=p_1^{α_1}\\times p_2^{α_2}\\times p_3^{α_3}\\times \\cdots\\times p_k^{α_k}n=p1α1​​×p2α2​​×p3α3​​×⋯×pkαk​​ m=p1β1×p2β2×p3β3×⋯×pkβkm=p_1^{β_1}\\times p_2^{β_2}\\times p_3^{β_3}\\times \\cdots\\times p_k^{β_k}m=p1β1​​×p2β2​​×p3β3​​×⋯×pkβk​​ ​则 n×m=p1α1+β1×p2α2+β2×p3α3+β3×⋯×pkαk+βkn\\times m=p_1^{α_1+β_1}\\times p_2^{α_2+β_2}\\times p_3^{α_3+β_3}\\times \\cdots\\times p_k^{α_k+β_k}n×m=p1α1​+β1​​×p2α2​+β2​​×p3α3​+β3​​×⋯×pkαk​+βk​​ gcd⁡(n,m)=p1min{α1,β1}×p2min{α1,β1}×⋯×pkmin{αk,βk}\\gcd(n,m)=p_1^{min\\{α_1,β_1\\}}\\times p_2^{min\\{α_1,β_1\\}}\\times \\cdots\\times p_k^{min\\{α_k,β_k\\}}gcd(n,m)=p1min{α1​,β1​}​×p2min{α1​,β1​}​×⋯×pkmin{αk​,βk​}​ lcm(n,m)=p1max{α1,β1}×p2max{α1,β1}×⋯×pkmax{αk,βk}\\text{lcm}(n,m)=p_1^{max\\{α_1,β_1\\}}\\times p_2^{max\\{α_1,β_1\\}}\\times \\cdots\\times p_k^{max\\{α_k,β_k\\}}lcm(n,m)=p1max{α1​,β1​}​×p2max{α1​,β1​}​×⋯×pkmax{αk​,βk​}​ 0x13.4 GCD 与 LCM 的一些性质与定理 性质13.4.1：fibnfib_nfibn​表示斐波那契数列的第n项 gcd⁡(fibn,fibm)=fibgcd⁡(n,m)\\gcd\\left(fib_{n},fib_{m}\\right)=fib_{\\gcd(n,m)}gcd(fibn​,fibm​)=fibgcd(n,m)​ 性质13.4.2： gcd⁡(am−1,an−1)=agcd⁡(n,m)−1 (a&gt;1,n&gt;0,m&gt;0)\\gcd(a^m−1,a^n−1)=a^{\\gcd(n,m)}−1\\ (a&gt;1,n&gt;0,m&gt;0)gcd(am−1,an−1)=agcd(n,m)−1 (a&gt;1,n&gt;0,m&gt;0) 性质13.4.3： gcd⁡(am−bm,an−bn)=agcd⁡(m,n)−bgcd⁡(m,n) (gcd(a,b)=1)\\gcd(a^m−b^m,a^n−b^n)=a^{\\gcd(m,n)}−b^{\\gcd(m,n)}\\quad \\ (gcd(a,b)=1)gcd(am−bm,an−bn)=agcd(m,n)−bgcd(m,n) (gcd(a,b)=1) 性质13.4.4： gcd⁡(a,b)=1,gcd⁡(am,bn)=1\\gcd(a,b)=1,\\gcd(a^m,b^n)=1gcd(a,b)=1,gcd(am,bn)=1 性质13.4.5： (a+b)∣ab⟹gcd⁡(a,b)≠1(a+b)\\mid ab\\Longrightarrow \\gcd(a,b)\\neq 1(a+b)∣ab⟹gcd(a,b)=1 a,b不互质，因为互质就提不出来公因子了。 性质13.4.6： 设G=gcd⁡(Cn1,Cn2,...Cnn−1)G=\\gcd(C_n^1,C_n^2,...C_n^{n-1})G=gcd(Cn1​,Cn2​,...Cnn−1​) n 为素数，G = n n 非素且有一个素因子 p ，G = p n 有多个素因子，G = 1 性质13.4.7： (n+1)lcm(Cn0,Cn1,⋯ ,Cnn)=lcm(1,2,⋯ ,n+1)(n+1)\\text{lcm}(C_n^0,C_n^1,\\cdots ,C_n^n)=\\text{lcm}(1,2,\\cdots ,n+1)(n+1)lcm(Cn0​,Cn1​,⋯,Cnn​)=lcm(1,2,⋯,n+1) 性质13.4.8： ∑i=1ngcd⁡(i,n)=∑d∣ndφ(nd)\\displaystyle\\sum^n_{i=1}\\gcd(i,n)=\\sum_{d|n}d\\varphi(\\frac{n}{d})i=1∑n​gcd(i,n)=d∣n∑​dφ(dn​) 性质13.4.8： 在 FibonaccFibonaccFibonacc 数列中求相邻两项的 ⁡ gcd⁡\\gcdgcd时，辗转相减次数等于辗转相除次数。 0x13.5 补充知识： FibonaccFibonaccFibonacc 数列及其推论 基本性质定理： \\begin{align} fib_n&amp;= \\\\&amp;0 \\quad(n=0); \\\\&amp;1 \\quad(n=1); \\\\&amp;fib_{n-1}+fib_{n-2} \\quad(n=2); \\end{align} 推导结论： 性质13.5.1： ∑i=1nfi=fn+2−1\\sum_{i=1}^{n}{f_{i}}=f_{n+2}-1∑i=1n​fi​=fn+2​−1 性质13.5.2：∑i=1nf2i−1=f2n\\sum_{i=1}^{n}{f_{2i-1}}=f_{2n}∑i=1n​f2i−1​=f2n​ 性质13.5.3： ∑i=1nf2i=f2n+1−1\\sum_{i=1}^{n}{f_{2i}}=f_{2n+1}-1∑i=1n​f2i​=f2n+1​−1 性质13.5.4：∑i=1n(fn)2=fnfn+1\\sum_{i=1}^{n}{(f_{n})^2}=f_{n}f_{n+1}∑i=1n​(fn​)2=fn​fn+1​ 性质13.5.5：fn+m=fn−1fm−1+fnfmf_{n+m}=f_{n-1}f_{m-1}+f_{n}f_{m}fn+m​=fn−1​fm−1​+fn​fm​ 性质13.5.6： (fn)2=(−1)(n−1)+fn−1fn+1(f_{n})^2=(-1)^{(n-1)}+f_{n-1}f_{n+1}(fn​)2=(−1)(n−1)+fn−1​fn+1​ 性质13.5.7：f2n−1=(fn)2−(fn−2)2f_{2n-1}=(f_{n})^2-(f_{n-2})^2f2n−1​=(fn​)2−(fn−2​)2 性质13.5.8：fn=fn+2+fn−23f_{n}=\\cfrac{f_{n+2}+f_{n-2}}{3}fn​=3fn+2​+fn−2​​ 性质13.5.9： $\\frac{f_{i}}{f_{i-1}} \\approx \\dfrac{\\sqrt{5}-1}{2} \\approx 0.618 $ 性质13.5.10：fn=(1+52)n−(1−52)n5f_{n}=\\cfrac{\\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n}-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}}{\\sqrt{5}}fn​=5​(21+5​​)n−(21−5​​)n​ ​ Modified GCD 题目描述 Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it’s an easy task to calculate the GCD between two positive integers. A common divisor for two positive numbers is a number which both numbers are divisible by. But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor $ d $ between two integers $ a $ and $ b $ that is in a given range from $ low $ to $ high $ (inclusive), i.e. $ low&lt;=d&lt;=high $ . It is possible that there is no common divisor in the given range. You will be given the two integers $ a $ and $ b $ , then $ n $ queries. Each query is a range from $ low $ to $ high $ and you have to answer each query. 输入格式 The first line contains two integers $ a $ and $ b $ , the two integers as described above ( $ 1&lt;=a,b&lt;=10^{9} $ ). The second line contains one integer $ n $ , the number of queries ( $ 1&lt;=n&lt;=10^{4} $ ). Then $ n $ lines follow, each line contains one query consisting of two integers, $ low $ and $ high $ ( $ 1&lt;=low&lt;=high&lt;=10^{9} $ ). 输出格式 Print $ n $ lines. The $ i $ -th of them should contain the result of the $ i $ -th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query. 样例输入 #1 123459 2731 510 119 11 样例输出 #1 1233-19 解决这题首先要来看一个命题： a,b 所有公共的约数一定是 gcd(a,b) 的约数。 若要求解a，b的每一个公约数，只需先求出他们的最大公约数，然后再求出这个数的所有因子即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define int long longusing namespace std;vector&lt;int&gt; diver;int gcd(int a,int b)&#123; if(a&lt;b)&#123;a^=b;b^=a;a^=b;&#125;//交换a，b的值交换后恒有a&gt;b if(!b)return a; if(!(a&amp;1)&amp;&amp;!(b&amp;1))return 2*gcd(a&gt;&gt;1,b&gt;&gt;1); else if(!(a&amp;1))return gcd(a&gt;&gt;1,b); else if(!(b&amp;1))return gcd(a,b&gt;&gt;1); else return gcd(a-b,b);&#125;signed main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int grst_com_div=gcd(a,b); //cout&lt;&lt;grst_com_div&lt;&lt;endl; int n; for(int i=1;i*i&lt;=grst_com_div;i++) if(grst_com_div%i==0) &#123; diver.emplace_back(i); if(grst_com_div/i!=i) diver.emplace_back(grst_com_div/i); &#125;//求出最大公约数的所有因子 sort(diver.begin(),diver.end()) ; //对所有因子排序 //for(auto j:diver)cout&lt;&lt;j&lt;&lt;&quot; &quot;; cin&gt;&gt;n; while(n--)//回答n次询问 &#123; int l,r,ans=-1; cin&gt;&gt;l&gt;&gt;r; int i=0,j=diver.size()-1; while(i&lt;=j)//二分查找解决确定区间问题 &#123; int mid=j+(i-j)/2; if(diver[mid]&gt;=l &amp;&amp; diver[mid]&lt;=r) &#123; ans=diver[mid]; i = mid + 1; &#125; else if(diver[mid]&lt;l) i=mid+1; else j=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"最大公约数gcd","slug":"最大公约数gcd","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0gcd/"},{"name":"最小公倍数lcm","slug":"最小公倍数lcm","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm/"},{"name":"辗转相除法","slug":"辗转相除法","permalink":"https://xqc-1368.github.io/tags/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/"}]},{"title":"整除：素数算法和筛法","slug":"03-1整除： 素数算法和筛法","date":"2024-08-18T12:07:25.633Z","updated":"2024-08-19T02:08:20.345Z","comments":true,"path":"2024/08/18/03-1整除： 素数算法和筛法/","permalink":"https://xqc-1368.github.io/2024/08/18/03-1%E6%95%B4%E9%99%A4%EF%BC%9A%20%E7%B4%A0%E6%95%B0%E7%AE%97%E6%B3%95%E5%92%8C%E7%AD%9B%E6%B3%95/","excerpt":"","text":"整除，素数和筛法 0x00整除，讲解了一些整除的基础知识，理解这些内容是我们学习接下来的内容的基础。 整除的定义：若整数 n 除以整数 d 的余数为 0，即 d 能整除 n ，则称 d 是 n 的约数，n 是 d 的倍数，记为 d∣nd\\mid nd∣n 性质1.1： a∣b,b∣c⇒a∣ca\\mid b,b\\mid c \\Rightarrow a | ca∣b,b∣c⇒a∣c 性质1.2：a∣b⇒a∣bca∣b⇒a∣bca∣b⇒a∣bc，c 为任意的整数。 性质1.3： $a ∣ b , a ∣ c ⇒ a ∣ k b ± lc $（k 与 l ll 均为任意的整数）。（都有公因子 a，正确性显然） 性质1.3推论：k1,k2互质，则k1+k2与k1×k2互质k_1 , k_2互质，则 k_1+k_2与k_1×k_2互质k1​,k2​互质，则k1​+k2​与k1​×k2​互质（仅有a=1能整除$k_1,k_2k_1,k_2 $​能同时整除 k1+k2与k1×k2k_1+k_2与k_1×k_2k1​+k2​与k1​×k2​） 性质1.4：a∣b,b∣a⇒a=±ba∣b,b∣a⇒a=±ba∣b,b∣a⇒a=±b 性质1.5：$a = k b ± c ⇒ a , b $ 的公因数与 b , c 的公因数完全相同 性质1.6：若 $a ∣ b c $，且 a与 c 互质，则 a∣ba\\mid ba∣b 0x10 整除相关 0x11 素数（质数） 定义： 素数（又称质数）是只有 1 和它本身两个因数的数。 规定 1 既非素数也非合数。特殊的，2是唯一的偶素数。 素数定理：设 π ( x )为 1 到 x 中素数的个数。 其中： π(n)=−1+∑k=1x⌊cos⁡2⌊π(n−1)!+1n⌋⌋π ( n ) =-1+\\sum_{k=1}^x\\lfloor \\cos^2\\lfloor\\pi\\cfrac{(n-1)!+1}{n}\\rfloor \\rfloor π(n)=−1+k=1∑x​⌊cos2⌊πn(n−1)!+1​⌋⌋ 尝试求极限发现（其中$ \\ln(x)$ 表示x 的自然对数）： lim⁡x−&gt;∞π(x)(xln⁡(x))=1\\lim_{x-&gt;∞}\\cfrac{π(x)}{(\\frac{x}{\\ln(x)})}=1limx−&gt;∞​(ln(x)x​)π(x)​=1 即可得到定理： 定理2.1： 在自然数集中，小于 n 的质数约有 $\\cfrac {n}{\\ln(n)} $ 个。 由该定理可知，是 int 范围内的素数的个数并不会很多，其中 int 范围内的素数间距大概是 10210^2102的数量级。 定理2.2： （伯特兰—切比雪夫定理）（伯特兰 — 切比雪夫定理）（伯特兰—切比雪夫定理）若整数 n &gt; 3，则至少存在一个质数 p ，符合 n&lt;p&lt;2n−2n &lt; p &lt; 2 n − 2n&lt;p&lt;2n−2。另一个稍弱说法是：对于所有大于 1的整数 n，至少存在一个质数 p，符合 n&lt;p&lt;2nn &lt; p &lt; 2nn&lt;p&lt;2n。 接下来介绍的四种算法均为单个素数的判定方法。 1.试除法 试除法是最常用的判断素数的方法。 一个数如果不是素数，则一定能被一个小于它自己的数整除。假设一个数能整除 nnn 即$ a ∣ n $那么 $\\frac{n}{a} $ 也必定能整除 nnn，不妨设$ a \\le \\frac{n}{a}，则有，则有，则有a^2\\le n，即，即，即a \\le \\sqrt n$。 时间复杂度：O(n)O(\\sqrt{n})O(n​) 12345678inline bool is_prime(int x)&#123; if(x &lt; 2) return false; for(register int i = 2; i * i &lt;= x; ++ i) if(x % i == 0) return false; return true;&#125; 2.kn+i 法 一个大于 1 的整数如果不是素数，那么一定有素因子，因此在枚举因子时只需要考虑可能为素数的因子即可。$ k n + i$法即枚举形如 $k n + i $的数，例如取 k=6k=6k=6，那么6n+3,6n+4,6n+66n+3,6n+4,6n+66n+3,6n+4,6n+6 都不可能为素数（显然它们分别有因子 2,3,2,62 , 3 , 2 , 62,3,2,6一定不是素数），因此我们只需要枚举形如$6 n + 1 , 6 n + 5 $ 的数即可，这样整体的时间复杂度就会降低了$\\frac{2}{3} $ ，也就是 O(n13)O(n^\\frac{1}{3})O(n31​) 下面是$kn+i $法 k=30k = 30k=30 版本的模板： 1234567bool isPrime(ll n)&#123; if(n == 2 || n == 3 || n == 5)return 1; if(n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n == 1) return 0; ll c = 7, a[8] = &#123;4,2,4,2,4,6,2,6&#125;; while(c * c &lt;= n) for(auto i : a)&#123;if(n % c == 0)return 0; c += i;&#125; return 1;&#125; 3.预处理法 对于多组数据，如果 n是合数，那么它必然有一个小于等于 n\\sqrt nn​的素因子，只需要对 n\\sqrt n n​内的素数进行测试即可，也就是预处理求出 n\\sqrt nn​ ​中的素数，假设该范围内素数的个数为 s （ s=nln⁡ns=\\dfrac{n}{\\ln n}s=lnnn​），那么时间复杂度为 O(nln⁡n)O(\\dfrac{n}{\\ln n})O(lnnn​) 4.Miller−Rabin 判定法 对于一个很大的数 n（例如十进制表示有 100 位），如果还是采用试除法进行判定，时间复杂度必定难以承受，目前比较稳定的大素数测试算法是米勒-拉宾（Miller−RabinMiller−Rabin\\tt Miller-RabinMiller−RabinMiller−RabinMiller−Rabin）素数测试算法，该素数测试算法可以通过控制迭代次数来间接控制正确率。 Miller−RabinMiller−Rabin\\tt Miller-RabinMiller−RabinMiller−RabinMiller−Rabin 判定法是基于费马小定理的，即如果一个数 p 为素数的条件是对于所有和 p互素的正整数 a满足以下等式： ap−1≡1 (mod p)a^{p-1}\\equiv 1\\ (\\mod p)ap−1≡1 (modp)。（费马小定理的相关概念定理性质详见本文 0x21.2 费马小定理） 然而我们不可能试遍所有和 p 互素的正整数，这样的话复杂度反而更高，事实上我们只需要取比 p 小的几个素数进行测试就行了。 具体判断 n 是否为素数的算法如下： 如果 n==2 ，返回 true；如果 n&lt;2 || !(n &amp; 1), 返回 false；否则跳到 (2) 。 令 n=m∗(2k)+1n = m *(2 ^ k) + 1n=m∗(2k)+1，其中 m 为奇数，则n−1=m×(2k)n - 1 = m \\times (2 ^ k)n−1=m×(2k) 。 枚举小于 n的素数 p（至多枚举 10个），对每个素数执行费马测试，费马测试如下：计算 pre=pmpre = p ^ m % npre=pm ，如果pre 等于1，则该测试失效，继续回到 3) 测试下一个素数；否则进行 k次计算$ next = pre ^ 2 \\mod n$，如果 next == 1 &amp;&amp; pre != 1 &amp;&amp; pre != n-1 则n必定是合数，直接返回；k次计算结束判断 pre 的值，如果不等于 1，必定是合数。 10次判定完毕，如果 n都没有检测出是合数，那么 n为素数。 时间复杂度为O(klog⁡n)O(k\\log n)O(klogn) 以下为该方法的证明： \\begin{align} x^{k\\times2^e}-1&amp;=(x^{k\\times 2^{e-1}})^2-1\\\\ &amp;=(x^{k\\times 2^{e-1}}+1)\\times(x^{k\\times 2^{e-1}}-1)\\\\ &amp;=(x^{k\\times 2^{e-1}}+1)(x^{k\\times 2^{e-2}}+1)(x^{k\\times 2^{e-2}}-1)\\\\ &amp;=·······\\\\ &amp;=(x^{k\\times 2^{e-1}}+1)······(x^{2k}+1)(x^{k}+1)(x^{k}-1) \\end{align} 如果p是素数，1&lt;=a&lt;=p1&lt;=a&lt;=p1&lt;=a&lt;=p，那么根据费马小定理可以得到：ap−1≡1(mod p)a^{p-1}\\equiv1(\\mod p)ap−1≡1(modp) 设p−1=k×2ep-1= k\\times2^ep−1=k×2e： (ak−1)(ak+1)(a2k+1)(a4k+1)⋅⋅⋅⋅⋅⋅(ak×2e−1)≡0(mod n)(a^k-1)(a^k+1)(a^{2k}+1)(a^{4k}+1)······(a^{k\\times2^{e-1}})\\equiv0(\\mod n)(ak−1)(ak+1)(a2k+1)(a4k+1)⋅⋅⋅⋅⋅⋅(ak×2e−1)≡0(modn) 也就是： ak≡1mod na^k\\equiv1\\mod nak≡1modn 或 ak×2i≡−1mod n(i∈0,...,e−1)a^{k\\times2^i}\\equiv-1\\mod n(i\\in{0,...,e-1})ak×2i≡−1modn(i∈0,...,e−1) 如果要检验nnn是否为素数，我们设n−1=k×2en-1=k\\times2^en−1=k×2e，求出使得 eee 最大的 kkk，接着为我们选择aaa，如果这些式子都不成立，那么当然这个数nnn是合数，否则继续选择aaa。 要判断n是否为素数，对于一定范围内的n，只要以一定范围内a为底就可以保证这是一个确定性算法了。下面详细说明： if n &lt; 1 373 653 a = 2 and 3. if n &lt; 9 080 191 a = 31 and 73. if n &lt; 4 759 123 141 a = 2, 7, and 61. if n &lt; 2 152 302 898 747 a = 2, 3, 5, 7, and 11. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int qmul(int a,int b ,int mod)&#123; a%=mod; b%=mod; int c=(long double)a*b/mod; int ans=a*b-c*mod; return (ans%mod+mod)%mod;&#125;int qpow(int flor,int m,int n)&#123; int ret=1; while(m) &#123; if(m%2==1)ret=qmul(ret,flor,n); flor=qmul(flor,flor,n); m/=2; &#125; return (ret+n)%n;&#125;bool miller_rabbin_one(int n)&#123; if(n==2)return true; if(n&lt;2 || n%2==0)return false; int m=n-1; int k=0; while(m%2==0) &#123; m/=2;k++;&#125; int recordk=k;//记录k的值 vector&lt;int&gt; primes = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23,29,31,37&#125;;//12个质数可以检验long long范围的所有数 for (int inode : primes) &#123; if(n==inode)return true; int pre=qpow(inode,m,n),next=pre; if(pre==1) continue; k=recordk; while(k--) &#123; next=qmul(pre,pre,n); if(next==1 &amp;&amp; pre!=1 &amp;&amp; pre!=n-1)return false; pre=next; &#125; if(pre!=1)return false; &#125; return true;&#125; 0x11.2 素数的筛法 通过上文的学习，我们了解了判断单个数是否为素数的四种常用方法，那么对于一个很大范围内的所有数的素数判定，若我们直接对于每一个数都使用一次素数判定法，如此庞大的时间复杂度我们是无法承担的，因此引入了对于大规模数的素数判定方法：质数筛法。 质数筛法一般分为埃氏筛和线性筛。 埃氏筛没有线性筛时间复杂度好，不常用，但是他的时间复杂度分析方法却比较常用。 埃氏筛法 Eratosthenes 筛法 （埃拉托色尼筛法） 显然如果 x xx 是合数，那么 x xx 的倍数也一定是合数。利用这个结论，我们可以避免很多次不必要的检测。 我们可以从小到大枚举分析每一个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。 12345678910int v[N];void primes(int n&#123; memset(v, 0, sizeof v); for(int i = 2;i &lt;= n; ++ i)&#123; if(v[i])continue; cout &lt;&lt; i &lt;&lt; endl; for(int j = i;j &lt;= n / i; ++ j) v[i * j] = 1; &#125;&#125; 埃氏筛的时间复杂度为O(nlog⁡log⁡n)≈O(n)O(n\\log\\log n)≈O(n)O(nloglogn)≈O(n)这里的⁡$ \\log$以10为底），因为我们这里外层循环 O(n)O ( n )O(n)，内层循环上界为$\\frac{n}{i} ，随着i的增加，， 随着 i 的增加，，随着i的增加，\\frac n i\\in{n,\\frac{n}{2},\\frac{n}{3},\\frac{n}{4},\\frac{n}{5}…,\\frac{n}{n}}$ ，而调和级数 f(n)=1+12+13+14+15…+1n≈loglognf(n) = 1+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}…+\\frac{1}{n}≈loglognf(n)=1+21​+31​+41​+51​…+n1​≈loglogn，所以整体的算法时间复杂度为 O(nlog⁡log⁡n)O(n\\log \\log n)O(nloglogn)。 线性筛法（欧拉筛法） 在欧拉筛我们可以保证每个数一定只会被它的最小质因子筛掉一次。由于 primes 数组中的质数是递增的。我们从小到大枚举 primes 数组，当第一次枚举到一个质数 primes [ j ] 满足primes[j]∣i\\text{primes}[ j ] \\mid iprimes[j]∣i 时， primes[ j ] 一定是 i 的最小质因子，primes[j] 也一定是 i×primes[j]i\\times\\text{primes}[j]i×primes[j] 的最小质因子，而接下来的i×primes[j+1]i\\times \\text{primes}[j+1]i×primes[j+1]的最小质因子应该是 primes [ j ] 而不是` primes [ j + 1 ] ，故此时直接 break 即可。（这解释的太好了吧） 那么对于任意一个合数 x ，假设 x 的最小质因子为 y ，那么当枚举到$\\frac{x}{y}&lt;x $ 的时候一定会把 x 筛掉，即在枚举到 x 之前一定能把合数 x 筛掉，所以一定能把所有的合数都筛掉。 由于 保证每个合数只都被自己的最小质因子筛掉一遍 ，所以时间复杂度是 O ( n ) 的。（注意到筛法求素数的同时也得到了每个数的最小质因子，这是后面筛法求欧拉函数的关键） 12345678910111213141516171819202122vector&lt;int&gt; prime; //记录比i小的所有素数void get_prime(int n)&#123; vector&lt;bool&gt; mark(n+5); //建立一个长度为n+1的动态数组用于标记是否不为素数 //初始化为0，默认全部为素数； mark[1] = 1; // 1不是素数 for (int i = 2; i &lt;= n; i++) &#123; if (mark[i] == 0) prime.push_back(i);//经历了腥风血雨之后依然屹立不倒的是素数 for (auto j : prime)//j遍历prime中元素，即遍历比i小的所有质数 &#123; if (j * i &gt; n)//超出讨论范围，不讨论 break; mark[i * j] = 1; if (i % j == 0)//* break; &#125; &#125; return;&#125; 对代码中*的解释： “最小质因数 j× 最大因数（非自己）：i = 这个合数：i*j” 我们必须保证在内层循环中枚举的每一个prime是合数i*j的最小质因子才行。 那就要保证i质因数分解之后不能有比j小的数字。 我们假设一下如果我们运行到某一个i%j==0的情况不实行break；（比如i=4，j=2） 那么继续运行把i=4,j=3 ，即43的最小质因数必不是3，因为我总能找到2，使得2&lt;3为最小质因数 prime[ij]=12也给标记了，但事实上，12 的最小质因子不是3 而是2，那么到i=6,j=2的时候就会又标记一次，造成浪费 真不行就看链接内容吧：线性筛质数（欧拉筛） 例题：线性筛 复合 埃氏筛：黄题 素数密度 题目描述 给定区间 [L,R][L,R][L,R]（1≤L≤R&lt;2311\\leq L\\leq R &lt; 2^{31}1≤L≤R&lt;231，R−L≤106R-L\\leq 10^6R−L≤106），请计算区间中素数的个数。 输入格式 第一行，两个正整数 LLL 和 RRR。 输出格式 一行，一个整数，表示区间中素数的个数。 样例 #1 样例输入 #1 12 11 样例输出 #1 15 纯纯线性筛会空间溢出：（错误代码） 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;vector&lt;int&gt; prime;signed main()&#123; int L,R;int minn=0,maxn; scanf(&quot;%d %d&quot;,&amp;L,&amp;R); vector&lt;bool&gt; is_prime(R + 1); //是质数为0，否则为1； is_prime[1]=1; for(int i=2;i&lt;=R;i++) &#123; if(is_prime[i]==0)prime.emplace_back(i); for(auto num:prime) &#123; if(num*i&gt;R)break; is_prime[i*num]=1; if(i%num==0)break; &#125; if(i==L-1)minn=prime.size(); &#125; maxn=prime.size(); printf(&quot;%d&quot;,maxn-minn); return 0;&#125; 于是我们经过思考看题解发现：判定L~R区间的是否为质数，只需要线性筛到n\\sqrt{n}n​ 即可在通过埃氏筛法确定L~R的所有素数，于是我们边欧筛边埃筛； 所以筛法的时候我们只要筛[2,R​]就行了 注意1不是质数（不过数据里好像没有） 在得到[2,R\\sqrt{R}R​​]中的质数的时候顺便将[L,R]中的数筛去 离散一下就存的下了 时间复杂度：O(反正极限数据只要0.2s不到) 空间：O(R\\sqrt{R}R​+(R−L))≈O(1e6) 这里转换了算法，本来是用prime数组大小相减得到答案，现在改为用is_prime数组来求： 突破口就在于我们的l和r区间很小，我们就能够最后用循环遍历is_prime数组，以求出总素数数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define int long longusing namespace std;vector&lt;int&gt; prime;signed main()&#123; int L,R; scanf(&quot;%d %d&quot;,&amp;L,&amp;R); if(L==1)L=2;//特判L=1情况 vector&lt;bool&gt; is_prime_of_ltor(R-L+5); vector&lt;bool&gt; is_prime(sqrt(R) + 1); //是质数为0，否则为1； is_prime[1]=1; for(int i=2;i&lt;=sqrt(R);i++) &#123; if(is_prime[i]==0)prime.emplace_back(i); for(auto num:prime) &#123; if(num*i&gt;sqrt(R))break; is_prime[i*num]=1; if(i%num==0)break; &#125;//以下为增加部分 if(is_prime[i]==0) &#123; int j; if(L%i==0)j=L/i; else j=L/i+1; for(;j*i&lt;=R;j++) &#123; if(j*i!=i) is_prime_of_ltor[j*i-L]=1; &#125; &#125;//以上为增加部分 &#125; int ans=0;//以下为修改部分 for(int i=0;i&lt;=R-L;i++)ans+=(1-is_prime_of_ltor[i]); printf(&quot;%d&quot;,ans); return 0;&#125; 0x12 $ Z^ $与 (Zp∗,.)(Z^*_p,^.)(Zp∗​,.)结构* Z∗Z^*Z∗，即正整数集。 (Zp∗,.)(Z^*_p,^.)(Zp∗​,.),ZpZ_pZp​的剩余类群，即(1,2,…,p−1)(1,2, \\dots,p-1)(1,2,…,p−1)，与 p 互素的数，即 U（Zp）U（Z_p）U（Zp​） 0x12.1 唯一分解定理（算数基本定理） 任何一个大于 1的数都可以被分解成有限个质数乘积的形式 ∏i=1mpiCi=p1C1×p2Ci×⋯×PnCn\\prod_{i=1}^{m}p_i^{C^i}=p_1^{C_1}\\times p_2^{C_i}\\times \\cdots \\times P_n^{C_n} i=1∏m​piCi​=p1C1​​×p2Ci​​×⋯×PnCn​​ 其中 $p_1 &lt; p_2 &lt; ··· &lt; p_m 为质数， 为质数，为质数，C_i$为正整数。 显然 n 最多仅有一个大于 n\\sqrt nn​ 的质因子（若有两个的话，他们的乘积就大于n 了）。 试除法 类似埃式筛，我们直接枚举因子然后把当前因子全部除尽即可，时间复杂度O(n)O(\\sqrt n)O(n​) 1234567891011121314int c[N],p[N];void divide(int n) &#123; cnt = 0; for(int i = 2; i * i &lt;= n; ++ i) &#123; if(n % i == 0) &#123; p[ ++ cnt] = i,c[cnt] = 0; while(n % i == 0) n /= i,c[cnt] ++ ; &#125; &#125; if(n &gt; 1)//如果n是质数 p[ ++ cnt] = n,c[cnt] = 1; for(int i = 1;i &lt;= cnt; ++ i) cout &lt;&lt; p[i] &lt;&lt; &quot;^&quot; &lt;&lt; c[i] &lt;&lt; endl;&#125; Pollard Rho 算法：用于寻找某个质因子/最大质因子 对于数据较大的情况，如 n≥1018n ≥ 10^{18}n≥1018，有用来分解其因数的 Pollard Rho\\tt Pollard\\ RhoPollard Rho算法。 Pollard-rho 算法是一个大数分解的随机算法，能够在 O(n14)O(n ^\\frac{1}{4})O(n41​)的时间内找到 n 的一个素因子 p ，然后再递归计算 n’ =$ \\frac{n}{p}$，直到 n 为素数(因此还需要miller-rabbin判断素数or筛法判素)为止，通过这样的方法将 n 进行素因子分解。 Pollard-rho 的策略为：从 [2,n)[2, n)[2,n)中随机选取 k 个数x1、x2、x3、...、xkx_1、x_2、x_3、...、x_kx1​、x2​、x3​、...、xk​，求任意两个数xi、xjx_i、x_jxi​、xj​的差和 n 的最大公约数，即 d=gcd⁡(xi−xj,n)d = \\gcd(x_i - x_j, n)d=gcd(xi​−xj​,n)，如果 1 &lt; d &lt; n，则 d为 n的一个因子，直接返回 d即可。 然后来看如何选取这 k个数，我们采用生成函数法，令 x1=rand()%(n−1)+1x_1= rand()\\%(n-1) + 1x1​=rand()%(n−1)+1，$ x_i = (x_i-1 ^ 2 + 1 ) \\mod n$，很明显，这个序列是有循环节的，如图所示： 我们需要做的就是在它进入循环的时候及时跳出循环，因为x1x_1x1​是随机选的，x1x_1x1​选的不好可能使得这个算法永远都找不到 n 的一个范围在 $( 1 , n ) $的因子，这里采用步进法，保证在进入环的时候直接跳出循环。 基于Floyd算法优化的Pollard Rho 为了判断环的存在,可以用一个简单的Floyd判圈算法,也就是&quot;龟兔赛跑&quot;. 假设乌龟为t,兔子为rrr,初始时t=r=1t=r=1t=r=1.假设兔子的速度是乌龟的一倍. 过了时间i后,t=i,r=2i,t=i,r=2i,t=i,r=2i.此时两者得到的数列值xt​=xi​,xr​=x2i​x_t​=x_i​,x_r​=x_{2i}​xt​​=xi​​,xr​​=x2i​​. 假设环的长度为c,在环内恒有:xi​=xi+c​:x_i​=x_i+c​:xi​​=xi​+c​. 如果龟兔&quot;相遇&quot;,此时有:xr​=xt​x_r​=x_t​xr​​=xt​​,也就是xi​=x2i​=xi+kcx_i​=x_2i​=x_{i+kc}xi​​=x2​i​=xi+kc​​.此时两者路径之差正好是环长度的整数倍。 这样以来,我们得到了一套基于Floyd判圈算法的Pollard Rho 算法. 例题：【模板】Pollard-Rho 题目描述 Miller Rabin 算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。 Pollard rho 是一个非常玄学的方式，用于在 O(n1/4)O(n^{1/4})O(n1/4) 的期望时间复杂度内计算合数 nnn 的某个非平凡因子。事实上算法导论给出的是 O(p)O(\\sqrt p)O(p​)，ppp 是 nnn 的某个最小因子，满足 ppp 与 n/pn/pn/p 互质。但是这些都是期望，未必符合实际。但事实上 Pollard rho 算法在实际环境中运行的相当不错。 这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出 Prime；如果不是质数，输出它最大的质因子是哪个。 输入格式 第一行，TTT 代表数据组数（不大于 350350350） 以下 TTT 行，每行一个整数 nnn，保证 2≤n≤10182 \\le n \\le {10}^{18}2≤n≤1018。 输出格式 输出 TTT 行。 对于每组测试数据输出结果。 样例 #1 样例输入 #1 12345676213134889712345676543211000000000000 样例输出 #1 123456PrimePrime674146495 提示 2018.8.14 新加数据两组，时限加大到 2s，感谢 @whzzt 2022.12.22 加入新的数据，感谢 @ftt2333 和 Library Checker by @will7101 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#define int long longusing namespace std;int ans,T;int qmul(int a,int b ,int mod)&#123; a%=mod; b%=mod; int c=(long double)a*b/mod; int ans=a*b-c*mod; return (ans%mod+mod)%mod;&#125;int qpow(int flor,int m,int n)&#123; int ret=1; while(m) &#123; if(m%2==1)ret=qmul(ret,flor,n); flor=qmul(flor,flor,n); m/=2; &#125; return (ret+n)%n;&#125;bool miller_rabbin_one(int n)&#123; if(n==2)return true; if(n&lt;2 || n%2==0)return false; int m=n-1; int k=0; while(m%2==0) &#123; m/=2;k++;&#125; int recordk=k; vector&lt;int&gt; primes = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23,29,31,37&#125;; for (int inode : primes) &#123; if(n==inode)return true; int pre=qpow(inode,m,n),next=pre; if(pre==1) continue; k=recordk; while(k--) &#123; next=qmul(pre,pre,n); if(next==1 &amp;&amp; pre!=1 &amp;&amp; pre!=n-1)return false; pre=next; &#125; if(pre!=1)return false; &#125; return true;&#125;int f(int x, int c, int n)&#123; return (qmul(x , x ,n)+ c) % n;&#125;int gcd(int x, int y)//卡常时gcd的优化&#123; if (!x) return y; if (!y) return x; int t = __builtin_ctzll(x | y); x &gt;&gt;= __builtin_ctzll(x); do &#123; y &gt;&gt;= __builtin_ctzll(y); if (x &gt; y) swap(x, y); y -= x; &#125; while (y); return x &lt;&lt; t;&#125;int pollard_rho(int N)&#123; if (N %2==0) return 2; if (miller_rabbin_one(N) == true) return N; int t=rand()%(N+1); int c = rand() % (N + 1) ; int tur=t;int rab=t; while (true) &#123; tur = f(tur, c, N); rab = f(f(rab, c, N), c, N); int d = gcd(abs(tur - rab), N); if (d &gt; 1&amp;&amp; d&lt;N) return d; if(tur==rab)return pollard_rho(N); &#125;&#125;void find_max_primeofn(int N)//深度优先搜索求最大质因数&#123; if(N&lt;=1)return; if(miller_rabbin_one(N)) &#123; ans=max(ans,N); return; &#125; int u=pollard_rho(N); find_max_primeofn(u); find_max_primeofn(N/u);&#125;signed main()&#123; srand(time(NULL)); scanf(&quot;%lld&quot;,&amp;T); while(T--) &#123; int N; scanf(&quot;%lld&quot;,&amp;N); if (miller_rabbin_one(N) == true) printf(&quot;Prime\\n&quot;); else &#123; ans=0;find_max_primeofn(N); printf(&quot;%lld\\n&quot;,ans); &#125; &#125; return 0;&#125; 0x12.2 Z ∗ Z^*Z ∗ 结构中的一些定理 推论12.2.1： 若 n=p1α1×p2α2×p3α3×⋯×pkαkm=p1β1×p2β2×p3β3×⋯×pkβkn=p_1^{α_1}\\times p_2^{α_2}\\times p_3^{α_3}\\times \\cdots\\times p_k^{α_k} \\\\m=p_1^{β_1}\\times p_2^{β_2}\\times p_3^{β_3}\\times \\cdots\\times p_k^{β_k} n=p1α1​​×p2α2​​×p3α3​​×⋯×pkαk​​m=p1β1​​×p2β2​​×p3β3​​×⋯×pkβk​​ 则 n×m=p1α1+β1×p2α2+β2×p3α3+β3×⋯×pkαk+βkgcd⁡(n,m)=p1min⁡{α1,β1}×p2min⁡{α1,β1}×⋯×pkmin⁡{αk,βk}lcm(n,m)=p1max⁡{α1,β1}×p2max⁡{α1,β1}×⋯×pkmax⁡{αk,βk}\\begin{array}{l} n\\times m=p_1^{α_1+β_1}\\times p_2^{α_2+β_2}\\times p_3^{α_3+β_3}\\times \\cdots\\times p_k^{α_k+β_k} \\\\\\gcd(n,m)=p_1^{\\min\\{α_1,β_1\\}}\\times p_2^{\\min\\{α_1,β_1\\}}\\times \\cdots\\times p_k^{\\min\\{α_k,β_k\\}} \\\\\\text{lcm}(n,m)=p_1^{\\max\\{α_1,β_1\\}}\\times p_2^{\\max\\{α_1,β_1\\}}\\times \\cdots\\times p_k^{\\max\\{α_k,β_k\\}} \\end{array} n×m=p1α1​+β1​​×p2α2​+β2​​×p3α3​+β3​​×⋯×pkαk​+βk​​gcd(n,m)=p1min{α1​,β1​}​×p2min{α1​,β1​}​×⋯×pkmin{αk​,βk​}​lcm(n,m)=p1max{α1​,β1​}​×p2max{α1​,β1​}​×⋯×pkmax{αk​,βk​}​​ 定理12.2.2：：$ (p-1)!+1 \\equiv0\\ (\\mod p)$ 定理12.2.3： ((n+1)(n+2)...(n+k))%k≠0((n+1)(n+2)...(n+k))\\%k≠0((n+1)(n+2)...(n+k))%k=0 0x12.3(Zp∗,.)(Z^*_p,^.)(Zp∗​,.)结构 定理12.3.1：(Zp∗,.)(Z^*_p,^.)(Zp∗​,.)是循环群，即存在a∈Zp∗a\\in Z^*_pa∈Zp∗​，使得Zp∗={an∣n=1,2,⋯ ,p−1}Z^*_p=\\{ a^n|n=1,2,\\cdots,p-1\\}Zp∗​={an∣n=1,2,⋯,p−1} 这样的 a称为 p 的原根。 素数一定有原根，原根不唯一，部分合数也有原根 1000000007 的原根为5 998244353 的原根为 3 原根详见0x60原根","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/categories/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/categories/%E7%B4%A0%E6%95%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/tags/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"素数判定","slug":"素数判定","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A/"},{"name":"Miller-Rabin素性检验","slug":"Miller-Rabin素性检验","permalink":"https://xqc-1368.github.io/tags/Miller-Rabin%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/"},{"name":"Pollard-Rho","slug":"Pollard-Rho","permalink":"https://xqc-1368.github.io/tags/Pollard-Rho/"},{"name":"埃氏筛法","slug":"埃氏筛法","permalink":"https://xqc-1368.github.io/tags/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/"},{"name":"线性筛法（欧拉筛法）","slug":"线性筛法（欧拉筛法）","permalink":"https://xqc-1368.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%EF%BC%88%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%89/"}]},{"title":"快速乘","slug":"02 快速乘","date":"2024-08-18T12:07:25.626Z","updated":"2024-08-18T11:58:23.778Z","comments":true,"path":"2024/08/18/02 快速乘/","permalink":"https://xqc-1368.github.io/2024/08/18/02%20%E5%BF%AB%E9%80%9F%E4%B9%98/","excerpt":"","text":"02快速乘 因为我们知道乘法有的时候会溢出，即使是 long long 也可能在乘法时因为结果过大溢出（当模数也是 long long ）。所以我们需要寻找一种能高效完成乘法操作并且不会爆 long long 的算法，也就是快速乘。本文也将对几种常用快速乘及其优化技巧做个总结。 1. 复杂度为 O(log) 的快速乘： 我们知道乘法其实就是把很多个加法运算合到一起。现在我们的乘法会爆范围，那我们就把它转化为加法。但是我们不可能一个一个的加，这样复杂度会是 O(n) 级别。所以我们模仿2进制加法操作来完成。 12345678inline ll ksc(ll x,ll y,ll p)&#123;//计算x乘y的积 ll res=0;//加法初始化 while(y)&#123; if(y&amp;1)res=(res+x)%p;//模仿二进制 x=(x&lt;&lt;1)%p; y&gt;&gt;=1;//将x不断乘2达到二进制 &#125;return res;&#125;// ll 表示 long long 当然我们不一定要仿照2进制，也可以是其他进制，只要中间算每一位上数字代表值时不会爆 longlong 就行！ 2. 优秀的 STL 结构：__int128 __int128是c++自带的一个数据类型，顾名思义，它可以装下 2128 2^{128} 2128 级别的大数据，而且可以直接进行各种加减乘除之类的操作（复杂度很接近 O(1) ），不过它需要手写输出（但其实我们只需要在运算时用一下就可以了，就像下面这样：） 1long long ans=((__int128)x*y)%p 不过有一点遗憾的就是：联赛中基本上不会允许使用这个数据类型的 3. 非常优秀的 O(1) 快速乘 这个东西最初我感觉很不靠谱，但它就是能算出来正确答案。它就是用 long double 来进行优化取模运算。让我们先看一代码实现吧： 123456789inline ll ksc(ll x,ll y,ll p)&#123; ll z=(ld)x/p*y; ll res=(ull)x*y-(ull)z*p; return (res+p)%p;&#125;// ll 表示 long long// ld 表示 long double// ull 表示 unsigned long long// 一种自动溢出的数据类型（存满了就会自动变为0） 看到这份代码有没有感到十分奇怪？ 它中间是直接用了乘法操作的啊！这不直接爆掉了吗？ 但是它就是可以算出正确答案来。因为它其实很巧妙的运用了自动溢出这个操作，我们的代码中的 zzz 就表示 ⌊x×y/p⌋⌊x×y/p⌋⌊x×y/p⌋ ，所以我们要求的就变成了 x×y−⌊x×y/p⌋×px×y−⌊x×y/p⌋×px×y−⌊x×y/p⌋×p ，虽然这两个部分都是会溢出的，但（unsigned）保证了它们溢出后的差值基本不变，所以即使它会溢出也不会影响最终结果的！ 4. 关于快速乘的灵活转化： 我们知道快速乘的原理其实就是乘法转加法（上面这种不算），但是这是可以根据题目性质灵活转变的，我们如何转成加法决定了我们的复杂度，就像如果模数并没有超过int范围很多，那我们适当的运用乘法分配律可以让复杂度非常接近 O(1) ： 12345inline ll ksc(ll x, ll y, ll P)&#123; ll L=x*(y&gt;&gt;25)%P*(1&lt;&lt;25)%P; ll R=x*(y&amp;((1&lt;&lt;25)-1))%P; return (L+R)%P;&#125; 在保证运算不会爆long long的前提下，我们可以尽量优化其复杂度，就像上述代码在模数小于 1012 10^{12} 1012 的情况下完全变成了 O(1) 级别，在某些题目中会十分优秀！ 5. 一些经常需要快速乘的算法： Miller rabin 判大质数 Pollard Rho 大数因子寻找 BSGS 大步小步算法","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"快速乘","slug":"快速乘","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/"}]},{"title":"快速幂","slug":"01 快速幂","date":"2024-08-18T12:07:25.620Z","updated":"2024-08-18T11:58:17.845Z","comments":true,"path":"2024/08/18/01 快速幂/","permalink":"https://xqc-1368.github.io/2024/08/18/01%20%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂 快速幂（Exponentiation by squaring，平方求幂）是一种简单而有效的小算法，它可以以O(logn)的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。 让我们先来思考一个问题：7的10次方，怎样算比较快？ 方法1：最朴素的想法，77=49，497=343，… 一步一步算，共进行了9次乘法。 这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。 方法2：先算7的5次方，即77777，再算它的平方，共进行了5次乘法。 但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。 方法3：先算77得49，则7的5次方为4949*7，再算它的平方，共进行了4次乘法。 模仿这样的过程，我们得到一个在O(logn) 时间内计算出幂的算法，也就是快速幂。 递归快速幂 12345678910111213//递归快速幂int qpow(int a, int n)&#123; if (n == 0) return 1; else if (n % 2 == 1) return qpow(a, n - 1) * a; else &#123; int temp = qpow(a, n / 2); return temp * temp; &#125;&#125; 在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是步步取模，如果MOD较大，还应当开long long。 123456789101112131415//递归快速幂（对大素数取模）#define MOD 1000000007typedef long long ll;ll qpow(ll a, ll n)&#123; if (n == 0) return 1; else if (n % 2 == 1) return qpow(a, n - 1) * a % MOD; else &#123; ll temp = qpow(a, n / 2) % MOD; return temp * temp % MOD; &#125;&#125; 非递归快速幂 1234567891011//非递归快速幂int qpow(int a, int n)&#123; int ans = 1; while(n)&#123; if(n&amp;1) //如果n的当前末位为1 ans *= a; //ans乘上当前的a a *= a; //a自乘 n &gt;&gt;= 1; //n往右移一位 &#125; return ans;&#125; 最初ans为1，然后我们一位一位算： 1010的最后一位是0，所以a1这一位不要。然后1010变为101，a变为a2。 101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。 10的最后一位是0，跳过，右移，自乘。 然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。 这里的位运算符，&gt;&gt;是右移，表示把二进制数往右移一位，相当于/2；&amp;是按位与，&amp;1可以理解为取出二进制数的最后一位，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。 以上内容摘自知乎用户Pecco南大计院大佬； 例题： 【模板】快速幂 题目描述 给你三个整数 a,b,pa,b,pa,b,p，求 ab mod pa^b \\bmod pabmodp。 输入格式 输入只有一行三个整数，分别代表 a,b,pa,b,pa,b,p。 输出格式 输出一行一个字符串 a^b mod p=s，其中 a,b,pa,b,pa,b,p 分别为题目给定的值， sss 为运算结果。 样例 #1 样例输入 #1 12 10 9 样例输出 #1 12^10 mod 9=7 提示 样例解释 210=10242^{10} = 1024210=1024，1024 mod 9=71024 \\bmod 9 = 71024mod9=7。 数据规模与约定 对于 100%100\\%100% 的数据，保证 0≤a,b&lt;2310\\le a,b &lt; 2^{31}0≤a,b&lt;231，a+b&gt;0a+b&gt;0a+b&gt;0，2≤p&lt;2312 \\leq p \\lt 2^{31}2≤p&lt;231。 按照上面思路，代码如下： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longsigned main(void)&#123; int a,b,p; int cona,conb; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; cona=a;conb=b; int ans=1; while(b) &#123; if(b&amp;1)ans=(ans*a)%p; a=a*a%p; b&gt;&gt;=1; &#125; printf(&quot;%lld^%lld mod %lld=%lld\\n&quot;,cona,conb,p,ans); return 0;&#125; 例题2：费马小定理和线性算法的应用 【模板】模意义下的乘法逆元 题目背景 这是一道模板题 题目描述 给定 n,pn,pn,p 求 1∼n1\\sim n1∼n 中所有整数在模 ppp 意义下的乘法逆元。 这里 aaa 模 ppp 的乘法逆元定义为 ax≡1(modp)ax\\equiv1\\pmod pax≡1(modp) 的解。 输入格式 一行两个正整数 n,pn,pn,p。 输出格式 输出 nnn 行，第 iii 行表示 iii 在模 ppp 下的乘法逆元。 样例 #1 样例输入 #1 110 13 样例输出 #1 12345678910179108112534 提示 $ 1 \\leq n \\leq 3 \\times 10 ^ 6，，，n &lt; p &lt; 20000528 $。 输入保证 $ p $ 为质数。 一、逆元的概念 单位元 和 逆元，我们在初中和高中的时候其实就已经接触到了，只不过到了大学才系统性的给他们更加官方的命名。接下来，我们首先来了解下什么是单位元，什么是逆元。 1、单位元 【定义1】在一个集合中，对于某种运算 （注意：这里代表通用运算的表示符号，并不是特指乘法），如果对于任何的集合元素 ，和元素 运算，得到还是集合元素 本身，则称 为这个运算下的单位元。 2、逆元 【定义2】在一个集合中，对于某种运算 ，如果任意两个元素的运算结果等于单位元，则称这两个元素互为逆元。 先是费马小定理： 12345678910ll fpm(ll x, ll power, ll mod) &#123; x %= mod; ll ans = 1; for (; power; power &gt;&gt;= 1, (x *= x) %= mod) if(power &amp; 1) (ans *= x) %= mod; return ans;&#125;int main() &#123; ll x = fpm(a, p - 2, p); //x为a在mod p意义下的逆元&#125; 但是，这个做法会tle 于是我们用线代的知识： 123inv[1] = 1;for(int i = 2; i &lt; p; ++ i) inv[i] = (p - p / i) * inv[p % i] % p; 完整代码如下： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longint n_e[20000528]=&#123;0&#125;;signed main(void)&#123; int n,p; n_e[1]=1; cin&gt;&gt;n&gt;&gt;p; cout&lt;&lt;n_e[1]&lt;&lt;&quot;\\n&quot;; for(int i=2;i&lt;=n;i++) &#123; n_e[i]=((p-(p/i))*n_e[p%i])%p; cout&lt;&lt;n_e[i]&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"快速幂","slug":"快速幂","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"差分","slug":"差分","date":"2024-08-18T12:07:25.616Z","updated":"2024-08-18T11:48:39.750Z","comments":true,"path":"2024/08/18/差分/","permalink":"https://xqc-1368.github.io/2024/08/18/%E5%B7%AE%E5%88%86/","excerpt":"","text":"差分算法 1、介绍 一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。 所以差分往往应用于线性的场合，即一维数组的环境，但是除此之外，差分还可以应用于二维数组，但是相比较一维数组，应用的较少。 2、定义 差分可以简单的看成序列中每个元素与其前一个元素的差。 3、差分与前缀和 12345678910111213141516171819202122const int N = 100010;int n; //n数组长度//定义两个一维整形数组 a为原数组，b为差分数组int a[N],b[N]; //根据定义可知b[i] = a[i] - a[i-1];//稍微具体b[1] = a[1];b[2] = a[2] - a[1];b[3] = a[3] - a[2];...b[i] = a[i] - a[i-1];//转化一下，求数组b的前缀和,根据上面公式可得 b[1]+b[2]+b[3]+...+b[i]= a[1]+(a[2]-a[1])+(a[3]-a[2])+...+(a[i]-a[i-1])= a[i]//由此可知，原序列为差分序列的前缀和序列a[i] = b[1]+b[2]+b[3]+...+b[i]; 一般地，我们认为原序列就是差分序列的前缀和，所以把差分看做前缀和的逆运算 二、一维差分 1、定义 一维差分是指给定一个长度为n的序列a，要求支持操作pro(l,r,c)表示对a[l]~a[r]区间上的每一个值都加上或减去常数c，并求修改后的序列a。 2、作用 让一个序列中某个区间内的所有值均加上或减去一个常数。 可以将对a数组任意区间的同一操作优化到O(1)。 12345//区间[l,r]中的所有值都加上常数cb[l] += c;b[r+1] -= c; //想象下： 因为：b[l]=a[l]-a[l-1];，而前面的b[1]b[l-1]都没有发生变化，所以$a[l-1]=b[1]+…+b[l-1]$不变，所以只可能是a[l]加了c。若要使a[l]a[r]区间都加上c，则： 12345b[l+1]=a[l+1]-a[l]......b[r]=a[r]-a[r-1] 这中间所有的b中元素统统不变（被减数和减数同时加了c） 而 b[r+1]=a[r+1]-a[r] 因为要使得a[r]+c，而a[r+1]不变，则有b[r+1]-=c 最后对b数组求前缀和，所以以上程序可以实现在a[l]~a[r]里面同时加上c 12345for(int i = 1; i &lt;= n; i++)&#123; b[i] += b[i-1]; printf(&quot;%d &quot;,b[i]);&#125; 例题： 语文成绩 题目背景 语文考试结束了，成绩还是一如既往地有问题。 题目描述 语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？ 输入格式 第一行有两个整数 n，p，代表学生数与增加分数的次数。 第二行有 n 个数，a_1 \\sim a_n，代表各个学生的初始成绩。 接下来 p 行，每行有三个数，x，y，z，代表给第 x 个到第 y 个学生每人增加 z 分。 输出格式 输出仅一行，代表更改分数后，全班的最低分。 样例 #1 样例输入 #1 12343 21 1 11 2 12 3 1 样例输出 #1 12 提示 对于 40% 的数据，有 n \\le 10^3。 对于 60% 的数据，有 n \\le 10^4。 对于 80% 的数据，有 n \\le 10^5。 对于 100% 的数据，有 n \\le 5\\times 10^6，p \\le n，学生初始成绩 \\le 100，z \\le 100。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"差分","slug":"差分","permalink":"https://xqc-1368.github.io/tags/%E5%B7%AE%E5%88%86/"}]},{"title":"单调栈基础：奶牛排队","slug":"单调栈基础：奶牛排队","date":"2024-08-18T11:46:37.853Z","updated":"2024-08-18T12:19:18.409Z","comments":true,"path":"2024/08/18/单调栈基础：奶牛排队/","permalink":"https://xqc-1368.github.io/2024/08/18/%E5%8D%95%E8%B0%83%E6%A0%88%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%A5%B6%E7%89%9B%E6%8E%92%E9%98%9F/","excerpt":"","text":"单调栈 引入 何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。 为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。 过程 插入 将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。 例如，栈中自顶向下的元素为 0,11,45,81。 插入元素 14时为了保证单调性需要依次弹出元素 0,11，操作后栈变为 !14,45,81。 用伪代码描述如下： 1234insert xwhile !sta.empty() &amp;&amp; sta.top()&lt;x sta.pop()sta.push(x) 实现 1234insert xwhile !sta.empty() &amp;&amp; sta.top()&lt;x sta.pop()sta.push(x) 使用 可以用于从乱序数组某一元素出发，向左可以找到第一个小于他的数，或者第一个大于他的数，向右可以找到第一个小于他，或者大于他的数字（大于等于，小于等于也可以实现），而且能实现对每一个数组中元素，都找到对应的第一个大于他or小于他的数字，由此生成一个新数组。 以下为经典的奶牛排队问题 [USACO09MAR] Look Up S 题目描述 约翰的 N(1≤N≤105)N(1\\le N\\le10^5)N(1≤N≤105) 头奶牛站成一排，奶牛 iii 的身高是 Hi(1≤Hi≤106)H_i(1\\le H_i\\le10^6)Hi​(1≤Hi​≤106)。现在，每只奶牛都在向右看齐。对于奶牛 iii，如果奶牛 jjj 满足 i&lt;ji&lt;ji&lt;j 且 Hi&lt;HjH_i&lt;H_jHi​&lt;Hj​，我们可以说奶牛 iii 可以仰望奶牛 jjj。 求出每只奶牛离她最近的仰望对象。 Input 输入格式 第 111 行输入 NNN，之后每行输入一个身高 HiH_iHi​。 输出格式 共 NNN 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 000。 样例 #1 样例输入 #1 12345676 3 2 6 1 1 2 样例输出 #1 1234563 3 0 6 6 0 提示 【输入说明】666 头奶牛的身高分别为 3,2,6,1,1,2。 【输出说明】奶牛 #1,#2 仰望奶牛 #3，奶牛 #4,#5 仰望奶牛 #6，奶牛 #3 和 #6 没有仰望对象。 【数据规模】 对于 20%20\\%20% 的数据：1≤N≤101\\le N\\le101≤N≤10； 对于 50%50\\%50% 的数据：1≤N≤1031\\le N\\le10^31≤N≤103； 对于 100%100\\%100% 的数据：1≤N≤105,1≤Hi≤1061\\le N\\le10^5,1\\le H_i\\le10^61≤N≤105,1≤Hi​≤106。 用单调栈完成： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef struct &#123; long long number,watch,height;&#125;cow;int main()&#123; int n; stack&lt;cow&gt; st; cin&gt;&gt;n; cow a[n]; for (int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i].height ; a[i].number =i+1; &#125; for (int i=0;i&lt;n;i++) &#123; while(!st.empty() &amp;&amp; st.top().height&lt;a[i].height ) &#123;//奶牛按照身高进入单调栈，栈底小，栈顶大 a[st.top().number-1].watch =a[i].number ;//被pop出单调栈的奶牛意味着他的右侧最近的比他大的奶牛是a【i】可以将他的箭头指向那个元素 st.pop(); &#125; st.push(a[i]); &#125; while(!st.empty() ) &#123; a[st.top().number-1].watch =0; st.pop();//剩下没出栈的奶牛的右边都没有比他高的奶牛了，根据题意，赋值为0； &#125; for (int i=0;i&lt;n;i++) &#123; cout&lt;&lt;a[i].watch &lt;&lt;endl; &#125; return 0;&#125; 注意，这里的关键是我去遍历到a[i]时候，所确定的不是a[i]仰望的奶牛，而是仰望a[i]的奶牛，a[i]是”被看“的奶牛！ 奶牛排队 题目描述 奶牛在熊大妈的带领下排成了一条直队。 显然，不同的奶牛身高不一定相同…… 现在，奶牛们想知道，如果找出一些连续的奶牛，要求最左边的奶牛 AAA 是最矮的，最右边的 BBB 是最高的，且 BBB 高于 AAA 奶牛。中间如果存在奶牛，则身高不能和 A,BA,BA,B 奶牛相同。问这样的奶牛最多会有多少头？ 从左到右给出奶牛的身高，请告诉它们符合条件的最多的奶牛数（答案可能是 0,20,20,2，但不会是 111）。 输入格式 第一行一个正整数 NNN，表示奶牛的头数。 接下来 NNN 行，每行一个正整数，从上到下表示从左到右奶牛的身高 hih_ihi​。 输出格式 一行一个整数，表示最多奶牛数。 样例 #1 样例输入 #1 123456512341 样例输出 #1 14 提示 样例解释 取第 111 头到第 444 头奶牛，满足条件且为最多。 数据范围 对于全部的数据，满足 2≤N≤1052 \\le N \\le 10^52≤N≤105，1≤hi&lt;2311 \\le h_i &lt;2^{31}1≤hi​&lt;231。 题中的“左边最矮”“右边最高”等信息让我们考虑使用单调栈来快速处理。 首先用单调栈处理出每头奶牛左边第一个身高大于等于它的奶牛位置+1的位置（watchlefthigh元素）以及右边第一个身高小于等于它的奶牛位置−1的位置（watchrightlow元素）。为什么呢？这样做，我们就框定了每头奶牛分别作为合题奶牛组的左端点A和右端点B时，剩余的端点B，A可取的范围。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef struct &#123; long long number,watchrightlow,height,watchlefthigh;&#125;cow;int main()&#123; int n,max=0; stack&lt;cow&gt; st; scanf(&quot;%d&quot;,&amp;n); cow a[n]; //输入部分 for (int i=0;i&lt;n;i++) &#123; scanf(&quot;%ld&quot;,&amp;a[i].height); a[i].number =i; &#125; //第一次单调栈 for (int i=0;i&lt;n;i++) &#123; while(!st.empty() &amp;&amp; st.top().height&gt;=a[i].height ) &#123; a[st.top().number].watchrightlow =a[i].number-1 ; st.pop(); &#125; st.push(a[i]); &#125; while(!st.empty() ) &#123; a[st.top().number].watchrightlow =n-1; st.pop(); &#125;//第二次单调栈 for (int i=n-1;i&gt;=0;i--) &#123; while(!st.empty() &amp;&amp; st.top().height&lt;=a[i].height ) &#123; a[st.top().number].watchlefthigh =a[i].number+1 ; st.pop(); &#125; st.push(a[i]); &#125; while(!st.empty() ) &#123; a[st.top().number].watchlefthigh =0; st.pop(); &#125;//检索重合区域 for(int i=n-1;i&gt;=0;i--) &#123; for (int j=i;j&gt;=a[i].watchlefthigh ;j--) &#123; if(a[j].watchrightlow &gt;=i) &#123; max=max&gt;i-j+1?max:i-j+1; &#125; &#125; &#125; if(max==1)max=0;//处理特殊情况（题意） cout&lt;&lt;max&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"算法/数据结构/栈","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://xqc-1368.github.io/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://xqc-1368.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"栈基础：后缀表达式求值","slug":"栈基础：后缀表达式求值","date":"2024-08-18T11:46:37.837Z","updated":"2024-08-18T11:43:07.200Z","comments":true,"path":"2024/08/18/栈基础：后缀表达式求值/","permalink":"https://xqc-1368.github.io/2024/08/18/%E6%A0%88%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/","excerpt":"","text":"后缀表达式 题目描述 所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。 如：3*(5-2)+7\\texttt{3*(5-2)+7}3*(5-2)+7 对应的后缀表达式为：3.5.2.-*7.+@\\texttt{3.5.2.-*7.+@}3.5.2.-*7.+@。在该式中，@ 为表达式的结束符号。. 为操作数的结束符号。 输入格式 输入一行一个字符串 sss，表示后缀表达式。 输出格式 输出一个整数，表示表达式的值。 样例 #1 样例输入 #1 13.5.2.-*7.+@ 样例输出 #1 116 提示 数据保证，1≤∣s∣≤501 \\leq |s| \\leq 501≤∣s∣≤50，答案和计算过程中的每一个值的绝对值不超过 10910^9109。 以下为c++用stl写的代码 123456789101112131415161718192021222324252627int main()&#123; cin&gt;&gt;c; int a=0,b=0; int i,j; for(int k=0;k&lt;c.length();k++) &#123; if(c[k]==&#x27;@&#x27;) break; else if(c[k]==&#x27;.&#x27;)&#123; q.push(a); b=0,a=0; &#125; else if(c[k]&lt;=&#x27;9&#x27;&amp;&amp;c[k]&gt;=&#x27;0&#x27;)&#123; a=b*10+c[k]-&#x27;0&#x27;; b=a; &#125; else&#123; if(c[k]==&#x27;-&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j-i); if(c[k]==&#x27;+&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j+i); if(c[k]==&#x27;*&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j*i); if(c[k]==&#x27;/&#x27;) i=q.top(),q.pop(),j=q.top(),q.pop(), q.push(j/i); &#125; &#125; cout&lt;&lt;q.top()&lt;&lt;endl;&#125; 以下为c语言（掺了一点c++的水，关键部分还是用c语言和cpp共有的函数写的）原始人代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define maxsize 100using namespace std;typedef struct sttack&#123; int st[maxsize]; int top;&#125;stack;stack *init_stack()&#123; stack *st; st = (stack*)malloc(sizeof(stack)); st-&gt;top =-1; return st;&#125;int push(stack *s,int x)&#123; if(s-&gt;top+1&gt;=maxsize ) &#123; return 0; &#125; else &#123; s-&gt;top++; s-&gt;st[s-&gt;top]=x; &#125; return 1;&#125;int pop(stack *s)&#123; long long ret; if(s-&gt;top&lt;=-1)&#123; return 0; &#125; else&#123; ret=s-&gt;st [s-&gt;top ]; s-&gt;top--; &#125; return ret;&#125;void printstack(stack *s)&#123; while((*s).top !=-1)&#123; printf(&quot;%d&quot;,(*s).st [s-&gt;top]); s-&gt;top--; &#125;&#125;int main(void)&#123; stack *st; st = init_stack(); char ch[15],c; int i=0; long long tar,a1,a2; cin&gt;&gt;c; while(c!=&#x27;@&#x27;) &#123; if(c&gt;=&#x27;0&#x27; &amp;&amp; c&lt;=&#x27;9&#x27;) &#123; while(c!=&#x27;.&#x27;) &#123; ch[i]=c; i++; cin&gt;&gt;c; &#125; i=0; tar=atol(ch); push(st,tar); memset(ch,0,sizeof(ch));//memset函数用于清空字符串ch的值 &#125; else if(c==&#x27;+&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a1+a2); &#125; else if(c==&#x27;-&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a2-a1); &#125; else if(c==&#x27;*&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a1*a2); &#125; else if(c==&#x27;/&#x27;) &#123; a1=pop(st); a2=pop(st); push(st,a2/a1); &#125; cin&gt;&gt;c; &#125; cout&lt;&lt;st-&gt;st [st-&gt;top ]&lt;&lt;endl; free(st);return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"算法/数据结构/栈","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://xqc-1368.github.io/tags/%E6%A0%88/"}]},{"title":"03二叉树的节点距离（LCA）+深度标记：二叉树问题","slug":"03二叉树的节点距离（LCA）+深度标记：二叉树问题","date":"2024-08-18T09:06:00.750Z","updated":"2024-08-18T09:40:10.964Z","comments":true,"path":"2024/08/18/03二叉树的节点距离（LCA）+深度标记：二叉树问题/","permalink":"https://xqc-1368.github.io/2024/08/18/03%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%EF%BC%88LCA%EF%BC%89+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"[JLOI2009] 二叉树问题 题目描述 如下图所示的一棵二叉树的深度、宽度及结点间距离分别为： 深度：444 宽度：444 结点 8 和 6 之间的距离：888 结点 7 和 6 之间的距离：333 其中宽度表示二叉树上同一层最多的结点个数，节点 u,vu, vu,v 之间的距离表示从 uuu 到 vvv 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。 给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 x,yx, yx,y 之间的距离。 输入格式 第一行是一个整数，表示树的结点个数 nnn。 接下来 n−1n - 1n−1 行，每行两个整数 u,vu, vu,v，表示树上存在一条连接 u,vu, vu,v 的边。 最后一行有两个整数 x,yx, yx,y，表示求 x,yx, yx,y 之间的距离。 输出格式 输出三行，每行一个整数，依次表示二叉树的深度、宽度和 x,yx, yx,y 之间的距离。 样例 #1 样例输入 #1 123456789101110 1 2 1 3 2 42 53 63 75 85 96 108 6 样例输出 #1 123448 提示 对于全部的测试点，保证 1≤u,v,x,y≤n≤1001 \\leq u, v, x, y \\leq n \\leq 1001≤u,v,x,y≤n≤100，且给出的是一棵树。 相当于分解成三个问题是吧。 1.求最大深度（深度优先搜索算法解决） MY思路 1234567891011121314151617181920void depth(int p)&#123; if(bi[p].lchild !=-1) &#123; dep++; depth(bi[p].lchild); &#125; if(bi[p].rchild !=-1) &#123; dep++; depth(bi[p].rchild); &#125; if(bi[p].lchild ==-1 &amp;&amp; bi[p].rchild ==-1 &amp;&amp; dep&gt;ans1) &#123; ans1=dep; &#125; dep--; return;&#125; dalao思路 1234567struct node&#123; int father; //爸爸 int left; //左儿子 int right; //右儿子 int deep; //深度 int data; //记录节点走过没&#125;a[10001]; 直接在结构体里面定义了一个深度属性 1a[y].deep=a[x].deep+1;//遍历树，后一项深度等于前一项加一 2.最大宽度 my思路(迭代版本 广度优先搜索) 123456789101112131415161718192021222324252627282930void breath()&#123; q.push(bi[1]); int siz=q.size(); for(int j=0;j&lt;ans1-1;j++) &#123; for (int i=0;i&lt;siz;i++) &#123; if(q.front().lchild!=-1) &#123; q.push(bi[q.front().lchild]); &#125; if(q.front().rchild!=-1) &#123; q.push(bi[q.front().rchild]); &#125; q.pop(); if(q.size()&gt;ans2) &#123; ans2=q.size(); &#125; &#125; siz=q.size(); &#125; cout&lt;&lt;ans2&lt;&lt;endl;&#125; dalao思路 直接利用第一题的deep，deep相同的在一个桶数组中加在一起 1234for(int i=1;i&lt;=n;i++) //把每一个深度有多少个节点记录 sum[a[i].deep]++; sort(sum+1,sum+1+100); cout&lt;&lt;maxx&lt;&lt;endl&lt;&lt;sum[100]&lt;&lt;endl&lt;&lt;num+num1; //sum[100]是最大的宽度节点个数 3.路径长度 my思路（深度优先搜索） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void search(int node,int come)//come表示这个节点是怎么被寻找到的（方便回溯） 1：父节点找左子树，2：父节点找右子树3：左子树找父节点4：右子树找父节点 &#123; if(node==node2) &#123; ans3=pathlen; return; &#125; else &#123; if(bi[node].lchild !=-1 &amp;&amp; come!=3) &#123; top++; path[top]=bi[node].lchild; pathlen++; search(bi[node].lchild ,1); &#125; if(bi[node].rchild !=-1 &amp;&amp; come !=4) &#123; top++; path[top]=bi[node].rchild; pathlen++; search(bi[node].rchild ,2); &#125; if(bi[node].father !=-1 &amp;&amp; come!=1&amp;&amp;come!=2) &#123; top++; path[top]=bi[node].father;pathlen+=2; if(bi[bi[node].father].lchild!=-1 &amp;&amp; bi[bi[node].father].lchild==node) &#123; search(bi[node].father ,3); &#125; else if(bi[bi[node].father].rchild!=-1 &amp;&amp; bi[bi[node].father].rchild==node) &#123; search(bi[node].father ,4); &#125; &#125; &#125; if(come==1|| come==2) &#123; pathlen--; &#125; else if(come==3 || come==4)pathlen-=2; top--; return;&#125; dalao思路（lca算法） 普及一下 最近公共祖先 简单引入 对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。 红色的都是是A和B的公共祖先，但只有最近的C才是最近公共祖先。 LCA问题是树上的一个经典问题，在很多方面有着广泛的应用，比如求LCP（最长公共前缀），接下来我们就来介绍他的几种算法。 LCA的算法 暴力枚举法 如果我们要求a和b的最近公共祖先，就沿着父亲的方向把a的所有祖先都标记一下（类似并查集找父亲，但是没有路径压缩），然后在从b开始往上找祖先，碰到第一个被标记的点，就是a和b的最近公共祖先。 C是最近公共祖先。 求一个对点的LCA时间复杂度高达O（N）。 求m个点对的LCA时间复杂度高达O（mN）。 当m和n都高达10万的时候，超时了！！！ 宝宝难以承受！！！！！ 求m个点对的最近公共祖先是可以优化的，一般有两种： 1、离线算法（Tarjan离线算法）：所谓的离线算法指的是把所有问题收集起来以后一起去算，最后一起回答。 2、在线算法（倍增算法）：所谓的在线算法就是来一个点对，处理一个点对。 Tarjan离线算法 Robert Tarjan设计了求解的应用领域的许多问题的广泛有效的算法和数据结构。 他已发表了超过228篇理论文章（包括杂志，一些书中的一些章节文章等）。Robert Tarjan以在数据结构和图论上的开创性工作而闻名。 他的一些著名的算法包括 Tarjan最近共同祖先离线算法 ，Tarjan的强连通分量算法等。其中Hopcroft-Tarjan平面嵌入算法是第一个线性时间平面算法。Tarjan也开创了重要的数据结构如：斐波纳契堆和splay树（splay发明者还有Daniel Sleator）。另一项重大贡献是分析了并查集。他是第一个证明了计算反阿克曼函数的乐观时间复杂度的科学家。（此段来自百度百科，有删改） 简单的介绍一下tarjan算法： tarjan算法是离线算法，它必须先将所有的要查询的点对存起来，然后在搜的时候输出结果。 tarjan算法很经典，因为算法的思想很巧妙，利用了并查集思想，在dfs下，将查询一步一步的搜出来。 基本思路： 下面给出真代码： 123456789101112131415161718192021int f[N],n,m,ans[N],check[N]; vector&lt;int&gt; a[N],b[N],id[N];int find(int x) &#123; return x==f[x] ? x : f[x]=find(f[x]); &#125;void tarjan(int x) &#123; f[x]=x; check[x]=1; for(int i=0; i&lt;a[x].size(); i++) &#123; int v=a[x][i]; if(!check[v]) &#123; tarjan(v); f[v]=x; &#125; &#125; for(int i=0; i&lt;b[x].size(); i++) &#123; int v=b[x][i]; if(!check[v]) continue; ans[id[x][i]]=find(v); &#125;&#125; 我们在深度优先遍历的时候，先遍历x节点的左子树，当遍历到u的时候，发现v没有被遍历过，那么就不去管lca(u,v)这个问题，然后我们把已经遍历的x子树的所有节点都合并到他的父亲（即father指向父亲），然后当我们遍历到v的时候，发现u已经遍历过了，那么此时u在并查集里的father就是u和v的最近公共祖先. 时间复杂度：由于每个点只遍历一次，每个问题只枚举2次，所以时间复杂度是O（N+2Mα(N))。α(N)为并查集查询一次根所需要的时间。 倍增算法 首先一个小问题，给你两个点a和b，你如何快速的回答这两个点在树里面是否具有祖先和后代的关系。 暴力算法又是o（N），明显太浪费时间！ 引入时间戳的概念：所谓的时间戳就是在给一棵树进行深度优先遍历的同时，记录下计入每个点的时候和离开每个点的时间。 如图所示，每个节点的左边是进入的时间，右边是离开的时间。 如果a是b的祖先，只要满足 (in[a]&lt;=in[b]) and (out[b]&lt;=out[a]) 也就是我们只需要一次深搜，接下来对于任何询问a和b是否有祖先关系的时候，我们只要O(1)的时间就能回答这个问题。 建立倍增数组： 定义f[i][j]为与节点i距离为2^j的祖先的编号。 明显的f[i][0]就是每个点直接的父亲。 另有递推关系：f[i][j]=f[f[i][j-1],j-1]。 于是我们只需要在nlogn的时间内就可以求出f数组的值。 如果f[i][j]不存在，我们就令f[i][j]=根，方便我们计算 接下来如何求a和b的最近公共祖先呢？ 1、如果a是b的祖先，那么输出a 2、如果b是a的祖先，那么输出b 3、for i:=20 downto 0 do if f[a][i]不是b的祖先，那么令 a=f[a][i]; 循环结束的时候，f[a][0]就是最近公共祖先。 12345678int lca(int x,int y) &#123; if(ancestor(x,y)) return x; if(ancestor(y,x)) return y; for(int i=20; i&gt;=0; i--) if(!ancestor(f[x][i],y)) x=f[x][i]; return f[x][0]; &#125; 1234567891011int lca(int x,int y)&#123; //最最重要！！！求最近公共祖先 a[x].data=1; //把x的节点记录已走过 while(a[x].father!=0)&#123; //遍历至根节点 x=a[x].father; //更新遍历爸爸 a[x].data=1; //记录已走过 &#125; while(a[y].data!=1)&#123; //遍历至x节点已走过的节点，找到最近公共祖先 y=a[y].father; &#125; return y;&#125; 上面最后一个代码是实现本题目的代码哦 完结！","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://xqc-1368.github.io/tags/BFS/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"},{"name":"树上距离","slug":"树上距离","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E8%B7%9D%E7%A6%BB/"}]},{"title":"03 最近公共祖先（LCA）：倍增解法","slug":"03 最近公共祖先（LCA）：倍增解法","date":"2024-08-18T09:06:00.743Z","updated":"2024-08-18T09:39:55.993Z","comments":true,"path":"2024/08/18/03 最近公共祖先（LCA）：倍增解法/","permalink":"https://xqc-1368.github.io/2024/08/18/03%20%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89%EF%BC%9A%E5%80%8D%E5%A2%9E%E8%A7%A3%E6%B3%95/","excerpt":"","text":"最近公共祖先（LCA）问题——倍增解法 【模板】最近公共祖先（LCA） 题目描述 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 输入格式 第一行包含三个正整数 N,M,SN,M,SN,M,S，分别表示树的结点个数、询问的个数和树根结点的序号。 接下来 N−1N-1N−1 行每行包含两个正整数 x,yx, yx,y，表示 xxx 结点和 yyy 结点之间有一条直接连接的边（数据保证可以构成树）。 接下来 MMM 行每行包含两个正整数 a,ba, ba,b，表示询问 aaa 结点和 bbb 结点的最近公共祖先。 输出格式 输出包含 MMM 行，每行包含一个正整数，依次为每一个询问的结果。 样例 #1 样例输入 #1 123456789105 5 43 12 45 11 42 43 23 51 24 5 样例输出 #1 1234544144 提示 对于 30%30\\%30% 的数据，N≤10N\\leq 10N≤10，M≤10M\\leq 10M≤10。 对于 70%70\\%70% 的数据，N≤10000N\\leq 10000N≤10000，M≤10000M\\leq 10000M≤10000。 对于 100%100\\%100% 的数据，1≤N,M≤5000001 \\leq N,M\\leq 5000001≤N,M≤500000，1≤x,y,a,b≤N1 \\leq x, y,a ,b \\leq N1≤x,y,a,b≤N，不保证 a≠ba \\neq ba=b。 样例说明： 该树结构如下： 第一次询问：2,42, 42,4 的最近公共祖先，故为 444。 第二次询问：3,23, 23,2 的最近公共祖先，故为 444。 第三次询问：3,53, 53,5 的最近公共祖先，故为 111。 第四次询问：1,21, 21,2 的最近公共祖先，故为 444。 第五次询问：4,54, 54,5 的最近公共祖先，故为 444。 故输出依次为 4,4,1,4,44, 4, 1, 4, 44,4,1,4,4。 倍增算法求LCA 第一步：预处理对数表数组 如果我们预处理一个数组，规定：lg2[i]表示log_2^i+1（别问为什么加一，不然不方便在O(n)的时间内求出，用到的时候-1即可） 使得：对数可以查表获得，则大大方便： 1234for(int i=1;i&lt;=n;i++)//deal array:lg2[i]+1 &#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i); &#125; 处理方法自己推： 1234lg2[1]:1 lg2[2]:2 lg2[3]:2 lg2[4]:3 lg2[5]:3 lg2[6]:3 lg2[7]:3 lg2[8]:4 lg2[9]:4 lg2[10]:4lg2[11]:4 lg2[12]:4 lg2[13]:4 lg2[14]:4 lg2[15]:4lg2[16]:5 lg2[17]:5 lg2[18]:5 lg2[19]:5 lg2[20]:5 解释如下：（ai生成，有删改） 这段代码定义了一个名为lg2的数组,用于计算以2为底的对数+1。具体来说,lg2[i]表示数字i的以2为底的对数+1的值。 在循环中,首先将lg2[0]赋值为0。然后,对于每个i(从1到n),将lg2[i]的值设置为lg2[i-1]+(1&lt;&lt;lg2[i-1]==i)。 这个循环的目的是计算2的整数次幂在lg2数组中的对应位置。具体来说,(1&lt;&lt;lg2[i-1])表示2的i-1次方,==i表示i是2的i-1次方的整数次幂。如果i是2的i-1次方的整数次幂,那么(1&lt;&lt;lg2[i-1])==i,否则(1&lt;&lt;lg2[i-1])!=i。因此,(1&lt;&lt;lg2[i-1]==i)的值为1或0,可以用来判断i是否是2的i-1次方的整数次幂。 最后,lg2[i]表示数字i的以2为底的对数+1,即log_2(i)+1。 第二步：通过一次dfs，预处理找2的i次方祖先数组fa和深度数组depth，后面会有用 123456789101112131415161718192021void predfs(int nowpoint,int father=0)&#123;//每递归到一个节点nowpoint,就完成nowpoint节点的depth[nowpoint]和//nowpoint的最高能跳到的2的i次方级祖先的编纂 depth[nowpoint]=depth[father]+1;//nowpoint的深度比其父的深度大1 fa[nowpoint][0]=father;//nowpoint的2的0次方级祖先，即nowpoint的1级祖先为父亲节点 for(int i=1;i&lt;=lg2[depth[nowpoint]];i++) &#123;//这个循环跑遍了nowpoint能大跃进到的每一个祖先节点的可能性 fa[nowpoint][i]=fa[fa[nowpoint][i-1]][i-1]; //意思是now的2^i祖先等于now的2^(i-1)祖先的2^(i-1)祖先//例如：nowpoint的4级祖先等于nowpoint的2级祖先的2级祖先 &#125; for(auto ip :ipoint[nowpoint] ) &#123;//遍历nowpoint的子节点，继续编纂 if(ip!=father) &#123; predfs(ip,nowpoint); &#125; &#125;&#125; 第三步，理解LCA算法： 以下开始正式说明：倍增算法 原理视频：https://www.bilibili.com/video/BV1nE411L7rz?vd_source=c6cac99ae3e57c727ad51765bee0a508 所谓倍增，就是按2的倍数来增大，也就是跳 1,2,4,8,16,32 …… 不过在这我们不是按从小到大跳，而是从大向小跳，即按……32,16,8,4,2,1来跳，如果大的跳不过去，再把它调小。这是因为从小开始跳，可能会出现“悔棋”的现象。拿 5 为例，从小向大跳，5=1+2+4,所以我们还要回溯一步，然后才能得出5=1+4；而从大向小跳，直接可以得出5=4+1。 如图：节点19的深度depth[19]=13，节点2的深度depth[2]=2 （如果认为0号节点深度为0的话） 则18号节点称为19号节点的1级祖先，即为202^020级祖先 同理：17号节点称为19号节点的2级祖先，即为212^121级祖先 同理：15号节点称为19号节点的4级祖先，即为222^222级祖先 同理：11号节点称为19号节点的8级祖先，即为232^323级祖先 所以如果有这样一种可能，一次性跳到 2…32,16,8,4,2,12^{…32,16,8,4,2,1}2…32,16,8,4,2,1 级祖先，则加快效率 一：使得蓝色箭头经过：先跳越232^323次（3这个数字通过：floor(log2depth[19]−depth[2])floor(log_2^{depth[19]-depth[2]})floor(log2depth[19]−depth[2]​)得到，本来理想状况下跳跃depth[19]-depth[2]=13-2=11个节点，由于要用2的……4，3，2，1次方去逼近最终取等depth[19]-depth[2]这个差值） 二：此时蓝色箭头已经跳跃到了11号点，再跳跃2floor(log2depth[11]−depth[2])2^{floor(log_2^{depth[11]-depth[2]})}2floor(log2depth[11]−depth[2]​) 个点，即212^121=2个点，同理，再跳202^020=1个点，到3号点。于是此时：箭头与2就处于相同深度（如下图所示） 特判：此时，箭头与2就处于相同深度，如果此时，箭头恰好指向2号节点，即证明19号节点为2号节点的子节点，所以LCA为2号节点，直接返回2号节点作为结果 如果以上特判不成立： 三：下面开始做尝试，让两个端点（2，3节点）同时向上跳跃，优先尝试跳跃212^121（因为最多也只能向上跳这么多）再尝试跳跃202^020 个，再尝试不跳越。看何时有跳跃后节点不重合情况（因为如下图：0号点和1号点都是2，3点的Common Ancester，所以重合并不能作为判断条件，而是应该寻找非重合的深度最浅的两点（在下图中不用跳即可到达这两点，即这两点恰好为2，3），让2，3处的箭头跳到这两个点，即有：这两个新确定的点的公共父节点为LCA） 12345678910111213141516171819202122232425int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) &#123; swap(x,y); &#125;//以上特判，用数学语言来说就是：不妨设x的深度 &gt;= y的深度 while(depth[x]&gt;depth[y]) &#123; x=fa[x][lg2[depth[x]-depth[y]]-1]; &#125; //先跳到同一深度 if(x==y)return x;//如果x是y的祖先，那他们的LCA肯定就是x了 else &#123; for(int i=lg2[depth[x]]-1;i&gt;=0;--i)//不断向上跳（lg就是之前说的常数优化） &#123; if(fa[x][i]!=fa[y][i]) &#123; //因为我们要跳到它们LCA的下面一层，所以它们肯定不相等，如果不相等就跳过去。 x=fa[x][i]; y=fa[y][i]; &#125; &#125; &#125; return fa[x][0];//返回父节点&#125; 完整代码（100unaccepted） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;vector&gt;#define int long longusing namespace std;const int N=5e5+5;vector&lt;int&gt; ipoint[N];int u,a[N]=&#123;0&#125;;int lg2[N]=&#123;0&#125;,depth[N],father[N][22];void dfs(int nowpoint,int fa=0)&#123; depth[nowpoint]=depth[fa]+1; father[nowpoint][0]=fa; for(int i=1;i&lt;=lg2[depth[nowpoint]]-1;i++) &#123; father[nowpoint][i]=father[father[nowpoint][i-1]][i-1]; &#125; for(auto ip:ipoint[nowpoint]) &#123; if(ip!=fa) dfs(ip,nowpoint); &#125; return;&#125;int LCA(int x, int y)&#123; if(depth[x]&lt;depth[y]) &#123; swap(x,y); &#125; while(depth[x]&gt;depth[y]) &#123; x=father[x][lg2[depth[x]-depth[y]]-1]; &#125; if(x==y)return x; for(int i=lg2[depth[x]]-1;i&gt;=0;i--) &#123; if(father[x][i]!=father[y][i]) &#123; x=father[x][i]; y=father[y][i]; &#125; &#125; return father[x][0];&#125;signed main(void)&#123; int n,m,s,edge1,edge2; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++)//deal array:lg2[i]+1 &#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i); &#125; for(int i=1;i&lt;=n-1;i++) &#123; scanf(&quot;%d %d&quot;, &amp;edge1, &amp;edge2); ipoint[edge1].emplace_back(edge2); ipoint[edge2].emplace_back(edge1); &#125; dfs(s); while(m--) &#123; scanf(&quot;%d %d&quot;,&amp;edge1,&amp;edge2); cout&lt;&lt;LCA(edge1,edge2)&lt;&lt;endl; &#125; return 0;&#125; LCA解决：树上两点距离公式 lca处理树上任意两点间距离，即：dis[a]+dis[b]-2*dis[lca(a,b)] LCA解决：树上路径相交问题 例题如下： 仓鼠找 sugar 题目描述 小仓鼠的和他的基（mei）友（zi）sugar 住在地下洞穴中，每个节点的编号为 1∼n1\\sim n1∼n。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（aaa）到餐厅（bbb），而他的基友同时要从他的卧室（ccc）到图书馆（ddd）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？ 小仓鼠那么弱，还要天天被 zzq 大爷虐，请你快来救救他吧！ 输入格式 第一行两个正整数 nnn 和 qqq，表示这棵树节点的个数和询问的个数。 接下来 n−1n-1n−1 行，每行两个正整数 uuu 和 vvv，表示节点 uuu 到节点 vvv 之间有一条边。 接下来 qqq 行，每行四个正整数 aaa、bbb、ccc 和 ddd，表示节点编号，也就是一次询问，其意义如上。 输出格式 对于每个询问，如果有公共点，输出大写字母 Y；否则输出N。 样例 #1 样例输入 #1 123456789105 52 54 21 31 45 1 5 12 2 1 44 1 3 43 1 1 53 5 1 4 样例输出 #1 12345YNYYY 提示 本题时限 1s，内存限制 128M，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。 20%20\\%20% 的数据 n,q≤200n, q\\le200n,q≤200。 40%40\\%40% 的数据 n,q≤2×103n, q\\le 2\\times10^3n,q≤2×103。 70%70\\%70% 的数据 n,q≤5×104n, q\\le 5\\times10^4n,q≤5×104。 100%100\\%100% 的数据 1≤n,q≤1051\\le n, q\\le10^51≤n,q≤105。 先上结论： 如果两条路径相交，那么一定有一条路径的LCA在另一条路径上 而判断一个节点x，是否在路径s-t上需要满足如下几个条件 123- 条件一：deep[x]&gt;=deep[LCA(s,t)]- 条件二：LCA(s,x)=x或LCA(t,x)=x; 判断条件一：（以下一大段内容可以缩写为：不妨设depth[x]&gt;=depth[y]） 只需讨论两种情况： 假设要求算a-b和c-d两条路径是否相交，设： x=LCA(a,b); y=LCA(c,d); 则先比较：depth[x]和depth[y]的大小，如果depth[x]&gt;=depth[y]不做处理，如果depth[x]&lt;depth[y]则对应的交换x与y，a与c，b与d， 使得现在的x,a,b,这一组数有depth[x]&gt;depth[y] 然后再判断条件二是否成立即可； 样例代码（LCA部分和DFS部分不变，主程序如下） 12345678910111213141516171819202122232425262728293031323334353637int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin.tie(0); int n,q,v,u; cin&gt;&gt;n&gt;&gt;q; lg[0]=0; for(int i=1;i&lt;=n;i++) &#123; lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); &#125; for(int i=1;i&lt;=n-1;i++) &#123; cin&gt;&gt;u&gt;&gt;v; ipoint[u].emplace_back(v); ipoint[v].emplace_back(u); &#125; dfs(1); int a,b,c,d; for(int i=1;i&lt;=q;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; int x=LCA(a,b); int y=LCA(c,d); if(depth[x]&lt;depth[y]) &#123; swap(x,y); swap(a,c); swap(b,d); &#125; if(LCA(c,x)==x || LCA(d,x)==x) printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"}]},{"title":"02顺序二叉树+深度标记：二叉树深度","slug":"02顺序二叉树+深度标记：二叉树深度","date":"2024-08-18T09:06:00.734Z","updated":"2024-08-18T09:38:53.374Z","comments":true,"path":"2024/08/18/02顺序二叉树+深度标记：二叉树深度/","permalink":"https://xqc-1368.github.io/2024/08/18/02%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E6%B7%B1%E5%BA%A6%E6%A0%87%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"【深基16.例3】二叉树深度 题目描述 有一个 n(n≤106)n(n \\le 10^6)n(n≤106) 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 nnn），建立一棵二叉树（根节点的编号为 111），如果是叶子结点，则输入 0 0。 建好这棵二叉树之后，请求出它的深度。二叉树的深度是指从根节点到叶子结点时，最多经过了几层。 输入格式 第一行一个整数 nnn，表示结点数。 之后 nnn 行，第 iii 行两个整数 lll、rrr，分别表示结点 iii 的左右子结点编号。若 l=0l=0l=0 则表示无左子结点，r=0r=0r=0 同理。 输出格式 一个整数，表示最大结点深度。 样例 #1 样例输入 #1 1234567872 73 64 50 00 00 00 0 样例输出 #1 14 本蒟蒻的小记 这道题的步骤划分为两个： 第一步：根据要求建树，对于这种1-7元素都有的这种树，除了传统的顺序存储，和传统的链式存储，还可以用数组顺序存储链式存储混合存储（即数组中的每个元素都是一个结构体，都有leftchild和rightchild的下标，通过下表实现“指向”的概念） 第二步：广度优先搜索算法：这个比较简单直接看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;queue&gt;#define max_size 1000005using namespace std;typedef struct bit&#123; long long depth=1; long long number; long long lchild; long long rchild;&#125;bitree;bitree bi[max_size];//树的数组是全局变量queue&lt;bitree&gt; q;//广搜需要队列long long bfs()//广度优先搜索算法部分&#123; q.push(bi[1]); long long max=0; while(!q.empty()) &#123; if(q.front().lchild!=-1) &#123; bi[q.front().lchild].depth =q.front().depth+1; q.push(bi[q.front().lchild]); &#125; if(q.front().rchild!=-1) &#123; bi[q.front().rchild].depth =q.front().depth+1; q.push(bi[q.front().rchild]); &#125; if(q.front().lchild==-1 &amp;&amp; q.front().rchild==-1 &amp;&amp; q.front().depth&gt;max) &#123; max=q.front().depth; &#125; q.pop(); &#125; return max;&#125;int main()&#123; long long n,lch,rch,ans; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)//这个循环实现了建树功能 &#123; cin&gt;&gt;lch&gt;&gt;rch; bi[i].number =i; bi[i].lchild =lch==0?-1:lch; bi[i].rchild =rch==0?-1:rch; &#125; ans=bfs(); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 完结撒花","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"树的深度","slug":"树的深度","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"},{"name":"BFS","slug":"BFS","permalink":"https://xqc-1368.github.io/tags/BFS/"}]},{"title":"02 树的直径问题","slug":"02 树的直径问题","date":"2024-08-18T09:06:00.724Z","updated":"2024-08-18T09:37:52.249Z","comments":true,"path":"2024/08/18/02 树的直径问题/","permalink":"https://xqc-1368.github.io/2024/08/18/02%20%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"02 树的直径问题 做法 1. 两次 DFS 首先从任意节点 y开始进行第一次 DFS，到达距离其最远的节点，记为z，然后再从 z开始做第二次 DFS，到达距离 z最远的节点，记为 z’，则z~z’即为树的直径。 缺陷：不能处理负权边 以下代码来自OIWIKI 1234567891011121314151617181920212223242526const int N = 10000 + 10;int n, c, d[N];vector&lt;int&gt; E[N];void dfs(int u, int fa) &#123; for (int v : E[u]) &#123; if (v == fa) continue; d[v] = d[u] + 1; if (d[v] &gt; d[c]) c = v; dfs(v, u); &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); E[u].push_back(v), E[v].push_back(u); &#125; dfs(1, 0); d[c] = 0, dfs(c, 0); printf(&quot;%d\\n&quot;, d[c]); return 0;&#125; 做法2：树形dp 1234567/ /树形dp结构伪代码描述void dfs(节点u)&#123; for()&#123; / /循环访问所有u的子节点 dfs(u的子节点); 用u的子节点信息更新节点u的信息; &#125;&#125; 二.用树形dp求树的直径： 既然是树形动态规划，我们就尝试用上面树形dp的框架来解决问题。 1.首先，要确定维护的信息是什么？ 假设当前父节点是u ,u的所有儿子节点为 v1,...,vnv_{1},...,v_{n}v1​,...,vn​,那么这个信息必然要满足“只要知道了儿子节点 v1,...,vnv_{1},...,v_{n}v1​,...,vn​ 的该信息，就能确定 u 的该信息”。由于最终要求树上最远两个节点的距离，不妨做这样的定义：设d[x]为节点x到其子孙节点的最大距离、设f[x]为以x为根结点的一条最长路径的距离。即要维护的信息就是d[]，f[]。 2.如何维护上述信息？ (1) 假设当前遍历到的节点是u，u的子节点是v_{1},…,v_{n}，对应的边权是w_1,…,w_n.依据树形dp的“后序”思想，继续假设已经求得了u的所有子节点v_{1},…,v_{n}到其子孙节点的最大距离 d[v_{1}],…,d[v_n] 。已知信息画成下图，其中红色箭头所示的边为虚拟的边，也可看成是一条路径。 (2) 根据已知信息求d[u]:若边权都是正值,则d[u]=max(d[v_1]+w_{1},d[v_2]+w_{2},…,d[ v_n]+w_n)，若存在负的权值，则d[u]=max(0,w_1,d[v_1]+w_{1},w_2,d[v_2]+w_{2},…,w_n,d[v_n]+w_n)，可见d[u]&gt;=0。 (3)确定f[u]的值：若边权都是正值，则f[u]=(d[ v_x]+w_x)+(d[ v_y]+ w_y ),其中(d[ v_x]+ w_x)和(d[ v_y]+w_y)分别是u能到达子孙节点的最远距离和次远距离。即f[u]=d[u]+(d[ v_y]+w_y)。 以上过程仅为原理解释，不作为下属程序参数和具体做法 真正的过程： 我们记录当 111 为树的根时，每个节点作为子树的根向下，所能延伸的最长路径长度 d1 d_1 d1​与次长路径（与最长路径无公共边）长度 d2 d_2 d2​，那么直径就是对于每一个点，该点 d1+d2d_1+d_2d1​+d2​ 能取到的值中的最大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;vector&gt;#define int long longusing namespace std;class edge&#123; public: int point; int weight; edge(int po,int wei):point(po),weight(wei)&#123;&#125;&#125;;const int N=5e5+1;vector&lt;edge&gt;ipoint[N];int d1[N],d2[N],ans=0;int n,u,v,w;void dfs(int nowpoint,int fa=0)&#123; d1[nowpoint]=d2[nowpoint]=0; for(edge ip : ipoint[nowpoint]) &#123; if(ip.point!=fa) &#123; dfs(ip.point,nowpoint); int tempd=d1[ip.point]+ip.weight; if(tempd&gt;d1[nowpoint]) &#123; d2[nowpoint]=d1[nowpoint]; d1[nowpoint]=tempd; &#125; else if(tempd&gt;d2[nowpoint]) &#123; d2[nowpoint]=tempd; &#125; &#125; &#125; ans=max(ans,d1[nowpoint]+d2[nowpoint]);&#125;signed main(void)&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; ipoint[u].emplace_back(edge(v,w)); ipoint[v].emplace_back(edge(u,w)); &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 如果需要求出一条直径上所有的节点，则可以在 DP 的过程中，记录下每个节点能向下延伸的最长路径与次长路径（定义同上）所对应的子节点，在求 ans 的同时记下对应的nowpoint 节点 ，使得 ans=d1[nowpoint]+d2[nowpoint]ans=d_1[nowpoint]+d_2[nowpoint]ans=d1​[nowpoint]+d2​[nowpoint]，即可分别沿着从 nowpoint 开始的最长路径的次长路径对应的子节点一路向某个方向（对于无根树，虽然这里指定了 1为树的根，但仍需记录每点跳转的方向；对于有根树，一路向上跳即可），遍历直径上所有的节点。 OIWIKI版本代码： 1234567891011121314151617181920212223242526const int N = 10000 + 10;int n, c, d[N];vector&lt;int&gt; E[N];void dfs(int u, int fa) &#123; for (int v : E[u]) &#123; if (v == fa) continue; d[v] = d[u] + 1; if (d[v] &gt; d[c]) c = v; dfs(v, u); &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); E[u].push_back(v), E[v].push_back(u); &#125; dfs(1, 0); d[c] = 0, dfs(c, 0); printf(&quot;%d\\n&quot;, d[c]); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"树形dp","slug":"树形dp","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"树的直径","slug":"树的直径","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"}]},{"title":"01树的重心 and 换根dp","slug":"01树的重心 and 换根dp","date":"2024-08-18T09:06:00.705Z","updated":"2024-08-18T09:37:21.513Z","comments":true,"path":"2024/08/18/01树的重心 and 换根dp/","permalink":"https://xqc-1368.github.io/2024/08/18/01%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%20and%20%E6%8D%A2%E6%A0%B9dp/","excerpt":"","text":"无根树——树的重心问题 在后文中，我将用 mss（maximum subtree size）表示最大子树大小。用 sizeu(v) size_u(v) sizeu​(v)表示以u为根节点时包含v的子树的大小。 此外，我们设整棵树大小为n。 1. 定义 如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。 2. 引理 引理1：例如，设 u 和 v 相邻，则 sizeu(v)+sizev(u)=nsize_u(v)+size_v(u)=nsizeu​(v)+sizev​(u)=n。因为树上任意节点 w 要么在以 u 为根 v 所在的子树上，此时有 w=v 或有 w 与 v 进而与 u 连通；要么在以 v 为根 u 所在的子树上，此时此时有 w=u 或有 w 与 u 进而与 v 连通 。 引理2：设u，v, w 连通，则sizeu(v)&gt;sizev(w)size_u(v) &gt; size_v(w)sizeu​(v)&gt;sizev​(w) 。 3. 性质 性质1: 某个点是树的重心等价于它最大子树大小不大于整棵树大小的一半。 性质2: 树至多有两个重心。如果树有两个重心，那么它们相邻。此时树一定有偶数个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。 性质3：树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。 性质4：往树上增加或减少一个叶子，如果原节点数是奇数，那么重心可能增加一个，原重心仍是重心；如果原节点数是偶数，重心可能减少一个，另一个重心仍是重心。 性质5：把两棵树通过一条边相连得到一棵新的树，则新的重心在较大的一棵树一侧的连接点与原重心之间的简单路径上。如果两棵树大小一样，则重心就是两个连接点。 找重心 利用性质1，一趟dfs即可。 123456789101112131415int n, sz[MAXN], mss[MAXN]; // n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小vector&lt;int&gt; ctr; // 重心void dfs(int p, int fa = 0) // 找重心&#123; sz[p] = 1, mss[p] = 0; for (auto [to, w] : edges[p]) if (to != fa) &#123; dfs(to, p); mss[p] = max(mss[p], sz[to]); sz[p] += sz[to]; &#125; mss[p] = max(mss[p], n - sz[p]); if (mss[p] &lt;= n / 2) ctr.push_back(p);&#125; 变式例题：同时需要统计计算距离的情况——使用换根dp 洛谷 P1395 会议 题目描述 有一个村庄居住着 nnn 个村民，有 n−1n-1n−1 条路径使得这 nnn 个村民的家联通，每条路径的长度都为 111。现在村长希望在某个村民家中召开一场会议，村长希望所有村民到会议地点的距离之和最小，那么村长应该要把会议地点设置在哪个村民的家中，并且这个距离总和最小是多少？若有多个节点都满足条件，则选择节点编号最小的那个点。 输入格式 第一行，一个数 nnn，表示有 nnn 个村民。 接下来 n−1n-1n−1 行，每行两个数字 aaa 和 bbb，表示村民 aaa 的家和村民 bbb 的家之间存在一条路径。 输出格式 一行输出两个数字 xxx 和 yyy。 xxx 表示村长将会在哪个村民家中举办会议。 yyy 表示距离之和的最小值。 样例 #1 样例输入 #1 123441 2 2 3 3 4 样例输出 #1 12 4 提示 数据范围 对于 70%70\\%70% 数据 n≤103n \\le 10^3n≤103。 对于 100%100\\%100% 数据 n≤5×104n \\le 5 \\times 10^4n≤5×104。 这一题知道思路后还是非常好理解的 我们为了使这棵树有一个确定的顺序,可以先定1为根(从1开始遍历,假如从i点走向j点就记i为j的父亲) 我们定义d[i]为所有点到i点的距离和,ct[i]为i点的子树的所有节点数 对于这一题,我们可以从点1开始找最佳点,所以我们可以先求d[1]的值,求d[1]时顺便还可以求出所有ct[i]的值,然后我们再考虑怎么求其他的d[i] 我们先看一张图 我们首先知道d[1]=16,我们来看d[2]应该怎么求,我们发现相对于d[1]来说,如果设2为最佳点,2,5,6其距离-1,剩下的1,4,3,7,8,9,10到其距离+1, 所以d[2]=d[1]+3×(−1)+7×1=20 我们发现3为2的子树加自己的节点数,即ct[2]+1,7则为其他点的数量,即n−(ct[2]+1), 再试着举几个例子,不难发现,如果y为x的子树: 则,d[y]=d[x]+(ct[y]+1)×(−1)+(n−(ct[y]+1))×1 所以我们直接从1开始遍历,然后一个个算,最后再求最小值就可以了 由此我们可以看出换根DP的套路： 1，指定某个节点为根节点。 2，第一次搜索完成预处理（如子树大小等），同时得到该节点的解。 3，第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。 根据以上想法，也即是先利用深搜求出d [1]，继而用递推公式求出d[ n ]： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N=5e4+5;vector &lt;int&gt; g[N];int sum=0;int v[N]=&#123;0&#125;;int n,d[N]=&#123;0&#125;,ct[N]=&#123;0&#125;;void dfs(int nowpoint,int dis,int fa=0)&#123; for(auto ip :g[nowpoint]) &#123; if(ip!=fa) &#123; dfs(ip,dis+1,nowpoint); ct[nowpoint]+=ct[ip]+1; &#125; &#125; d[1]+=dis; return;&#125;void calculate(int x,int fa=0)&#123; for(auto ip: g[x]) &#123; if(ip!=fa) &#123; d[ip]=d[x]-(ct[ip]+1)+(n-(ct[ip]+1)); calculate(ip,x); &#125; &#125; return;&#125;int main()&#123; int a,b; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++) &#123; cin&gt;&gt;a&gt;&gt;b; g[a].push_back(b); g[b].push_back(a); &#125; dfs(1,0); calculate(1); int minn=d[1],minnp=1; //cout&lt;&lt;d[1]&lt;&lt;&quot; &quot;; for(int i=2;i&lt;=n;i++) &#123; //cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;; if(d[i]&lt;minn) &#123; minn=d[i]; minnp=i; &#125; &#125; //cout&lt;&lt;endl; cout&lt;&lt;minnp&lt;&lt;&quot; &quot;&lt;&lt;minn&lt;&lt;endl; return 0;&#125; 变式例题：同时需要节点加权的情况 医院设置 题目描述 设有一棵二叉树，如图： 其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 111。如上图中，若医院建在 111 处，则距离和 =4+12+2×20+2×40=136=4+12+2\\times20+2\\times40=136=4+12+2×20+2×40=136；若医院建在 333 处，则距离和 =4×2+13+20+40=81=4\\times2+13+20+40=81=4×2+13+20+40=81。 输入格式 第一行一个整数 nnn，表示树的结点数。 接下来的 nnn 行每行描述了一个结点的状况，包含三个整数 w,u,vw, u, vw,u,v，其中 www 为居民人口数，uuu 为左链接（为 000 表示无链接），vvv 为右链接（为 000 表示无链接）。 输出格式 一个整数，表示最小距离和。 样例 #1 样例输入 #1 1234565 13 2 34 0 012 4 520 0 040 0 0 样例输出 #1 181 提示 数据规模与约定 对于 100%100\\%100% 的数据，保证 1≤n≤1001 \\leq n \\leq 1001≤n≤100，0≤u,v≤n0 \\leq u, v \\leq n0≤u,v≤n，1≤w≤1051 \\leq w \\leq 10^51≤w≤105。 即把原来的 ct（节点数）变成人口规模（size）即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; pt[105];int w[105],size[105],ds[105];int n,u,v,sumw;void dfs(int nowpoint,int dis,int fa=0)&#123; for(auto ip:pt[nowpoint]) &#123; if(ip!=fa) &#123; dfs(ip,dis+1,nowpoint); size[nowpoint]+=size[ip]+w[ip]; &#125; &#125; ds[1]+=w[nowpoint]*dis; return ;&#125;void dynamic_programming(int nowpoint,int fa=0)&#123; for(auto ip:pt[nowpoint]) &#123; if(ip!=fa) &#123; ds[ip]=ds[nowpoint]-size[ip]-w[ip]+(sumw-size[ip]-w[ip]); dynamic_programming(ip,nowpoint); &#125; &#125;&#125;int main(void)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;u&gt;&gt;v; sumw+=w[i]; if(u!=0)&#123;pt[i].emplace_back(u);pt[v].emplace_back(i);&#125; if(v!=0)&#123;pt[i].emplace_back(v);pt[u].emplace_back(i);&#125; &#125; dfs(1,0); dynamic_programming(1); //先以1为根求出ds[1],和size[1~n] int mindis=ds[1]; for(int i=2;i&lt;=n;i++) &#123; mindis=min(mindis,ds[i]); &#125; cout&lt;&lt;mindis&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"树的重心","slug":"树的重心","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"换根dp","slug":"换根dp","permalink":"https://xqc-1368.github.io/tags/%E6%8D%A2%E6%A0%B9dp/"},{"name":"树形dp","slug":"树形dp","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"}]},{"title":"01链式二叉树+遍历问题：求先序遍历","slug":"01链式二叉树+遍历问题：求先序遍历","date":"2024-08-18T09:06:00.699Z","updated":"2024-08-18T09:37:06.108Z","comments":true,"path":"2024/08/18/01链式二叉树+遍历问题：求先序遍历/","permalink":"https://xqc-1368.github.io/2024/08/18/01%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91+%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"[NOIP2001 普及组] 求先序排列 题目描述 给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \\le 8$）。 输入格式 共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。 输出格式 共一行一个字符串，表示一棵二叉树的先序。 样例 #1 样例输入 #1 12BADCBDCA 样例输出 #1 1ABCD 提示 【题目来源】 NOIP 2001 普及组第三题 以下为正文： 这道题本蒟蒻居然去建树，真的是太垃圾了我太菜了，但好在也学习了一下怎么建树，也是比较好的。 本题思路与大佬代码： 模拟了好久，终于找出了套路，用的是DFS，其实就是递归； 我说一下这题的主要的方法（要点）， 1.后序遍历中，最后一个节点一定是根节点（对于每一颗子树也成立）； 2.既然这题要求先序遍历，那么我们只需一次输出访问的父节点即可； 这样的话，我们只要递归将一棵大树分成两颗子树，让后找他们的父节点，不断递归输出； 3.那么难点就在这了，如何通过一个中序和后序遍历中找出两段子树的后序遍历序列（后序，因为只有后序我们才方便找到父节点）呢？ 自己可以拿几个样例做一做，耐性点就会发现它的套路，我这里简单说一下： 在中序遍历中找到当前父节点后，我们可以分别求出他的左子树节点数和右子树节点数，因为中序遍历访问的顺序是左子树，父节点，右子树，所以可以直接计算出； 然后，由于我们对结点的访问一定是先访问一颗子树，在访问另一颗，所以在我们的原后序遍历串右边界中减掉右子树节点个数再减一即为新的左子树右边界，在原后序遍历串左边界加上左子树节点个数即为新的右子树左边界； 当然右子树右边界和左子树左边界这个非常好确定，就不在多说，自己看代码吧 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;char s1[10];char s2[10];int len;inline int find(char ch)&#123; for(int i=0;i&lt;len;i++) &#123; if(s1[i]==ch) return i; &#125;&#125;void dfs(int l1,int r1,int l2,int r2)&#123; int m=find(s2[r2]); cout&lt;&lt;s2[r2]; if(m&gt;l1) /*具有左子树*/dfs(l1,m-1,l2,r2-r1+m-1);//r1-m为右子树结点数 if(m&lt;r1) /*具有右子树*/dfs(m+1,r1,l2+m-l1,r2-1);//m-l1为左子树节点数&#125;int main()&#123; cin&gt;&gt;s1; cin&gt;&gt;s2; len=strlen(s1); dfs(0,len-1,0,len-1);&#125; 然而本蒟蒻的传统型建树代码效率也很高，也是AC捏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;string mid,post;typedef struct bit&#123;//二叉树结构体 char content; bit* lchild; bit *rchild;&#125;bitree;void freebypostertraversal(bitree* root)//释放内存空间函数&#123; if(root) &#123; freebypostertraversal(root-&gt;lchild ); freebypostertraversal(root-&gt;rchild ); free(root); &#125;&#125;void preordertraversal(bitree* root)//前序遍历函数&#123; if(root) &#123; cout&lt;&lt;root-&gt;content; preordertraversal(root-&gt;lchild ); preordertraversal(root-&gt;rchild ); &#125;&#125;bitree* mptopre(char inp,int start,int end,int startp,int endp)&#123;//m=中序遍历，p=后续遍历，to=到，pre=前序遍历 int start1,start2,end1,end2,trans,start4,start3,end3,end4; bitree *root=(bitree*)malloc(sizeof(bitree));//建立一个节点的内存 root-&gt;content =inp; for (int i=start;i&lt;=end ;i++) &#123; if(mid[i]==inp) &#123; trans=i; break; &#125; &#125;//这个循环是在中序遍历中找后序遍历的最后一项的根 start1=start; start2=trans+1; end1=trans-1; end2=end; start3=startp; end3=start3+end1-start1; start4=end3+1; end4=endp-1; if (end3&lt;start3)// 判断非空 &#123; root-&gt;lchild =NULL; &#125; else&#123; root-&gt;lchild=mptopre(post[end3],start1,end1,start3,end3); &#125; if (end4&lt;start4)// 判断非空 &#123; root-&gt;rchild =NULL; &#125; else&#123; root-&gt;rchild =mptopre(post[end4],start2,end2,start4,end4); &#125; return root;//返回指针实现连接 &#125;int main()&#123; cin&gt;&gt; mid&gt;&gt;post; bitree *root=mptopre(post[post.length() -1],0,mid.length() -1,0,post.length() -1); preordertraversal(root); freebypostertraversal(root); return 0;&#125; 完结撒花！","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链式二叉树","slug":"链式二叉树","permalink":"https://xqc-1368.github.io/tags/%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"遍历问题","slug":"遍历问题","permalink":"https://xqc-1368.github.io/tags/%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"}]},{"title":"04 树上差分：最大流问题","slug":"04 树上差分：最大流问题","date":"2024-08-18T09:06:00.687Z","updated":"2024-08-18T09:40:24.188Z","comments":true,"path":"2024/08/18/04 树上差分：最大流问题/","permalink":"https://xqc-1368.github.io/2024/08/18/04%20%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"LCA+树上差分 解决最大流问题：Max Flow P 树上差分 树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。这就是树上差分的基本操作。 树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用dfs 遍历求出差分数组的前缀和，就可以达到降低复杂度的目的。 树上差分时需要求LCA，对点和边的树上差分原理相同，实现略有不同，这里分开来讲。 点差分 设将两点u,v之间路径上的所有点权增加x，o=LCA(u,v),o的父亲节点为p，则操作如下：diff[u]+=x,diff[v]+=x,diff[o]-=x,diff[p]-=x; 怎么样，是不是很简单！原理也很简单，举个例子： 设原树如下，现要将2,3之间路径上的所有点的权值增加3，设原权值均为0。 则操作后有： 这样，只要dfs一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点的最终权值！ 边差分 思想一样，讲一下操作。 设将两点u,v之间路径上的所有边权增加x，o=LCA(u,v)，以每条边两端深度较大的节点存储该边的差分数组，则操作如下： diff[u]+=x,diff[v]+=x,diff[o]-=2*x; 再举个例子，还是上面那个图 则操作后有： 同样地，只要dfs一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点到父亲节点的边的最终权值了！ 例题： [USACO15DEC] Max Flow P 题目描述 Farmer John has installed a new system of N−1N-1N−1 pipes to transport milk between the NNN stalls in his barn (2≤N≤50,0002 \\leq N \\leq 50,0002≤N≤50,000), conveniently numbered 1…N1 \\ldots N1…N. Each pipe connects a pair of stalls, and all stalls are connected to each-other via paths of pipes. FJ is pumping milk between KKK pairs of stalls (1≤K≤100,0001 \\leq K \\leq 100,0001≤K≤100,000). For the iiith such pair, you are told two stalls sis_isi​ and tit_iti​, endpoints of a path along which milk is being pumped at a unit rate. FJ is concerned that some stalls might end up overwhelmed with all the milk being pumped through them, since a stall can serve as a waypoint along many of the KKK paths along which milk is being pumped. Please help him determine the maximum amount of milk being pumped through any stall. If milk is being pumped along a path from sis_isi​ to tit_iti​, then it counts as being pumped through the endpoint stalls sis_isi​ and tit_iti​, as well as through every stall along the path between them. FJ 给他的牛棚的 NNN 个隔间之间安装了 N−1N-1N−1 根管道，隔间编号从 111 到 NNN。所有隔间都被管道连通了。 FJ 有 KKK 条运输牛奶的路线，第 iii 条路线从隔间 sis_isi​ 运输到隔间 tit_iti​。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 输入格式 The first line of the input contains NNN and KKK. The next N−1N-1N−1 lines each contain two integers xxx and yyy (x≠yx \\ne yx=y) describing a pipe between stalls xxx and yyy. The next KKK lines each contain two integers sss and ttt describing the endpoint stalls of a path through which milk is being pumped. 第一行输入两个整数 NNN 和 KKK。 接下来 N−1N-1N−1 行每行输入两个整数 xxx 和 yyy，其中 x≠yx \\ne yx=y。表示一根在牛棚 xxx 和 yyy 之间的管道。 接下来 KKK 行每行两个整数 sss 和 ttt，描述一条从 sss 到 ttt 的运输牛奶的路线。 输出格式 An integer specifying the maximum amount of milk pumped through any stall in the barn. 一个整数，表示压力最大的隔间的压力是多少。 样例 #1 样例输入 #1 1234567891011121314155 103 41 54 25 45 45 43 54 34 31 33 55 41 53 4 样例输出 #1 19 提示 2≤N≤5×104,1≤K≤1052 \\le N \\le 5 \\times 10^4,1 \\le K \\le 10^52≤N≤5×104,1≤K≤105 以下程序中power为每个点流量大小的差分 对于每一次要求的两个端点，先用LCA算法求出其LCA，再对power的差分数组进行++和–操作，以下内容为主函数的一部分： 1234567891011121314151617181920 int x,y;cin&gt;&gt;n&gt;&gt;k;for(int i=1;i&lt;=n-1;i++)&#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ipoint[x].emplace_back(y); ipoint[y].emplace_back(x);&#125;for(int i=1;i&lt;=n;i++)&#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i);&#125;predfs(1);while(k--)&#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); int lca=LCA(x,y); ++power[x];++power[y]; --power[lca];--power[fa[lca][0]];&#125; 然后使用深度优先搜索实现对每一个节点的子树的差分数组求和操作，同时在算完每一个点时候，使用ans来统计最大流 在主函数中写：dfs(1); 123456789101112void dfs(int nowpoint,int father=0)&#123; for(auto ip: ipoint[nowpoint]) &#123; if(ip!=father) &#123; dfs(ip,nowpoint); power[nowpoint]+=power[ip]; &#125; &#125; ans=max(ans,power[nowpoint]);&#125; 最后输出ans即可 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;vector&gt;#define int long longusing namespace std;const int N=1e5+5;vector&lt;int&gt; ipoint[N]; int n,k,depth[N],fa[N][17],lg2[N]=&#123;0&#125;,power[N]=&#123;0&#125;,ans=-1e7;void predfs(int nowpoint,int father=0)&#123; depth[nowpoint]=depth[father]+1; fa[nowpoint][0]=father; for(int i=1;i&lt;=lg2[depth[nowpoint]];i++)//1 &#123; fa[nowpoint][i]=fa[fa[nowpoint][i-1]][i-1]; &#125; for(auto ip :ipoint[nowpoint] ) &#123; if(ip!=father) &#123; predfs(ip,nowpoint); &#125; &#125;&#125;int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) &#123; swap(x,y); &#125; while(depth[x]&gt;depth[y]) &#123; x=fa[x][lg2[depth[x]-depth[y]]-1]; &#125; if(x==y)return x; else &#123; for(int i=lg2[depth[x]]-1;i&gt;=0;--i) &#123; if(fa[x][i]!=fa[y][i]) &#123; x=fa[x][i]; y=fa[y][i]; &#125; &#125; &#125; return fa[x][0];&#125;void dfs(int nowpoint,int father=0)&#123; for(auto ip: ipoint[nowpoint]) &#123; if(ip!=father) &#123; dfs(ip,nowpoint); power[nowpoint]+=power[ip]; &#125; &#125; ans=max(ans,power[nowpoint]);&#125;signed main(void)&#123; int x,y; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n-1;i++) &#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ipoint[x].emplace_back(y); ipoint[y].emplace_back(x); &#125; for(int i=1;i&lt;=n;i++) &#123; lg2[i]=lg2[i-1]+(1&lt;&lt;lg2[i-1]==i); &#125; predfs(1); while(k--) &#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); int lca=LCA(x,y); ++power[x];++power[y]; --power[lca];--power[fa[lca][0]]; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"},{"name":"树上差分","slug":"树上差分","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"最大流","slug":"最大流","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"}]},{"title":"01 并查集，路径压缩优化，按秩合并优化","slug":"01 并查集，路径压缩优化，按秩合并优化","date":"2024-08-18T09:05:45.715Z","updated":"2024-08-18T09:36:48.404Z","comments":true,"path":"2024/08/18/01 并查集，路径压缩优化，按秩合并优化/","permalink":"https://xqc-1368.github.io/2024/08/18/01%20%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%EF%BC%8C%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/","excerpt":"","text":"并·查·集 需要解决的问题： 【模板】并查集 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 N,MN,MN,M ,表示共有 NNN 个元素和 MMM 个操作。 接下来 MMM 行，每行包含三个整数 Zi,Xi,YiZ_i,X_i,Y_iZi​,Xi​,Yi​ 。 当 Zi=1Z_i=1Zi​=1 时，将 XiX_iXi​ 与 YiY_iYi​ 所在的集合合并。 当 Zi=2Z_i=2Zi​=2 时，输出 XiX_iXi​ 与 YiY_iYi​ 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式 对于每一个 Zi=2Z_i=2Zi​=2 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1 样例输入 #1 123456784 72 1 21 1 22 1 21 3 42 1 41 2 32 1 4 样例输出 #1 1234NYNY 提示 对于 30%30\\%30% 的数据，N≤10N \\le 10N≤10，M≤20M \\le 20M≤20。 对于 70%70\\%70% 的数据，N≤100N \\le 100N≤100，M≤103M \\le 10^3M≤103。 对于 100%100\\%100% 的数据，1≤N≤1041\\le N \\le 10^41≤N≤104，1≤M≤2×1051\\le M \\le 2\\times 10^51≤M≤2×105，1≤Xi,Yi≤N1 \\le X_i, Y_i \\le N1≤Xi​,Yi​≤N，Zi∈{1,2}Z_i \\in \\{ 1, 2 \\}Zi​∈{1,2}。 1.初始化 因为我们在初始化的时候，每个节点的根节点初始化为它自己，即我爸爸是我自己，这就是根节点和其他节点的不同之处，当 r==fa[r] 的时候，就说明 r 是根节点. 12345void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125; 2.查（“查”的意思是查找一个结点的根节点.） 初始化一个fa数组，里面存放每个节点的的父节点（ fa[i]=i 的父节点） fa数组可以表示一颗树，其目的是为了查根节点，根据这个数组，我们就可以“顺藤摸瓜”，找到每个节点的根节点。 假如你在一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root. 于是我们可以写出find函数（未经过路径压缩版本） 1234567int find(int x)&#123; if(x==fa[x]) return fa[x]; else return find(fa[x]);&#125; 路径压缩 最简单的并查集效率是比较低的。例如，来看下面这个场景： 现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样： 然后我们又找来一个元素4，并需要执行merge(2,4)： 从2找到1，再找到3，然后fa[3]=4，于是变成了这样： 大家应该有感觉了，这样可能会形成一条长长的链，随着链越来越长，我们想要从底部找到根节点会变得越来越难。 怎么解决呢？我们可以使用路径压缩的方法。既然我们只关心一个元素对应的根节点，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样： 其实这说来也很好实现。只要我们在查询的过程中，把沿途的每个节点的父节点都设为根节点即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现： 合并（路径压缩） 123456789int find(int x)&#123; if(x == fa[x]) return x; else&#123; fa[x] = find(fa[x]); //父节点设为根节点 return fa[x]; //返回父节点 &#125;&#125; 以上代码常常简写为一行： 1234int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x]));&#125; 注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。 路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。 3.并（“并”指把两个在同一连通分量的结点合并） 比如有两个节点 x和y, 我们就查一下x的根节点和y的根节点（并的时候用到了查）是不是同一个节点（咱们的祖先是不是同一个人），如果是，那么x和y本来就是一家人，不用做任何操作。 如果发现x和y的祖先不同，必须有一个人要迁移户口，例如就让y的祖先做x祖先的儿子，这样x 和 y还是成为一家人了（实现了并操纵）。 代码如下： 1234567void merge(int x,int y)&#123; int fax=f_a(x);//找到i的祖先 int fay=f_a(y);//找到j的祖先 if(fax!=fay) fa[fax]=fay;//让i的祖先指向j的祖先&#125; 并查集的生动阐释： 以上题目的参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5;int fa[N];int n,m;void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;int f_a(int x)&#123; if(x==fa[x]) return fa[x]; else &#123; fa[x]=f_a(fa[x]); return fa[x]; &#125;&#125;void merge(int x,int y)&#123; int fax=f_a(x); int fay=f_a(y); if(fax!=fay) fa[fax]=fay;&#125;bool decide(int x,int y)&#123; return f_a(x)==f_a(y);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; init(); int z,x,y; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; if(z==1)merge(x,y); else if(z==2) &#123; bool result=decide(x,y); if(result)cout&lt;&lt;&quot;Y&quot;&lt;&lt;&quot;\\n&quot;; else cout&lt;&lt;&quot;N&quot;&lt;&lt;&quot;\\n&quot;; &#125; &#125; return 0;&#125; 例题：需要记录压缩路径长度，和集合总长度的变式 [NOI2002] 银河英雄传说 题目背景 公元 580158015801 年，地球居民迁至金牛座 α\\alphaα 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。 宇宙历 799799799 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。 题目描述 杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 300003000030000 列，每列依次编号为 1,2,…,300001, 2,\\ldots ,300001,2,…,30000。之后，他把自己的战舰也依次编号为 1,2,…,300001, 2, \\ldots , 300001,2,…,30000，让第 iii 号战舰处于第 iii 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 M i j，含义为第 iii 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 jjj 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。 在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：C i j。该指令意思是，询问电脑，杨威利的第 iii 号战舰与第 jjj 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。 作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。 输入格式 第一行有一个整数 TTT（1≤T≤5×1051 \\le T \\le 5 \\times 10^51≤T≤5×105），表示总共有 TTT 条指令。 以下有 TTT 行，每行有一条指令。指令有两种格式： M i j：iii 和 jjj 是两个整数（1≤i,j≤300001 \\le i,j \\le 300001≤i,j≤30000），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 iii 号战舰与第 jjj 号战舰不在同一列。 C i j：iii 和 jjj 是两个整数（1≤i,j≤300001 \\le i,j \\le 300001≤i,j≤30000），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。 输出格式 依次对输入的每一条指令进行分析和处理： 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 iii 号战舰与第 jjj 号战舰之间布置的战舰数目。如果第 iii 号战舰与第 jjj 号战舰当前不在同一列上，则输出 −1-1−1。 样例 #1 样例输入 #1 123454M 2 3C 1 2M 2 4C 4 2 样例输出 #1 12-11 提示 样例解释 战舰位置图：表格中阿拉伯数字表示战舰编号。 解析： fa[]数组维护两个编号之间的连通性，dis[]维护编号为i的战舰到fa[i]之间的距离，num[]维护编号为i的战舰所在的那一列有多少战舰。 记录距离根节点的距离显得尤为重要，其中距离根节点的距离存储在dis数组内 1234567891011121314int find(int x)&#123; if(fa[x]!=x) &#123; int k=fa[x]; fa[x]=find(fa[x]); dis[x]+=dis[k];//这句话很难理解，//但是经过尝试可以发现，这很好的维护了数组dis，//以压缩后路径权值的方式维护了每一个节点到根节点的实际距离（配合下面的初始化）//（即上面的1,2,3）所以记住就好 num[x]=num[fa[x]];//x节点的队伍长度等于根节点的 &#125; return fa[x];&#125; 于是合并函数可以修改如下： 1234567891011void merge(int x,int y)&#123; int r1=find(x),r2=find(y);//直接把根节点插上，不多说 if(r1!=r2) &#123; fa[r1]=r2;//记录父亲 dis[r1]=num[r2];//原队列长度即是此节点到父亲的距离 num[r2]+=num[r1];//r2队列后放了num[r1]个战舰 num[r1]=num[r2];//r1所在的队列和r2所在的已经是同一个队列了 &#125;&#125; 每一次输出只用输出abs(dis[x]-dis[y])-1;即可 注意，这里是问中间有几个城市， 不算两边，所以要-1 完整代码如下： 1 按秩合并 有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个菊花图（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并： 假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？ 当然是后者。因为如果把7的父节点设为8，会使树的深度（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。 这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。 我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的子树的深度）。一开始，把所有元素的rank（秩）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。 路径压缩和按秩合并如果一起使用，时间复杂度接近 O(n)O(n)O(n) ，但是很可能会破坏rank的准确性。 初始化（按秩合并） 12345678inline void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; rank[i] = 1; &#125;&#125; 合并（按秩合并） 12345678910inline void merge(int i, int j)&#123; int x = find(i), y = find(j); //先找到两个根节点 if (rank[x] &lt;= rank[y]) fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) rank[y]++; //如果深度相同且根节点不同，则新的根节点的深度+1&#125; 为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)： 这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样： 显然树的深度增加了1。另一种合并方式同样会让树的深度+1。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"并查集的路径优化压缩","slug":"并查集的路径优化压缩","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%E5%8E%8B%E7%BC%A9/"},{"name":"并查集的按秩合并优化","slug":"并查集的按秩合并优化","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/"}]},{"title":"02 种类并查集","slug":"02 种类并查集","date":"2024-08-18T09:05:44.155Z","updated":"2024-08-18T09:37:37.392Z","comments":true,"path":"2024/08/18/02 种类并查集/","permalink":"https://xqc-1368.github.io/2024/08/18/02%20%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"种类并查集 一般的并查集，维护的是具有连通性、传递性的关系，例如亲戚的亲戚是亲戚。但是，有时候，我们要维护另一种关系：敌人的敌人是朋友。种类并查集就是为了解决这个问题而诞生的。 我们先来看一个例题： （洛谷P1525 关押罪犯） [NOIP2010 提高组] 关押罪犯 题目背景 NOIP2010 提高组 T3 题目描述 S 城现有两座监狱，一共关押着 NNN 名罪犯，编号分别为 1∼N1\\sim N1∼N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 ccc 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 ccc 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了 NNN 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ 输入格式 每行中两个数之间用一个空格隔开。第一行为两个正整数 N,MN,MN,M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 MMM 行每行为三个正整数 aj,bj,cja_j,b_j,c_jaj​,bj​,cj​，表示 aja_jaj​ 号和 bjb_jbj​ 号罪犯之间存在仇恨，其怨气值为 cjc_jcj​。数据保证 1&lt;aj≤bj≤N,0&lt;cj≤1091&lt;a_j\\leq b_j\\leq N, 0 &lt; c_j\\leq 10^91&lt;aj​≤bj​≤N,0&lt;cj​≤109，且每对罪犯组合只出现一次。 输出格式 共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。 样例 #1 样例输入 #1 12345674 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884 样例输出 #1 13512 提示 输入输出样例说明 罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 351235123512（由 222 号和 333 号罪犯引发）。其他任何分法都不会比这个分法更优。 数据范围 对于 30%30\\%30% 的数据有 N≤15N\\leq 15N≤15。 对于 70%70\\%70% 的数据有 N≤2000,M≤50000N\\leq 2000,M\\leq 50000N≤2000,M≤50000。 对于 100%100\\%100% 的数据有 N≤20000,M≤100000N\\leq 20000,M\\leq 100000N≤20000,M≤100000。 我们开一个两倍大小的并查集。例如，假如我们要维护4个元素的并查集，我们改为开8个单位的空间： 我们用14维护**朋友**关系（就这道题而言，是指关在同一个监狱的狱友），用58维护敌人关系（这道题里是指关在不同监狱的仇人）。现在假如我们得到信息：1和2是敌人，应该怎么办？ 我们merge(1, 2+n), merge(1+n, 2);。这里n就等于4，但我写成n这样更清晰。对于1个编号为i的元素，i+n是它的敌人。所以这里的意思就是：1是2的敌人，2是1的敌人。 现在假如我们又知道2和4是敌人，我们merge(2, 4+n), merge(2+n, 4);： 发现了吗，敌人的敌人就是朋友，2和4是敌人，2和1也是敌人，所以这里，1和4通过2+n这个元素间接地连接起来了。这就是种类并查集工作的原理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int read() //快速读入，可忽略&#123; int ans = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); while (isdigit(c)) &#123; ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - &#x27;0&#x27;; c = getchar(); &#125; return ans;&#125;struct data //以结构体方式保存便于排序&#123; int a, b, w;&#125; C[100005];int cmp(data &amp;a, data &amp;b)&#123; return a.w &gt; b.w;&#125;int fa[40005], rank[40005]; //以下为并查集int find(int a)&#123; return (fa[a] == a) ? a : (fa[a] = find(fa[a]));&#125;int query(int a, int b)&#123; return find(a) == find(b);&#125;void merge(int a, int b)&#123; int x = find(a), y = find(b); if (rank[x] &gt;= rank[y]) fa[y] = x; else fa[x] = y; if (rank[x] == rank[y] &amp;&amp; x != y) rank[x]++;&#125;void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; rank[i] = 1; fa[i] = i; &#125;&#125;int main()&#123; int n = read(), m = read(); init(n * 2); //对于罪犯i，i+n为他的敌人 for (int i = 0; i &lt; m; ++i) &#123; C[i].a = read(); C[i].b = read(); C[i].w = read(); &#125; std::sort(C, C + m, cmp); for (int i = 0; i &lt; m; ++i) &#123; if (query(C[i].a, C[i].b)) //试图把两个已经被标记为“朋友”的人标记为“敌人” &#123; printf(&quot;%d\\n&quot;, C[i].w); //此时的怒气值就是最大怒气值的最小值 break; &#125; merge(C[i].a, C[i].b + n); merge(C[i].b, C[i].a + n); if (i == m - 1) //如果循环结束仍无冲突，输出0 puts(&quot;0&quot;); &#125; return 0;&#125; 刚才我说，种类并查集可以维护敌人的敌人是朋友这样的关系，这种说法不够准确，较为本质地说，种类并查集（包括普通并查集）维护的是一种循环对称的关系。 所以如果是三个及以上的集合，只要每个集合都是等价的，且集合间的每个关系都是等价的，就能够用种类并查集进行维护。例如下面这道题： [NOI2001] 食物链 题目描述 动物王国中有三类动物 A,B,CA,B,CA,B,C，这三类动物的食物链构成了有趣的环形。AAA 吃 BBB，BBB 吃 CCC，CCC 吃 AAA。 现有 NNN 个动物，以 1∼N1 \\sim N1∼N 编号。每个动物都是 A,B,CA,B,CA,B,C 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 NNN 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 XXX 和 YYY 是同类。 第二种说法是2 X Y，表示 XXX 吃 YYY。 此人对 NNN 个动物，用上述两种说法，一句接一句地说出 KKK 句话，这 KKK 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中 XXX 或 YYY 比 NNN 大，就是假话； 当前的话表示 XXX 吃 XXX，就是假话。 你的任务是根据给定的 NNN 和 KKK 句话，输出假话的总数。 输入格式 第一行两个整数，N,KN,KN,K，表示有 NNN 个动物，KKK 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式 一行，一个整数，表示假话的总数。 样例 #1 样例输入 #1 12345678100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5 样例输出 #1 13 提示 对于全部数据，1≤N≤5×1041\\le N\\le 5 \\times 10^41≤N≤5×104，1≤K≤1051\\le K \\le 10^51≤K≤105。 于是我们可以用一个三倍大小的并查集进行维护，用i+n表示i的捕食对象，而i+2n表示i的天敌。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;#define int long longconst int N = 3e5 + 5;int fa[N];int n, k;int find(int x)&#123; if (fa[x] != x) &#123; fa[x] = find(fa[x]); &#125; return fa[x];&#125;void merge(int x, int y)&#123; int r1 = find(x), r2 = find(y); if (r1 != r2) fa[r1] = r2;&#125;bool question(int x, int y)&#123; return find(x) == find(y);&#125;void init()&#123; for (int i = 1; i &lt;= 3 * n; i++) fa[i] = i;&#125;signed main()&#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); init(); int oper, x, y, ans = 0; for (int i = 1; i &lt;= k; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;oper, &amp;x, &amp;y); if (x &gt; n || y &gt; n) ans++; else if (oper == 1) &#123; if (question(x + n, y) || question(x + 2 * n, y)) &#123; ans++; &#125; else &#123; merge(x, y); merge(x + n, y + n); merge(x + 2 * n, y + 2 * n); &#125; &#125; else if (oper == 2) &#123; if (question(x, y) || question(x, y + n)) &#123; ans++; &#125; else &#123; merge(x + n, y); merge(x + 2 * n, y + n); merge(x, y + 2 * n); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"种类并查集","slug":"种类并查集","permalink":"https://xqc-1368.github.io/tags/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"10 数位DP：数字计数","slug":"10 数位DP：数字计数","date":"2024-08-17T06:53:17.229Z","updated":"2024-08-17T14:32:09.030Z","comments":true,"path":"2024/08/17/10 数位DP：数字计数/","permalink":"https://xqc-1368.github.io/2024/08/17/10%20%E6%95%B0%E4%BD%8DDP%EF%BC%9A%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/","excerpt":"","text":"10数位DP：数字计数 [ZJOI2010] 数字计数 题目描述 给定两个正整数 aaa 和 bbb，求在 [a,b][a,b][a,b] 中的所有整数中，每个数码(digit)各出现了多少次。 输入格式 仅包含一行两个整数 a,ba,ba,b，含义如上所述。 输出格式 包含一行十个整数，分别表示 0∼90\\sim 90∼9 在 [a,b][a,b][a,b] 中出现了多少次。 样例 #1 样例输入 #1 11 99 样例输出 #1 19 20 20 20 20 20 20 20 20 20 提示 数据规模与约定 对于 30%30\\%30% 的数据，保证 a≤b≤106a\\le b\\le10^6a≤b≤106； 对于 100%100\\%100% 的数据，保证 1≤a≤b≤10121\\le a\\le b\\le 10^{12}1≤a≤b≤1012。 数位DP主要通过记忆化搜索实现，记忆化搜索的本质就是把条件对应的结论记下来，相同条件一定最后对应相同的结论，条件的个数也就决定了DP的维数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define int long long//注意都要开long longusing namespace std;int ay[20];//ay来存这个数每个位子上的数码，倒序存放int dp[20][2][20][2];//zero=1表示前面是否全部都是前导零//limit=1 表示前面对本位有没有限制//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；/*记忆化搜索。pos是当前为从高到低位置。limit表示当前位之前的所有位置是否和ay[pos]相等， 1是相等，0是不相等。sum表示当前数字出现的次数。zero表示之前是否都是前导0。target是当前在算的数码。*/int dfs(int pos,int limit,int sum,int zero,int target)&#123; int ret=0; if(pos==0)return sum;//递归终止条件 if(dp[pos][limit][sum][zero]!=-1)return dp[pos][limit][sum][zero]; //记搜检索：检索是否已经被记录 int maxnum=limit?ay[pos]:9;/* 由于我们是从高位到低位枚举的，所以如果之前一位的数码和最大数的数码相同， 这一位就只能枚举到ay[pos]； 否则如果之前一位比最大数的数码小，那这一位就可以从0~9枚举了。*/ for(int i=0;i&lt;=maxnum;i++) &#123; ret+=dfs(pos-1,limit &amp;&amp;(i==maxnum),sum+((i==target) &amp;&amp; (i||!zero)),zero &amp;&amp; (i==0),target); /* 继续搜索，数位减一（到下一个位置，倒序存储，从高位到低位）， limit的更新要看之前有没有相等，且这一位有没有相等； sum的更新要看之前是否为前导0或者这一位不是0； zero的更新就看之前是否为前导0且这一位继续为0； target继续传进去。 */ &#125; dp[pos][limit][sum][zero]=ret;//记忆化，把搜到的都记下来 return ret;&#125;int part(int a,int d)&#123; int len=0; while(a) &#123; ay[++len]=a%10; a/=10; &#125; memset(dp, -1, sizeof dp);//初始化 dfs(len,1,0,1,d); //开始在第len位上，最高位只能枚举到ay[pos]所以limit是0，sum=0，有前导0。&#125;signed main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int i=0;i&lt;=9;i++) &#123; cout&lt;&lt;part(b,i)-part(a-1,i)&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 再来看一道题： [SCOI2009] windy 数 题目背景 windy 定义了一种 windy 数。 题目描述 不含前导零且相邻两个数字之差至少为 222 的正整数被称为 windy 数。windy 想知道，在 aaa 和 bbb 之间，包括 aaa 和 bbb ，总共有多少个 windy 数？ 输入格式 输入只有一行两个整数，分别表示 aaa 和 bbb。 输出格式 输出一行一个整数表示答案。 样例 #1 样例输入 #1 11 10 样例输出 #1 19 样例 #2 样例输入 #2 125 50 样例输出 #2 120 提示 数据规模与约定 对于全部的测试点，保证 1≤a≤b≤2×1091 \\leq a \\leq b \\leq 2 \\times 10^91≤a≤b≤2×109。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;int ay[100];int len=0;int dp[100][100];//dp[i][j]表示搜到第i位，前一位是j，的！limit方案totnum；//zero=1表示前面是否全部都是前导零//limit=1 表示前面对本位有没有限制//即：前面都是贴着放的为1，前面某一位不是贴着放的，为0；int dfs(int pos,int prenum,int st,int limit)&#123;//pos当前位置,pre前一位数,st判断前面是否全是0,limit最高位限制 if(pos&gt;len)return 1;//搜完了 if(limit==0 &amp;&amp; dp[pos][prenum]!=-1)return dp[pos][prenum]; //没有最高位限制且已经搜过了 int maxnum=limit?ay[len+1-pos]:9;//当前位最大数字 int ret=0; for(int i=0;i&lt;=maxnum;i++)//从0枚举到最大数字 &#123; if(abs(i-prenum)&lt;2)continue;//不符合题意，继续 if(i==0 &amp;&amp; st==1)ret+=dfs(pos+1,-2,st,limit &amp;&amp; (i==maxnum)); //如果有前导0，下一位随意 else ret+=dfs(pos+1,i,0,limit &amp;&amp; (i==maxnum)); //如果没有前导0，继续按部就班地搜 &#125; if(limit==0 &amp;&amp; st==0)dp[pos][prenum]=ret;//没有最高位限制且没有前导0时记录结果 ，至于为什么要这样，我也不知道，其实可以都记下来的 return ret;&#125;int part(int a)&#123; len=0; while(a) &#123; ay[++len]=a%10; a/=10; &#125; memset(dp, -1, sizeof (dp)); return dfs(1,-2,1,1);&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;part(b)-part(a-1)&lt;&lt;endl; return 0;&#125; 咱就主打一个看注释吧。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"算法/动态规划/数位DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"09 区间DP的博弈论模型： Letter Picking","slug":"09 区间DP的博弈论模型： Letter Picking","date":"2024-08-17T06:53:17.224Z","updated":"2024-08-17T14:31:59.812Z","comments":true,"path":"2024/08/17/09 区间DP的博弈论模型： Letter Picking/","permalink":"https://xqc-1368.github.io/2024/08/17/09%20%E5%8C%BA%E9%97%B4DP%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%A8%A1%E5%9E%8B%EF%BC%9A%20Letter%20Picking/","excerpt":"","text":"区间DP的博弈论模型： Letter Picking Letter Picking 题面翻译 题目描述 Alice 和 Bob 在玩游戏。 给出一个长度为偶数的，非空的且仅含小写字母的字符串 sss。每个玩家还拥有一个初始为空的字符串。 Alice 先手，两名玩家交替行动。在一次行动中，玩家可以取 sss 首或尾字符，将其从 sss 中移除后加入到自己的字符串的 最前面。 当 sss 为空时游戏结束，拥有字典序更小的字符串的玩家获胜。若两名玩家的字符串相等则平局。 若 Alice 和 Bob 都足够聪明，判断谁会取胜，或者游戏为平局。 数据组数 t≤103t\\leq 10^3t≤103，∑∣s∣≤2×103\\sum|s|\\leq 2\\times 10^3∑∣s∣≤2×103。保证所有输入的 ∣s∣|s|∣s∣ 长度都为偶数。 题目描述 Alice and Bob are playing a game. Initially, they are given a non-empty string sss , consisting of lowercase Latin letters. The length of the string is even. Each player also has a string of their own, initially empty. Alice starts, then they alternate moves. In one move, a player takes either the first or the last letter of the string sss , removes it from sss and prepends (adds to the beginning) it to their own string. The game ends when the string sss becomes empty. The winner is the player with a lexicographically smaller string. If the players’ strings are equal, then it’s a draw. A string aaa is lexicographically smaller than a string bbb if there exists such position iii that aj=bja_j = b_jaj​=bj​ for all j&lt;ij &lt; ij&lt;i and ai&lt;bia_i &lt; b_iai​&lt;bi​ . What is the result of the game if both players play optimally (e. g. both players try to win; if they can’t, then try to draw)? 输入格式 The first line contains a single integer ttt ( 1≤t≤10001 \\le t \\le 10001≤t≤1000 ) — the number of testcases. Each testcase consists of a single line — a non-empty string sss , consisting of lowercase Latin letters. The length of the string sss is even. The total length of the strings over all testcases doesn’t exceed 200020002000 . 输出格式 For each testcase, print the result of the game if both players play optimally. If Alice wins, print “Alice”. If Bob wins, print “Bob”. If it’s a draw, print “Draw”. 样例 #1 样例输入 #1 1232forcesabba 样例输出 #1 12AliceDraw 提示 One of the possible games Alice and Bob can play in the first testcase: Alice picks the first letter in sss : s=s=s= “orces”, a=a=a= “f”, b=b=b= “”; Bob picks the last letter in sss : s=s=s= “orce”, a=a=a= “f”, b=b=b= “s”; Alice picks the last letter in sss : s=s=s= “orc”, a=a=a= “ef”, b=b=b= “s”; Bob picks the first letter in sss : s=s=s= “rc”, a=a=a= “ef”, b=b=b= “os”; Alice picks the last letter in sss : s=s=s= “r”, a=a=a= “cef”, b=b=b= “os”; Bob picks the remaining letter in sss : s=s=s= “”, a=a=a= “cef”, b=b=b= “ros”. Alice wins because “cef” &lt; “ros”. Neither of the players follows any strategy in this particular example game, so it doesn’t show that Alice wins if both play optimally. 定义状态： 对于区间i~j，博弈后的结果，记1为先手胜，0为先手平，-1为先手负 考虑先手： 以上为先手必获胜的结果，当先手出招时候，后手想使用反制手段，但是发现后手的每一种选择都是使结果导向先手方胜利，那么后手方没办法只能输； 接下来讨论先手出招，但后手通过反制手段，但因为选择当中没有使后手方获胜的情况，但存在若干个平手的情况，于是后手方退而求其次，使最终结果导向平局的情况； 当然这里讨论的是先手不输的情况，先手不输的情况包括先手赢和先手平两种，如果用if+先手赢+else if+先手不输 来把先手赢的情况再第二种情况之前拒之门外，那么第二种情况就是先手不输的情况 即为 附上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;#define int long longint dp[2005][2005] = &#123;0&#125;;int solve(string s)&#123; int n = s.size() - 1; for (int i = 1, j = 2; j &lt;= n; i++, j++) // 1 start &#123; if (s[i] == s[j]) dp[i][j] = 0; else dp[i][j] = 1; &#125; for (int k = 2; 2 * k &lt;= n; k++) for (int i = 1, j = 2 * k; j &lt;= n; i++, j++) &#123; if ((s[i] &lt; s[i + 1] &amp;&amp; dp[i + 2][j] == 0 || dp[i + 2][j] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[i] &lt; s[j] || dp[i + 1][j - 1] == 1) || (s[j] &lt; s[j - 1] &amp;&amp; dp[i][j - 2] == 0 || dp[i][j - 2] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[j] &lt; s[i] || dp[i + 1][j - 1] == 1)) &#123; dp[i][j] = 1; &#125; else if (((s[i] &lt;= s[i + 1] &amp;&amp; dp[i + 2][j] == 0 || dp[i + 2][j] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[i] &lt;= s[j] || dp[i + 1][j - 1] == 1)) || (s[j] &lt;= s[j - 1] &amp;&amp; dp[i][j - 2] == 0 || dp[i][j - 2] == 1) &amp;&amp; (dp[i + 1][j - 1] == 0 &amp;&amp; s[j] &lt;= s[i] || dp[i + 1][j - 1] == 1)) &#123; dp[i][j] = 0; &#125; else dp[i][j] = -1; &#125; // for(int i=1;i&lt;=n;i++) // &#123; // for(int j=1;j&lt;=n;j++) // &#123; // cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;; // &#125; // cout&lt;&lt;endl; // &#125; return dp[1][n];&#125;signed main(void)&#123; int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) &#123; string temp, s = &quot;0&quot;; cin &gt;&gt; temp; s += temp; int ans = solve(s); if (ans == 0) cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl; if (ans == 1) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; if (ans == -1) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"08 四边形不等式优化的环形DP：石子合并","slug":"08 四边形不等式优化的环形DP： 石子合并","date":"2024-08-17T06:53:17.221Z","updated":"2024-08-17T14:32:04.714Z","comments":true,"path":"2024/08/17/08 四边形不等式优化的环形DP： 石子合并/","permalink":"https://xqc-1368.github.io/2024/08/17/08%20%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96%E7%9A%84%E7%8E%AF%E5%BD%A2DP%EF%BC%9A%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/","excerpt":"","text":"环形DP+四边形不等式优化的区间DP：石子合并 [NOI1995] 石子合并 题目描述 在一个圆形操场的四周摆放 NNN 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 222 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出一个算法,计算出将 NNN 堆石子合并成 111 堆的最小得分和最大得分。 输入格式 数据的第 111 行是正整数 NNN，表示有 NNN 堆石子。 第 222 行有 NNN 个整数，第 iii 个整数 aia_iai​ 表示第 iii 堆石子的个数。 输出格式 输出共 222 行，第 111 行为最小得分，第 222 行为最大得分。 样例 #1 样例输入 #1 1244 5 9 4 样例输出 #1 124354 提示 1≤N≤1001\\leq N\\leq 1001≤N≤100，0≤ai≤200\\leq a_i\\leq 200≤ai​≤20。 考虑的难点主要有两个： 1.区间dp处理环形dp的思路是什么？ 2.区间dp的优化方法：四边形不等式； 先解决问题1： 环形dp的处理方法就是将原来的数组扩充两倍，将n+1项写成第1项，将n+2项写成第2项······以此类推。 12345678910111213int n,stone[500],pre[500]=&#123;0&#125;; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;stone[i]; stone[i+n]=stone[i]; &#125; for(int i=1;i&lt;=2*n;i++) &#123; pre[i]=pre[i-1]+stone[i]; //cout&lt;&lt;pre[i]&lt;&lt;&quot; &quot;; &#125; //cout&lt;&lt;endl; 以n=4为例，最后要输出的是 dp[1][4]，dp[2][5]，dp[3][6]，dp[4][7]，dp[5][8]的最小值/最大值，即所有长度为n的区间的最值 1234567int minn=INT_MAX,maxn=0; for(int i=1,j=n;j&lt;=2*n;i++,j++) &#123; minn=min(minn,dpmin[i][j]); maxn=max(maxn,dp[i][j]); &#125; cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxn&lt;&lt;endl; 再解决问题2： 先介绍方法： 12345678910111213141516for (int i = 1; i &lt;= n; ++i) m[i][i] = i; // 初始化边界决策点for (int d = 2; d &lt;= n; ++d) for (int l = 1, r = d; r &lt;= n; ++l，++ r) &#123; dp[l][r] = INF; for (int k = m[l][r - 1]; k &lt;= m[l + 1][r];++k) // 利用结论，缩小了枚举范围 if (dp[l][k] + dp[k + 1][r] + w(l, r) &lt; dp[l][r]) &#123; dp[l][r] = dp[l][k] + dp[k + 1][r] + w(l, r); // 更新dp数组 m[l][r] = k; // 更新决策点 &#125; &#125; 运用最优决策点的关系，可以实现优化。 然而，我们由上面的文章可以看到，四边形不等式的使用条件其一是w（l，r）满足区间单调性，这个只能数学证明，而且很容易看出来。 其二是，m这个用于标记最佳决策点的数组，在每一行，每一列上都实现单调不下降。本题中，求最大值的时候，m数组不符合这个条件（怎么发现的呢，假设符合条件，然后敲一遍代码，敲完后把m数组打印出来结果如下） 于是就不符合，只能使用简单的区间dp完成。 而求最小值的时候，m数组符合这个条件（运行截图如下），于是就可以使用四边形不等式 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int dp[500][500]=&#123;0&#125;;int dpmin[500][500]=&#123;0&#125;;int m[500][500]=&#123;0&#125;;int m1[500][500]=&#123;0&#125;;signed main(void)&#123; int n,stone[500],pre[500]=&#123;0&#125;; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;stone[i]; stone[i+n]=stone[i]; &#125; for(int i=1;i&lt;=2*n;i++) &#123; pre[i]=pre[i-1]+stone[i]; &#125; //m数组初始化 for(int i=1;i&lt;=2*n;i++) &#123; m[i][i]=i; m1[i][i]=i; &#125; for(int e=2;e&lt;=2*n;e++) &#123; for(int i=1,j=e;j&lt;=2*n;i++,j++) &#123; dpmin[i][j]=INT_MAX; for(int k=i;k&lt;=j-1;k++) &#123; if(dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]&gt;dp[i][j] &amp;&amp; k+1&lt;=j &amp;&amp; i&lt;=k) &#123; dp[i][j]=dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]; m[i][j]=k; &#125; &#125; for (int k = m1[i][j - 1]; k &lt;= m1[i + 1][j]; k++) &#123; if (dpmin[i][k] + dpmin[k + 1][j] + pre[j] - pre[i - 1] &lt; dpmin[i][j] &amp;&amp; k + 1 &lt;= j &amp;&amp; i &lt;= k) &#123; dpmin[i][j] = dpmin[i][k] + dpmin[k + 1][j] + pre[j] - pre[i - 1]; m1[i][j] = k; &#125; &#125; &#125; &#125; int minn=INT_MAX,maxn=0; for(int i=1,j=n;j&lt;=2*n;i++,j++) &#123; minn=min(minn,dpmin[i][j]); maxn=max(maxn,dp[i][j]); &#125; cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxn&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"环形DP的四边形不等式优化","slug":"算法/动态规划/环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"环形DP的四边形不等式优化","slug":"环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/tags/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"}]},{"title":"07 二进制优化多重背包问题：樱花","slug":"07 二进制优化多重背包问题：樱花","date":"2024-08-17T06:53:17.218Z","updated":"2024-08-17T14:31:50.109Z","comments":true,"path":"2024/08/17/07 二进制优化多重背包问题：樱花/","permalink":"https://xqc-1368.github.io/2024/08/17/07%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E6%A8%B1%E8%8A%B1/","excerpt":"","text":"二进制优化多重背包问题：樱花 樱花 题目背景 《爱与愁的故事第四弹·plant》第一章。 题目描述 爱与愁大神后院里种了 nnn 棵樱花树，每棵都有美学值 Ci(0≤Ci≤200)C_i(0 \\le C_i \\le 200)Ci​(0≤Ci​≤200)。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 Pi(0≤Pi≤100)P_i(0 \\le P_i \\le 100)Pi​(0≤Pi​≤100) 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 Ti(0≤Ti≤100)T_i(0 \\le T_i \\le 100)Ti​(0≤Ti​≤100)。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。 输入格式 共 n+1n+1n+1行： 第 111 行：现在时间 TsT_sTs​（几时：几分），去上学的时间 TeT_eTe​（几时：几分），爱与愁大神院子里有几棵樱花树 nnn。这里的 TsT_sTs​，TeT_eTe​ 格式为：hh:mm，其中 0≤hh≤230 \\leq hh \\leq 230≤hh≤23，0≤mm≤590 \\leq mm \\leq 590≤mm≤59，且 hh,mm,nhh,mm,nhh,mm,n 均为正整数。 第 222 行到第 n+1n+1n+1 行，每行三个正整数：看完第 iii 棵树的耗费时间 TiT_iTi​，第 iii 棵树的美学值 CiC_iCi​，看第 iii 棵树的次数 PiP_iPi​（Pi=0P_i=0Pi​=0 表示无数次，PiP_iPi​ 是其他数字表示最多可看的次数 PiP_iPi​）。 输出格式 只有一个整数，表示最大美学值。 样例 #1 样例输入 #1 12346:50 7:00 32 1 03 3 14 5 4 样例输出 #1 111 提示 100%100\\%100% 数据：Te−Ts≤1000T_e-T_s \\leq 1000Te​−Ts​≤1000（即开始时间距离结束时间不超过 100010001000 分钟），n≤10000n \\leq 10000n≤10000。保证 Te,TsT_e,T_sTe​,Ts​ 为同一天内的时间。 样例解释：赏第一棵樱花树一次，赏第三棵樱花树 222 次。 这是一个普通背包，多重背包，完全背包的混合 其他的背包正常做就行，但由于平时都是把多重背包一个物品最多取n件拆成n个这种的一件物品。时间会消耗得很厉害。于是就出现了二进制优化： 一个正整数n，可以被分解成1,2,4,…,2(k-1),n-2k+1的形式。其中，k是满足n-2^k+1&gt;0的最大整数。 例如，假设给定价值为2，数量为10的物品，依据二进制优化思想可将10分解为1+2+4+3，则原来价值为2，数量为10的物品可等效转化为价值分别为1x2，2x2，4x2，3x2，即价值分别为2，4，8，6，数量均为1的物品。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;vector&lt;int&gt; t,c,p;int dp[100000]=&#123;0&#125;;int T,n;int exchage(string st,string ed)&#123; if(st[1]==&#x27;:&#x27;)st=&quot;0&quot;+st; if(ed[1]==&#x27;:&#x27;)ed=&quot;0&quot;+ed; int hs=stoi(st.substr(0,2)),hed=stoi(ed.substr(0,2)); int ms=stoi(st.substr(3,5)),med=stoi(ed.substr(3,5)); if(hed&lt;hs)hed+=24; int ret=(hed-hs)*60+med-ms; return ret;&#125;signed main(void)&#123; string st,ed; cin&gt;&gt;st&gt;&gt;ed&gt;&gt;n; T=exchage(st,ed); //cout&lt;&lt;T&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; int tempt,tempc,tempp; cin&gt;&gt;tempt&gt;&gt;tempc&gt;&gt;tempp; if(tempp==1 || tempp==0) &#123; t.push_back(tempt); c.push_back(tempc); p.push_back(tempp); &#125; else if(tempp&gt;1) &#123; int x=0; while (tempp &gt; pow(2, x)) &#123; t.push_back(tempt * pow(2, x)); c.push_back(tempc * pow(2, x)); p.push_back(1); tempp -= pow(2, x); x++; &#125; t.push_back(tempt * tempp); c.push_back(tempc * tempp);//注意，数量（2个，4个...）绑定后相应的价值和重量也会发生改变 p.push_back(1); &#125; &#125; for(int i=0;i&lt;t.size();i++) &#123; if(p[i]==0)//complete package &#123; for(int j=t[i];j&lt;=T;j++) &#123; dp[j]=max(dp[j],dp[j-t[i]]+c[i]); &#125; &#125; else &#123; for(int j=T;j&gt;=t[i];j--) &#123; dp[j]=max(dp[j],dp[j-t[i]]+c[i]); &#125; &#125; &#125; cout&lt;&lt;dp[T]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"多重背包DP的二进制优化","slug":"算法/动态规划/多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"多重背包DP的二进制优化","slug":"多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"}]},{"title":"06 树形DP：金明的预算方案","slug":"06 树形DP：金明的预算方案","date":"2024-08-17T06:53:17.215Z","updated":"2024-08-17T14:31:45.547Z","comments":true,"path":"2024/08/17/06 树形DP：金明的预算方案/","permalink":"https://xqc-1368.github.io/2024/08/17/06%20%E6%A0%91%E5%BD%A2DP%EF%BC%9A%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/","excerpt":"","text":"树形DP：金明的预算方案 其实这道题不用树形dp，也可以使用普通的背包dp，但是鉴于树形dp的简单题一题难求，于是我们用树形dp做。 P1064 [NOIP2006 提高组] 金明的预算方案 题目描述 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 nnn 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 000 个、111 个或 222 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 nnn 元。于是，他把每件物品规定了一个重要度，分为 555 等：用整数 1∼51 \\sim 51∼5 表示，第 555 等最重要。他还从因特网上查到了每件物品的价格（都是 101010 元的整数倍）。他希望在不超过 nnn 元的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第 jjj 件物品的价格为 vjv_jvj​，重要度为wjw_jwj​，共选中了 kkk 件物品，编号依次为 j1,j2,…,jkj_1,j_2,\\dots,j_kj1​,j2​,…,jk​，则所求的总和为： vj1×wj1+vj2×wj2+⋯+vjk×wjkv_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times w_{j_k}vj1​​×wj1​​+vj2​​×wj2​​+⋯+vjk​​×wjk​​。 请你帮助金明设计一个满足要求的购物单。 输入格式 第一行有两个整数，分别表示总钱数 nnn 和希望购买的物品个数 mmm。 第 222 到第 (m+1)(m + 1)(m+1) 行，每行三个整数，第 (i+1)(i + 1)(i+1) 行的整数 viv_ivi​，pip_ipi​，qiq_iqi​ 分别表示第 iii 件物品的价格、重要度以及它对应的的主件。如果 qi=0q_i=0qi​=0，表示该物品本身是主件。 输出格式 输出一行一个整数表示答案。 样例 #1 样例输入 #1 1234561000 5800 2 0400 5 1300 5 1400 3 0500 2 0 样例输出 #1 12200 提示 数据规模与约定 对于全部的测试点，保证 1≤n≤3.2×1041 \\leq n \\leq 3.2 \\times 10^41≤n≤3.2×104，1≤m≤601 \\leq m \\leq 601≤m≤60，0≤vi≤1040 \\leq v_i \\leq 10^40≤vi​≤104，1≤pi≤51 \\leq p_i \\leq 51≤pi​≤5，0≤qi≤m0 \\leq q_i \\leq m0≤qi​≤m，答案不超过 2×1052 \\times 10^52×105。 定义状态：dp【i】【j】=以后序遍历的方式遍历到节点 i 时，还剩的空间为 j 时的最佳answer。 首先，我们需要构建一个树：（对于测试样例）注意一开始为了统摄所有根节点，我们建立一个0号节点来统摄。 这是这个dp数组在测试案例的情况下的最后输出结果，（后面可能会用到） 状态转移方程：xbcl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;vector&lt;int&gt; point_to[61];int v[100]=&#123;0&#125;, p[100]=&#123;0&#125;, q[100]=&#123;0&#125;;int dp[100][3200]=&#123;0&#125;;int n, m;void dfs(int nowpoint,int nowweight)&#123;//第一个参数表示当前节点，第二个参数表示当前还剩的重量 if(nowweight&lt;=0)return ;//如果当前还剩的重量已经小于0，那么直接返回 for(int i=0;i&lt;point_to[nowpoint].size();i++) &#123;//遍历每一个当前节点的子节点 int child = point_to[nowpoint][i];//child为子节点 for (int j = nowweight-v[child]; j &gt;= 0; j--) &#123; dp[child][j] = dp[nowpoint][j] + p[child]*v[child]; &#125;/*把当前0~nowweight-v[child]的所有项给直接搬过来。再加上p[child]*v[child]即题目规定的权值其中0~nowweight-v[child]记录着遍历过他的哥哥节点（前面的兄弟节点）后，所得出的最佳答案为什么把0~nowweight-v[child]直接搬过来加？首先我们要知道dp[父节点]【0~nowweight-v[child]】表示的是在父亲只有该子节点的所有哥哥节点的时候，而完全不取该子节点的有关权值的时候的最优解。因为我们现在在讨论该子节点取的情况下的最优解，而取该子节点势必会消耗v[child]的限额，于是我们给该子节点预留v[child]，那么取完该节点后剩下0~nowweight-v[child]，在递归到叶子节点（即下一行程序的dfs）返回后0~nowweight-v[child]一一顺序对应v[child]~nowweight于是对应原来父节点集合的v[child]~nowweight元素比大小（下面一个循环干的事），最终得到父节点nowpoint的最优值集合*/ dfs(child, nowweight - v[child]); for (int k = nowweight; k &gt;= v[child]; k--) &#123; dp[nowpoint][k] = max(dp[nowpoint][k], dp[child][k - v[child]]); &#125; &#125;/*这时候你会问了，对于兄弟节点之间，取两个，三个等等在哪里体现。其实，这在搬过来加权值的时候已经体现了；如处理样例中5号这个节点的时候，我们把00000000···00000 1200 1200 1200···1200（十一（因为包括首尾）个）搬过来在5号节点这个节点的权值1000加上去，dp第五行自然也就变成了1000 1000···1000 2200 2200··2200了*/&#125;signed main(void)&#123; cin&gt;&gt;n&gt;&gt;m; n/=10; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;p[i]&gt;&gt;q[i]; v[i]/=10; point_to[q[i]].push_back(i);//建树的过程，point_to是二维数组，用point_to[i]记录i号节点指向的所有节点 &#125; dfs(0,n); cout&lt;&lt;dp[0][n]*10&lt;&lt;endl; return 0;&#125; 总结： 树状dp主要解决树形最优解问题。 步骤： 0.递归终止条件： 剩下限重小于0，返回即可； 1.遍历每一个子节点： （1）搬来加权值：把父节点剪掉子节点的重量的部分照搬，加上子节点的权值，成为子节点的那一行的数组； （2）递归：往下递归一层，就更新传参，更新当前节点的参数，更新当前限重。 （3）高位搬回去比较。","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"算法/动态规划/树形DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"05 单调队列优化DP：华科A题","slug":"05 单调队列优化DP：华科A题","date":"2024-08-17T06:53:17.210Z","updated":"2024-08-17T14:31:40.881Z","comments":true,"path":"2024/08/17/05 单调队列优化DP：华科A题/","permalink":"https://xqc-1368.github.io/2024/08/17/05%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP%EF%BC%9A%E5%8D%8E%E7%A7%91A%E9%A2%98/","excerpt":"","text":"单调队列 “如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理 单调队列是一种主要用于解决”滑动区间“的最值问题的数据结构 即，在长度为 的序列中，求每个长度为 的区间的区间最值。它的时间复杂度是 ，在这个问题中比 的ST表和线段树要优。 单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素可能成为某个区间最值时才保留它。 形象地打个比方，上面的序列可以看成学校里各个年级XCPC选手，数字越大代表能力越强。每个选手只能在大学四年间参赛，毕业了就没有机会了。那么，每一年的王牌选手都在哪个年级呢？ 一开始的时候，大三大四的学长都比较菜，大二的最强，而大一的等大二的毕业后还有机会上位，所以队列里有两个数。 一年过去了，原本大一的成为大二，却发现新进校的新生非常强，自己再也没有机会成为最大值了，所以弹出队列。 又过了一年，新入校的新生尽管能力只有1，但理论上只要后面的人比他还菜，还是可能成为区间最大值的，所以入队。 终于，原本的王牌毕业了，后面的人以为熬出头了，谁知道这时一个巨佬级别的新生进入了集训队，这下其他所有人都没机会了。 （这只是比方，现实中各位选手的实力是会增长的，不符合这个模型ovo） 总之，观察就会发现，我们维护的这个队列总是单调递减的。如果维护区间最小值，那么维护的队列就是单调递增的。这就是为什么叫单调队列。 例题：单调队列优化动态规划的应用 选择数字 题目描述 给定一行 nnn 个非负整数 a1⋯ana_1 \\cdots a_na1​⋯an​。现在你可以选择其中若干个数，但不能有超过 kkk 个连续的数字被选择。你的任务是使得选出的数字的和最大。 输入格式 第一行两个整数 nnn，kkk。 以下 nnn 行，每行一个整数表示 aia_iai​。 输出格式 输出一个值表示答案。 样例 #1 样例输入 #1 1234565 212345 样例输出 #1 112 提示 对于 20%20\\%20% 的数据，n≤10n \\le 10n≤10。 对于另外 20%20\\%20% 的数据，k=1k=1k=1。 对于 60%60\\%60% 的数据，n≤1000n \\le 1000n≤1000。 对于 100%100\\%100% 的数据，1≤n≤1000001 \\le n \\le 1000001≤n≤100000，1≤k≤n1 \\le k \\le n1≤k≤n，0≤0 \\le0≤ 数字大小 ≤1,000,000,000\\le 1,000,000,000≤1,000,000,000。 时间限制 500500500 ms。 这种题是很典型的单调队列优化DP。 我们把问题转化为删除若干个数，且删除的数间隔不超过k，求删除数的最小值。设dp[i]表示在删除第i个数的情况下， 前i个数中删除数的最小和。那么很容易想到转移方程： 这是因为，如果要删除某个数，除非它是前 k+1个数之一，否则在它之前的k+1个数中，至少要删除一个。最后的答案在最后 k+1个数里找最小值，然后用总和去减即可，因为最后 k+1个数中至少有一个是要删除的。 这个朴素方法是O（mn）的，为了优化它，我们可以使用单调队列。注意到，我们不断地在求dp的区间最小值，而且区间长度是固定的m+1 ，这正好符合滑动窗口的模型。只不过，我们需要动态地进行整个过程，即，在维护单调队列的过程中求出dp。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxsize = 100005;int dp[maxsize] = &#123;0&#125;;deque&lt;int&gt; q;signed main()&#123; int n,k,a[maxsize],sum=0; cin&gt;&gt;n&gt;&gt;k; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; sum+=a[i]; &#125; //看作删除若干个数，但是不能有间隔超过k； //dp[i]表示，删除a[i]的情况下，完成删除的最小值 for(int i=1;i&lt;=n;i++) &#123; if(i&lt;=k+1) dp[i]=a[i]; else dp[i]=dp[q.front()]+a[i]; if(!q.empty() &amp;&amp; q.front()&lt;i-k) q.pop_front(); while (!q.empty() &amp;&amp; dp[q.back()] &gt; dp[i]) &#123; q.pop_back(); &#125; q.push_back(i); &#125; int emin=LONG_LONG_MAX; for(int i=n-k;i&lt;=n;i++) &#123; emin=min(dp[i],emin); &#125; cout&lt;&lt;sum-emin&lt;&lt;endl;&#125; 注意，在这个过程中的易错点是： 进入队列的是元素下标不是元素内容！！，且每一次循环不一定一定有元素从头部出队。 另一个例题：华中科技大学2023新生赛A题 [HUSTFC 2023] 简单的加法乘法计算题 题目描述 JokerShaco 有一个数字 xxx，最开始 x=0x=0x=0，他想要把 xxx 变成 yyy。为了达到这个目标，他可以利用两个集合 AAA 和 BBB。其中集合 AAA 包含 nnn 个元素，分别是从 111 到 nnn 的所有正整数；集合 BBB 包含 mmm 个元素。每次它可以对 xxx 进行如下任意次操作： 选择 AAA 中的一个元素 aaa，令 xxx 加上 aaa。 选择 BBB 中的一个元素 bbb，令 xxx 乘以 bbb。 已知 yyy，nnn，mmm 和 BBB 中 mmm 个元素的具体值，JokerShaco 想知道让 xxx 变成 yyy 的最少操作次数。 输入格式 第一行包含三个整数 y (1≤y≤5⋅106)y\\ (1\\le y\\le 5\\cdot 10^6)y (1≤y≤5⋅106)，n (1≤n≤5⋅106)n\\ (1\\le n\\le 5\\cdot 10^6)n (1≤n≤5⋅106) 和 m (1≤m≤10)m\\ (1\\le m\\le 10)m (1≤m≤10)，其含义如题目所述。 第二行包含 mmm 个正整数，其中第 iii 个表示 BBB 中的第 iii 个元素 bi (1≤bi≤5⋅106)b_i\\ (1\\le b_i\\le 5\\cdot 10^6)bi​ (1≤bi​≤5⋅106)。 输出格式 输出一个整数，表示让 xxx 变成 yyy 的最少操作次数。在题目条件下可知一定能将 xxx 变成 yyy。 样例 #1 样例输入 #1 1210 3 12 样例输出 #1 13 样例 #2 样例输入 #2 12100 6 32 3 5 样例输出 #2 13 初步想法是利用线性动态规划进行，dp[i]表示y=i的时候需要走的最少步骤数，状态转移方程为： dp[i]=min( minE(k from i-1 to i-n) {dp[k]+1} , minE(r from 1 to m) if(dp[i]%b[r]=0）dp[i]/b[r] ) 可行代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxsize=5000005;int dp[maxsize]=&#123;0&#125;;deque &lt;int&gt; dq;signed main()&#123; long long b[11]; long long y,n,m; cin&gt;&gt;y&gt;&gt;n&gt;&gt;m; for(long long i=1;i&lt;=m;i++) &#123; cin&gt;&gt;b[i]; &#125; for(int j=1;j&lt;maxsize;j++) &#123; dp[j]=INT_MAX; &#125; for (long long i = 1; i &lt;= y; i++) &#123; if(i&lt;=n) &#123; dp[i]=1; &#125; else &#123; dp[i]=min(dp[i],dp[dq.front()]+1); for (long long r = 1; r &lt;= m; r++) &#123; if (i % b[r] == 0) &#123; dp[i] = min(dp[i], dp[i / b[r]] + 1); &#125; &#125; &#125; if(!dq.empty() &amp;&amp; dq.front()&lt;=i-n) &#123; dq.pop_front(); &#125; while(!dq.empty() &amp;&amp; dp[dq.back()]&gt;dp[i]) &#123; dq.pop_back(); &#125; dq.push_back(i);//注意队列中始终是位置，而不是元素内容 &#125; cout&lt;&lt;dp[y]&lt;&lt;endl;&#125; 特定类型的题型：多重背包的单调队列优化 宝物筛选 题目描述 终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。 这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。 小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 WWW 的采集车，洞穴里总共有 nnn 种宝物，每种宝物的价值为 viv_ivi​，重量为 wiw_iwi​，每种宝物有 mim_imi​ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。 输入格式 第一行为一个整数 nnn 和 WWW，分别表示宝物种数和采集车的最大载重。 接下来 nnn 行每行三个整数 vi,wi,miv_i,w_i,m_ivi​,wi​,mi​。 输出格式 输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。 样例 #1 样例输入 #1 123454 203 9 35 9 19 4 28 1 3 样例输出 #1 147 提示 对于 30%30\\%30% 的数据，n≤∑mi≤104n\\leq \\sum m_i\\leq 10^4n≤∑mi​≤104，0≤W≤1030\\le W\\leq 10^30≤W≤103。 对于 100%100\\%100% 的数据，n≤∑mi≤105n\\leq \\sum m_i \\leq 10^5n≤∑mi​≤105，0≤W≤4×1040\\le W\\leq 4\\times 10^40≤W≤4×104，1≤n≤1001\\leq n\\le 1001≤n≤100。 多重背包的原始状态转移方程： f(i,j)=max(f(i−1,j),f(i−1,j−v)+w,⋯,f(i−1,j−sv)+sw) f(i,j−v)=max(f(i−1,j−v),f(i−1,j−2v)+w,⋯,f(i−1,j−(s+1)v)+(s)w) f(i,j−2v)=max(f(i−1,j−2v),f(i−1,j−3v)+w,⋯,f(i−1,j−(s+2)v)+sw) … 此处我们取 r = j % v f(i,r+sv)=max(f(i−1,r+sv),f(i−1,r+(s−1)v)+w,⋯,f(i−1,r)+sw) ⋯ f(i,r+2v)=max(f(i−1,r+2v),f(i−1,r+v)+w,f(i−1,r)+2w) f(i,r+v)=max(f(i−1,r+v),f(i−1,r)+w) f(i,r)=f(i−1,r) 朴素二维数组代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxsize=4e2+5;int dp[maxsize][maxsize]=&#123;0&#125;;int v[105],w[105],m[105],n,W;signed main()&#123; cin&gt;&gt;n&gt;&gt;W; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i]; &#125; for(int i=1;i&lt;=n;i++)//当前考虑到第i件物品 &#123; for(int r=0;r&lt;w[i];r++)//考虑余数r，余数可能为0~w[i]-1中的任意一个数字 &#123; deque&lt;int&gt; q; for(int j=r;j&lt;=W;j+=w[i]) &#123; while(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i]) q.pop_front(); while (!q.empty() &amp;&amp; dp[i - 1][q.back()] + (j - q.back()) / w[i] * v[i] &lt;= dp[i - 1][j]) q.pop_back(); q.push_back(j); dp[i][j] = dp[i - 1][q.front()] + (j - q.front()) / w[i] * v[i]; &#125; &#125; &#125; cout&lt;&lt;dp[n][W]&lt;&lt;endl; return 0; &#125; 一维数组空间优化代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxsize=4e4+5;int dp[maxsize]=&#123;0&#125;,g[maxsize]=&#123;0&#125;;int v[10005],w[10005],m[10005],n,W;signed main()&#123; cin&gt;&gt;n&gt;&gt;W; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;m[i]; &#125; for(int i=1;i&lt;=n;i++)//当前考虑到第i件物品 &#123; for(int r=0;r&lt;w[i];r++)//考虑余数r，余数可能为0~w[i]-1中的任意一个数字 &#123; deque&lt;int&gt; q; memcpy(g,dp,sizeof(dp)); for(int j=r;j&lt;=W;j+=w[i]) &#123; while(!q.empty() &amp;&amp; j-q.front()&gt;m[i]*w[i]) q.pop_front(); while (!q.empty() &amp;&amp; g[q.back()] + (j - q.back()) / w[i] * v[i] &lt;= g[j]) q.pop_back(); q.push_back(j); dp[j] = g[q.front()] + (j - q.front()) / w[i] * v[i]; &#125; &#125; &#125; cout&lt;&lt;dp[W]&lt;&lt;endl; return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP的单调队列优化","slug":"算法/动态规划/DP的单调队列优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP的单调队列优化","slug":"DP的单调队列优化","permalink":"https://xqc-1368.github.io/tags/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"}]},{"title":"04 状态压缩DP：吃奶酪+Vitamin","slug":"04 状态压缩DP：吃奶酪+Vitamin","date":"2024-08-17T06:53:17.207Z","updated":"2024-08-17T14:31:30.692Z","comments":true,"path":"2024/08/17/04 状态压缩DP：吃奶酪+Vitamin/","permalink":"https://xqc-1368.github.io/2024/08/17/04%20%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP%EF%BC%9A%E5%90%83%E5%A5%B6%E9%85%AA+Vitamin/","excerpt":"","text":"吃奶酪 题目描述 房间里放着 nnn 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0)(0,0)(0,0) 点处。 输入格式 第一行有一个整数，表示奶酪的数量 nnn。 第 222 到第 (n+1)(n + 1)(n+1) 行，每行两个实数，第 (i+1)(i + 1)(i+1) 行的实数分别表示第 iii 块奶酪的横纵坐标 xi,yix_i, y_ixi​,yi​。 输出格式 输出一行一个实数，表示要跑的最少距离，保留 222 位小数。 样例 #1 样例输入 #1 1234541 11 -1-1 1-1 -1 样例输出 #1 17.41 提示 数据规模与约定 对于全部的测试点，保证 1≤n≤151\\leq n\\leq 151≤n≤15，∣xi∣,∣yi∣≤200|x_i|, |y_i| \\leq 200∣xi​∣,∣yi​∣≤200，小数点后最多有 333 位数字。 提示 对于两个点 (x1,y1)(x_1,y_1)(x1​,y1​)，(x2,y2)(x_2, y_2)(x2​,y2​)，两点之间的距离公式为 (x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1​−x2​)2+(y1​−y2​)2​。 2022.7.132022.7.132022.7.13：新增加一组 Hack\\text{Hack}Hack 数据。 本题使用状态压缩动态规划：状态压缩DP用于解决N小于21的图论问题（本身需要搜索解决的） 理解状压DP： DP[ j ][ S ]表示已走过S的二进制表示的路径，目前终点为 j ； 比如S是00110101表示已走过第一个点，第三个点，第五个点，第六个点。 而假如所给输入一共有n个点，单独表示第一个点记为1&lt;&lt;0,单独表示第二个点记为1&lt;&lt;1由此类推单独表示第n个点为1&lt;&lt;(n-1)，表示已经走过n个点中所有的点，为(1&lt;&lt;n)-1因此，最外层循环枚举 00000000~11111111这所有的情况 核心部分代码： 123456for(int S=1;S&lt;(1&lt;&lt;n);S++)//S for(int i=1;i&lt;=n;i++)//i if(S &amp; (1&lt;&lt;(i-1)))//2 for(int j=1;j&lt;=n;j++) if (!(S &amp; (1 &lt;&lt; (j - 1))) &amp;&amp; G[i][j]!=-1)//3 dp[j][S | (1 &lt;&lt; (j - 1))] = min(dp[j][S | (1 &lt;&lt; (j - 1))] , dp[i][S] + G[i][j]); 状态转移方程为： if(S的j-1项为0) ： dp[j][S的j-1项置1]=minE(i from 1 to n and S的第i项为1) {dp[i][S]+G[i][j]}其中G为邻接表 总体思路： 以j为终点 枚举每个可能的i 到 j，所需要的权值，求最小； //S的一层循环提供了每个可能的已走过的路径： //i一层循环枚举了目前处于第i个点，但是第i个点不一定在当前的S状态下被走过，所以我们需要判断语句//2，来知晓是否被走过，如果没被走过，则不用再往下考虑。 S&amp;(1&lt;&lt;(i-1)) 表示S从右往左数第（i-1）位为1； 为什么要i-1，因为我们想最大化利用空间，S最右边是第零位，即S=00000001 = =1&lt;&lt;(1-1)以此类推； //j这层循环中枚举了每个在当前的S的状态下，还未到达过的点，即S为0的位置，//3处判断表示当前已走过路径的S的（j-1）位未走过（即为0），并且G[i][j]!=-1表示当前枚举的i可以到达j，G是一个整体的邻接表。 接下来填充dp[ j ][ S | (1 &lt;&lt; ( j - 1 ) ) ]位置的数字，即dp当中，以j位置结尾，已走过路径为当前的S在第（j-1）位加上1，即路径上的第j位表示走过 的数字等于每一个以i结尾，已走过路径为S的dp表格值加上i到j的权值的和的最小值，于是，我们求出整个dp表格 最后关于如何寻找最值位置的问题： 1234for(int i=1;i&lt;=n;i++) &#123; ans = ans &gt; dp[i][(1 &lt;&lt; n) - 1] ? dp[i][(1 &lt;&lt; n) - 1] : ans; &#125; ans为输出的最短路径规划，遍历每一个终点，寻找走过（1&lt;&lt;n）-1即走过11111111的路径的所有终点状态，即找以1号位置结尾的11111111，以2号位置结尾的11111111········ 于是，我们求出了答案； 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define maxsize 17double dp[16][66000];//n最大值为15，因此取2的15次方大小，为了保险我取了16次方int main()&#123; int n; double x[maxsize]=&#123;0&#125;,y[maxsize]=&#123;0&#125;,G[maxsize][maxsize]=&#123;0&#125;; cin&gt;&gt;n; for(int i=0;i&lt;maxsize;i++) for(int j=0;j&lt;maxsize;j++) G[i][j]=-1; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) &#123; if(i==j)continue; G[i][j] =G[j][i]= sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j])); &#125; for(int i=0;i&lt;16;i++) for(int j=0;j&lt;66000;j++) &#123; dp[i][j]=DBL_MAX; &#125; for(int i=1;i&lt;=n;i++) &#123; dp[i][1 &lt;&lt; (i-1)] = sqrt((x[i]) * (x[i]) + (y[i]) * (y[i])); &#125; for(int S=1;S&lt;(1&lt;&lt;n);S++) &#123; for(int i=1;i&lt;=n;i++) &#123; if(S &amp; (1&lt;&lt;(i-1))) &#123; for(int j=1;j&lt;=n;j++) &#123; if (!(S &amp; (1 &lt;&lt; (j - 1))) &amp;&amp; G[i][j]!=-1) &#123; dp[j][S | (1 &lt;&lt; (j - 1))] = dp[j][S | (1 &lt;&lt; (j - 1))] &gt; dp[i][S] + G[i][j] ? dp[i][S] + G[i][j] : dp[j][S | (1 &lt;&lt; (j - 1))]; &#125; &#125; &#125; &#125; &#125; double ans=INT_MAX; for(int i=1;i&lt;=n;i++) &#123; ans = ans &gt; dp[i][(1 &lt;&lt; n) - 1] ? dp[i][(1 &lt;&lt; n) - 1] : ans; &#125; printf(&quot;%.2lf&quot;,ans); return 0;&#125; 上面的题目是对图论的dp方法，下面的例题显然可以看出的状压dp Vitamins 题面翻译 数据有nnn组数,每组数有一个价值cic_ici​和一个字符串S,字符串S中包含3个字母A,B,C，问集齐ABC三个字母的最小价值（一个字母可以有多个） 样例 #1 样例输入 #1 1234545 C6 B16 BAC4 A 样例输出 #1 115 样例 #2 样例输入 #2 123210 AB15 BA 样例输出 #2 1-1 样例 #3 样例输入 #3 123456510 A9 BC11 CA4 A5 B 样例输出 #3 113 样例 #4 样例输入 #4 12345676100 A355 BCA150 BC160 AC180 B190 CA 样例输出 #4 1250 样例 #5 样例输入 #5 12325 BA11 CB 样例输出 #5 116 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define maxsize 1005#define int long longint c[maxsize] = &#123;0&#125;, a[maxsize] = &#123;0&#125;, dp[10] = &#123;0&#125;;void mark(int x, string s)&#123; for (int i = 0; i &lt; s.size(); i++) &#123; a[x] = a[x] | (1 &lt;&lt; ((long long)s[i] - 65)); &#125;&#125;signed main()&#123; int n; string s; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; c[i] &gt;&gt; s; mark(i, s); &#125; for (int j = 0; j &lt; 10; j++) &#123; dp[j] = LONG_LONG_MAX / pow(10, 10); &#125; for (int i = 1; i &lt;= n; i++) &#123; dp[0] = 0; for (int st = (1 &lt;&lt; 3) - 1; st &gt;= 0; st--) &#123; dp[st | a[i]] = min(dp[st | a[i]], dp[st] + c[i]); &#125; &#125; if (dp[(1 &lt;&lt; 3) - 1] == (long long)(LONG_LONG_MAX / pow(10, 10))) dp[(1 &lt;&lt; 3) - 1] = -1; cout &lt;&lt; dp[(1 &lt;&lt; 3) - 1] &lt;&lt; endl; return 0;&#125; 第一次实现了状压dp可视化！！！！","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"算法/动态规划/状压DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"https://xqc-1368.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"03 区域DP：三素数数","slug":"03 区域DP：三素数数","date":"2024-08-17T06:53:17.204Z","updated":"2024-08-18T09:39:30.356Z","comments":true,"path":"2024/08/17/03 区域DP：三素数数/","permalink":"https://xqc-1368.github.io/2024/08/17/03%20%E5%8C%BA%E5%9F%9FDP%EF%BC%9A%E4%B8%89%E7%B4%A0%E6%95%B0%E6%95%B0/","excerpt":"","text":"区域DP：三素数数 三素数数 题目背景 蛟川书院的一道练习题QAQ 题目描述 如果一个数的所有连续三位数字都是大于100的素数，则该数称为三素数数。比如113797是一个6位的三素数数。 输入格式 一个整数n（3 ≤ n ≤ 10000），表示三素数数的位数。 输出格式 一个整数，表示n位三素数的个数m，要求输出m除以10^9 + 9的余数。 样例 #1 样例输入 #1 14 样例输出 #1 1204 提示 区域动归QAQ 设dp[k][i][j]表示到了第k位，这个数字是i，上一个数字是j的方案数 初始化 dp[2][0→9][0→9]=1 枚举第几位i，现在的数字now，之前的数字pre，上上个数字last 如果last∗100+pre+10+now是素数，那么dp[i][now][pre]+=dp[i−1][pre][last] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define int long longusing namespace std;vector&lt;int&gt; prime;int dp[10001][11][11]=&#123;0&#125;;const int MOD=1e9+9;vector&lt;bool&gt; is_prime(1001); // 0表示质数，1表示不是质数void get_prime(int n)//欧拉筛板子&#123; is_prime[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (is_prime[i] == 0) prime.push_back(i); for (auto j : prime) &#123; if (i * j &gt; n) break; is_prime[i * j] = 1; if (i % j == 0) break; &#125; &#125; for(int i=0;i&lt;=100;i++)is_prime[i]=1; //仅需要统计101~999的质数，剩下的不属于这个范围&#125;int combine(int a,int b,int c)&#123; return a*100+b*10+c;&#125;signed main()&#123; int n; cin&gt;&gt;n; get_prime(1000); for(int i=0;i&lt;=9;i++) for(int j=0;j&lt;=9;j++) dp[2][i][j]=1; for(int k=3;k&lt;=n;k++) &#123; for(int i=1;i&lt;=9;i+=2) &#123; for(int j=0;j&lt;=9;j++) &#123; for(int l=0;l&lt;=9;l++) &#123; if(is_prime[combine(l,j,i)]==0) dp[k][i][j]=(dp[k][i][j]+dp[k-1][j][l])%MOD; &#125; &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;=9;i++)for(int j=0;j&lt;=9;j++)ans=(ans+dp[n][i][j])%MOD; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 另一道题目：Colo. 题目描述 小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 n，宽度为 1 的网格图上画画，从左往右第 i 个方格被涂成了一种颜色 a_i。 你觉得他的随意涂鸦太难看了，想要保留恰好 k 种颜色（你不能保留没在网格图上出现的颜色），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。 此外，小 Y 使用的第 i 种颜色有一个价值 b_i，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。 你需要求出你能够获得的最大的价值是多少。 输入格式 第一行两个整数 n,k，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。 第二行 n 个整数 a_i，表示小 Y 画出来的网格图从左往右第 i 个格子的颜色。 第三行 n 个整数 b_i，表示第 i 种颜色的价值。 输出格式 一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 -1。 样例 #1 样例输入 #1 1235 21 2 1 3 25 3 1 100 100 样例输出 #1 16 样例 #2 样例输入 #2 12310 31 3 4 2 9 3 4 2 5 11 5 2 3 9 8 1 2 3 10 样例输出 #2 1-1 提示 【样例解释 #1】 对于第一组样例，我们可以选择 1 号和 3 号颜色保留，剩下的网格图即为 [1,1,3]，满足单调不下降这一个限制，获得的价值即为 b_1+b_3=5+1=6，可以证明这是最优的办法。 【数据范围】 对于所有测试数据，满足 1 \\le n \\le 500，1 \\le k \\le 500，1 \\le a_i \\le n，1 \\le b_i \\le 10^9。 各测试点的附加限制如下表所示。 本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 \\text{Subtask}。 测试点 n,k \\le 特殊性质 1 \\sim 3 10 无 4 \\sim 5 100 无 6 \\sim 10 500 不同的颜色不超过 10 种 11 \\sim 15 500 每种颜色出现的次数不超过 2 次 16 \\sim 20 500 无 首先是输入部分代码 在输入时候用bucket的方式记录每一种颜色的对应第一个和最后一个位置（后面有用） 记录方式用桶的方式便于查询 12345678910111213cin&gt;&gt;n&gt;&gt;k;for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(bucket[a[i]].begin ==inf)&#123; bucket[a[i]].begin =i; bucket[a[i]].last =i; &#125; else &#123; bucket[a[i]].last =i; &#125; &#125;for (int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; 接下来记录遍历每个颜色（对于每个颜色i） ，看看有哪些颜色（即j）在原数组中的位置是完全在他前面的，即 j 颜色的last小于 i 颜色的begin，(并且j&lt;i由循环条件可知默认成立)。如果有的话加入到数组g的第 i 项指向的（可以这么理解）数组中去。表示在取 i 颜色时候，可以取 j 颜色作为他的前驱 1234567891011121314long long g[505][505]=&#123;0&#125;; for(int i=1;i&lt;=n;i++)&#123; count=0; if(bucket[i].begin ==inf)continue; for(int j=1;j&lt;i;j++)&#123; if(bucket[j].begin ==inf)continue; if(bucket[i].begin &gt;bucket[j].last )&#123; g[i][count]=j; count++; &#125; &#125; &#125; 最重要的部分：填表 表格含义如下 123456789for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) dp[1][i]=b[i]; for(int i=2;i&lt;=k;i++)//i循环 for(int j=i;j&lt;=n;j++)//j循环 if(bucket[j].begin !=inf &amp;&amp; g[j][0]!=0) for(int p=0;g[j][p]!=0;p++)//p循环 if(dp[i-1][g[j][p]] !=0) dp[i][j]=max(dp[i][j],dp[i-1][g[j][p]]+b[j]);//# 以样例二为例 关键数组信息 第一行循环设置递推初始调件； 第二个 i 循环，遍历从第二行到第k行，因为问的是选k个，再往下遍历没有意义 第三个 j 循环，遍历第 i 列到最后的值，ij用来定位每个位置 以上好像都是废话。。 第四个p循环，遍历当前所在位置的上一行中所有可能成为该位置前驱的位置，#处表示取这些通过状态转移方程到该位置的所有值的最大值 最后，遍历第k行找出所有可能情况的最大值，没有，则输出-1 123456long long maxf=0; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) maxf=max(maxf,dp[k][i]); if(maxf==0)maxf=-1; cout&lt;&lt;maxf&lt;&lt;endl; 完整代码附上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define inf -1using namespace std;long long g[505][505]=&#123;0&#125;; typedef struct&#123; long long begin; long long last;&#125;edge;edge bucket[505];int main(void)&#123; long long n,k,a[505],b[505],dp[505][505]=&#123;0&#125;,count; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;=n;i++)&#123; bucket[i].begin =inf; bucket[i].last =inf; &#125; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(bucket[a[i]].begin ==inf)&#123; bucket[a[i]].begin =i; bucket[a[i]].last =i; &#125; else &#123; bucket[a[i]].last =i; &#125; &#125; for (int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; for(int i=1;i&lt;=n;i++)&#123; count=0; if(bucket[i].begin ==inf)continue; for(int j=1;j&lt;i;j++)&#123; if(bucket[j].begin ==inf)continue; if(bucket[i].begin &gt;bucket[j].last )&#123; g[i][count]=j; count++; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) dp[1][i]=b[i]; for(int i=2;i&lt;=k;i++) for(int j=i;j&lt;=n;j++) if(bucket[j].begin !=inf &amp;&amp; g[j][0]!=0) for(int p=0;g[j][p]!=0;p++) if(dp[i-1][g[j][p]] !=0) dp[i][j]=max(dp[i][j],dp[i-1][g[j][p]]+b[j]); long long maxf=0; for(int i=1;i&lt;=n;i++) if(bucket[i].begin !=inf) maxf=max(maxf,dp[k][i]); if(maxf==0)maxf=-1; cout&lt;&lt;maxf&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区域DP","slug":"算法/动态规划/区域DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9FDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区域DP","slug":"区域DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E5%9F%9FDP/"}]},{"title":"02 区间DP：涂色","slug":"02 区间DP：涂色","date":"2024-08-17T06:53:17.201Z","updated":"2024-08-18T09:38:36.708Z","comments":true,"path":"2024/08/17/02 区间DP：涂色/","permalink":"https://xqc-1368.github.io/2024/08/17/02%20%E5%8C%BA%E9%97%B4DP%EF%BC%9A%E6%B6%82%E8%89%B2/","excerpt":"","text":"[CQOI2007] 涂色 题目描述 假设你有一条长度为 555 的木板，初始时没有涂过任何颜色。你希望把它的 555 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 555 的字符串表示这个目标：RGBGR\\texttt{RGBGR}RGBGR。 每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 RRRRR\\texttt{RRRRR}RRRRR，第二次涂成 RGGGR\\texttt{RGGGR}RGGGR，第三次涂成 RGBGR\\texttt{RGBGR}RGBGR，达到目标。 用尽量少的涂色次数达到目标。 输入格式 输入仅一行，包含一个长度为 nnn 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。 输出格式 仅一行，包含一个数，即最少的涂色次数。 样例 #1 样例输入 #1 1AAAAA 样例输出 #1 11 样例 #2 样例输入 #2 1RGBGR 样例输出 #2 13 提示 40%40\\%40% 的数据满足 1≤n≤101\\le n\\le 101≤n≤10。 100%100\\%100% 的数据满足 1≤n≤501\\le n\\le 501≤n≤50。 区间dp的plus版：我愿称之为完全区间dp 把从i到j的所有情况列在对应表格中；我们发现： GBBR可以分解为（此处为常规区间dp） G+BBR GB+BR GBB+R 这3种情况（隔板法分割把区间一分为二） 当然也会出现不用讨论分隔直接完成的：比如RGBBR相对于RGBB就可以相等； 首先赋初值，对角线为初值，赋1； 然后我们可以手动填上第二个斜线上的数字，我们可以看见，因为s[2]==s[3]，所以只要在刷一个的时候范围刷大刷到另一个所在位置即可，故dp[ i ][ j ] = =dp[ i-1 ][ j ]==dp[i+1][ j ] 所以当区间 i~j 首末数字相等时，可以直接 ”刷过来“ ，即等于下面的或者左边的； 当区间 i~j 首末数字不相等时候，则用区间dp对当前空格位置代表的字符串切分，比出一个最小值 例如GBBR可以分解为（此处为常规区间dp） G+BBR dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ] GB+BR dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ] GBB+R dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ] 这3种情况（隔板法分割把区间一分为二） 因此：dp[ 1 ][ 4 ]=max{ dp[ 1 ][ 1 ]+dp[ 2 ][ 4 ] , dp[ 1 ][ 2 ]+dp[ 3 ][ 4 ] , dp[ 1 ][ 3 ]+dp[ 4 ][ 4 ] }; 由此我们得到对于任意一个dp[ i ][ j ]的状态转移方程 dp[ i ][ j ]= case1: dp[ i-1 ][ j ] or dp[i+1][ j ] ( if s[ i ]==s[ j ] ) case 2: maxE(k from i to j-1){dp[ i ][ k ]+dp[ k+1 ][ j ]} ( if s[ i ]!=s[ j ] ) 由此我们就可以很愉快的敲代码了 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define maxsize 55using namespace std;int dp[maxsize][maxsize]=&#123;0&#125;;int main() &#123; string s; memset(dp,0x3f,sizeof(dp)); cin&gt;&gt;s; for(int i=0;i&lt;s.size();i++) dp[i][i]=1; for(int p=0;p&lt;s.size()-1;p++)//注意见下 for(int i=0,j=p+1;j&lt;s.size();i++,j++) &#123; if(s[i]==s[j])dp[i][j]=dp[i+1][j]; else &#123; dp[i][j]=dp[i][i]+dp[i+1][j]; for(int k=i;k&lt;j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]); &#125; &#125; cout&lt;&lt;dp[0][s.size()-1]&lt;&lt;endl; return 0; &#125; 这里的p是指对第2~n个主对角线方向的斜线的遍历（第一个斜线即主对角线已经遍历过了）","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"}]},{"title":"背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚","slug":"01 背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚","date":"2024-08-17T06:53:17.196Z","updated":"2024-08-17T14:31:12.026Z","comments":true,"path":"2024/08/17/01 背包DP：Make_Full_Use_Of模型：kkksc03考前临时抱佛脚/","permalink":"https://xqc-1368.github.io/2024/08/17/01%20%E8%83%8C%E5%8C%85DP%EF%BC%9AMake_Full_Use_Of%E6%A8%A1%E5%9E%8B%EF%BC%9Akkksc03%E8%80%83%E5%89%8D%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/","excerpt":"","text":"kkksc03考前临时抱佛脚 题目背景 kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。 题目描述 这次期末考试，kkksc03 需要考 444 科。因此要开始刷习题集，每科都有一个习题集，分别有 s1,s2,s3,s4s_1,s_2,s_3,s_4s1​,s2​,s3​,s4​ 道题目，完成每道题目需要一些时间，可能不等（A1,A2,…,As1A_1,A_2,\\ldots,A_{s_1}A1​,A2​,…,As1​​，B1,B2,…,Bs2B_1,B_2,\\ldots,B_{s_2}B1​,B2​,…,Bs2​​，C1,C2,…,Cs3C_1,C_2,\\ldots,C_{s_3}C1​,C2​,…,Cs3​​，D1,D2,…,Ds4D_1,D_2,\\ldots,D_{s_4}D1​,D2​,…,Ds4​​）。 kkksc03 有一个能力，他的左右两个大脑可以同时计算 222 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。 由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。 输入格式 本题包含 555 行数据：第 111 行，为四个正整数 s1,s2,s3,s4s_1,s_2,s_3,s_4s1​,s2​,s3​,s4​。 第 222 行，为 A1,A2,…,As1A_1,A_2,\\ldots,A_{s_1}A1​,A2​,…,As1​​ 共 s1s_1s1​ 个数，表示第一科习题集每道题目所消耗的时间。 第 333 行，为 B1,B2,…,Bs2B_1,B_2,\\ldots,B_{s_2}B1​,B2​,…,Bs2​​ 共 s2s_2s2​ 个数。 第 444 行，为 C1,C2,…,Cs3C_1,C_2,\\ldots,C_{s_3}C1​,C2​,…,Cs3​​ 共 s3s_3s3​ 个数。 第 555 行，为 D1,D2,…,Ds4D_1,D_2,\\ldots,D_{s_4}D1​,D2​,…,Ds4​​ 共 s4s_4s4​ 个数，意思均同上。 输出格式 输出一行,为复习完毕最短时间。 样例 #1 样例输入 #1 123451 2 1 3 54 362 4 3 样例输出 #1 120 提示 1≤s1,s2,s3,s4≤201\\leq s_1,s_2,s_3,s_4\\leq 201≤s1​,s2​,s3​,s4​≤20。 1≤A1,A2,…,As1,B1,B2,…,Bs2,C1,C2,…,Cs3,D1,D2,…,Ds4≤601\\leq A_1,A_2,\\ldots,A_{s_1},B_1,B_2,\\ldots,B_{s_2},C_1,C_2,\\ldots,C_{s_3},D_1,D_2,\\ldots,D_{s_4}\\leq601≤A1​,A2​,…,As1​​,B1​,B2​,…,Bs2​​,C1​,C2​,…,Cs3​​,D1​,D2​,…,Ds4​​≤60。 本题为背包dp的 “ 简单 ” 变式：虽然简单变一变本蒟蒻已经不会了。 一开始的思路是贪心算法：对每一组而言先排序，然后从后向前把元素往两个空脑子里丢，哪个脑子目前内容比较少就丢哪个。 代码如下，喜提零分（听取蛙声一片） 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#include &lt;algorithm&gt;#include &lt;queue&gt;const int maxsize = 25;int n, inp;int min_time(int a[],int n)&#123; if(n==1)return a[0]; int lsum=0,rsum=0; sort(a,a+n); for(int i=n-1;i&gt;=0;i--) &#123; if(lsum&gt;rsum)rsum+=a[i]; else lsum+=a[i]; &#125; return max(lsum,rsum);&#125;int main()&#123; int sum_time=0,na,nb,nc,nd; int a[maxsize],b[maxsize],c[maxsize],d[maxsize]; cin&gt;&gt;na&gt;&gt;nb&gt;&gt;nc&gt;&gt;nd; for(int i=0;i&lt;na;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;nb;i++) cin&gt;&gt;b[i]; for (int i = 0; i &lt; nc; i++) cin &gt;&gt; c[i]; for (int i = 0; i &lt; nd; i++) cin &gt;&gt; d[i]; cout &lt;&lt; min_time(a, na) + min_time(b, nb) + min_time(c, nc) + min_time(d, nd) &lt;&lt; endl; return 0;&#125; 注意：以上代码为错误代码！！！！！！！！！ 因为可以找到一组hack数据 12//在某一行：10 10 6 6 5 3 按照贪心算法 10 6 5 10 6 3 max为21 但是实际上： 10 10 6 6 5 3 max为20 于是验证了贪心的不可行性，而这种退一步达到全局最优解的情况，就应该使用dp 这道题使用的是最基本的背包dp。我们由以上思路可以知晓，当两个脑子处理的内容大小最接近 的时候将会达到本组最优解。于是我给第一个脑子一个容量预算为sum/2（即背包容量），在运算过程中不能超过这个预算。通过将每个选择装进背包的物品的v等价于其重量w这种方法，由此得出最大化利用sum/2的背包空间所能装得下的处理总量，即dp[ sum/2 ]; 而max（sum-dp[ sum/2 ]，dp[ sum/2 ]）即为某一组耗时。 1234567891011121314int dynamic_programming(int sum,int homework[],int n)&#123; if(n==1)return homework[1]; int dp[2501]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=sum/2;j&gt;=homework[i];j--) &#123; dp[j]=max(dp[j],dp[j-homework[i]]+homework[i]); &#125; &#125; return max(sum - dp[sum / 2], dp[sum / 2]); // return sum - dp[sum / 2];&#125; 此外由于int是除以2（在正数范围内）向下取整的特性，可以数学证明sum-dp[ sum/2 ]总是大于dp[ sum/2 ]，所以注释行也还可以那样输出。 最后，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int a[5];int dynamic_programming(int sum,int homework[],int n)&#123; if(n==1)return homework[1]; int dp[2501]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) &#123; for(int j=sum/2;j&gt;=homework[i];j--) &#123; dp[j]=max(dp[j],dp[j-homework[i]]+homework[i]); &#125; &#125; return max(sum - dp[sum / 2], dp[sum / 2]); // return sum - dp[sum / 2];&#125;int main()&#123; int b[21] = &#123;0&#125;,ans=0; for (int i = 1; i &lt;= 4; i++) cin &gt;&gt; a[i]; for(int i=1;i&lt;=4;i++) &#123; int sum=0; memset(b,0,sizeof(b)); for(int j=1;j&lt;=a[i];j++) &#123; cin&gt;&gt;b[j]; sum+=b[j]; &#125; ans+=dynamic_programming(sum,b,a[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包DP","slug":"算法/动态规划/背包DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包DP","slug":"背包DP","permalink":"https://xqc-1368.github.io/tags/%E8%83%8C%E5%8C%85DP/"}]},{"title":"11 期望DP：收集邮票","slug":"11 期望DP：收集邮票","date":"2024-08-17T06:53:17.192Z","updated":"2024-08-17T14:32:13.333Z","comments":true,"path":"2024/08/17/11 期望DP：收集邮票/","permalink":"https://xqc-1368.github.io/2024/08/17/11%20%E6%9C%9F%E6%9C%9BDP%EF%BC%9A%E6%94%B6%E9%9B%86%E9%82%AE%E7%A5%A8/","excerpt":"","text":"11期望DP 收集邮票 题目描述 有 nnn 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 nnn 种邮票中的哪一种是等概率的，概率均为 1/n1/n1/n。但是由于凡凡也很喜欢邮票，所以皮皮购买第 kkk 次邮票需要支付 kkk 元钱。 现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。 输入格式 一行，一个数字 NNN（N≤10000N \\le 10000N≤10000）。 输出格式 输出要付出多少钱，保留二位小数。 样例 #1 样例输入 #1 13 样例输出 #1 121.25 定义状态 众所周知，期望DP的定义状态一般都为已经……还需要……的期望 由于本题需要求的就是 自己得到所有种类的邮票需要花费的钱数目的期望。 那么我们就可以定义一个 ex ，它的意义是： ex(i)ex(i)ex(i)：已经收集到了 i 种邮票，还需要花费的钱数的期望。 但是题目中有一个条件 皮皮购买第k张邮票需要支付k元钱 这意味着购买价格是与购买次数有关的。 所以我们还需要定义一个状态 num ，它的意义是：num(i)num(i)num(i)： 已经收集到了 i 种邮票，还需要购买的次数的期望。 初始化：num(n)=0num(n)=0num(n)=0，ex(n)=0ex(n)=0ex(n)=0 这个应该不需要我讲吧qwq 状态转移 首先吧这个写在前面 期望公式：E(X)=∑pi​⋅xiE(X)= \\sum pi​⋅xiE(X)=∑pi​⋅xi​ ，其中 pi​ 是事件 i 发生的概率，xi​ 是权值。 发现 num 的转移是比较简单的，先考虑 num。有以下两种情况： 买到之前买到过的邮票种类，此时 x=num(i)+1x=num(i)+1x=num(i)+1（种类总数不变），p=inp=\\frac{i}{n}p=ni​​ 买到之前没有买到过的，此时 x=num(i+1)+1x=num(i+1)+1x=num(i+1)+1（总种类数量+1），p=n−inp=\\frac{n-i}{n}p=nn−i​​ 注：以上的 x 指的是次数。 根据公式，我们就可以得到关于 num 的公式： num(i)=(num(i)+1)×in+(num(i+1)+1)×n−innum(i)=(num(i)+1)×\\frac{i}{n}+(num(i+1)+1)×\\frac{n-i}{n}num(i)=(num(i)+1)×ni​+(num(i+1)+1)×nn−i​ 化简之后得到状态转移方程： num(i)=num(i+1)×n−in+11−n−in​num(i)= \\frac{num(i+1)×\\frac{n-i}{n}+1}{1−\\frac{n-i}{n}}​ num(i)=1−nn−i​num(i+1)×nn−i​+1​​ 得到 num 后，我们再思考 ans 的转移，同样是以上的两种情况 买到之前买到过的邮票种类：此时 x=ex(i)+num(i)+1x=ex(i)+num(i)+1x=ex(i)+num(i)+1（种类+1，总花费=之前花费+本次花费），p=inp=\\frac{i}{n}p=ni​ 买到之前没有买到过的，此时x=ex(i+1)+num(i+1)+1x=ex(i+1)+num(i+1)+1x=ex(i+1)+num(i+1)+1（同上），p=n−inp=\\frac{n-i}{n}p=nn−i​ 然后我们又轻松地得到了关于 ex 的公式： ex(i)=(ex(i)+num(i)+1)×in​+(ex(i+1)+num(i+1)+1)×​n−inex(i)=(ex(i)+num(i)+1)×\\frac{i}{n}​+(ex(i+1)+num(i+1)+1)×​\\frac{n-i}{n}ex(i)=(ex(i)+num(i)+1)×ni​​+(ex(i+1)+num(i+1)+1)×​nn−i​ 请自行化简 既然我们有了转移方程，那就开写呗 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;double num[10005]=&#123;0&#125;,ex[10005]=&#123;0&#125;;signed main()&#123; int n; cin&gt;&gt;n; num[n]=0;ex[n]=0; for(int i=n-1;i&gt;=0;i--) &#123; double p=(double)n/(n-i); num[i]=p+num[i+1]; ex[i]=p*num[i]+ex[i+1]; &#125; // for(int i=0;i&lt;=n;i++)cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; // for(int i=0;i&lt;=n;i++)cout&lt;&lt;ex[i]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; printf(&quot;%.2lf&quot;,ex[0]); //cout&lt;&lt;ex[0]&lt;&lt;&quot;\\n&quot;; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"期望DP","slug":"算法/动态规划/期望DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"期望DP","slug":"期望DP","permalink":"https://xqc-1368.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"}]},{"title":"CSS定位","slug":"09 CSS定位","date":"2024-08-17T02:28:01.411Z","updated":"2024-08-17T02:19:44.500Z","comments":true,"path":"2024/08/17/09 CSS定位/","permalink":"https://xqc-1368.github.io/2024/08/17/09%20CSS%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"定位 今日目标 能够说出 为什么要用定位 能够说出 定位的 4 种分类 能够说出 4 种定位各自的特点 能够说出 为什么常用子绝父相布局 能够写出 淘宝轮播图布局 能够说出 显示隐藏的 3 种方式以及区别 1. 定位(position) 介绍 1.1 为什么使用定位 我们先来看一个效果，同时思考一下用标准流或浮动能否实现类似的效果？ 场景1： 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子. 场景2：当我们滚动窗口的时候，盒子是固定屏幕某个位置的。 结论：要实现以上效果，标准流 或 浮动都无法快速实现 所以： 1.浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 2.定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 1.2 定位组成 定位：将盒子定在某一个位置，所以定位也是在摆放盒子， 按照定位的方式移动盒子 定位也是用来布局的，它有两部分组成： 定位 = 定位模式 + 边偏移 定位模式 用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 1.2.1 边偏移（方位名词） 边偏移 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性。 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 1.2.2 定位模式 (position) 在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 123选择器 &#123; position: 属性值; &#125; 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个： 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 1.3 定位模式介绍 1.3.1. 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none，静态定位static，不要定位的时候用。 语法： 123选择器 &#123; position: static; &#125; 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 1.3.2. 相对定位(relative) - 重要 相对定位是元素在移动位置的时候，是相对于它自己原来的位置来说的（自恋型）。 语法： 123选择器 &#123; position: relative; &#125; 相对定位的特点：（务必记住） 1.它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。 2.原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。 因此，相对定位并没有脱标。它最典型的应用是给绝对定位当爹的。。。 效果图： 1.3.3. 绝对定位(absolute) - 重要 1.3.3.1 绝对定位的介绍 绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的（拼爹型）。 语法： 123选择器 &#123; position: absolute; &#125; 完全脱标 —— 完全不占位置； 父元素没有定位，则以浏览器为准定位（Document 文档）。 父元素要有定位 元素将依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的特点总结：（务必记住） 1.如果没有祖先元素或者祖先元素没有定位，则以浏览器为基准定位（Document 文档）。 2.如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。 3.绝对定位不再占有原先的位置。所以绝对定位是脱离标准流的。（脱标） 1.3.3.2 定位口诀 —— 子绝父相 弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。 这个**“子绝父相”太重要了，是我们学习定位的口诀**，是定位中最常用的一种方式这句话的意思是：子级是绝对定位的话，父级要用相对定位。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 ①子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 ②父盒子需要加定位限制子盒子在父盒子内显示。 ③父盒子布局时，需要占有位置，因此父亲只能是相对定位。 这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。 总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。 疑问：为什么在布局时，子级元素使用绝对定位时，父级元素就要用相对定位呢？ 观察下图，思考一下在布局时，左右两个方向的箭头图片以及父级盒子的定位方式。 分析： 方向箭头叠加在其他图片上方，应该使用绝对定位，因为绝对定位完全脱标，完全不占位置。 父级盒子应该使用相对定位，因为相对定位不脱标，后续盒子仍然以标准流的方式对待它。 如果父级盒子也使用绝对定位，会完全脱标，那么下方的广告盒子会上移，这显然不是我们想要的。 结论：父级要占有位置，子级要任意摆放，这就是子绝父相的由来。 1.3.4. 固定定位(fixed) - 重要 固定定位是元素固定于浏览器可视区的位置。（认死理型） 主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。 语法： 123选择器 &#123; position: fixed; &#125; 固定定位的特点：（务必记住）： 1.以浏览器的可视窗口为参照点移动元素。 跟父元素没有任何关系 不随滚动条滚动。 2.固定定位不在占有原先的位置。 固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。（认死理型） 完全脱标—— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 固定定位举例： 提示：IE 6 等低版本浏览器不支持固定定位。 小tip：固定在版心右侧 12345.fixed&#123; position:fixed; left:50%; margin-left:版面宽度的一半&#125; 1.3.5 粘性定位(sticky) - 了解 粘性定位可以被认为是相对定位和固定定位的混合。 Sticky 粘性的 语法： 1234选择器 &#123; position: sticky; top: 10px; &#125; 粘性定位的特点： 1.以浏览器的可视窗口为参照点移动元素（固定定位特点） 2.粘性定位占有原先的位置（相对定位特点） 3.必须添加 top 、left、right、bottom 其中一个才有效 跟页面滚动搭配使用。 兼容性较差，IE 不支持。 1.3.6 定位总结 定位模式 是否脱标 移动位置 是否常用 static 静态定位 否 不能使用边偏移 很少 relative 相对定位 否 (占有位置) 相对于自身位置移动 基本单独使用 absolute绝对定位 是（不占有位置） 带有定位的父级 要和定位父级元素搭配使用 fixed 固定定位 是（不占有位置） 浏览器可视区 单独使用，不需要父级 sticky 粘性定位 否 (占有位置) 浏览器可视区 当前阶段少 一定记住 相对定位、固定定位、绝对定位 两个大的特点： 1. 是否占有位置（脱标否） 2. 以谁为基准点移动位置。 学习定位重点学会子绝父相。 注意： 边偏移需要和定位模式联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 2. 综合案例：学成在线-hot 模块添加 2. 1 案例截图： 2.2 案例分析 一个大的 li 中包含 一个课程图片，课程介绍文字信息，还有hot的小图标； hot图片重叠在课程图片上面—— 脱标，不占位置，需要使用绝对定位； hot图片重叠在li的右上方 —— 需要使用边偏移确定准确位置。 2.3 案例小结 子绝父相 —— 子元素使用绝对定位，父元素使用相对定位； 与浮动的对比： 绝对定位：脱标，利用边偏移指定准确位置； 浮动：脱标，不能指定准确位置，让多个块级元素在一行显示。 课堂练习：模拟老师的随堂案例完成哈根达斯案例（5 分钟）。 结构修改： 123456789101112131415&lt;!-- 修改.box-bd里面的li标签内容，添加一个hot图标 --&gt;&lt;li&gt; &lt;!-- 添加hot小图片 --&gt; &lt;em&gt; &lt;img src=&quot;images/hot.png&quot; alt=&quot;&quot;&gt; &lt;/em&gt; &lt;img src=&quot;images/pic.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt; Think PHP 5.0 博客系统实战项目演练 &lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt;&lt;/li&gt; 样式修改： 123456789101112131415161718192021222324252627.box-bd ul li &#123; /* 子绝父相 */ /* 父元素相对定位 */ position: relative; float: left; width: 228px; height: 270px; background-color: #fff; margin-right: 15px; margin-bottom: 15px;&#125;.box-bd ul li &gt; img &#123; width: 100%;&#125;.box-bd ul li h4 &#123; margin: 20px 20px 20px 25px; font-size: 14px; color: #050505; font-weight: 400;&#125;.box-bd ul li em &#123; /* 子元素绝对定位 */ position: absolute; top: 4px; right: -4px;&#125; 3. 定位(position)的应用 3.1. 固定定位小技巧： 固定在版心左侧位置。 小算法： 1.让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。 2.让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。 案例效果： 123456789101112131415161718192021222324&lt;style&gt; .w &#123; width: 800px; height: 1400px; background-color: pink; margin: 0 auto; &#125; .fixed &#123; position: fixed; /* 1. 走浏览器宽度的一半 */ left: 50%; /* 2. 利用margin 走版心盒子宽度的一半距离 */ margin-left: 405px; width: 50px; height: 150px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt; &lt;div class=&quot;w&quot;&gt;版心盒子 800像素&lt;/div&gt;&lt;/body&gt; 3.2. 堆叠顺序（z-index） 在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴) 语法： 123选择器 &#123; z-index: 1; &#125; z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。如下图所示： 案例演示：堆叠顺序。 4. 定位(position)的拓展 4.1 绝对定位的盒子居中：注意不能用margin：0 auto 注意：加了绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中。 但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 盒子居中定位示意图 4.2 定位特殊特性 绝对定位和固定定位也和浮动类似。 1.行内元素添加绝对或者固定定位，可以直接设置高度和宽度。 2.块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。 前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 4.3 脱标的盒子不会触发外边距塌陷 浮动元素、**绝对定位(固定定位）**元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的） 也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。 4.4 绝对定位（固定定位）会完全压住盒子 浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片） 但是绝对定位（固定定位） 会压住下面标准流所有的内容。 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素 5. 综合案例 - 淘宝轮播图(重点) 5.1 效果图 5.2 布局分析 5.3 步骤 大盒子我们类名为： tb-promo 淘宝广告 里面先放一张图片。 左右两个按钮 用链接就好了。 左箭头 prev 右箭头 next ​ 左按钮样式（border-radius：左上，右上，右下，左下）， ​ 右按钮定位，提取左右按钮共同的样式代码（并集选择器） 底侧小圆点ul 继续做。 类名为 promo-nav ​ 中间长方形椭圆 ul的定位（水平居中，离底部15px） ​ 长方形需要五个小圆点，ul无序列表，li浮动，椭圆中小圆点的样式 5.4 知识点：圆角矩形设置4个角 圆角矩形可以为4个角分别设置圆度， 但是是有顺序的 1234border-top-left-radius:20px;border-top-right-radius:20px;border-bottom-right-radius:20px;border-bottom-left-radius:20px; 如果4个角，数值相同 1border-radius: 15px; 里面数值不同，我们也可以按照简写的形式，具体格式如下: 1border-radius: 左上角 右上角 右下角 左下角; 还是遵循的顺时针。 5.5 代码参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;淘宝轮播图做法&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; &#125; .tb-promo &#123; position: relative; width: 520px; height: 280px; background-color: pink; margin: 100px auto; &#125; .tb-promo img &#123; width: 520px; height: 280px; &#125; /* 并集选择器可以集体声明相同的样式 */ .prev, .next &#123; position: absolute; /* 绝对定位的盒子垂直居中 */ top: 50%; margin-top: -15px; /* 加了绝对定位的盒子可以直接设置高度和宽度 */ width: 20px; height: 30px; background: rgba(0, 0, 0, .3); text-align: center; line-height: 30px; color: #fff; text-decoration: none; &#125; .prev &#123; left: 0; /* border-radius: 15px; */ border-top-right-radius: 15px; border-bottom-right-radius: 15px; &#125; .next &#123; /* 如果一个盒子既有left属性也有right属性，则默认会执行 left属性 同理 top bottom 会执行 top */ right: 0; /* border-radius: 15px; */ border-top-left-radius: 15px; border-bottom-left-radius: 15px; &#125; .promo-nav &#123; position: absolute; bottom: 15px; left: 50%; margin-left: -35px; width: 70px; height: 13px; /* background-color: pink; */ background: rgba(255,255,255, .3); border-radius: 7px; &#125; .promo-nav li &#123; float: left; width: 8px; height: 8px; background-color: #fff; border-radius: 50%; margin: 3px; &#125; /* 不要忘记选择器权重的问题 */ .promo-nav .selected &#123; background-color: #ff5000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tb-promo&quot;&gt; &lt;img src=&quot;images/tb.jpg&quot; alt=&quot;&quot;&gt; &lt;!-- 左侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;prev&quot;&gt; &lt; &lt;/a&gt; &lt;!-- 右侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;next&quot;&gt; &gt; &lt;/a&gt; &lt;!-- 小圆点 --&gt; &lt;ul class=&quot;promo-nav&quot;&gt; &lt;li class=&quot;selected&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. 网页布局总结 通过盒子模型，清楚知道大部分html标签是一个盒子。 通过CSS浮动、定位 可以让每个盒子排列成为网页。 一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。 6.1. 标准流 可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。 6.2. 浮动 可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局 6.3. 定位 定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 7. 元素的显示与隐藏 目的（本质） ​ 让一个元素在页面中消失或者显示出来 场景 ​ 类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 7.1. display 显示（重点） display 设置或检索对象是否及如何显示。 123display: none 隐藏对象display：block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： display 隐藏元素后，不再占有原来的位置。 后面应用及其广泛，搭配 JS 可以做很多的网页特效。实际开发场景： 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 7.2. visibility 可见性 （了解） visibility 属性用于指定一个元素应可见还是隐藏。 123visibility：visible ; 元素可视visibility：hidden; 元素隐藏 特点：visibility 隐藏元素后，继续占有原来的位置。（停职留薪） 如果隐藏元素想要原来位置， 就用 visibility：hidden 如果隐藏元素不想要原来位置， 就用 display：none (用处更多 重点） 7.3. overflow 溢出（重点） overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。 但是如果有定位的盒子， 请慎用overflow:hidden 因为它会隐藏多余的部分。 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 7.4. 显示与隐藏总结 属性 区别 用途 display 显示 （重点） 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 可见性 （了解） 隐藏对象，保留位置 使用较少 overflow 溢出（重点） 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 8 综合案例：土豆网鼠标经过显示遮罩 8.1. 效果图 8.2. 案例目标 1.练习元素的显示与隐藏 2.练习元素的定位 8.3. 核心原理 原先半透明的黑色遮罩看不见， 鼠标经过 大盒子，就显示出来。 遮罩的盒子不占有位置， 就需要用绝对定位 和 display 配合使用。 8.4. 代码参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;仿土豆网显示隐藏遮罩案例&lt;/title&gt; &lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .mask &#123; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面遮罩层显示出来 */ .tudou:hover .mask &#123; /* 而是显示元素 */ display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS绝对定位","slug":"CSS绝对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS相对定位","slug":"CSS相对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS定位注意事项","slug":"CSS定位注意事项","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AE%9A%E4%BD%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"CSS子绝父相","slug":"CSS子绝父相","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8/"},{"name":"CSS元素显示与隐藏","slug":"CSS元素显示与隐藏","permalink":"https://xqc-1368.github.io/tags/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"name":"CSS溢出处理","slug":"CSS溢出处理","permalink":"https://xqc-1368.github.io/tags/CSS%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/"}]},{"title":"CSS浮动布局","slug":"08 CSS 浮动布局 float","date":"2024-08-17T02:28:01.400Z","updated":"2024-08-17T02:11:10.177Z","comments":true,"path":"2024/08/17/08 CSS 浮动布局 float/","permalink":"https://xqc-1368.github.io/2024/08/17/08%20CSS%20%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80%20float/","excerpt":"","text":"一、浮动 1、传统网页布局的三种方式 ​ CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)： 普通流（标准流） 浮动 定位 这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。 注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。 2、标准流（普通流/文档流） 所谓的标准流: 就是标签按照规定好默认方式排列 块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等 以上都是标准流布局，我们前面学习的就是标准流，标准流是最基本的布局方式。 3、为什么需要浮动？ ​ 总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式. ​ 浮动最典型的应用：可以让多个块级元素一行内排列显示。 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 4、什么是浮动？ ​ float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 语法： 1选择器 &#123; float: 属性值; &#125; 5、浮动特性 加了浮动之后的元素,会具有很多特性,需要我们掌握的. 1、浮动元素会脱离标准流(脱标：浮动的盒子不再保留原先的位置) 2、浮动的元素会一行内显示并且元素顶部对齐 注意： ​ 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。 3、浮动的元素会具有行内块元素的特性 如果行内元素or块元素有了浮动，则都自动转换为行内块元素 ​ 浮动元素的大小根据内容来决定 ​ 浮动的盒子中间是没有缝隙的 6、浮动元素经常和标准流父级搭配使用 为了约束浮动元素位置, 我们网页布局一般采取的策略是: ​ 先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧 二、常见网页布局 浮动布局注意点 1、浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置 2、一个元素浮动了，理论上其余的兄弟元素也要浮动。 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流. 三、清除浮动 1、为什么需要清除浮动？ ​ 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。 2、清除浮动本质 清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度 注意： 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。 父级有了高度，就不会影响下面的标准流了 3、清除浮动样式 语法： 1选择器&#123;clear:属性值;&#125; 我们实际工作中， 几乎只用 clear: both; 清除浮动的策略是: 闭合浮动. 4、清除浮动的多种方式 自动设置父div的高度 4.1、额外标签法（不常用） 额外标签法也称为隔墙法，是 W3C 推荐的做法。 使用方式： ​ 额外标签法会在浮动元素末尾添加一个空的标签。 1例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;，或者其他标签（如&lt;br /&gt;等）。 ​ 优点： 通俗易懂，书写方便 ​ 缺点： 添加许多无意义的标签，结构化较差 ​ 注意： 要求这个新的空标签必须是块级元素。 总结: ​ 1、清除浮动本质是? ​ 清除浮动的本质是清除浮动元素脱离标准流造成的影响 ​ 2、清除浮动策略是? ​ 闭合浮动. 只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子. ​ 3、额外标签法? ​ 隔墙法, 就是在最后一个浮动的子元素后面添 ​ 4、加一个额外标签, 添加 清除浮动样式. ​ 实际工作可能会遇到,但是不常用 4.2、父级添加 overflow 属性 可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。 例如： 1overflow:hidden | auto | scroll; 优点：代码简洁 缺点：无法显示溢出的部分 注意：是给父元素添加代码 4.3、父级添加after伪元素 :after 方式是额外标签法的升级版。给父元素添加： 12345678910.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; /* IE6、7 专有 */ *zoom: 1;&#125; 在父元素里面写成： 123&lt;div class=&quot;原有类 clearfix&quot;&gt; ......&lt;/div&gt; 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站： 百度、淘宝网、网易等 4.4、父级添加双伪元素 给父元素添加 12345678910.clearfix:before,.clearfix:after &#123; content:&quot;&quot;; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 在父元素里面写成： 123&lt;div class=&quot;原有类 clearfix&quot;&gt; ......&lt;/div&gt; 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 总结 为什么需要清除浮动？ 父级没高度。 子盒子浮动了。 影响下面布局了，我们就应该清除浮动了。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS浮动float","slug":"CSS浮动float","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B5%AE%E5%8A%A8float/"},{"name":"CSS清除浮动","slug":"CSS清除浮动","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"}]},{"title":"CSS盒子模型","slug":"07 CSS 盒子模型 BoxModel","date":"2024-08-17T02:28:01.389Z","updated":"2024-08-17T02:05:56.499Z","comments":true,"path":"2024/08/17/07 CSS 盒子模型 BoxModel/","permalink":"https://xqc-1368.github.io/2024/08/17/07%20CSS%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%20BoxModel/","excerpt":"","text":"一、盒子模型 1、网页布局的本质 网页布局的核心本质： 就是利用 CSS 摆盒子。 网页布局过程： 先准备好相关的网页元素，网页元素基本都是盒子 Box 。 利用 CSS 设置好盒子样式，然后摆放到相应位置。 往盒子里面装内容 2、盒子模型（Box Model）组成 ​ 盒子模型：把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 ​ CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 实际内容 3、边框（border） 3.1、边框的使用 1、border可以设置元素的边框。边框有三部分组成：边框宽度(粗细) 边框样式 边框颜色； 2、语法： 1border : border-width || border-style || border-color; 边框样式 border-style 可以设置如下值： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 3、边框的合写分写 边框简写： 1border: 1px solid red; 边框分开写法： 1border-top: 1px solid red; /* 只设定上边框， 其余同理 */ 3.2、表格的细线边框 123456789101112&lt;style&gt; table&#123; width:500px; height:249px; &#125; table,td,th&#123; border:1px solid pink; border-collapse:collaspe; font-size:14px; text-align:center; &#125;&lt;/style&gt; 1、border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 2、语法： 1border-collapse:collapse; collapse 单词是合并的意思 border-collapse: collapse; 表示相邻边框合并在一起 3.3、边框会影响盒子实际大小 边框会额外增加盒子的实际大小。因此我们有两种方案解决： 测量盒子大小的时候,不量边框。 如果测量的时候包含了边框,则需要 width/height 减去边框宽度 4、内边距（padding） 4.1、内边距的使用方式 1、padding 属性用于设置内边距，即边框与内容之间的距离。 2、语法： 合写属性： 分写属性： 4.2、内边距会影响盒子实际大小 1、当我们给盒子指定 padding 值之后，发生了 2 件事情： 内容和边框有了距离，添加了内边距。 padding影响了盒子实际大小。 2、内边距对盒子大小的影响： 如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。 如何盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小。 3、解决方案： ​ 如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。 利用padding撑开盒子做法：导航栏字数不同时候 5、外边距（margin） 5.1、外边距的使用方式 123&lt;style&gt; p&#123;margin-top:30px;&#125;&lt;/style&gt; margin 属性用于设置外边距，即控制盒子和盒子之间的距离。 5.2、外边距典型应用 外边距可以让块级盒子水平居中的两个条件： 盒子必须指定了宽度（width）。 盒子左右的外边距都设置为 auto 。 常见的写法，以下三种都可以： 123margin-left: auto; margin-right: auto;margin: auto;margin: 0 auto; 注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。 5.3、外边距合并 使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。 主要有两种情况: 1、相邻块元素垂直外边距的合并 ​ 当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。 解决方案： 尽量只给一个盒子添加 margin 值。 2、嵌套块元素垂直外边距的塌陷 ​ 对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方案： 可以为父元素定义上边框。 .father&#123; border:1px solid transparent; &#125; &lt;!--code￼7--&gt; 可以为父元素添加 overflow:hidden。(不会使盒子变大) .father&#123; overflow:hidden; &#125; &lt;!--code￼8--&gt; ​ 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了 二、盒子模型的其他样式 1、圆角边框 在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。 border-radius 属性用于设置元素的外边框圆角。 语法： 1border-radius:length; 参数值可以为数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius 兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用 2、盒子阴影 CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。 语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 1box-shadow:10px 10px 10px -4px rgba(0,0,0,.3) 3、文字阴影 在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。 语法： 1text-shadow: h-shadow v-shadow blur color; 1text-shadow: 5px 5px 6px rgba(0,0,0,.3)","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS盒子模型","slug":"CSS盒子模型","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"name":"CSS边框样式","slug":"CSS边框样式","permalink":"https://xqc-1368.github.io/tags/CSS%E8%BE%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/"},{"name":"CSS内边距padding","slug":"CSS内边距padding","permalink":"https://xqc-1368.github.io/tags/CSS%E5%86%85%E8%BE%B9%E8%B7%9Dpadding/"},{"name":"CSS外边距margin","slug":"CSS外边距margin","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%96%E8%BE%B9%E8%B7%9Dmargin/"},{"name":"CSS清除内外边距","slug":"CSS清除内外边距","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E5%86%85%E5%A4%96%E8%BE%B9%E8%B7%9D/"},{"name":"CSS圆角边框","slug":"CSS圆角边框","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/"},{"name":"CSS盒子阴影","slug":"CSS盒子阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1/"}]},{"title":"CSS显示模式","slug":"06 CSS 元素的显示模式","date":"2024-08-17T02:28:01.364Z","updated":"2024-08-17T02:37:08.439Z","comments":true,"path":"2024/08/17/06 CSS 元素的显示模式/","permalink":"https://xqc-1368.github.io/2024/08/17/06%20CSS%20%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、css的显示模式 1、什么是元素的显示模式 定义： ​ 元素显示模式就是元素（标签）以什么方式进行显示，比如自己占一行，比如一行可以放多个。 作用： ​ 网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。 2、元素显示模式的分类 2.1、块元素 常见的块元素： 1&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; ​ 标签是最典型的块元素。 块级元素的特点： 比较霸道，自己独占一行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： ​ 文字类的元素内不能放块级元素 12&lt;p&gt; 标签主要用于存放文字，因此 &lt;p&gt; 里面不能放块级元素，特别是不能放&lt;div&gt; 同理， &lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 2.2、行内元素 常见的行内元素： 1&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; ​ 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 12345&lt;style&gt; span&#123; background-color:hotpink; &#125;&lt;/style&gt; 注意： 链接里面不能再放链接 特殊情况链接 &lt;a&gt; 里面可以放块级元素，但是给 &lt;a&gt; 转换一下块级模式最安全 2.3、行内块元素 常见的行内块标签： 1&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt; ​ 它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 行内块元素的特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。 一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点）。 123456&lt;style&gt; input&#123; width:250px; height:39px; &#125;&lt;/style&gt; 2.4、元素显示模式总结 ​ 学习元素显示模式的主要目的就是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。 3、元素显示模式的转换 简单理解: ​ 一个模式的元素需要另外一种模式的特性 ​ 比如想要增加链接 &lt;a&gt; 的触发范围。 转换方式 转换为块元素：display:block; 转换为行内元素：display:inline; 转换为行内块：display: inline-block; 123456789101112131415161718&lt;style&gt; a&#123; height:150px; width:150px; background-color:pink; display:block; &#125; div&#123; background-color:purple; display:inline; &#125; span&#123; height:300px; width:30px; background-color:blue; display:inline-block; &#125;&lt;/style&gt; 案例，小米侧边栏 4、单行文字垂直居中的代码 解决方案: ​ 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中 实现： line-height:40px; 简单理解: ​ 行高的上空隙和下空隙把文字挤到中间了， ​ 如果行高小于盒子高度,文字会偏上， ​ 如果行高大于盒子高度,则文字偏下。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS显示模式","slug":"CSS显示模式","permalink":"https://xqc-1368.github.io/tags/CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"},{"name":"CSS块元素","slug":"CSS块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS行内元素","slug":"CSS行内元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"},{"name":"CSS行内块元素","slug":"CSS行内块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0/"}]},{"title":"CSS选择器","slug":"05 CSS 选择器 Selector","date":"2024-08-17T02:28:01.343Z","updated":"2024-08-17T01:57:46.906Z","comments":true,"path":"2024/08/17/05 CSS 选择器 Selector/","permalink":"https://xqc-1368.github.io/2024/08/17/05%20CSS%20%E9%80%89%E6%8B%A9%E5%99%A8%20Selector/","excerpt":"","text":"一、选择器分类 基本语法架构： CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明 CSS声明总是以分号 ; 结束，声明总以大括号 &#123;&#125; 括起来: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 标签选择器 1234p &#123; color:red; text-align:center;&#125; 类选择器 class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以一个点 . 号显示： 在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。 1.center &#123;text-align:center;&#125; 1在标签里面加上：class=&quot;nounderline gray&quot;就可以用了 你也可以指定特定的 HTML 元素使用 class。 在以下实例中, 所有的 p 元素使用 class=“center” 让该元素的文本居中: 1p.center &#123;text-align:center;&#125; id选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 以下的样式规则应用于元素属性 id=“para1”: 12345#para1&#123; text-align:center; color:red;&#125; 通配符选择器 1234*&#123; 属性1：属性值1 ; ......&#125; 二、css的复合选择器 1、什么是复合选择器？ ​ 在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。 ​ 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签） ​ 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等 2、后代选择器 (重要） 定义： ​ 后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 语法：(在head里面) 1234567891011121314&lt;style&gt; ol li &#123; color:pink; &#125; ol li a&#123; color:red; &#125;nav为class名 .nav li a&#123; color:yellow; &#125;&lt;/style&gt; ​ 上述语法表示选择元素 1 里面的所有元素 2 (后代元素)。 语法说明： 元素1 和 元素2 中间用空格隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可 元素1 和 元素2 可以是任意基础选择器 3、子选择器 (重要） 定义： ​ 子元素选择器（子选择器）只能选择作为某元素的最近一级子元素。 ​ （简单理解就是选亲儿子元素） 语法： 12345&lt;style&gt; .nav&gt;a&#123; color:red; &#125;&lt;/style&gt; ​ 上述语法表示选择元素1 里面的所有直接后代(子元素) 元素2。 语法说明： 元素1 和 元素2 中间用 大于号 隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 必须是亲儿子，其孙子、重孙之类都不归他管. 你也可以叫他 亲儿子选择器 例子： 4、并集选择器 (重要） 定义： ​ 并集选择器可以选择多组标签, 同时为他们定义相同的样式，通常用于集体声明。并集选择器是各选择器通过英文逗号（,）连接而成，任何形式的选择器都可以作为并集选择器的一部分。 语法： 1234567891011&lt;style&gt; div,p&#123; color:pink; &#125;或者 div, p, .pig li&#123; color:pink; &#125;&lt;/style&gt; ​ 上述语法表示选择元素1 和 元素2。 语法说明： 元素1 和 元素2 中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 例子： 5、伪类选择器 定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法： ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 6、链接伪类选择器 定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法：（请按照LVHA顺序书写，不能换序） 123456789101112131415&lt;style&gt; a:link&#123; color:#333 text-decoration:none; &#125; a:visited&#123; color:orange; &#125; a:hover&#123; color:skyblue; &#125; a:active&#123; color:green; &#125;&lt;/style&gt; ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 ​ a:link 没有点击过的(访问过的)链接 ​ a:visited 点击过的(访问过的)链接 ​ a:hover 鼠标经过的那个链接 ​ a:active 鼠标正在按下还没有弹起鼠标的那个链接 链接伪类选择器注意事项 ​ 为了确保生效，请按照 LVHA 的循顺序声明 :link－:visited－:hover－:active。 ​ 记忆法：love hate 或者 lv 包包 hao 。 ​ 因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 12345&lt;style&gt; a&#123; color:red; &#125;&lt;/style&gt; 链接伪类选择器实际工作开发中的写法：(重要) 7、:focus 伪类选择器 定义： ​ :focus 伪类选择器用于选取获得焦点的表单元素。 ​ 焦点就是光标，一般情况 类表单元素才能获取 例子： 123456&lt;style&gt; input:focus&#123; background-color:pink; color:red; &#125;&lt;/style&gt; 复合选择器总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS复合选择器","slug":"CSS复合选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS伪元素选择器","slug":"CSS伪元素选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS链接伪类选择器","slug":"CSS链接伪类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS属性选择器","slug":"CSS属性选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS类选择器","slug":"CSS类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS标签选择器","slug":"CSS标签选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSSID选择器","slug":"CSSID选择器","permalink":"https://xqc-1368.github.io/tags/CSSID%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS通配符选择器","slug":"CSS通配符选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%9A%E9%85%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS后代选择器","slug":"CSS后代选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS子选择器","slug":"CSS子选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS并集选择器","slug":"CSS并集选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"CSS背景","slug":"04 CSS 背景 background","date":"2024-08-17T02:28:01.319Z","updated":"2024-08-17T01:54:26.951Z","comments":true,"path":"2024/08/17/04 CSS 背景 background/","permalink":"https://xqc-1368.github.io/2024/08/17/04%20CSS%20%E8%83%8C%E6%99%AF%20background/","excerpt":"","text":"一、背景基础 CSS 背景属性用于定义HTML元素的背景。 CSS 属性定义背景效果: background-color background-color 属性定义了元素的背景颜色，页面的背景颜色使用在body的选择器中: 1body &#123;background-color:#b0c4de;&#125; 二、css的背景样式 通过 CSS 背景属性，可以给页面元素添加背景样式。 背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 1、背景颜色 样式名称： ​ background-color 定义元素的背景颜色 使用方式： 1background-color:颜色值; 其他说明： ​ 元素背景颜色默认值是 transparent（透明） 1background-color:transparent; 2、背景图片 样式名称： ​ background-image 定义元素的背景图片 使用方式： 1background-image:url(images/logo.png) 其他说明： ​ 实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置. (精灵图也是一种运用场景) ​ 注意：背景图片后面的地址，千万不要忘记加 URL， 同时里面的路径不要加引号。 3、背景平铺 样式名称： ​ background-repeat 设置元素背景图像的平铺 1background-repeat:repeat|no-repeat|repeat-x|repeat-y 使用方式： 4、背景图片位置 样式名称： ​ background-position 属性可以改变图片在背景中的位置 使用方式： ​ ​ 参数代表的意思是：x 坐标和 y 坐标。 可以使用 方位名词 或者 精确单位 其他说明： 1、参数是方位名词 ​ 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致 ​ 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 2、参数是精确单位 ​ 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标 ​ 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中 1background-poisition:20px 50px; 3、参数是混合单位 ​ 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标 wzry成长守护平台案例 虞姬皮肤全屏背景案例 5、背景图片固定 样式名称： ​ background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。 使用方式： ​ 其他说明： ​ background-attachment 后期可以制作视差滚动的效果。 6、背景样式合写 背景合写样式： ​ background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置; 使用方式： 7、背景色半透明 CSS3 提供了背景颜色半透明的效果。 使用方式： 最后一个参数是 alpha 透明度，取值范围在 0~1之间 我们习惯把 0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明，盒子里面的内容不受影响 CSS3 新增属性，是 IE9+ 版本浏览器才支持的，但是现在实际开发,我们不太关注兼容性写法了,可以放心使用 8、背景总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS背景","slug":"CSS背景","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF/"},{"name":"CSS背景平铺","slug":"CSS背景平铺","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%B9%B3%E9%93%BA/"},{"name":"CSS背景图片位置","slug":"CSS背景图片位置","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/"}]},{"title":"CSS字体","slug":"03 CSS 字体 font","date":"2024-08-17T02:28:01.297Z","updated":"2024-08-17T01:55:51.059Z","comments":true,"path":"2024/08/17/03 CSS 字体 font/","permalink":"https://xqc-1368.github.io/2024/08/17/03%20CSS%20%E5%AD%97%E4%BD%93%20font/","excerpt":"","text":"一、CSS 字体 CSS字体属性定义字体，加粗，大小，文字样式。 Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 字体系列 font-family 属性设置文本的字体系列。 font-family 属性应该设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，他将尝试下一种字体。 注意: 如果字体系列的名称超过一个字，它必须用引号，如Font Family：“宋体”。 多个字体系列是用一个逗号分隔指明： 1p&#123;font-family:&quot;Times New Roman&quot;, Times, serif;&#125; 字体样式 主要是用于指定斜体文字的字体样式属性。 这个属性有三个值： 正常 - 正常显示文本 斜体 - 以斜体字显示的文字 倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）字体大小 123p.normal &#123;font-style:normal;&#125;p.italic &#123;font-style:italic;&#125;p.oblique &#123;font-style:oblique;&#125;/*没什么用*/ 字体大小 font-size 属性设置文本的大小。 能否管理文字的大小，在网页设计中是非常重要的。但是，你不能通过调整字体大小使段落看上去像标题，或者使标题看上去像段落。 绝对大小： 设置一个指定大小的文本 不允许用户在所有浏览器中改变文本大小 确定了输出的物理尺寸时绝对大小很有用 相对大小： 相对于周围的元素来设置大小 允许用户在浏览器中改变文字大小 如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。 设置字体大小像素(绝对大小): 123h1 &#123;font-size:40px;&#125;h2 &#123;font-size:30px;&#125;p &#123;font-size:14px;&#125; 用em来设置字体大小(相对大小): 1h1 &#123;font-size:2.5em;&#125; font-weight 属性 123p.normal &#123;font-weight:normal;&#125;p.thick &#123;font-weight:bold;&#125;p.thicker &#123;font-weight:900;&#125; 属性值 值 描述 normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100 200 300 400 500 600 700 800900 定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold。 inherit 规定应该从父元素继承字体的粗细。 font复合属性 font 简写属性在一个声明中设置所有字体属性。 可设置的属性是（按顺序）： “font-style font-variant font-weight font-size/line-height font-family” font-size和font-family的值是必需的。如果缺少了其他值，默认值将被插入，如果有默认值的话。 123456789p.ex1&#123; font:15px arial,sans-serif;&#125;p.ex2&#123; font:italic bold 12px/30px Georgia, serif;&#125; 二、CSS 文本格式 文本颜色 颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 参阅 CSS 颜色值 查看完整的颜色值。 一个网页的背景颜色是指在主体内的选择： 123body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式 文本排列属性是用来设置文本的水平对齐方式。 文本可居中或对齐到左或右,两端对齐. 当text-align设置为&quot;justify&quot;，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。 123h1 &#123;text-align:center;&#125;p.date &#123;text-align:right;&#125;p.main &#123;text-align:justify;&#125; 文本修饰 text-decoration 属性用来设置或删除文本的装饰。 从设计的角度看 text-decoration属性主要是用来删除链接的下划线： 1a &#123;text-decoration:none;&#125; 也可以这样装饰文字： 123h1 &#123;text-decoration:overline;&#125;h2 &#123;text-decoration:line-through;&#125;h3 &#123;text-decoration:underline;&#125; 文本转换 文本转换属性是用来指定在一个文本中的大写和小写字母。 可用于所有字句变成大写或小写字母，或每个单词的首字母大写。 123p.uppercase &#123;text-transform:uppercase;&#125;p.lowercase &#123;text-transform:lowercase;&#125;p.capitalize &#123;text-transform:capitalize;&#125; 文本缩进 文本缩进属性是用来指定文本的第一行的缩进。 1p &#123;text-indent:50px;&#125; 三、文字阴影 在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。 语法： 1text-shadow: h-shadow v-shadow blur color; 1text-shadow: 5px 5px 6px rgba(0,0,0,.3)","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS文本格式属性","slug":"CSS文本格式属性","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%B1%9E%E6%80%A7/"},{"name":"CSS文本修饰","slug":"CSS文本修饰","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/"},{"name":"CSS文本对齐","slug":"CSS文本对齐","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS字体font","slug":"CSS字体font","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93font/"}]},{"title":"CSS配套工具","slug":"02 CSS 配套实用工具emmet，PS","date":"2024-08-17T02:28:01.281Z","updated":"2024-08-17T01:45:51.423Z","comments":true,"path":"2024/08/17/02 CSS 配套实用工具emmet，PS/","permalink":"https://xqc-1368.github.io/2024/08/17/02%20CSS%20%E9%85%8D%E5%A5%97%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7emmet%EF%BC%8CPS/","excerpt":"","text":"一、emmet语法 1、简介 ​ Emmet语法的前身是Zen coding,它使用缩写,来提高html/css的编写速度, Vscode内部已经集成该语法。 作用： ​ 快速生成HTML结构语法 ​ 快速生成CSS样式语法 2、快速生成HTML结构语法 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成&lt;div&gt;&lt;/div&gt; 如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 如果生成的div 类名是有顺序的， 可以用 自增符号 $ 如果想要在生成的标签内部写内容可以用 { } 表示 3、快速生成CSS样式语法 CSS 基本采取简写形式即可 ​ 比如 w200 按tab 可以 生成 width: 200px; ​ 比如 lh26px 按tab 可以生成 line-height: 26px; 4、快速格式化代码 Vscode 快速格式化代码: shift+alt+f 也可以设置 当我们 保存页面的时候自动格式化代码: 1）文件 ------.&gt;【首选项】----------&gt;【设置】； 2）搜索emmet.include; 3）在settings.json下的【工作区设置】中添加以下语句： ​ “editor.formatOnType”: true, ​ “editor.formatOnSave”: true 二、PS 基本操作 ​ 因为网页美工大部分效果图都是利用 PS（Photoshop）来做的，所以以后我们大部分切图工作都是在 PS 里面完成。 ​ 部分操作： 文件→打开 ：可以打开我们要测量的图片 Ctrl+R：可以打开标尺，或者 视图→标尺 右击标尺，把里面的单位改为像素 Ctrl+ 加号(+)可以放大视图， Ctrl+ 减号(-)可以缩小视图 按住空格键，鼠标可以变成小手，拖动 PS 视图 用选区拖动 可以测量大小 Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区 三、PS 切图 1、图层切图 1最简单的切图方式：右击图层 → 导出 → 切片。 2、切片切图 2.1、利用切片选中图片 1利用切片工具手动划出 2.2、导出选中的图片 1文件菜单 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储 。 3、PS插件切图 ​ Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 官网：http://www.cutterman.cn/zh/cutterman 注意：Cutterman 插件要求你的 PS 必须是完整版，不能是绿色版，所以大家需要安装完整版本。","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"emmet","slug":"emmet","permalink":"https://xqc-1368.github.io/tags/emmet/"},{"name":"PS","slug":"PS","permalink":"https://xqc-1368.github.io/tags/PS/"}]},{"title":"CSS简介","slug":"01 CSS 注释，三大特性，三种样式表","date":"2024-08-17T02:27:57.504Z","updated":"2024-08-17T02:32:33.313Z","comments":true,"path":"2024/08/17/01 CSS 注释，三大特性，三种样式表/","permalink":"https://xqc-1368.github.io/2024/08/17/01%20CSS%20%E6%B3%A8%E9%87%8A%EF%BC%8C%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E4%B8%89%E7%A7%8D%E6%A0%B7%E5%BC%8F%E8%A1%A8/","excerpt":"","text":"CSS (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS 文件扩展名为 .css。 一、CSS 注释 注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它。 CSS注释以 /* 开始, 以 */ 结束, 实例如下: 12/*这是个注释*/ /*这是另一个注释*/ 二、css三大特性 1、层叠性 ​ 相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题 ​ 层叠性原则: 样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 2、继承性 ​ CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。 子元素可以继承父元素的样式： ​ （text-，font-，line-这些元素开头的可以继承，以及color属性） 继承性口诀：龙生龙，凤生凤，老鼠生的孩子会打洞 行高的继承性： 123body &#123; font:12px/1.5 Microsoft YaHei；&#125; 行高可以跟单位也可以不跟单位 如果子元素没有设置行高，则会继承父元素的行高为 1.5 此时子元素的行高是：当前子元素的文字大小 * 1.5 body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高 3、优先级 当同一个元素指定多个选择器，就会有优先级的产生。 选择器相同，则执行层叠性 选择器不同，则根据选择器权重执行 选择器优先级计算表格： 优先级注意点: 权重是有4组数字组成,但是不会有进位。 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推… 等级判断从左向右，如果某一位数值相同，则判断下一位数值。 可以简单记忆法: 通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。 a链接浏览器默认制定了一个样式：蓝色下划线 a &#123;color:blue;&#125;因此需要手动指定样式 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。 权重虽然可以叠加，但是不存在进位 div ul li ------&gt; 0,0,0,3 .nav ul li ------&gt; 0,0,1,2 a:hover -----—&gt; 0,0,1,1 .nav a ------&gt; 0,0,1,1 案例1：继承权重为0 案例2：权重叠加 三、CSS 三种样式表 当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。 如何插入样式表？ 插入样式表的方法有三种: 外部样式表(External style sheet) 内部样式表(Internal style sheet) 内联样式(Inline style) 外部样式表 当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 标签链接到样式表。 标签在（文档的）头部： 1234&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;/*href后面跟css文件路径*/&lt;/head&gt; 内部样式表 当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 1234567&lt;head&gt;&lt;style&gt;hr &#123;color:sienna;&#125;p &#123;margin-left:20px;&#125;body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125;&lt;/style&gt;&lt;/head&gt; 内联样式（行内样式） 由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。 要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距： 1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS注释","slug":"CSS注释","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B3%A8%E9%87%8A/"},{"name":"CSS的插入","slug":"CSS的插入","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9A%84%E6%8F%92%E5%85%A5/"},{"name":"CSS优先级问题","slug":"CSS优先级问题","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"}]},{"title":"CSS杂项","slug":"10 CSS杂项","date":"2024-08-17T02:27:56.205Z","updated":"2024-08-17T02:27:36.920Z","comments":true,"path":"2024/08/17/10 CSS杂项/","permalink":"https://xqc-1368.github.io/2024/08/17/10%20CSS%E6%9D%82%E9%A1%B9/","excerpt":"","text":"CSS杂项 学习目标： ​ 能够使用精灵图 ​ 能够使用字体图标 ​ 能够写出 CSS 三角 ​ 能够写出常见的 CSS 用户界面样式 ​ 能够说出常见的布局技巧 1. 精灵图（重点） 1.1 为什么需要精灵图 一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。 为什么使用精灵图（目的）： ​ 为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。 核心原理： ​ 将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。 精灵图举例: 1.2 精灵图（sprites）的使用 使用精灵图核心： 精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。 这个大图片也称为 sprites 精灵图 或者 雪碧图 移动背景图片位置， 此时可以使用 background-position 。 移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同 因为一般情况下都是往上往左移动，所以数值是负值。 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。 使用精灵图核心总结： 精灵图主要针对于小的背景图片使用。 主要借助于背景位置来实现—background-position 。 一般情况下精灵图都是负值。（千万注意网页中的坐标： x轴右边走是正值，左边走是负值， y轴同理。） 1.3 案例：拼出自己名字 1.3.1 案例效果 1.3.2 代码参考 结构 1234&lt;span class=&quot;p&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;i&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;k&lt;/span&gt; 样式 12345678910111213141516171819202122232425262728span &#123; display: inline-block; background: url(images/abcd.jpg) no-repeat;&#125;.p &#123; width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px;&#125;.i &#123; width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px;&#125;.n &#123; width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px;&#125;.k &#123; width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px;&#125; 2. 字体图标 2.1 字体图标的产生 字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标。 精灵图是有诸多优点的，但是缺点很明显。 1.图片文件还是比较大的。 2.图片本身放大和缩小会失真。 3.一旦图片制作完毕想要更换非常复杂。 此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。 字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。 2.2 字体图标的优点 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器，请放心使用 注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。 总结： 1.如果遇到一些结构和样式比较简单的小图标，就用字体图标。 2.如果遇到一些结构和样式复杂一点的小图片，就用精灵图。 使用步骤 字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为： 1.字体图标的下载 2.字体图标的引入 （引入到我们html页面中） 3.字体图标的追加 （以后添加新的小图标） 2.3 字体图标的下载 推荐下载网站： icomoon 字库 http://icomoon.io 推荐指数 ★★★★★ IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 阿里 iconfont 字库 http://www.iconfont.cn/ 推荐指数 ★★★★★ 这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 AI制作图标上传生成。 重点是，免费！ 2.4 字体图标的引入 下载完毕之后，注意原先的文件不要删，后面会用。 把下载包里面的 fonts 文件夹放入页面根目录下 字体文件格式 不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。 1).TureType( .ttf )格式.ttf字体是Windows和Mac的最常见的字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+； 2).Web Open Font Format( .woff )格式woff字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+； 3).Embedded Open Type( .eot )格式.eot字体是IE专用字体，支持这种字体的浏览器有IE4+； 4).SVG( .svg )格式.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+； 2.在 CSS 样式中全局声明字体： 简单理解把这些字体文件通过css引入到我们页面中。 一定注意字体文件路径的问题 复制过来： 12345678910@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?7kkyc2&#x27;); src: url(&#x27;fonts/icomoon.eot?7kkyc2#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?7kkyc2&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?7kkyc2&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?7kkyc2#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal;&#125; html 标签内添加小图标。 给标签定义字体。 123span &#123; font-family: &quot;icomoon&quot;;&#125; 甚至可以改变颜色： 注意：务必保证 这个字体和上面@font-face里面的字体保持一致 2.5 字体图标的追加 如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。 把压缩包里面的 selection.json 从新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。 2.6 字体图标加载的原理： 3. CSS 三角 3.1 介绍 网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标。 一张图， 你就知道 CSS 三角是怎么来的了, 做法如下： 123456789div &#123; width: 0; height: 0; border: 50px solid transparent; border-color: red green blue black;/*以下两句话为了照顾兼容性而写*/ line-height:0; font-size: 0;&#125; 我们用css 边框可以模拟三角效果 宽度高度为0 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了 为了照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0; 3.2 案例：京东三角 3.2.1效果图 3.2.2 代码参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS 三角制作&lt;/title&gt; &lt;style&gt; .box1 &#123; width: 0; height: 0; /* border: 10px solid pink; */ border-top: 10px solid pink; border-right: 10px solid red; border-bottom: 10px solid blue; border-left: 10px solid green; &#125; .box2 &#123; width: 0; height: 0; border: 50px solid transparent; border-left-color: pink; margin: 100px auto; &#125; .jd &#123; position: relative; width: 120px; height: 249px; background-color: pink; &#125; .jd span &#123; position: absolute; right: 15px; top: -10px; width: 0; height: 0; /* 为了照顾兼容性 */ line-height: 0; font-size: 0; border: 5px solid transparent; border-bottom-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;jd&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. CSS 用户界面样式 什么是界面样式 所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓 防止表单域拖拽 4.1 鼠标样式 cursor 123li &#123; cursor: pointer; &#125; 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 4.2 轮廓线 outline 给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。 123input &#123; outline: none; &#125; 4.3 防止拖拽文本域 resize 实际开发中，我们文本域右下角是不可以拖拽的。(文本域尽量把两个textarea标签，放到一行书写，不然会出现莫名空格) 123textarea&#123; resize: none;&#125; vertical-align 属性应用 5. vertical-align 属性应用 CSS 的 vertical-align 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 官方解释： 用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。（如果是块元素应该先转换为行内块元素） 语法：图文中线对齐，在图的样式中加： 1vertical-align : baseline | top | middle | bottom 5.1 图片、表单和文字对齐 图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。 此时可以给图片、表单这些行内块元素的 vertical-align 属性设置为 middle 就可以让文字和图片垂直居中对齐了。 5.2 解决图片底部默认空白缝隙问题 bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。 主要解决方法有两种： 1.给图片添加 vertical-align:middle | top| bottom 等。 （提倡使用的） 2.把图片转换为块级元素 display: block; 6. 溢出的文字省略号显示 6.1 单行文本溢出显示省略号 单行文本溢出显示省略号–必须满足三个条件： 12345678/*1. 先强制一行内显示文本*/ white-space: nowrap; （ 默认 normal 自动换行）/*2. 超出的部分隐藏*/ overflow: hidden;/*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; 6.2 多行文本溢出显示省略号（了解） 多行文本溢出显示省略号，有较大兼容性问题，适合于webKit浏览器或移动端（移动端大部分是webkit内核） 1234567891011121314/*1. 超出的部分隐藏 */overflow: hidden;/*2. 文字用省略号替代超出的部分 */text-overflow: ellipsis;/* 3. 弹性伸缩盒子模型显示 */display: -webkit-box;/* 4. 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。 7. 常见布局技巧 巧妙利用一个技术更快更好的布局： margin负值的运用 文字围绕浮动元素 行内块的巧妙运用 CSS三角强化 7.1. margin负值运用 1.让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框 2.鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index） 7.2 文字围绕浮动元素 效果 布局示意图 巧妙运用浮动元素不会压住文字的特性 7.3 行内块巧妙运用 页码在页面中间显示: 把这些链接盒子转换为行内块， 之后给父级指定 text-align:center; 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中 7.4. CSS 三角强化 案例 7.4.1 原理 12345678910111213141516171819202122232425&lt;style&gt; .box1 &#123; width: 0; height: 0; /* 把上边框宽度调大 */ /* border-top: 100px solid transparent; border-right: 50px solid skyblue; */ /* 左边和下边的边框宽度设置为0 */ /* border-bottom: 0 solid blue; border-left: 0 solid green; */ /* 1.只保留右边的边框有颜色 */ border-color: transparent red transparent transparent; /* 2. 样式都是solid */ border-style: solid; /* 3. 上边框宽度要大， 右边框 宽度稍小， 其余的边框该为 0 */ border-width: 100px 50px 0 0 ; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt; 7.4.2 案例效果 7.4.3 代码参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS三角强化的巧妙运用&lt;/title&gt; &lt;style&gt; .price &#123; width: 160px; height: 24px; line-height: 24px; border: 1px solid red; margin: 0 auto; &#125; .miaosha &#123; position: relative; float: left; width: 90px; height: 100%; background-color:red; text-align: center; color: #fff; font-weight: 700; margin-right: 8px; &#125; .miaosha i &#123; position: absolute; right: 0; top: 0; width: 0; height: 0; border-color: transparent #fff transparent transparent; border-style: solid; border-width: 24px 10px 0 0; &#125; .origin &#123; font-size: 12px; color: gray; text-decoration: line-through; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;price&quot;&gt; &lt;span class=&quot;miaosha&quot;&gt; ¥1650 &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 8. CSS 初始化 不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS 初始化 简单理解： CSS初始化是指重设浏览器的样式。 (也称为CSS reset） 每个网页都必须首先进行 CSS初始化。 这里我们以 京东CSS初始化代码为例。 Unicode编码字体： 把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。 比如： 黑体 \\9ED1\\4F53 宋体 \\5B8B\\4F53 微软雅黑 \\5FAE\\8F6F\\96C5\\9ED1","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS精灵图","slug":"CSS精灵图","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS字体图标","slug":"CSS字体图标","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"},{"name":"CSS三角绘制","slug":"CSS三角绘制","permalink":"https://xqc-1368.github.io/tags/CSS%E4%B8%89%E8%A7%92%E7%BB%98%E5%88%B6/"}]},{"title":"HTML列表","slug":"05 HTML 列表 list","date":"2024-08-16T14:35:51.896Z","updated":"2024-08-16T14:35:38.344Z","comments":true,"path":"2024/08/16/05 HTML 列表 list/","permalink":"https://xqc-1368.github.io/2024/08/16/05%20HTML%20%E5%88%97%E8%A1%A8%20list/","excerpt":"","text":"列表 表格是用来显示数据的，那么列表就是用来布局的。 表格是用来显示数据的，那么列表就是用来布局的。 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。 根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。 无序： ​&lt;ul&gt; 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 &lt;li&gt; 标签定义。无序列表的基本语法格式如下： 12345&lt;ul&gt;&lt;li&gt;列表项1&lt;/li&gt;&lt;li&gt;列表项2&lt;/li&gt;&lt;li&gt;列表项3&lt;/li&gt;...&lt;/ul&gt; 无序列表的各个列表项之间没有顺序级别之分，是并列的。 &lt;ul&gt;&lt;/ul&gt; 中只能嵌套 &lt;li&gt;&lt;/li&gt;，直接在 &lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。 有序： ​ 有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，&lt;ol&gt; 标签用于定义有序列表，列表排序以数字来显示，并且使用 标签来定义列表项。有序列表的基本语法格式如下： 1234567&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ... &lt;/ol&gt; &lt;ol&gt;&lt;/ol&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ol&gt;&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。 自定义： 自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中，&lt;dl&gt; 标签用于定义描述列表（或定义列表），该标签会与 &lt;dt&gt;（定义项目/名字）和 &lt;dd&gt;（描述每一个项目/名字）一起使用。语法如下： 12345&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; 列表总结","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML列表","slug":"HTML列表","permalink":"https://xqc-1368.github.io/tags/HTML%E5%88%97%E8%A1%A8/"}]},{"title":"HTML表格","slug":"04 HTML 表格 table","date":"2024-08-16T14:34:44.300Z","updated":"2024-08-16T14:34:30.647Z","comments":true,"path":"2024/08/16/04 HTML 表格 table/","permalink":"https://xqc-1368.github.io/2024/08/16/04%20HTML%20%E8%A1%A8%E6%A0%BC%20table/","excerpt":"","text":"表格 表格的主要作用 1.表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理 2.表格不是用来布局页面的,而是用来展示数据的。 3.表格的具体用法： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ... &lt;/table&gt; 1. 是用于定义表格的标签。 2. 标签用于定义表格中的行，必须嵌套在 标签中。 3. 用于定义表格中的单元格，必须嵌套在标签中。 4.字母 td 指表格数据（table data），即数据单元格的内容。 表头单元格标签： 4.表头标签的具体实现： 12345&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; ... &lt;/tr&gt; ... &lt;/table&gt; (1).一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示. 标签表示 HTML 表格的表头部分(table head 的缩写) (2)一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示. 标签表示 HTML 表格的表头部分(table head 的缩写) 5.表头单元格也是单元格，常用于表格第一行突出重要性，表头单元格里面的文字会加粗居中 表格属性： 1.表格标签这部分属性我们实际开发我们不常用，后面通过 CSS 来设置. ​ ​ 思路： 先制作表格的结构. 1.第一行里面是 th 表头单元格 2.第二行开始里面是 td 普通单元格单元格里面可以放任何元素 3.文字链接图片等都可以 后书写表格属性 1.用到宽度高度边框cellpadding 和 cellspacing 2.表格浏览器中对齐 align 表格结构标签： 使用场景: 因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分. 在表格标签中，分别用：标签 表格的头部区域、标签 表格的主体区域. 这样可以更好的分清表格结构。 总结: 1. ：用于定义表格的头部。 内部必须拥有 标签。 一般是位于第一行。 2. ：用于定义表格的主体，主要用于放数据本体 。 3. 以上标签都是放在&lt;table&gt;&lt;/table&gt; 标签中。 合并单元格： 特殊情况下,可以把多个单元格合并为一个单元格 1.合并单元格方式 2.目标单元格 3.合并单元格的步骤 如下图： 合并单元格方式： 跨行合并：rowspan=“合并单元格的个数” ​ 最上侧单元格为目标单元格, 写合并代码 跨列合并：colspan=“合并单元格的个数” ​ 最左侧单元格为目标单元格, 写合并代码 比如：。删除多余的单元格。 表格总结 ​ 表格学习整体可以分为三大部分: 表格的相关标签 ​ table thead body tr th td 表格的相关属性 ​ cellspacing cellpadding width height border 合并单元格 ​ rowspan collspan","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML表格","slug":"HTML表格","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E6%A0%BC/"}]},{"title":"HTML表单","slug":"03 HTML 表单 form","date":"2024-08-16T14:32:38.946Z","updated":"2024-08-16T14:47:39.876Z","comments":true,"path":"2024/08/16/03 HTML 表单 form/","permalink":"https://xqc-1368.github.io/2024/08/16/03%20HTML%20%E8%A1%A8%E5%8D%95%20form/","excerpt":"","text":"表单 表单的组成： 在 HTML 中，一个完整的表单通常由表单域、表单控件（也称为表单元素）和 提示信息3个部分构成。 表单域： 表单域是一个包含表单元素的区域。 在 HTML 标签中， &lt;form&gt;标签用于定义表单域，以实现用户信息的收集和传递。 &lt;form&gt;会把它范围内的表单元素信息提交给服务器. 实现代码： 123&lt;form action=“url地址” method=“提交方式” name=“表单域名称&quot;&gt;各种表单元素控件&lt;/form&gt;` 表单域的常用属性： 表单控件(表单元素) &lt;input&gt; 表单元素 在英文单词中，input 是输入的意思，而在表单元素中 &lt;input&gt; 标签用于收集用户信息。在 &lt;input&gt; 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。 1&lt;input type=&quot;属性值&quot; /&gt; 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型 type 属性的属性值及其描述如下： 除 type 属性外，&lt;input&gt;标签还有其他很多属性，其常用属性如下： &lt;label&gt; 标签 &lt;label&gt;标签为 input 元素定义标注（标签）。 &lt;label&gt;标签用于绑定一个表单元素, 当点击&lt;label&gt; 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验. 语法： 12&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; 核心： 标签的 for 属性应当与相关元素的 id 属性相同。 &lt;select&gt; 表单元素 使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用&lt;select&gt;标签控件定义下拉列表。 语法： 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ... &lt;/select&gt; &lt;textarea&gt; 表单元素 使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 &lt;textarea&gt; 标签。 在表单元素中，&lt;textarea&gt; 标签是用于定义多行文本输入的控件。 使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。 语法： &lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt; 文本内容 &lt;/textarea&gt; 通过 &lt;textarea&gt; 标签可以轻松地创建多行文本输入框。cols=“每行中的字符数” ，rows=“显示的行数”， 我们在实际开发中不会使用，都是用 CSS 来改变大小。 表单元素我们学习了三大组 input 输入表单元素 select 下拉表单元素 textarea 文本域表单元素.这三组表单元素都应该包含在form表单域里面,并且有 name 属性. 有三个名字非常相似的标签: 表单域 form 使用场景: 提交区域内表单元素给后台服务器 文件域 file 是input type 属性值 使用场景: 上传文件 文本域 textarea 使用场景: 可以输入多行文字, 比如留言板 网站介绍等… 我们当前阶段不需要提交表单元素,所以我们只负责表单元素的外观形态即可.","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML表单","slug":"HTML表单","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E5%8D%95/"}]},{"title":"HTML标签","slug":"02 HTML 标签 tag","date":"2024-08-16T11:40:19.107Z","updated":"2024-08-16T12:46:56.248Z","comments":true,"path":"2024/08/16/02 HTML 标签 tag/","permalink":"https://xqc-1368.github.io/2024/08/16/02%20HTML%20%E6%A0%87%E7%AD%BE%20tag/","excerpt":"","text":"一、HTML标签 1.HTML语法规则： 1.HTML 标签是由尖括号包围的关键词，例如 &lt;html&gt;。 2.HTML 标签通常是成对出现的，例如 &lt;html&gt; 和 &lt;/html&gt; ，我们称为双标签。 3.签:标签对中的第一个标签是开始标签，第二个标签是结束标签。 有些特殊的标签必须是单个标签（极少情况），例如&lt;br /&gt;，我们称为单标签。 2. 标签的关系： 双标签关系可以分为两类：包含关系和并列关系 包含标签 123456&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写 (1) 骨架构建快捷键 VSCode生成页面骨架结构： 输入! 按下 Tab 键。 利用插件在浏览器中预览页面：单击鼠标右键，在弹出窗口中点击“Open In Default Browser”。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;hello world&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;hello world!!!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (2) DOCTYPE &lt;!DOCTYPE html&gt; 文档类型声明标签,告诉浏览器这个页面采取html5版本来显示页面. (3) lang 语言种类 用来定义当前文档显示的语言。 en定义语言为英语 zh-CN定义语言为中文 简单来说,定义为en 就是英文网页, 定义为 zh-CN 就是中文网页 其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文 这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的 (4) 字符集 1.字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。 2.在&lt;head&gt;标签内，可以通过&lt;meta&gt; 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码。 3.&lt;meta charset=&quot; UTF-8&quot; /&gt; 4.charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符. 5.注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 &quot;UTF-8&quot;，不要写成 &quot;utf8&quot; 或 &quot;UTF8&quot;。 (5) 语义化标签 学习标签是有技巧的，重点是记住每个标签的语义。简单理解就是指标签的含义，即这个标签是用来干嘛的。 根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。 [1] 标签 &lt;h1&gt; - &lt;h6&gt; HTML 提供了 6 个等级的网页标题，即&lt;h1&gt; - &lt;h6&gt;。 具体实现： 1&lt;h1&gt; 我是一级标题 &lt;/h1&gt; [2] 段落标签 在 HTML 标签中，标签用于定义段落，它可以将整个网页分为若干个段落。 具体实现： 1&lt;p&gt; 我是一个段落标签 &lt;/p&gt; [3] 换行标签 如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br /&gt;。 具体实现： 1&lt;br /&gt; [4] 文本格式化标签： 在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。 语义 标签 加粗 &lt; strong &gt;&lt; /strong &gt;或者&lt; b&gt;&lt; /b &gt; 倾斜 &lt; em &gt;&lt; /em &gt;或者&lt; i &gt;&lt; /i &gt; 删除线 &lt; del &gt;&lt; /del &gt;或者&lt; s &gt;&lt; /s &gt; 下划线 &lt; ins &gt;&lt; /ins &gt;或者&lt; u &gt;&lt; /u &gt; [5] div和span标签 &lt;div&gt; 和 &lt;span&gt; 是没有语义的，它们就是一个盒子，用来装内容的。 具体实现： 12&lt;div&gt; 这是头部 &lt;/div&gt;&lt;span&gt; 今日价格 &lt;/span&gt; [6]图片标签 在 HTML 标签中，&lt;img&gt;标签用于定义 HTML 页面中的图像。 具体实现： 1&lt;img src=&quot;smiley-2.gif&quot; alt=&quot;Smiley face&quot; width=&quot;42&quot; height=&quot;42&quot;&gt; 解释： src 是标签的必须属性，它用于指定图像文件的路径和文件名。 属性 形式 功能 src URL 规定显示图像的 URL。 width pixels 规定图像的宽度 height pixels 规定图像的高度 alt text 规定图像的替代文本 图像标签的其他属性： 图像标签注意点： 1.图像标签可以拥有多个属性，必须写在标签名的后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.属性采取键值对的格式，即 key=“value&quot; 的格式，属性 =“属性值”。 分为相对路径和绝对路径： (6)链接标签： 链接的语法格式 1&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt; 文本或图像 &lt;/a&gt; 1.href：用于指定链接目标的url地址 2.target:用于指定链接页面的打开方式：_self默认值 _blank新窗口打开 3.#：空链接 在链接文本的 href 属性中，设置属性值为 #名字 的形式，如 &lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt; 找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如： &lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt; (7) 注释 如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字 具体实现： 1&lt;!-- 注释语句 --&gt; 快捷键: ctrl + / 一句话: 注释标签里面的内容是给程序猿看的, 这个代码是不执行不显示到页面中的. 添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的 (8) 特殊字符 在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。 重点记住：空格 、大于号、 小于号 这三个， 其余的使用很少，如果需要回头查阅即可。 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;nbsp; 空格","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML注释","slug":"HTML注释","permalink":"https://xqc-1368.github.io/tags/HTML%E6%B3%A8%E9%87%8A/"},{"name":"HTML特殊字符","slug":"HTML特殊字符","permalink":"https://xqc-1368.github.io/tags/HTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"}]},{"title":"HTML语言简介","slug":"01 HTML 简介","date":"2024-08-16T11:33:16.683Z","updated":"2024-08-16T11:32:36.314Z","comments":true,"path":"2024/08/16/01 HTML 简介/","permalink":"https://xqc-1368.github.io/2024/08/16/01%20HTML%20%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、网页开发网页的相关概念 1. 什么是网页： 1.网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 2.网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。 2. 网页的组成： 1.网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。 2.HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。 3. 网页的总结： 1.网页是图片、链接、文字、声音、视频等元素组成, 其实就是一个html文件(后缀名为html) 2.网页生成制作: 有前端人员书写 HTML 文件, 然后浏览器打开,就能看到了网页. 3.HTML: 超文本标记语言, 用来制作网页的一门语言. 有标签组成的. 比如 图片标签 链接标签 视频标签等… 4. 浏览器： 浏览器内核（渲染引擎） 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面 目前国内一般浏览器都会采用 Webkit/Blink 内核，如 360、UC、QQ、搜狗等。 5. web标准： Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。 6. 为什么需要Web标准： 浏览器不同，它们显示页面或者排版就有些许差异 遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 1.让 Web 的发展前景更广阔。 2.内容能被更广泛的设备访问。 3.更容易被搜寻引擎搜索。 4.降低网站流量费用。 5.使网站更易于维护。 6.提高页面浏览速度。 7. web标准的构成： 主要包括 《结构Structure》 、《表现（Presentation）》和《行为（Behavior）》三个方面。 Web 标准提出的最佳体验方案：结构、样式、行为相分离。 简单理解：结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中 1.结构类似身体 2.表现类似外观装饰 3.行为类似行为动作 4.相比较而言, 三者中结构最重要. 二、查阅文档： 经常查阅文档是一个非常好的学习习惯。 推荐的网址： 百度: http://www.baidu.com W3C : http://www.w3school.com.cn/ MDN: https://developer.mozilla.org/zh-CN/","categories":[{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"web标准","slug":"web标准","permalink":"https://xqc-1368.github.io/tags/web%E6%A0%87%E5%87%86/"}]},{"title":"浏览器生成信息","slug":"01 浏览器生成信息","date":"2024-08-16T03:21:02.986Z","updated":"2024-08-16T09:31:49.788Z","comments":true,"path":"2024/08/16/01 浏览器生成信息/","permalink":"https://xqc-1368.github.io/2024/08/16/01%20%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E4%BF%A1%E6%81%AF/","excerpt":"","text":"关键词：浏览器，Web服务器，网址（URL），HTTP，HTML，协议，URI，请求消息，解析器，Socket库，DNS服务器，域名 浏览器的具体工作步骤是： 解析URL（注意这个“解析”跟解析器没有关系） 生成HTTP请求消息 向DNS服务器查询域名对应的ip地址 委托操作系统内部的协议栈将消息发送给Web服务器，按照指定的顺序来调用Socket库中的程序组件。 一、输入URL，浏览器解析网址 1、统一资源定位器 URL 浏览器：具备多种客户端功能的综合性客户端软件 FTP：文件传输协议 域名：像www.glasscom.com这样用句点（.）分隔的名称 URL：统一资源定位器 功能：不同的头，可以用以判断使用哪种功能。访问Web服务器的时候，用“http”，访问FTP服务器的时候用“ftp:“ 格式：协议（http:，ftp:，file:，mailto:，）//服务器名称+数据源路径 ![Web浏览器解析URL的过程](/images/2024-07-24-22-38-54-Web浏览器解析URL的过程.jpg) - Web服务器和FTP服务器： 用http协议访问Web服务器：http://用户名(可省略):密码(可省略)@Web服务器域名:端口号(可省略)/文件的路径名 1http://user:password@www.glasscom.com:80/dir/file.html 用FTP协议下载和上传文件：ftp://用户名(可省略):密码(可省略)@FTP服务器域名:端口号(可省略)/文件的路径名 1ftp://user:password@ftp.glasscom.com:21/dir/file/html 服务器读取客户端本地文件：file://计算机名(可省略)/文件路径名 1file://localhost/c:/path/file1.zip 发送邮件的URL：邮件地址 1mailto:tone@glasscom.com 省略文件名情况： 比如http://www.lab.glasscom.com/dir/预先在dir文件夹下设置省略时访问的默认文件名，一般是index.html或者default.html，遇到这种情况直接访问默认页面 2、浏览器解析HTTP协议的URL HTTP协议 功能：定义了客户端和服务器之间的交互 请求信息包括：”对什么“（URI，统一资源标识符）+“进行怎样的操作”（访问方法，包括GET方法，POST方法等） URI：访问的各种目标，可以是一个网页数据文件名（html文件），也可以是一个CGI程序（Web服务器调用其他的程序） GET方法：URI指定的是文件返回文件；URI指定的是CGI程序，返回输出结果 POST方法：向服务器发送数据，此时URI一般指向一个应用程序的文件名 HEAD方法：用于获取文件最后更新时间 注：超链接主要是GET方法，表单有POST也有GET 返回消息是状态码 二、生成HTTP请求消息 HTTP消息 请求消息 请求行（方法 URI HTTP版本）+消息头（请求附加信息）+消息体（POST方法消息体内有表单数据） 响应消息 状态行（HTTP 状态码 响应短语）＋消息头+消息体（从文件中读取的数据orCGI程序的输出数据） 状态码和响应短语表示内容一致，用途不同，状态码是一个数字，用来像程序告知执行结果；响应短语是文字，向人们告知执行结果。 每条请求消息只能写一个URI，所以最多只能获取一个文件。当网页包含图片时，会在网页相应位置嵌入图片标签，屏幕上会预留显示图片的空间，然后再次访问Web服务器请求图片。 所以，一个网页包含3张图片，一共要向Web服务器发送4条请求 三、向DNS服务器发起 查询 Web服务器的IP地址 请求 1、IP地址 需求：在委托操作系统发送消息时，需要提供通信对象的IP地址。所以需要根据域名查询IP地址。（如果Web服务器采用了虚拟主机功能，可能无法通过IP地址访问） 局域网是基于TCP/IP结构设计的，小的子网通过路由器组成一个大的网络 IP地址（一共32bit） 定义：网络号+主机号（xx栋+xx室） 子网掩码：与IP地址等长，左半边全是1，右半边全是0，用以区分网络号和主机号 例如：10.11.12.13/255.255.255.0表示网络号是10.11.12，主机号是13 若为10.11.12.13/24，则表示子网掩码前24位为1 特殊情况：主机号比特全为0，表示代表整个子网。主机号比特全为1，表示对整个子网每个主机进行广播 2、Socket库提供查询功能，解析器向DNS服务器发起查询 Socket库：可以让其他应用程序调用操作系统网络功能的库。 解析器（DNS解析器，DNS客户端）：是一段程序，包含在Socket库中，通过DNS查询IP地址的操作是 域名解析 解析器工作过程：一行代码内存地址=gethostbyname('域名') 解析器工作的内部原理： 1.当网络应用程序（浏览器）调用解析器时，程序的控制流程就会转移（原程序暂停，被调用的程序运行）到解析器内 2.解析器会生成发送给DNS服务器的查询消息，这个过程与生成要发送给Web服务器的HTTP请求类似。 3.之后委托给操作系统内部的协议栈来执行发送功能，协议栈执行发送消息操作网卡将消息发送给DNS服务器。 4.之后按照上述相反的过程层层返回 注意：与发送其他消息不同的是，我们的终端预先已知DNS服务器的IP地址，不需要再去查询 四、DNS查询到 Web服务器地址 的过程 DNS服务器的功能： 接收来自客户端的查询消息，然后根据消息内容返回IP地址。 解析器（DNS终端）向DNS服务器发送的查询消息包括： 域名（服务器名称，邮件服务器名称（即邮件地址中@之后的部分，不是邮件服务器的域名）） Class（始终为IN） 记录类型（A对应记录得到的是IP地址，MX对应记录得到的是邮件服务器） 注：当记录类型为MX时，DNS服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级。DNS服务器再次在自己内部用邮件服务器的域名搜索，可以找到邮件服务器的IP地址。 域名的层次结构 域名：越靠右表示层级越高 比如www.lab.glasscom.com表示：com集团，glasscom部，lab科，的www。 子域：下级域 建树：下级域的DNS服务器IP地址要注册到上级域的DNS服务器上 根域：其实域名应该是www.lab.glasscom.com.最后有一个点，表示注册在根域之下，不过根域一般省略。但是根域DNS服务器注册在互联网所有DNS服务器上。 工作原理：客户端访问最近的一台DNS服务器，该服务器经过以下反复找寻环节后可以响应解析器的查询消息。（注意：反复找寻的操作是第一个DNS服务器干的活） 实际的访问过程： 上级域和下级域共享一个DNS服务器，常有跳过一级查询 DNS服务器有缓存功能，若已缓存则直接返回，缓存有有效期 五、委托协议栈发送消息 收发数据：TCP协议、UDP协议。 TCP协议收发数据过程（由协议栈执行）： （1）创建套接字（创建套接字阶段） （2）将管道连接到服务器端的套接字上（连接阶段） （3）收发数据（通信阶段） （4）断开管道并删除套接字（断开阶段） 套接字：数据通信管道两端的数据出入口 创建套接字： 管道在连接是由客户端发起的，在断开是由服务器or客户端任意一方发起 调用socket：创建套接字，返回描述符，放到指定内存中。 描述符：用来识别不同的套接字的标识符 连接阶段： 调用connect组件，需要： 描述符 IP地址 端口号：当同时指定IP地址和端口号时，就可以识别出某台具体计算机上的套接字 注：在创建套接字时，协议栈会为这个套接字分配一个端口号；在执行连接操作时，会将这个随便分配的端口号通知服务器。 描述符和端口号的区别 描述符：用来在一台计算机内部识别套接字的机制 端口号：让通信的另一方能够识别出套接字的机制。预先约定：Web是80号端口，电子邮件是25端口。 通信阶段 调用write，需要： 描述符 发送的数据 调用read，需要： 指定接收到的内存地址：接收缓冲区（位于应用程序的内存空间） 断开操作 HTTP要求Web服务器先断开，HTTP1.1（能在一次连接中收发多个请求和响应）要求浏览器先断开","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xqc-1368.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Web服务器","slug":"Web服务器","permalink":"https://xqc-1368.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"DNS服务器","slug":"DNS服务器","permalink":"https://xqc-1368.github.io/tags/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://xqc-1368.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"URL","slug":"URL","permalink":"https://xqc-1368.github.io/tags/URL/"},{"name":"URI","slug":"URI","permalink":"https://xqc-1368.github.io/tags/URI/"},{"name":"请求消息","slug":"请求消息","permalink":"https://xqc-1368.github.io/tags/%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/"},{"name":"域名","slug":"域名","permalink":"https://xqc-1368.github.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"Socket库","slug":"Socket库","permalink":"https://xqc-1368.github.io/tags/Socket%E5%BA%93/"},{"name":"解析器","slug":"解析器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A3%E6%9E%90%E5%99%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-08-16T02:59:19.785Z","updated":"2024-08-16T02:59:19.904Z","comments":true,"path":"2024/08/16/hello-world/","permalink":"https://xqc-1368.github.io/2024/08/16/hello-world/","excerpt":"","text":"本博客所有文章除特别声明外，均采用Hexo制作。 这是题名为HelloWorld的主页。文件信息来源于documentation。如果遇到问题，也许可以在troubleshooting上找到答案。 快速开始 创建新帖 系统会自动在 scaffolds 文件夹中搜寻名为 My New Post 的文件，根据其中的内容生成新的.md 文章文件。 1$ hexo new &quot;My New Post&quot; 更多信息: Writing 启动服务器 启动本地服务器，用于预览主题 1$ hexo server 或者 1$ hexo s 更多信息: 服务器 生成静态文件 在发布之前，需要先生成静态文件 生成网站静态文件到默认设置的 public 文件夹 1$ hexo generate 或者 1$ hexo g 更多信息: 启动 部署到服务器 将文件部署到服务器上 1$ hexo deploy 或者 1$ hexo d 更多信息: 部署 清除文件 清除缓存文件 (db.json) 和已生成的静态文件 (public) 1$ hexo clean","categories":[],"tags":[]}],"categories":[{"name":"《code编码：隐匿在计算机软硬件背后的语言》","slug":"《code编码：隐匿在计算机软硬件背后的语言》","permalink":"https://xqc-1368.github.io/categories/%E3%80%8Acode%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%8B/"},{"name":"数字电子技术基础","slug":"数字电子技术基础","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"},{"name":"C语言程序设计","slug":"C语言程序设计","permalink":"https://xqc-1368.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"OOP面向对象","slug":"OOP面向对象","permalink":"https://xqc-1368.github.io/categories/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"算法/搜索","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"},{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/categories/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"},{"name":"C++ STL","slug":"C-STL","permalink":"https://xqc-1368.github.io/categories/C-STL/"},{"name":"二分","slug":"算法/二分","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"},{"name":"git","slug":"git","permalink":"https://xqc-1368.github.io/categories/git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://xqc-1368.github.io/categories/Markdown/"},{"name":"CMake","slug":"CMake","permalink":"https://xqc-1368.github.io/categories/CMake/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/categories/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/categories/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/categories/%E7%B4%A0%E6%95%B0/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"算法/数据结构/栈","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"算法/动态规划/数位DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E4%BD%8DDP/"},{"name":"区间DP","slug":"算法/动态规划/区间DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"环形DP的四边形不等式优化","slug":"算法/动态规划/环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"},{"name":"多重背包DP的二进制优化","slug":"算法/动态规划/多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"树形DP","slug":"算法/动态规划/树形DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"},{"name":"DP的单调队列优化","slug":"算法/动态规划/DP的单调队列优化","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"},{"name":"状压DP","slug":"算法/动态规划/状压DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"},{"name":"区域DP","slug":"算法/动态规划/区域DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E5%9F%9FDP/"},{"name":"背包DP","slug":"算法/动态规划/背包DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85DP/"},{"name":"期望DP","slug":"算法/动态规划/期望DP","permalink":"https://xqc-1368.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"},{"name":"前端","slug":"前端","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://xqc-1368.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://xqc-1368.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"《code编码》","slug":"《code编码》","permalink":"https://xqc-1368.github.io/tags/%E3%80%8Acode%E7%BC%96%E7%A0%81%E3%80%8B/"},{"name":"编译原理","slug":"编译原理","permalink":"https://xqc-1368.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://xqc-1368.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"浮点数","slug":"浮点数","permalink":"https://xqc-1368.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://xqc-1368.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统","slug":"操作系统","permalink":"https://xqc-1368.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"机器语言","slug":"机器语言","permalink":"https://xqc-1368.github.io/tags/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/"},{"name":"存储模块","slug":"存储模块","permalink":"https://xqc-1368.github.io/tags/%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97/"},{"name":"RAM","slug":"RAM","permalink":"https://xqc-1368.github.io/tags/RAM/"},{"name":"ROM","slug":"ROM","permalink":"https://xqc-1368.github.io/tags/ROM/"},{"name":"总线","slug":"总线","permalink":"https://xqc-1368.github.io/tags/%E6%80%BB%E7%BA%BF/"},{"name":"IO模块","slug":"IO模块","permalink":"https://xqc-1368.github.io/tags/IO%E6%A8%A1%E5%9D%97/"},{"name":"CPU","slug":"CPU","permalink":"https://xqc-1368.github.io/tags/CPU/"},{"name":"加法器与减法器","slug":"加法器与减法器","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E5%87%8F%E6%B3%95%E5%99%A8/"},{"name":"ALU","slug":"ALU","permalink":"https://xqc-1368.github.io/tags/ALU/"},{"name":"连加器","slug":"连加器","permalink":"https://xqc-1368.github.io/tags/%E8%BF%9E%E5%8A%A0%E5%99%A8/"},{"name":"跳转JUMP","slug":"跳转JUMP","permalink":"https://xqc-1368.github.io/tags/%E8%B7%B3%E8%BD%ACJUMP/"},{"name":"扩展寻址","slug":"扩展寻址","permalink":"https://xqc-1368.github.io/tags/%E6%89%A9%E5%B1%95%E5%AF%BB%E5%9D%80/"},{"name":"GUI","slug":"GUI","permalink":"https://xqc-1368.github.io/tags/GUI/"},{"name":"数电","slug":"数电","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%94%B5/"},{"name":"触发器","slug":"触发器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"},{"name":"数值比较器","slug":"数值比较器","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83%E5%99%A8/"},{"name":"译码器","slug":"译码器","permalink":"https://xqc-1368.github.io/tags/%E8%AF%91%E7%A0%81%E5%99%A8/"},{"name":"编码器","slug":"编码器","permalink":"https://xqc-1368.github.io/tags/%E7%BC%96%E7%A0%81%E5%99%A8/"},{"name":"数据选择器","slug":"数据选择器","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"数制与码制","slug":"数制与码制","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E5%88%B6%E4%B8%8E%E7%A0%81%E5%88%B6/"},{"name":"时序逻辑电路","slug":"时序逻辑电路","permalink":"https://xqc-1368.github.io/tags/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/"},{"name":"C语言","slug":"C语言","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"函数","slug":"函数","permalink":"https://xqc-1368.github.io/tags/%E5%87%BD%E6%95%B0/"},{"name":"C++","slug":"C","permalink":"https://xqc-1368.github.io/tags/C/"},{"name":"OOP","slug":"OOP","permalink":"https://xqc-1368.github.io/tags/OOP/"},{"name":"多态","slug":"多态","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E6%80%81/"},{"name":"虚函数","slug":"虚函数","permalink":"https://xqc-1368.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"name":"继承与复合关系","slug":"继承与复合关系","permalink":"https://xqc-1368.github.io/tags/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB/"},{"name":"派生类","slug":"派生类","permalink":"https://xqc-1368.github.io/tags/%E6%B4%BE%E7%94%9F%E7%B1%BB/"},{"name":"运算符重载","slug":"运算符重载","permalink":"https://xqc-1368.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"name":"流运算符","slug":"流运算符","permalink":"https://xqc-1368.github.io/tags/%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"BFS","slug":"BFS","permalink":"https://xqc-1368.github.io/tags/BFS/"},{"name":"双向BFS","slug":"双向BFS","permalink":"https://xqc-1368.github.io/tags/%E5%8F%8C%E5%90%91BFS/"},{"name":"思想方法","slug":"思想方法","permalink":"https://xqc-1368.github.io/tags/%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/"},{"name":"类和对象","slug":"类和对象","permalink":"https://xqc-1368.github.io/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"name":"构造函数和析构函数","slug":"构造函数和析构函数","permalink":"https://xqc-1368.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"},{"name":"引用","slug":"引用","permalink":"https://xqc-1368.github.io/tags/%E5%BC%95%E7%94%A8/"},{"name":"内联函数","slug":"内联函数","permalink":"https://xqc-1368.github.io/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"name":"重载函数","slug":"重载函数","permalink":"https://xqc-1368.github.io/tags/%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"name":"动态内存分配","slug":"动态内存分配","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"字符串","slug":"字符串","permalink":"https://xqc-1368.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"STL","slug":"STL","permalink":"https://xqc-1368.github.io/tags/STL/"},{"name":"数组","slug":"数组","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"指针","slug":"指针","permalink":"https://xqc-1368.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"算法","slug":"算法","permalink":"https://xqc-1368.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"前缀和","slug":"前缀和","permalink":"https://xqc-1368.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"二分","slug":"二分","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"git","slug":"git","permalink":"https://xqc-1368.github.io/tags/git/"},{"name":"Markdown","slug":"Markdown","permalink":"https://xqc-1368.github.io/tags/Markdown/"},{"name":"CMake","slug":"CMake","permalink":"https://xqc-1368.github.io/tags/CMake/"},{"name":"C语言 文件操作","slug":"C语言-文件操作","permalink":"https://xqc-1368.github.io/tags/C%E8%AF%AD%E8%A8%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"动态数组","slug":"动态数组","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"},{"name":"数论","slug":"数论","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"生成树","slug":"生成树","permalink":"https://xqc-1368.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"kruskal算法","slug":"kruskal算法","permalink":"https://xqc-1368.github.io/tags/kruskal%E7%AE%97%E6%B3%95/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"费马小定理","slug":"费马小定理","permalink":"https://xqc-1368.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"name":"扩展欧拉定理","slug":"扩展欧拉定理","permalink":"https://xqc-1368.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"name":"威尔逊定理","slug":"威尔逊定理","permalink":"https://xqc-1368.github.io/tags/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://xqc-1368.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"拓展欧几里得定理","slug":"拓展欧几里得定理","permalink":"https://xqc-1368.github.io/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86/"},{"name":"裴蜀定理","slug":"裴蜀定理","permalink":"https://xqc-1368.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"},{"name":"最大公约数gcd","slug":"最大公约数gcd","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0gcd/"},{"name":"最小公倍数lcm","slug":"最小公倍数lcm","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm/"},{"name":"辗转相除法","slug":"辗转相除法","permalink":"https://xqc-1368.github.io/tags/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/"},{"name":"筛法","slug":"筛法","permalink":"https://xqc-1368.github.io/tags/%E7%AD%9B%E6%B3%95/"},{"name":"素数","slug":"素数","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"素数判定","slug":"素数判定","permalink":"https://xqc-1368.github.io/tags/%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A/"},{"name":"Miller-Rabin素性检验","slug":"Miller-Rabin素性检验","permalink":"https://xqc-1368.github.io/tags/Miller-Rabin%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C/"},{"name":"Pollard-Rho","slug":"Pollard-Rho","permalink":"https://xqc-1368.github.io/tags/Pollard-Rho/"},{"name":"埃氏筛法","slug":"埃氏筛法","permalink":"https://xqc-1368.github.io/tags/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/"},{"name":"线性筛法（欧拉筛法）","slug":"线性筛法（欧拉筛法）","permalink":"https://xqc-1368.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%EF%BC%88%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%89/"},{"name":"快速乘","slug":"快速乘","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/"},{"name":"快速幂","slug":"快速幂","permalink":"https://xqc-1368.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"差分","slug":"差分","permalink":"https://xqc-1368.github.io/tags/%E5%B7%AE%E5%88%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://xqc-1368.github.io/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://xqc-1368.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"DFS","slug":"DFS","permalink":"https://xqc-1368.github.io/tags/DFS/"},{"name":"倍增","slug":"倍增","permalink":"https://xqc-1368.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"LCA","slug":"LCA","permalink":"https://xqc-1368.github.io/tags/LCA/"},{"name":"树上距离","slug":"树上距离","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E8%B7%9D%E7%A6%BB/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xqc-1368.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树的深度","slug":"树的深度","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"},{"name":"树形dp","slug":"树形dp","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2dp/"},{"name":"树的直径","slug":"树的直径","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"树的重心","slug":"树的重心","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"换根dp","slug":"换根dp","permalink":"https://xqc-1368.github.io/tags/%E6%8D%A2%E6%A0%B9dp/"},{"name":"链式二叉树","slug":"链式二叉树","permalink":"https://xqc-1368.github.io/tags/%E9%93%BE%E5%BC%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"遍历问题","slug":"遍历问题","permalink":"https://xqc-1368.github.io/tags/%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"},{"name":"树上差分","slug":"树上差分","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"最大流","slug":"最大流","permalink":"https://xqc-1368.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"并查集","slug":"并查集","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"并查集的路径优化压缩","slug":"并查集的路径优化压缩","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%E5%8E%8B%E7%BC%A9/"},{"name":"并查集的按秩合并优化","slug":"并查集的按秩合并优化","permalink":"https://xqc-1368.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96/"},{"name":"种类并查集","slug":"种类并查集","permalink":"https://xqc-1368.github.io/tags/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"动态规划","slug":"动态规划","permalink":"https://xqc-1368.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"https://xqc-1368.github.io/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"区间DP","slug":"区间DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"博弈论","slug":"博弈论","permalink":"https://xqc-1368.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"环形DP的四边形不等式优化","slug":"环形DP的四边形不等式优化","permalink":"https://xqc-1368.github.io/tags/%E7%8E%AF%E5%BD%A2DP%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96/"},{"name":"多重背包DP的二进制优化","slug":"多重背包DP的二进制优化","permalink":"https://xqc-1368.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85DP%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96/"},{"name":"树形DP","slug":"树形DP","permalink":"https://xqc-1368.github.io/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"DP的单调队列优化","slug":"DP的单调队列优化","permalink":"https://xqc-1368.github.io/tags/DP%E7%9A%84%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"},{"name":"状压DP","slug":"状压DP","permalink":"https://xqc-1368.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"区域DP","slug":"区域DP","permalink":"https://xqc-1368.github.io/tags/%E5%8C%BA%E5%9F%9FDP/"},{"name":"背包DP","slug":"背包DP","permalink":"https://xqc-1368.github.io/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"期望DP","slug":"期望DP","permalink":"https://xqc-1368.github.io/tags/%E6%9C%9F%E6%9C%9BDP/"},{"name":"层叠样式表CSS","slug":"层叠样式表CSS","permalink":"https://xqc-1368.github.io/tags/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8CSS/"},{"name":"网页","slug":"网页","permalink":"https://xqc-1368.github.io/tags/%E7%BD%91%E9%A1%B5/"},{"name":"CSS绝对定位","slug":"CSS绝对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS相对定位","slug":"CSS相对定位","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/"},{"name":"CSS定位注意事项","slug":"CSS定位注意事项","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AE%9A%E4%BD%8D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"CSS子绝父相","slug":"CSS子绝父相","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8/"},{"name":"CSS元素显示与隐藏","slug":"CSS元素显示与隐藏","permalink":"https://xqc-1368.github.io/tags/CSS%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"name":"CSS溢出处理","slug":"CSS溢出处理","permalink":"https://xqc-1368.github.io/tags/CSS%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/"},{"name":"CSS浮动float","slug":"CSS浮动float","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B5%AE%E5%8A%A8float/"},{"name":"CSS清除浮动","slug":"CSS清除浮动","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"},{"name":"CSS文字阴影","slug":"CSS文字阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1/"},{"name":"CSS盒子模型","slug":"CSS盒子模型","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"name":"CSS边框样式","slug":"CSS边框样式","permalink":"https://xqc-1368.github.io/tags/CSS%E8%BE%B9%E6%A1%86%E6%A0%B7%E5%BC%8F/"},{"name":"CSS内边距padding","slug":"CSS内边距padding","permalink":"https://xqc-1368.github.io/tags/CSS%E5%86%85%E8%BE%B9%E8%B7%9Dpadding/"},{"name":"CSS外边距margin","slug":"CSS外边距margin","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%96%E8%BE%B9%E8%B7%9Dmargin/"},{"name":"CSS清除内外边距","slug":"CSS清除内外边距","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B8%85%E9%99%A4%E5%86%85%E5%A4%96%E8%BE%B9%E8%B7%9D/"},{"name":"CSS圆角边框","slug":"CSS圆角边框","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/"},{"name":"CSS盒子阴影","slug":"CSS盒子阴影","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1/"},{"name":"CSS显示模式","slug":"CSS显示模式","permalink":"https://xqc-1368.github.io/tags/CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"},{"name":"CSS块元素","slug":"CSS块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS行内元素","slug":"CSS行内元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/"},{"name":"CSS行内块元素","slug":"CSS行内块元素","permalink":"https://xqc-1368.github.io/tags/CSS%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS复合选择器","slug":"CSS复合选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS伪元素选择器","slug":"CSS伪元素选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS链接伪类选择器","slug":"CSS链接伪类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%93%BE%E6%8E%A5%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS属性选择器","slug":"CSS属性选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS类选择器","slug":"CSS类选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS标签选择器","slug":"CSS标签选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSSID选择器","slug":"CSSID选择器","permalink":"https://xqc-1368.github.io/tags/CSSID%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS通配符选择器","slug":"CSS通配符选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E9%80%9A%E9%85%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS后代选择器","slug":"CSS后代选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%90%8E%E4%BB%A3%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS子选择器","slug":"CSS子选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS并集选择器","slug":"CSS并集选择器","permalink":"https://xqc-1368.github.io/tags/CSS%E5%B9%B6%E9%9B%86%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS背景","slug":"CSS背景","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF/"},{"name":"CSS背景平铺","slug":"CSS背景平铺","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%B9%B3%E9%93%BA/"},{"name":"CSS背景图片位置","slug":"CSS背景图片位置","permalink":"https://xqc-1368.github.io/tags/CSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/"},{"name":"CSS文本格式属性","slug":"CSS文本格式属性","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%B1%9E%E6%80%A7/"},{"name":"CSS文本修饰","slug":"CSS文本修饰","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0/"},{"name":"CSS文本对齐","slug":"CSS文本对齐","permalink":"https://xqc-1368.github.io/tags/CSS%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90/"},{"name":"CSS字体font","slug":"CSS字体font","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93font/"},{"name":"emmet","slug":"emmet","permalink":"https://xqc-1368.github.io/tags/emmet/"},{"name":"PS","slug":"PS","permalink":"https://xqc-1368.github.io/tags/PS/"},{"name":"CSS注释","slug":"CSS注释","permalink":"https://xqc-1368.github.io/tags/CSS%E6%B3%A8%E9%87%8A/"},{"name":"CSS的插入","slug":"CSS的插入","permalink":"https://xqc-1368.github.io/tags/CSS%E7%9A%84%E6%8F%92%E5%85%A5/"},{"name":"CSS优先级问题","slug":"CSS优先级问题","permalink":"https://xqc-1368.github.io/tags/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"},{"name":"CSS精灵图","slug":"CSS精灵图","permalink":"https://xqc-1368.github.io/tags/CSS%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS字体图标","slug":"CSS字体图标","permalink":"https://xqc-1368.github.io/tags/CSS%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"},{"name":"CSS三角绘制","slug":"CSS三角绘制","permalink":"https://xqc-1368.github.io/tags/CSS%E4%B8%89%E8%A7%92%E7%BB%98%E5%88%B6/"},{"name":"HTML语言","slug":"HTML语言","permalink":"https://xqc-1368.github.io/tags/HTML%E8%AF%AD%E8%A8%80/"},{"name":"HTML标签","slug":"HTML标签","permalink":"https://xqc-1368.github.io/tags/HTML%E6%A0%87%E7%AD%BE/"},{"name":"HTML列表","slug":"HTML列表","permalink":"https://xqc-1368.github.io/tags/HTML%E5%88%97%E8%A1%A8/"},{"name":"HTML表格","slug":"HTML表格","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E6%A0%BC/"},{"name":"HTML表单","slug":"HTML表单","permalink":"https://xqc-1368.github.io/tags/HTML%E8%A1%A8%E5%8D%95/"},{"name":"HTML注释","slug":"HTML注释","permalink":"https://xqc-1368.github.io/tags/HTML%E6%B3%A8%E9%87%8A/"},{"name":"HTML特殊字符","slug":"HTML特殊字符","permalink":"https://xqc-1368.github.io/tags/HTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xqc-1368.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"web标准","slug":"web标准","permalink":"https://xqc-1368.github.io/tags/web%E6%A0%87%E5%87%86/"},{"name":"Web服务器","slug":"Web服务器","permalink":"https://xqc-1368.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"DNS服务器","slug":"DNS服务器","permalink":"https://xqc-1368.github.io/tags/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://xqc-1368.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"URL","slug":"URL","permalink":"https://xqc-1368.github.io/tags/URL/"},{"name":"URI","slug":"URI","permalink":"https://xqc-1368.github.io/tags/URI/"},{"name":"请求消息","slug":"请求消息","permalink":"https://xqc-1368.github.io/tags/%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/"},{"name":"域名","slug":"域名","permalink":"https://xqc-1368.github.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"Socket库","slug":"Socket库","permalink":"https://xqc-1368.github.io/tags/Socket%E5%BA%93/"},{"name":"解析器","slug":"解析器","permalink":"https://xqc-1368.github.io/tags/%E8%A7%A3%E6%9E%90%E5%99%A8/"}]}